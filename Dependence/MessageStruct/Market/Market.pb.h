// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Market/Market.proto

#ifndef PROTOBUF_Market_2fMarket_2eproto__INCLUDED
#define PROTOBUF_Market_2fMarket_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace MarketMessInfo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Market_2fMarket_2eproto();
void protobuf_AssignDesc_Market_2fMarket_2eproto();
void protobuf_ShutdownFile_Market_2fMarket_2eproto();

class ClientReqMarketInfo;
class WSToClientMarketInfo;
class ClientItemInfo;
class MarketInfo;
class ClientReqMarketShopping;
class WSToClientShopping;
class WSToClientShopInfo;
class ShopInfo;
class ClientReqUnderCarriage;
class WSToClientUnderCarriage;
class ClientReqUpCarriage;
class WSToClientUpCarriage;
class WSToClientEarnings;
class Earnings;
class WSReqGameMarketInfo;
class GMRetGameMarketInfo;
class EarningsInfo;
class ClientMarketUIState;
class WSToGMSellerUIState;

// ===================================================================

class ClientReqMarketInfo : public ::google::protobuf::Message {
 public:
  ClientReqMarketInfo();
  virtual ~ClientReqMarketInfo();

  ClientReqMarketInfo(const ClientReqMarketInfo& from);

  inline ClientReqMarketInfo& operator=(const ClientReqMarketInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqMarketInfo& default_instance();

  void Swap(ClientReqMarketInfo* other);

  // implements Message ----------------------------------------------

  ClientReqMarketInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqMarketInfo& from);
  void MergeFrom(const ClientReqMarketInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 page = 1;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::int32 page() const;
  inline void set_page(::google::protobuf::int32 value);

  // optional int32 quality = 2;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 2;
  inline ::google::protobuf::int32 quality() const;
  inline void set_quality(::google::protobuf::int32 value);

  // optional int32 lv = 3;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 3;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // optional int32 coin = 4;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 4;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);

  // optional int32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 littletype = 6;
  inline bool has_littletype() const;
  inline void clear_littletype();
  static const int kLittletypeFieldNumber = 6;
  inline ::google::protobuf::int32 littletype() const;
  inline void set_littletype(::google::protobuf::int32 value);

  // optional string keyworld = 7;
  inline bool has_keyworld() const;
  inline void clear_keyworld();
  static const int kKeyworldFieldNumber = 7;
  inline const ::std::string& keyworld() const;
  inline void set_keyworld(const ::std::string& value);
  inline void set_keyworld(const char* value);
  inline void set_keyworld(const char* value, size_t size);
  inline ::std::string* mutable_keyworld();
  inline ::std::string* release_keyworld();
  inline void set_allocated_keyworld(::std::string* keyworld);

  // @@protoc_insertion_point(class_scope:MarketMessInfo.ClientReqMarketInfo)
 private:
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_littletype();
  inline void clear_has_littletype();
  inline void set_has_keyworld();
  inline void clear_has_keyworld();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 page_;
  ::google::protobuf::int32 quality_;
  ::google::protobuf::int32 lv_;
  ::google::protobuf::int32 coin_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 littletype_;
  ::std::string* keyworld_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static ClientReqMarketInfo* default_instance_;
};
// -------------------------------------------------------------------

class WSToClientMarketInfo : public ::google::protobuf::Message {
 public:
  WSToClientMarketInfo();
  virtual ~WSToClientMarketInfo();

  WSToClientMarketInfo(const WSToClientMarketInfo& from);

  inline WSToClientMarketInfo& operator=(const WSToClientMarketInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WSToClientMarketInfo& default_instance();

  void Swap(WSToClientMarketInfo* other);

  // implements Message ----------------------------------------------

  WSToClientMarketInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WSToClientMarketInfo& from);
  void MergeFrom(const WSToClientMarketInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 totalpage = 2;
  inline bool has_totalpage() const;
  inline void clear_totalpage();
  static const int kTotalpageFieldNumber = 2;
  inline ::google::protobuf::int32 totalpage() const;
  inline void set_totalpage(::google::protobuf::int32 value);

  // repeated .MarketMessInfo.MarketInfo markerinfo = 3;
  inline int markerinfo_size() const;
  inline void clear_markerinfo();
  static const int kMarkerinfoFieldNumber = 3;
  inline const ::MarketMessInfo::MarketInfo& markerinfo(int index) const;
  inline ::MarketMessInfo::MarketInfo* mutable_markerinfo(int index);
  inline ::MarketMessInfo::MarketInfo* add_markerinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::MarketMessInfo::MarketInfo >&
      markerinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::MarketMessInfo::MarketInfo >*
      mutable_markerinfo();

  // @@protoc_insertion_point(class_scope:MarketMessInfo.WSToClientMarketInfo)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_totalpage();
  inline void clear_has_totalpage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 totalpage_;
  ::google::protobuf::RepeatedPtrField< ::MarketMessInfo::MarketInfo > markerinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static WSToClientMarketInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClientItemInfo : public ::google::protobuf::Message {
 public:
  ClientItemInfo();
  virtual ~ClientItemInfo();

  ClientItemInfo(const ClientItemInfo& from);

  inline ClientItemInfo& operator=(const ClientItemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientItemInfo& default_instance();

  void Swap(ClientItemInfo* other);

  // implements Message ----------------------------------------------

  ClientItemInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientItemInfo& from);
  void MergeFrom(const ClientItemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional uint32 flag = 2;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 2;
  inline ::google::protobuf::uint32 flag() const;
  inline void set_flag(::google::protobuf::uint32 value);

  // repeated uint32 newattr = 3;
  inline int newattr_size() const;
  inline void clear_newattr();
  static const int kNewattrFieldNumber = 3;
  inline ::google::protobuf::uint32 newattr(int index) const;
  inline void set_newattr(int index, ::google::protobuf::uint32 value);
  inline void add_newattr(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      newattr() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_newattr();

  // repeated int32 stoneid = 4;
  inline int stoneid_size() const;
  inline void clear_stoneid();
  static const int kStoneidFieldNumber = 4;
  inline ::google::protobuf::int32 stoneid(int index) const;
  inline void set_stoneid(int index, ::google::protobuf::int32 value);
  inline void add_stoneid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      stoneid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_stoneid();

  // optional uint32 time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // optional uint32 num = 6;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 6;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // repeated int32 inlayPos = 7;
  inline int inlaypos_size() const;
  inline void clear_inlaypos();
  static const int kInlayPosFieldNumber = 7;
  inline ::google::protobuf::int32 inlaypos(int index) const;
  inline void set_inlaypos(int index, ::google::protobuf::int32 value);
  inline void add_inlaypos(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      inlaypos() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_inlaypos();

  // repeated uint32 refineAttrLv = 8;
  inline int refineattrlv_size() const;
  inline void clear_refineattrlv();
  static const int kRefineAttrLvFieldNumber = 8;
  inline ::google::protobuf::uint32 refineattrlv(int index) const;
  inline void set_refineattrlv(int index, ::google::protobuf::uint32 value);
  inline void add_refineattrlv(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      refineattrlv() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_refineattrlv();

  // @@protoc_insertion_point(class_scope:MarketMessInfo.ClientItemInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::uint32 flag_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > newattr_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > stoneid_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 num_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > inlaypos_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > refineattrlv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static ClientItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class MarketInfo : public ::google::protobuf::Message {
 public:
  MarketInfo();
  virtual ~MarketInfo();

  MarketInfo(const MarketInfo& from);

  inline MarketInfo& operator=(const MarketInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketInfo& default_instance();

  void Swap(MarketInfo* other);

  // implements Message ----------------------------------------------

  MarketInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketInfo& from);
  void MergeFrom(const MarketInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // optional int64 charid = 2;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 2;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // optional int32 itemid = 3;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 3;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 num = 4;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 4;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 price = 5;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 5;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional int32 coin = 6;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 6;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);

  // optional string charname = 7;
  inline bool has_charname() const;
  inline void clear_charname();
  static const int kCharnameFieldNumber = 7;
  inline const ::std::string& charname() const;
  inline void set_charname(const ::std::string& value);
  inline void set_charname(const char* value);
  inline void set_charname(const char* value, size_t size);
  inline ::std::string* mutable_charname();
  inline ::std::string* release_charname();
  inline void set_allocated_charname(::std::string* charname);

  // optional .MarketMessInfo.ClientItemInfo itemInfo = 8;
  inline bool has_iteminfo() const;
  inline void clear_iteminfo();
  static const int kItemInfoFieldNumber = 8;
  inline const ::MarketMessInfo::ClientItemInfo& iteminfo() const;
  inline ::MarketMessInfo::ClientItemInfo* mutable_iteminfo();
  inline ::MarketMessInfo::ClientItemInfo* release_iteminfo();
  inline void set_allocated_iteminfo(::MarketMessInfo::ClientItemInfo* iteminfo);

  // @@protoc_insertion_point(class_scope:MarketMessInfo.MarketInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_charname();
  inline void clear_has_charname();
  inline void set_has_iteminfo();
  inline void clear_has_iteminfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 charid_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 coin_;
  ::std::string* charname_;
  ::MarketMessInfo::ClientItemInfo* iteminfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static MarketInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqMarketShopping : public ::google::protobuf::Message {
 public:
  ClientReqMarketShopping();
  virtual ~ClientReqMarketShopping();

  ClientReqMarketShopping(const ClientReqMarketShopping& from);

  inline ClientReqMarketShopping& operator=(const ClientReqMarketShopping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqMarketShopping& default_instance();

  void Swap(ClientReqMarketShopping* other);

  // implements Message ----------------------------------------------

  ClientReqMarketShopping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqMarketShopping& from);
  void MergeFrom(const ClientReqMarketShopping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:MarketMessInfo.ClientReqMarketShopping)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static ClientReqMarketShopping* default_instance_;
};
// -------------------------------------------------------------------

class WSToClientShopping : public ::google::protobuf::Message {
 public:
  WSToClientShopping();
  virtual ~WSToClientShopping();

  WSToClientShopping(const WSToClientShopping& from);

  inline WSToClientShopping& operator=(const WSToClientShopping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WSToClientShopping& default_instance();

  void Swap(WSToClientShopping* other);

  // implements Message ----------------------------------------------

  WSToClientShopping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WSToClientShopping& from);
  void MergeFrom(const WSToClientShopping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MarketMessInfo.WSToClientShopping)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static WSToClientShopping* default_instance_;
};
// -------------------------------------------------------------------

class WSToClientShopInfo : public ::google::protobuf::Message {
 public:
  WSToClientShopInfo();
  virtual ~WSToClientShopInfo();

  WSToClientShopInfo(const WSToClientShopInfo& from);

  inline WSToClientShopInfo& operator=(const WSToClientShopInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WSToClientShopInfo& default_instance();

  void Swap(WSToClientShopInfo* other);

  // implements Message ----------------------------------------------

  WSToClientShopInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WSToClientShopInfo& from);
  void MergeFrom(const WSToClientShopInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MarketMessInfo.ShopInfo shopinfo = 1;
  inline int shopinfo_size() const;
  inline void clear_shopinfo();
  static const int kShopinfoFieldNumber = 1;
  inline const ::MarketMessInfo::ShopInfo& shopinfo(int index) const;
  inline ::MarketMessInfo::ShopInfo* mutable_shopinfo(int index);
  inline ::MarketMessInfo::ShopInfo* add_shopinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::MarketMessInfo::ShopInfo >&
      shopinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::MarketMessInfo::ShopInfo >*
      mutable_shopinfo();

  // @@protoc_insertion_point(class_scope:MarketMessInfo.WSToClientShopInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::MarketMessInfo::ShopInfo > shopinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static WSToClientShopInfo* default_instance_;
};
// -------------------------------------------------------------------

class ShopInfo : public ::google::protobuf::Message {
 public:
  ShopInfo();
  virtual ~ShopInfo();

  ShopInfo(const ShopInfo& from);

  inline ShopInfo& operator=(const ShopInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShopInfo& default_instance();

  void Swap(ShopInfo* other);

  // implements Message ----------------------------------------------

  ShopInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShopInfo& from);
  void MergeFrom(const ShopInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // optional int32 itemid = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 2;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional int32 coin = 5;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 5;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);

  // optional .MarketMessInfo.ClientItemInfo itemInfo = 6;
  inline bool has_iteminfo() const;
  inline void clear_iteminfo();
  static const int kItemInfoFieldNumber = 6;
  inline const ::MarketMessInfo::ClientItemInfo& iteminfo() const;
  inline ::MarketMessInfo::ClientItemInfo* mutable_iteminfo();
  inline ::MarketMessInfo::ClientItemInfo* release_iteminfo();
  inline void set_allocated_iteminfo(::MarketMessInfo::ClientItemInfo* iteminfo);

  // @@protoc_insertion_point(class_scope:MarketMessInfo.ShopInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_iteminfo();
  inline void clear_has_iteminfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 coin_;
  ::MarketMessInfo::ClientItemInfo* iteminfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static ShopInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqUnderCarriage : public ::google::protobuf::Message {
 public:
  ClientReqUnderCarriage();
  virtual ~ClientReqUnderCarriage();

  ClientReqUnderCarriage(const ClientReqUnderCarriage& from);

  inline ClientReqUnderCarriage& operator=(const ClientReqUnderCarriage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqUnderCarriage& default_instance();

  void Swap(ClientReqUnderCarriage* other);

  // implements Message ----------------------------------------------

  ClientReqUnderCarriage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqUnderCarriage& from);
  void MergeFrom(const ClientReqUnderCarriage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:MarketMessInfo.ClientReqUnderCarriage)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static ClientReqUnderCarriage* default_instance_;
};
// -------------------------------------------------------------------

class WSToClientUnderCarriage : public ::google::protobuf::Message {
 public:
  WSToClientUnderCarriage();
  virtual ~WSToClientUnderCarriage();

  WSToClientUnderCarriage(const WSToClientUnderCarriage& from);

  inline WSToClientUnderCarriage& operator=(const WSToClientUnderCarriage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WSToClientUnderCarriage& default_instance();

  void Swap(WSToClientUnderCarriage* other);

  // implements Message ----------------------------------------------

  WSToClientUnderCarriage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WSToClientUnderCarriage& from);
  void MergeFrom(const WSToClientUnderCarriage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MarketMessInfo.WSToClientUnderCarriage)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static WSToClientUnderCarriage* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqUpCarriage : public ::google::protobuf::Message {
 public:
  ClientReqUpCarriage();
  virtual ~ClientReqUpCarriage();

  ClientReqUpCarriage(const ClientReqUpCarriage& from);

  inline ClientReqUpCarriage& operator=(const ClientReqUpCarriage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqUpCarriage& default_instance();

  void Swap(ClientReqUpCarriage* other);

  // implements Message ----------------------------------------------

  ClientReqUpCarriage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqUpCarriage& from);
  void MergeFrom(const ClientReqUpCarriage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 itemid = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 coin = 2;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 2;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MarketMessInfo.ClientReqUpCarriage)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_price();
  inline void clear_has_price();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 coin_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 price_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static ClientReqUpCarriage* default_instance_;
};
// -------------------------------------------------------------------

class WSToClientUpCarriage : public ::google::protobuf::Message {
 public:
  WSToClientUpCarriage();
  virtual ~WSToClientUpCarriage();

  WSToClientUpCarriage(const WSToClientUpCarriage& from);

  inline WSToClientUpCarriage& operator=(const WSToClientUpCarriage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WSToClientUpCarriage& default_instance();

  void Swap(WSToClientUpCarriage* other);

  // implements Message ----------------------------------------------

  WSToClientUpCarriage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WSToClientUpCarriage& from);
  void MergeFrom(const WSToClientUpCarriage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MarketMessInfo.WSToClientUpCarriage)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static WSToClientUpCarriage* default_instance_;
};
// -------------------------------------------------------------------

class WSToClientEarnings : public ::google::protobuf::Message {
 public:
  WSToClientEarnings();
  virtual ~WSToClientEarnings();

  WSToClientEarnings(const WSToClientEarnings& from);

  inline WSToClientEarnings& operator=(const WSToClientEarnings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WSToClientEarnings& default_instance();

  void Swap(WSToClientEarnings* other);

  // implements Message ----------------------------------------------

  WSToClientEarnings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WSToClientEarnings& from);
  void MergeFrom(const WSToClientEarnings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MarketMessInfo.Earnings earnings = 1;
  inline int earnings_size() const;
  inline void clear_earnings();
  static const int kEarningsFieldNumber = 1;
  inline const ::MarketMessInfo::Earnings& earnings(int index) const;
  inline ::MarketMessInfo::Earnings* mutable_earnings(int index);
  inline ::MarketMessInfo::Earnings* add_earnings();
  inline const ::google::protobuf::RepeatedPtrField< ::MarketMessInfo::Earnings >&
      earnings() const;
  inline ::google::protobuf::RepeatedPtrField< ::MarketMessInfo::Earnings >*
      mutable_earnings();

  // @@protoc_insertion_point(class_scope:MarketMessInfo.WSToClientEarnings)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::MarketMessInfo::Earnings > earnings_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static WSToClientEarnings* default_instance_;
};
// -------------------------------------------------------------------

class Earnings : public ::google::protobuf::Message {
 public:
  Earnings();
  virtual ~Earnings();

  Earnings(const Earnings& from);

  inline Earnings& operator=(const Earnings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Earnings& default_instance();

  void Swap(Earnings* other);

  // implements Message ----------------------------------------------

  Earnings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Earnings& from);
  void MergeFrom(const Earnings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 itemid = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 coin = 2;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 2;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 earningsprice = 4;
  inline bool has_earningsprice() const;
  inline void clear_earningsprice();
  static const int kEarningspriceFieldNumber = 4;
  inline ::google::protobuf::int32 earningsprice() const;
  inline void set_earningsprice(::google::protobuf::int32 value);

  // optional int32 blocks = 5;
  inline bool has_blocks() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 5;
  inline ::google::protobuf::int32 blocks() const;
  inline void set_blocks(::google::protobuf::int32 value);

  // optional int64 time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional string charname = 7;
  inline bool has_charname() const;
  inline void clear_charname();
  static const int kCharnameFieldNumber = 7;
  inline const ::std::string& charname() const;
  inline void set_charname(const ::std::string& value);
  inline void set_charname(const char* value);
  inline void set_charname(const char* value, size_t size);
  inline ::std::string* mutable_charname();
  inline ::std::string* release_charname();
  inline void set_allocated_charname(::std::string* charname);

  // @@protoc_insertion_point(class_scope:MarketMessInfo.Earnings)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_earningsprice();
  inline void clear_has_earningsprice();
  inline void set_has_blocks();
  inline void clear_has_blocks();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_charname();
  inline void clear_has_charname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 coin_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 earningsprice_;
  ::google::protobuf::int64 time_;
  ::std::string* charname_;
  ::google::protobuf::int32 blocks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static Earnings* default_instance_;
};
// -------------------------------------------------------------------

class WSReqGameMarketInfo : public ::google::protobuf::Message {
 public:
  WSReqGameMarketInfo();
  virtual ~WSReqGameMarketInfo();

  WSReqGameMarketInfo(const WSReqGameMarketInfo& from);

  inline WSReqGameMarketInfo& operator=(const WSReqGameMarketInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WSReqGameMarketInfo& default_instance();

  void Swap(WSReqGameMarketInfo* other);

  // implements Message ----------------------------------------------

  WSReqGameMarketInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WSReqGameMarketInfo& from);
  void MergeFrom(const WSReqGameMarketInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // optional int32 itemid = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 2;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional int32 coin = 5;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 5;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MarketMessInfo.WSReqGameMarketInfo)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_coin();
  inline void clear_has_coin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 coin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static WSReqGameMarketInfo* default_instance_;
};
// -------------------------------------------------------------------

class GMRetGameMarketInfo : public ::google::protobuf::Message {
 public:
  GMRetGameMarketInfo();
  virtual ~GMRetGameMarketInfo();

  GMRetGameMarketInfo(const GMRetGameMarketInfo& from);

  inline GMRetGameMarketInfo& operator=(const GMRetGameMarketInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMRetGameMarketInfo& default_instance();

  void Swap(GMRetGameMarketInfo* other);

  // implements Message ----------------------------------------------

  GMRetGameMarketInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMRetGameMarketInfo& from);
  void MergeFrom(const GMRetGameMarketInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // required int32 itemid = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 2;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // optional int32 coin = 5;
  inline bool has_coin() const;
  inline void clear_coin();
  static const int kCoinFieldNumber = 5;
  inline ::google::protobuf::int32 coin() const;
  inline void set_coin(::google::protobuf::int32 value);

  // optional .MarketMessInfo.ClientItemInfo itemInfo = 6;
  inline bool has_iteminfo() const;
  inline void clear_iteminfo();
  static const int kItemInfoFieldNumber = 6;
  inline const ::MarketMessInfo::ClientItemInfo& iteminfo() const;
  inline ::MarketMessInfo::ClientItemInfo* mutable_iteminfo();
  inline ::MarketMessInfo::ClientItemInfo* release_iteminfo();
  inline void set_allocated_iteminfo(::MarketMessInfo::ClientItemInfo* iteminfo);

  // @@protoc_insertion_point(class_scope:MarketMessInfo.GMRetGameMarketInfo)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_coin();
  inline void clear_has_coin();
  inline void set_has_iteminfo();
  inline void clear_has_iteminfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 price_;
  ::MarketMessInfo::ClientItemInfo* iteminfo_;
  ::google::protobuf::int32 coin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static GMRetGameMarketInfo* default_instance_;
};
// -------------------------------------------------------------------

class EarningsInfo : public ::google::protobuf::Message {
 public:
  EarningsInfo();
  virtual ~EarningsInfo();

  EarningsInfo(const EarningsInfo& from);

  inline EarningsInfo& operator=(const EarningsInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EarningsInfo& default_instance();

  void Swap(EarningsInfo* other);

  // implements Message ----------------------------------------------

  EarningsInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EarningsInfo& from);
  void MergeFrom(const EarningsInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charId = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // optional int32 rets = 2;
  inline bool has_rets() const;
  inline void clear_rets();
  static const int kRetsFieldNumber = 2;
  inline ::google::protobuf::int32 rets() const;
  inline void set_rets(::google::protobuf::int32 value);

  // optional int32 rett = 3;
  inline bool has_rett() const;
  inline void clear_rett();
  static const int kRettFieldNumber = 3;
  inline ::google::protobuf::int32 rett() const;
  inline void set_rett(::google::protobuf::int32 value);

  // optional int32 retfo = 4;
  inline bool has_retfo() const;
  inline void clear_retfo();
  static const int kRetfoFieldNumber = 4;
  inline ::google::protobuf::int32 retfo() const;
  inline void set_retfo(::google::protobuf::int32 value);

  // optional .MarketMessInfo.ClientItemInfo itemInfo = 5;
  inline bool has_iteminfo() const;
  inline void clear_iteminfo();
  static const int kItemInfoFieldNumber = 5;
  inline const ::MarketMessInfo::ClientItemInfo& iteminfo() const;
  inline ::MarketMessInfo::ClientItemInfo* mutable_iteminfo();
  inline ::MarketMessInfo::ClientItemInfo* release_iteminfo();
  inline void set_allocated_iteminfo(::MarketMessInfo::ClientItemInfo* iteminfo);

  // @@protoc_insertion_point(class_scope:MarketMessInfo.EarningsInfo)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_rets();
  inline void clear_has_rets();
  inline void set_has_rett();
  inline void clear_has_rett();
  inline void set_has_retfo();
  inline void clear_has_retfo();
  inline void set_has_iteminfo();
  inline void clear_has_iteminfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::google::protobuf::int32 rets_;
  ::google::protobuf::int32 rett_;
  ::MarketMessInfo::ClientItemInfo* iteminfo_;
  ::google::protobuf::int32 retfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static EarningsInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClientMarketUIState : public ::google::protobuf::Message {
 public:
  ClientMarketUIState();
  virtual ~ClientMarketUIState();

  ClientMarketUIState(const ClientMarketUIState& from);

  inline ClientMarketUIState& operator=(const ClientMarketUIState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMarketUIState& default_instance();

  void Swap(ClientMarketUIState* other);

  // implements Message ----------------------------------------------

  ClientMarketUIState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientMarketUIState& from);
  void MergeFrom(const ClientMarketUIState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:MarketMessInfo.ClientMarketUIState)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static ClientMarketUIState* default_instance_;
};
// -------------------------------------------------------------------

class WSToGMSellerUIState : public ::google::protobuf::Message {
 public:
  WSToGMSellerUIState();
  virtual ~WSToGMSellerUIState();

  WSToGMSellerUIState(const WSToGMSellerUIState& from);

  inline WSToGMSellerUIState& operator=(const WSToGMSellerUIState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WSToGMSellerUIState& default_instance();

  void Swap(WSToGMSellerUIState* other);

  // implements Message ----------------------------------------------

  WSToGMSellerUIState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WSToGMSellerUIState& from);
  void MergeFrom(const WSToGMSellerUIState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charID = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharIDFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:MarketMessInfo.WSToGMSellerUIState)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Market_2fMarket_2eproto();
  friend void protobuf_AssignDesc_Market_2fMarket_2eproto();
  friend void protobuf_ShutdownFile_Market_2fMarket_2eproto();

  void InitAsDefaultInstance();
  static WSToGMSellerUIState* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientReqMarketInfo

// required int32 page = 1;
inline bool ClientReqMarketInfo::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqMarketInfo::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqMarketInfo::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqMarketInfo::clear_page() {
  page_ = 0;
  clear_has_page();
}
inline ::google::protobuf::int32 ClientReqMarketInfo::page() const {
  return page_;
}
inline void ClientReqMarketInfo::set_page(::google::protobuf::int32 value) {
  set_has_page();
  page_ = value;
}

// optional int32 quality = 2;
inline bool ClientReqMarketInfo::has_quality() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientReqMarketInfo::set_has_quality() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientReqMarketInfo::clear_has_quality() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientReqMarketInfo::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::google::protobuf::int32 ClientReqMarketInfo::quality() const {
  return quality_;
}
inline void ClientReqMarketInfo::set_quality(::google::protobuf::int32 value) {
  set_has_quality();
  quality_ = value;
}

// optional int32 lv = 3;
inline bool ClientReqMarketInfo::has_lv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientReqMarketInfo::set_has_lv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientReqMarketInfo::clear_has_lv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientReqMarketInfo::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 ClientReqMarketInfo::lv() const {
  return lv_;
}
inline void ClientReqMarketInfo::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// optional int32 coin = 4;
inline bool ClientReqMarketInfo::has_coin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientReqMarketInfo::set_has_coin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientReqMarketInfo::clear_has_coin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientReqMarketInfo::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 ClientReqMarketInfo::coin() const {
  return coin_;
}
inline void ClientReqMarketInfo::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// optional int32 type = 5;
inline bool ClientReqMarketInfo::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientReqMarketInfo::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientReqMarketInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientReqMarketInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ClientReqMarketInfo::type() const {
  return type_;
}
inline void ClientReqMarketInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 littletype = 6;
inline bool ClientReqMarketInfo::has_littletype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientReqMarketInfo::set_has_littletype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientReqMarketInfo::clear_has_littletype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientReqMarketInfo::clear_littletype() {
  littletype_ = 0;
  clear_has_littletype();
}
inline ::google::protobuf::int32 ClientReqMarketInfo::littletype() const {
  return littletype_;
}
inline void ClientReqMarketInfo::set_littletype(::google::protobuf::int32 value) {
  set_has_littletype();
  littletype_ = value;
}

// optional string keyworld = 7;
inline bool ClientReqMarketInfo::has_keyworld() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientReqMarketInfo::set_has_keyworld() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientReqMarketInfo::clear_has_keyworld() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientReqMarketInfo::clear_keyworld() {
  if (keyworld_ != &::google::protobuf::internal::kEmptyString) {
    keyworld_->clear();
  }
  clear_has_keyworld();
}
inline const ::std::string& ClientReqMarketInfo::keyworld() const {
  return *keyworld_;
}
inline void ClientReqMarketInfo::set_keyworld(const ::std::string& value) {
  set_has_keyworld();
  if (keyworld_ == &::google::protobuf::internal::kEmptyString) {
    keyworld_ = new ::std::string;
  }
  keyworld_->assign(value);
}
inline void ClientReqMarketInfo::set_keyworld(const char* value) {
  set_has_keyworld();
  if (keyworld_ == &::google::protobuf::internal::kEmptyString) {
    keyworld_ = new ::std::string;
  }
  keyworld_->assign(value);
}
inline void ClientReqMarketInfo::set_keyworld(const char* value, size_t size) {
  set_has_keyworld();
  if (keyworld_ == &::google::protobuf::internal::kEmptyString) {
    keyworld_ = new ::std::string;
  }
  keyworld_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientReqMarketInfo::mutable_keyworld() {
  set_has_keyworld();
  if (keyworld_ == &::google::protobuf::internal::kEmptyString) {
    keyworld_ = new ::std::string;
  }
  return keyworld_;
}
inline ::std::string* ClientReqMarketInfo::release_keyworld() {
  clear_has_keyworld();
  if (keyworld_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyworld_;
    keyworld_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientReqMarketInfo::set_allocated_keyworld(::std::string* keyworld) {
  if (keyworld_ != &::google::protobuf::internal::kEmptyString) {
    delete keyworld_;
  }
  if (keyworld) {
    set_has_keyworld();
    keyworld_ = keyworld;
  } else {
    clear_has_keyworld();
    keyworld_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WSToClientMarketInfo

// required int32 ret = 1;
inline bool WSToClientMarketInfo::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WSToClientMarketInfo::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WSToClientMarketInfo::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WSToClientMarketInfo::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 WSToClientMarketInfo::ret() const {
  return ret_;
}
inline void WSToClientMarketInfo::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 totalpage = 2;
inline bool WSToClientMarketInfo::has_totalpage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WSToClientMarketInfo::set_has_totalpage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WSToClientMarketInfo::clear_has_totalpage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WSToClientMarketInfo::clear_totalpage() {
  totalpage_ = 0;
  clear_has_totalpage();
}
inline ::google::protobuf::int32 WSToClientMarketInfo::totalpage() const {
  return totalpage_;
}
inline void WSToClientMarketInfo::set_totalpage(::google::protobuf::int32 value) {
  set_has_totalpage();
  totalpage_ = value;
}

// repeated .MarketMessInfo.MarketInfo markerinfo = 3;
inline int WSToClientMarketInfo::markerinfo_size() const {
  return markerinfo_.size();
}
inline void WSToClientMarketInfo::clear_markerinfo() {
  markerinfo_.Clear();
}
inline const ::MarketMessInfo::MarketInfo& WSToClientMarketInfo::markerinfo(int index) const {
  return markerinfo_.Get(index);
}
inline ::MarketMessInfo::MarketInfo* WSToClientMarketInfo::mutable_markerinfo(int index) {
  return markerinfo_.Mutable(index);
}
inline ::MarketMessInfo::MarketInfo* WSToClientMarketInfo::add_markerinfo() {
  return markerinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MarketMessInfo::MarketInfo >&
WSToClientMarketInfo::markerinfo() const {
  return markerinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::MarketMessInfo::MarketInfo >*
WSToClientMarketInfo::mutable_markerinfo() {
  return &markerinfo_;
}

// -------------------------------------------------------------------

// ClientItemInfo

// required int32 id = 1;
inline bool ClientItemInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientItemInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientItemInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientItemInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ClientItemInfo::id() const {
  return id_;
}
inline void ClientItemInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 flag = 2;
inline bool ClientItemInfo::has_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientItemInfo::set_has_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientItemInfo::clear_has_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientItemInfo::clear_flag() {
  flag_ = 0u;
  clear_has_flag();
}
inline ::google::protobuf::uint32 ClientItemInfo::flag() const {
  return flag_;
}
inline void ClientItemInfo::set_flag(::google::protobuf::uint32 value) {
  set_has_flag();
  flag_ = value;
}

// repeated uint32 newattr = 3;
inline int ClientItemInfo::newattr_size() const {
  return newattr_.size();
}
inline void ClientItemInfo::clear_newattr() {
  newattr_.Clear();
}
inline ::google::protobuf::uint32 ClientItemInfo::newattr(int index) const {
  return newattr_.Get(index);
}
inline void ClientItemInfo::set_newattr(int index, ::google::protobuf::uint32 value) {
  newattr_.Set(index, value);
}
inline void ClientItemInfo::add_newattr(::google::protobuf::uint32 value) {
  newattr_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ClientItemInfo::newattr() const {
  return newattr_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ClientItemInfo::mutable_newattr() {
  return &newattr_;
}

// repeated int32 stoneid = 4;
inline int ClientItemInfo::stoneid_size() const {
  return stoneid_.size();
}
inline void ClientItemInfo::clear_stoneid() {
  stoneid_.Clear();
}
inline ::google::protobuf::int32 ClientItemInfo::stoneid(int index) const {
  return stoneid_.Get(index);
}
inline void ClientItemInfo::set_stoneid(int index, ::google::protobuf::int32 value) {
  stoneid_.Set(index, value);
}
inline void ClientItemInfo::add_stoneid(::google::protobuf::int32 value) {
  stoneid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ClientItemInfo::stoneid() const {
  return stoneid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ClientItemInfo::mutable_stoneid() {
  return &stoneid_;
}

// optional uint32 time = 5;
inline bool ClientItemInfo::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientItemInfo::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientItemInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientItemInfo::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 ClientItemInfo::time() const {
  return time_;
}
inline void ClientItemInfo::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// optional uint32 num = 6;
inline bool ClientItemInfo::has_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientItemInfo::set_has_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientItemInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientItemInfo::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 ClientItemInfo::num() const {
  return num_;
}
inline void ClientItemInfo::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// repeated int32 inlayPos = 7;
inline int ClientItemInfo::inlaypos_size() const {
  return inlaypos_.size();
}
inline void ClientItemInfo::clear_inlaypos() {
  inlaypos_.Clear();
}
inline ::google::protobuf::int32 ClientItemInfo::inlaypos(int index) const {
  return inlaypos_.Get(index);
}
inline void ClientItemInfo::set_inlaypos(int index, ::google::protobuf::int32 value) {
  inlaypos_.Set(index, value);
}
inline void ClientItemInfo::add_inlaypos(::google::protobuf::int32 value) {
  inlaypos_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ClientItemInfo::inlaypos() const {
  return inlaypos_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ClientItemInfo::mutable_inlaypos() {
  return &inlaypos_;
}

// repeated uint32 refineAttrLv = 8;
inline int ClientItemInfo::refineattrlv_size() const {
  return refineattrlv_.size();
}
inline void ClientItemInfo::clear_refineattrlv() {
  refineattrlv_.Clear();
}
inline ::google::protobuf::uint32 ClientItemInfo::refineattrlv(int index) const {
  return refineattrlv_.Get(index);
}
inline void ClientItemInfo::set_refineattrlv(int index, ::google::protobuf::uint32 value) {
  refineattrlv_.Set(index, value);
}
inline void ClientItemInfo::add_refineattrlv(::google::protobuf::uint32 value) {
  refineattrlv_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ClientItemInfo::refineattrlv() const {
  return refineattrlv_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ClientItemInfo::mutable_refineattrlv() {
  return &refineattrlv_;
}

// -------------------------------------------------------------------

// MarketInfo

// required int64 id = 1;
inline bool MarketInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketInfo::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 MarketInfo::id() const {
  return id_;
}
inline void MarketInfo::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// optional int64 charid = 2;
inline bool MarketInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketInfo::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 MarketInfo::charid() const {
  return charid_;
}
inline void MarketInfo::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// optional int32 itemid = 3;
inline bool MarketInfo::has_itemid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketInfo::set_has_itemid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketInfo::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketInfo::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 MarketInfo::itemid() const {
  return itemid_;
}
inline void MarketInfo::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 num = 4;
inline bool MarketInfo::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MarketInfo::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MarketInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MarketInfo::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 MarketInfo::num() const {
  return num_;
}
inline void MarketInfo::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 price = 5;
inline bool MarketInfo::has_price() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MarketInfo::set_has_price() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MarketInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MarketInfo::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 MarketInfo::price() const {
  return price_;
}
inline void MarketInfo::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// optional int32 coin = 6;
inline bool MarketInfo::has_coin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MarketInfo::set_has_coin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MarketInfo::clear_has_coin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MarketInfo::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 MarketInfo::coin() const {
  return coin_;
}
inline void MarketInfo::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// optional string charname = 7;
inline bool MarketInfo::has_charname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MarketInfo::set_has_charname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MarketInfo::clear_has_charname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MarketInfo::clear_charname() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    charname_->clear();
  }
  clear_has_charname();
}
inline const ::std::string& MarketInfo::charname() const {
  return *charname_;
}
inline void MarketInfo::set_charname(const ::std::string& value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void MarketInfo::set_charname(const char* value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void MarketInfo::set_charname(const char* value, size_t size) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketInfo::mutable_charname() {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  return charname_;
}
inline ::std::string* MarketInfo::release_charname() {
  clear_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charname_;
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketInfo::set_allocated_charname(::std::string* charname) {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (charname) {
    set_has_charname();
    charname_ = charname;
  } else {
    clear_has_charname();
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .MarketMessInfo.ClientItemInfo itemInfo = 8;
inline bool MarketInfo::has_iteminfo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MarketInfo::set_has_iteminfo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MarketInfo::clear_has_iteminfo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MarketInfo::clear_iteminfo() {
  if (iteminfo_ != NULL) iteminfo_->::MarketMessInfo::ClientItemInfo::Clear();
  clear_has_iteminfo();
}
inline const ::MarketMessInfo::ClientItemInfo& MarketInfo::iteminfo() const {
  return iteminfo_ != NULL ? *iteminfo_ : *default_instance_->iteminfo_;
}
inline ::MarketMessInfo::ClientItemInfo* MarketInfo::mutable_iteminfo() {
  set_has_iteminfo();
  if (iteminfo_ == NULL) iteminfo_ = new ::MarketMessInfo::ClientItemInfo;
  return iteminfo_;
}
inline ::MarketMessInfo::ClientItemInfo* MarketInfo::release_iteminfo() {
  clear_has_iteminfo();
  ::MarketMessInfo::ClientItemInfo* temp = iteminfo_;
  iteminfo_ = NULL;
  return temp;
}
inline void MarketInfo::set_allocated_iteminfo(::MarketMessInfo::ClientItemInfo* iteminfo) {
  delete iteminfo_;
  iteminfo_ = iteminfo;
  if (iteminfo) {
    set_has_iteminfo();
  } else {
    clear_has_iteminfo();
  }
}

// -------------------------------------------------------------------

// ClientReqMarketShopping

// required int64 id = 1;
inline bool ClientReqMarketShopping::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqMarketShopping::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqMarketShopping::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqMarketShopping::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 ClientReqMarketShopping::id() const {
  return id_;
}
inline void ClientReqMarketShopping::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// WSToClientShopping

// required int32 ret = 1;
inline bool WSToClientShopping::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WSToClientShopping::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WSToClientShopping::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WSToClientShopping::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 WSToClientShopping::ret() const {
  return ret_;
}
inline void WSToClientShopping::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// WSToClientShopInfo

// repeated .MarketMessInfo.ShopInfo shopinfo = 1;
inline int WSToClientShopInfo::shopinfo_size() const {
  return shopinfo_.size();
}
inline void WSToClientShopInfo::clear_shopinfo() {
  shopinfo_.Clear();
}
inline const ::MarketMessInfo::ShopInfo& WSToClientShopInfo::shopinfo(int index) const {
  return shopinfo_.Get(index);
}
inline ::MarketMessInfo::ShopInfo* WSToClientShopInfo::mutable_shopinfo(int index) {
  return shopinfo_.Mutable(index);
}
inline ::MarketMessInfo::ShopInfo* WSToClientShopInfo::add_shopinfo() {
  return shopinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MarketMessInfo::ShopInfo >&
WSToClientShopInfo::shopinfo() const {
  return shopinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::MarketMessInfo::ShopInfo >*
WSToClientShopInfo::mutable_shopinfo() {
  return &shopinfo_;
}

// -------------------------------------------------------------------

// ShopInfo

// required int64 id = 1;
inline bool ShopInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShopInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShopInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShopInfo::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 ShopInfo::id() const {
  return id_;
}
inline void ShopInfo::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// optional int32 itemid = 2;
inline bool ShopInfo::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShopInfo::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShopInfo::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShopInfo::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 ShopInfo::itemid() const {
  return itemid_;
}
inline void ShopInfo::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 num = 3;
inline bool ShopInfo::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShopInfo::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShopInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShopInfo::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 ShopInfo::num() const {
  return num_;
}
inline void ShopInfo::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 price = 4;
inline bool ShopInfo::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShopInfo::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShopInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShopInfo::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 ShopInfo::price() const {
  return price_;
}
inline void ShopInfo::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// optional int32 coin = 5;
inline bool ShopInfo::has_coin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShopInfo::set_has_coin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShopInfo::clear_has_coin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShopInfo::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 ShopInfo::coin() const {
  return coin_;
}
inline void ShopInfo::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// optional .MarketMessInfo.ClientItemInfo itemInfo = 6;
inline bool ShopInfo::has_iteminfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ShopInfo::set_has_iteminfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ShopInfo::clear_has_iteminfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ShopInfo::clear_iteminfo() {
  if (iteminfo_ != NULL) iteminfo_->::MarketMessInfo::ClientItemInfo::Clear();
  clear_has_iteminfo();
}
inline const ::MarketMessInfo::ClientItemInfo& ShopInfo::iteminfo() const {
  return iteminfo_ != NULL ? *iteminfo_ : *default_instance_->iteminfo_;
}
inline ::MarketMessInfo::ClientItemInfo* ShopInfo::mutable_iteminfo() {
  set_has_iteminfo();
  if (iteminfo_ == NULL) iteminfo_ = new ::MarketMessInfo::ClientItemInfo;
  return iteminfo_;
}
inline ::MarketMessInfo::ClientItemInfo* ShopInfo::release_iteminfo() {
  clear_has_iteminfo();
  ::MarketMessInfo::ClientItemInfo* temp = iteminfo_;
  iteminfo_ = NULL;
  return temp;
}
inline void ShopInfo::set_allocated_iteminfo(::MarketMessInfo::ClientItemInfo* iteminfo) {
  delete iteminfo_;
  iteminfo_ = iteminfo;
  if (iteminfo) {
    set_has_iteminfo();
  } else {
    clear_has_iteminfo();
  }
}

// -------------------------------------------------------------------

// ClientReqUnderCarriage

// required int64 id = 1;
inline bool ClientReqUnderCarriage::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqUnderCarriage::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqUnderCarriage::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqUnderCarriage::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 ClientReqUnderCarriage::id() const {
  return id_;
}
inline void ClientReqUnderCarriage::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// WSToClientUnderCarriage

// required int32 ret = 1;
inline bool WSToClientUnderCarriage::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WSToClientUnderCarriage::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WSToClientUnderCarriage::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WSToClientUnderCarriage::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 WSToClientUnderCarriage::ret() const {
  return ret_;
}
inline void WSToClientUnderCarriage::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// ClientReqUpCarriage

// required int32 itemid = 1;
inline bool ClientReqUpCarriage::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqUpCarriage::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqUpCarriage::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqUpCarriage::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 ClientReqUpCarriage::itemid() const {
  return itemid_;
}
inline void ClientReqUpCarriage::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 coin = 2;
inline bool ClientReqUpCarriage::has_coin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientReqUpCarriage::set_has_coin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientReqUpCarriage::clear_has_coin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientReqUpCarriage::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 ClientReqUpCarriage::coin() const {
  return coin_;
}
inline void ClientReqUpCarriage::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// optional int32 num = 3;
inline bool ClientReqUpCarriage::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientReqUpCarriage::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientReqUpCarriage::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientReqUpCarriage::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 ClientReqUpCarriage::num() const {
  return num_;
}
inline void ClientReqUpCarriage::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 price = 4;
inline bool ClientReqUpCarriage::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientReqUpCarriage::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientReqUpCarriage::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientReqUpCarriage::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 ClientReqUpCarriage::price() const {
  return price_;
}
inline void ClientReqUpCarriage::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// -------------------------------------------------------------------

// WSToClientUpCarriage

// required int32 ret = 1;
inline bool WSToClientUpCarriage::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WSToClientUpCarriage::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WSToClientUpCarriage::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WSToClientUpCarriage::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 WSToClientUpCarriage::ret() const {
  return ret_;
}
inline void WSToClientUpCarriage::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// WSToClientEarnings

// repeated .MarketMessInfo.Earnings earnings = 1;
inline int WSToClientEarnings::earnings_size() const {
  return earnings_.size();
}
inline void WSToClientEarnings::clear_earnings() {
  earnings_.Clear();
}
inline const ::MarketMessInfo::Earnings& WSToClientEarnings::earnings(int index) const {
  return earnings_.Get(index);
}
inline ::MarketMessInfo::Earnings* WSToClientEarnings::mutable_earnings(int index) {
  return earnings_.Mutable(index);
}
inline ::MarketMessInfo::Earnings* WSToClientEarnings::add_earnings() {
  return earnings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MarketMessInfo::Earnings >&
WSToClientEarnings::earnings() const {
  return earnings_;
}
inline ::google::protobuf::RepeatedPtrField< ::MarketMessInfo::Earnings >*
WSToClientEarnings::mutable_earnings() {
  return &earnings_;
}

// -------------------------------------------------------------------

// Earnings

// required int32 itemid = 1;
inline bool Earnings::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Earnings::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Earnings::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Earnings::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 Earnings::itemid() const {
  return itemid_;
}
inline void Earnings::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 coin = 2;
inline bool Earnings::has_coin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Earnings::set_has_coin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Earnings::clear_has_coin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Earnings::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 Earnings::coin() const {
  return coin_;
}
inline void Earnings::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// optional int32 num = 3;
inline bool Earnings::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Earnings::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Earnings::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Earnings::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 Earnings::num() const {
  return num_;
}
inline void Earnings::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 earningsprice = 4;
inline bool Earnings::has_earningsprice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Earnings::set_has_earningsprice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Earnings::clear_has_earningsprice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Earnings::clear_earningsprice() {
  earningsprice_ = 0;
  clear_has_earningsprice();
}
inline ::google::protobuf::int32 Earnings::earningsprice() const {
  return earningsprice_;
}
inline void Earnings::set_earningsprice(::google::protobuf::int32 value) {
  set_has_earningsprice();
  earningsprice_ = value;
}

// optional int32 blocks = 5;
inline bool Earnings::has_blocks() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Earnings::set_has_blocks() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Earnings::clear_has_blocks() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Earnings::clear_blocks() {
  blocks_ = 0;
  clear_has_blocks();
}
inline ::google::protobuf::int32 Earnings::blocks() const {
  return blocks_;
}
inline void Earnings::set_blocks(::google::protobuf::int32 value) {
  set_has_blocks();
  blocks_ = value;
}

// optional int64 time = 6;
inline bool Earnings::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Earnings::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Earnings::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Earnings::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 Earnings::time() const {
  return time_;
}
inline void Earnings::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional string charname = 7;
inline bool Earnings::has_charname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Earnings::set_has_charname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Earnings::clear_has_charname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Earnings::clear_charname() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    charname_->clear();
  }
  clear_has_charname();
}
inline const ::std::string& Earnings::charname() const {
  return *charname_;
}
inline void Earnings::set_charname(const ::std::string& value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void Earnings::set_charname(const char* value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void Earnings::set_charname(const char* value, size_t size) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Earnings::mutable_charname() {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  return charname_;
}
inline ::std::string* Earnings::release_charname() {
  clear_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charname_;
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Earnings::set_allocated_charname(::std::string* charname) {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (charname) {
    set_has_charname();
    charname_ = charname;
  } else {
    clear_has_charname();
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WSReqGameMarketInfo

// optional int64 charid = 1;
inline bool WSReqGameMarketInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WSReqGameMarketInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WSReqGameMarketInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WSReqGameMarketInfo::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 WSReqGameMarketInfo::charid() const {
  return charid_;
}
inline void WSReqGameMarketInfo::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// optional int32 itemid = 2;
inline bool WSReqGameMarketInfo::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WSReqGameMarketInfo::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WSReqGameMarketInfo::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WSReqGameMarketInfo::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 WSReqGameMarketInfo::itemid() const {
  return itemid_;
}
inline void WSReqGameMarketInfo::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 num = 3;
inline bool WSReqGameMarketInfo::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WSReqGameMarketInfo::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WSReqGameMarketInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WSReqGameMarketInfo::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 WSReqGameMarketInfo::num() const {
  return num_;
}
inline void WSReqGameMarketInfo::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 price = 4;
inline bool WSReqGameMarketInfo::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WSReqGameMarketInfo::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WSReqGameMarketInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WSReqGameMarketInfo::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 WSReqGameMarketInfo::price() const {
  return price_;
}
inline void WSReqGameMarketInfo::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// optional int32 coin = 5;
inline bool WSReqGameMarketInfo::has_coin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WSReqGameMarketInfo::set_has_coin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WSReqGameMarketInfo::clear_has_coin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WSReqGameMarketInfo::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 WSReqGameMarketInfo::coin() const {
  return coin_;
}
inline void WSReqGameMarketInfo::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// -------------------------------------------------------------------

// GMRetGameMarketInfo

// required int32 ret = 1;
inline bool GMRetGameMarketInfo::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMRetGameMarketInfo::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMRetGameMarketInfo::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMRetGameMarketInfo::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 GMRetGameMarketInfo::ret() const {
  return ret_;
}
inline void GMRetGameMarketInfo::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// required int32 itemid = 2;
inline bool GMRetGameMarketInfo::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMRetGameMarketInfo::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMRetGameMarketInfo::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMRetGameMarketInfo::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 GMRetGameMarketInfo::itemid() const {
  return itemid_;
}
inline void GMRetGameMarketInfo::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 num = 3;
inline bool GMRetGameMarketInfo::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GMRetGameMarketInfo::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GMRetGameMarketInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GMRetGameMarketInfo::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 GMRetGameMarketInfo::num() const {
  return num_;
}
inline void GMRetGameMarketInfo::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 price = 4;
inline bool GMRetGameMarketInfo::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GMRetGameMarketInfo::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GMRetGameMarketInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GMRetGameMarketInfo::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 GMRetGameMarketInfo::price() const {
  return price_;
}
inline void GMRetGameMarketInfo::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// optional int32 coin = 5;
inline bool GMRetGameMarketInfo::has_coin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GMRetGameMarketInfo::set_has_coin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GMRetGameMarketInfo::clear_has_coin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GMRetGameMarketInfo::clear_coin() {
  coin_ = 0;
  clear_has_coin();
}
inline ::google::protobuf::int32 GMRetGameMarketInfo::coin() const {
  return coin_;
}
inline void GMRetGameMarketInfo::set_coin(::google::protobuf::int32 value) {
  set_has_coin();
  coin_ = value;
}

// optional .MarketMessInfo.ClientItemInfo itemInfo = 6;
inline bool GMRetGameMarketInfo::has_iteminfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GMRetGameMarketInfo::set_has_iteminfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GMRetGameMarketInfo::clear_has_iteminfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GMRetGameMarketInfo::clear_iteminfo() {
  if (iteminfo_ != NULL) iteminfo_->::MarketMessInfo::ClientItemInfo::Clear();
  clear_has_iteminfo();
}
inline const ::MarketMessInfo::ClientItemInfo& GMRetGameMarketInfo::iteminfo() const {
  return iteminfo_ != NULL ? *iteminfo_ : *default_instance_->iteminfo_;
}
inline ::MarketMessInfo::ClientItemInfo* GMRetGameMarketInfo::mutable_iteminfo() {
  set_has_iteminfo();
  if (iteminfo_ == NULL) iteminfo_ = new ::MarketMessInfo::ClientItemInfo;
  return iteminfo_;
}
inline ::MarketMessInfo::ClientItemInfo* GMRetGameMarketInfo::release_iteminfo() {
  clear_has_iteminfo();
  ::MarketMessInfo::ClientItemInfo* temp = iteminfo_;
  iteminfo_ = NULL;
  return temp;
}
inline void GMRetGameMarketInfo::set_allocated_iteminfo(::MarketMessInfo::ClientItemInfo* iteminfo) {
  delete iteminfo_;
  iteminfo_ = iteminfo;
  if (iteminfo) {
    set_has_iteminfo();
  } else {
    clear_has_iteminfo();
  }
}

// -------------------------------------------------------------------

// EarningsInfo

// required int64 charId = 1;
inline bool EarningsInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EarningsInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EarningsInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EarningsInfo::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 EarningsInfo::charid() const {
  return charid_;
}
inline void EarningsInfo::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// optional int32 rets = 2;
inline bool EarningsInfo::has_rets() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EarningsInfo::set_has_rets() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EarningsInfo::clear_has_rets() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EarningsInfo::clear_rets() {
  rets_ = 0;
  clear_has_rets();
}
inline ::google::protobuf::int32 EarningsInfo::rets() const {
  return rets_;
}
inline void EarningsInfo::set_rets(::google::protobuf::int32 value) {
  set_has_rets();
  rets_ = value;
}

// optional int32 rett = 3;
inline bool EarningsInfo::has_rett() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EarningsInfo::set_has_rett() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EarningsInfo::clear_has_rett() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EarningsInfo::clear_rett() {
  rett_ = 0;
  clear_has_rett();
}
inline ::google::protobuf::int32 EarningsInfo::rett() const {
  return rett_;
}
inline void EarningsInfo::set_rett(::google::protobuf::int32 value) {
  set_has_rett();
  rett_ = value;
}

// optional int32 retfo = 4;
inline bool EarningsInfo::has_retfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EarningsInfo::set_has_retfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EarningsInfo::clear_has_retfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EarningsInfo::clear_retfo() {
  retfo_ = 0;
  clear_has_retfo();
}
inline ::google::protobuf::int32 EarningsInfo::retfo() const {
  return retfo_;
}
inline void EarningsInfo::set_retfo(::google::protobuf::int32 value) {
  set_has_retfo();
  retfo_ = value;
}

// optional .MarketMessInfo.ClientItemInfo itemInfo = 5;
inline bool EarningsInfo::has_iteminfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EarningsInfo::set_has_iteminfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EarningsInfo::clear_has_iteminfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EarningsInfo::clear_iteminfo() {
  if (iteminfo_ != NULL) iteminfo_->::MarketMessInfo::ClientItemInfo::Clear();
  clear_has_iteminfo();
}
inline const ::MarketMessInfo::ClientItemInfo& EarningsInfo::iteminfo() const {
  return iteminfo_ != NULL ? *iteminfo_ : *default_instance_->iteminfo_;
}
inline ::MarketMessInfo::ClientItemInfo* EarningsInfo::mutable_iteminfo() {
  set_has_iteminfo();
  if (iteminfo_ == NULL) iteminfo_ = new ::MarketMessInfo::ClientItemInfo;
  return iteminfo_;
}
inline ::MarketMessInfo::ClientItemInfo* EarningsInfo::release_iteminfo() {
  clear_has_iteminfo();
  ::MarketMessInfo::ClientItemInfo* temp = iteminfo_;
  iteminfo_ = NULL;
  return temp;
}
inline void EarningsInfo::set_allocated_iteminfo(::MarketMessInfo::ClientItemInfo* iteminfo) {
  delete iteminfo_;
  iteminfo_ = iteminfo;
  if (iteminfo) {
    set_has_iteminfo();
  } else {
    clear_has_iteminfo();
  }
}

// -------------------------------------------------------------------

// ClientMarketUIState

// -------------------------------------------------------------------

// WSToGMSellerUIState

// required int64 charID = 1;
inline bool WSToGMSellerUIState::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WSToGMSellerUIState::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WSToGMSellerUIState::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WSToGMSellerUIState::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 WSToGMSellerUIState::charid() const {
  return charid_;
}
inline void WSToGMSellerUIState::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace MarketMessInfo

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Market_2fMarket_2eproto__INCLUDED

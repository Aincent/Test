// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Market/Market.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Market/Market.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace MarketMessInfo {

namespace {

const ::google::protobuf::Descriptor* ClientReqMarketInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqMarketInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* WSToClientMarketInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WSToClientMarketInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientItemInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientItemInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* MarketInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MarketInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqMarketShopping_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqMarketShopping_reflection_ = NULL;
const ::google::protobuf::Descriptor* WSToClientShopping_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WSToClientShopping_reflection_ = NULL;
const ::google::protobuf::Descriptor* WSToClientShopInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WSToClientShopInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShopInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShopInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqUnderCarriage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqUnderCarriage_reflection_ = NULL;
const ::google::protobuf::Descriptor* WSToClientUnderCarriage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WSToClientUnderCarriage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqUpCarriage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqUpCarriage_reflection_ = NULL;
const ::google::protobuf::Descriptor* WSToClientUpCarriage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WSToClientUpCarriage_reflection_ = NULL;
const ::google::protobuf::Descriptor* WSToClientEarnings_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WSToClientEarnings_reflection_ = NULL;
const ::google::protobuf::Descriptor* Earnings_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Earnings_reflection_ = NULL;
const ::google::protobuf::Descriptor* WSReqGameMarketInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WSReqGameMarketInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* GMRetGameMarketInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GMRetGameMarketInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* EarningsInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EarningsInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientMarketUIState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientMarketUIState_reflection_ = NULL;
const ::google::protobuf::Descriptor* WSToGMSellerUIState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WSToGMSellerUIState_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_Market_2fMarket_2eproto() {
  protobuf_AddDesc_Market_2fMarket_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "Market/Market.proto");
  GOOGLE_CHECK(file != NULL);
  ClientReqMarketInfo_descriptor_ = file->message_type(0);
  static const int ClientReqMarketInfo_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqMarketInfo, page_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqMarketInfo, quality_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqMarketInfo, lv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqMarketInfo, coin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqMarketInfo, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqMarketInfo, littletype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqMarketInfo, keyworld_),
  };
  ClientReqMarketInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqMarketInfo_descriptor_,
      ClientReqMarketInfo::default_instance_,
      ClientReqMarketInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqMarketInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqMarketInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqMarketInfo));
  WSToClientMarketInfo_descriptor_ = file->message_type(1);
  static const int WSToClientMarketInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientMarketInfo, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientMarketInfo, totalpage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientMarketInfo, markerinfo_),
  };
  WSToClientMarketInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WSToClientMarketInfo_descriptor_,
      WSToClientMarketInfo::default_instance_,
      WSToClientMarketInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientMarketInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientMarketInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WSToClientMarketInfo));
  ClientItemInfo_descriptor_ = file->message_type(2);
  static const int ClientItemInfo_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientItemInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientItemInfo, flag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientItemInfo, newattr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientItemInfo, stoneid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientItemInfo, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientItemInfo, num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientItemInfo, inlaypos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientItemInfo, refineattrlv_),
  };
  ClientItemInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientItemInfo_descriptor_,
      ClientItemInfo::default_instance_,
      ClientItemInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientItemInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientItemInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientItemInfo));
  MarketInfo_descriptor_ = file->message_type(3);
  static const int MarketInfo_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MarketInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MarketInfo, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MarketInfo, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MarketInfo, num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MarketInfo, price_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MarketInfo, coin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MarketInfo, charname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MarketInfo, iteminfo_),
  };
  MarketInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MarketInfo_descriptor_,
      MarketInfo::default_instance_,
      MarketInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MarketInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MarketInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MarketInfo));
  ClientReqMarketShopping_descriptor_ = file->message_type(4);
  static const int ClientReqMarketShopping_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqMarketShopping, id_),
  };
  ClientReqMarketShopping_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqMarketShopping_descriptor_,
      ClientReqMarketShopping::default_instance_,
      ClientReqMarketShopping_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqMarketShopping, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqMarketShopping, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqMarketShopping));
  WSToClientShopping_descriptor_ = file->message_type(5);
  static const int WSToClientShopping_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientShopping, ret_),
  };
  WSToClientShopping_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WSToClientShopping_descriptor_,
      WSToClientShopping::default_instance_,
      WSToClientShopping_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientShopping, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientShopping, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WSToClientShopping));
  WSToClientShopInfo_descriptor_ = file->message_type(6);
  static const int WSToClientShopInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientShopInfo, shopinfo_),
  };
  WSToClientShopInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WSToClientShopInfo_descriptor_,
      WSToClientShopInfo::default_instance_,
      WSToClientShopInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientShopInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientShopInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WSToClientShopInfo));
  ShopInfo_descriptor_ = file->message_type(7);
  static const int ShopInfo_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShopInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShopInfo, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShopInfo, num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShopInfo, price_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShopInfo, coin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShopInfo, iteminfo_),
  };
  ShopInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShopInfo_descriptor_,
      ShopInfo::default_instance_,
      ShopInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShopInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShopInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShopInfo));
  ClientReqUnderCarriage_descriptor_ = file->message_type(8);
  static const int ClientReqUnderCarriage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqUnderCarriage, id_),
  };
  ClientReqUnderCarriage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqUnderCarriage_descriptor_,
      ClientReqUnderCarriage::default_instance_,
      ClientReqUnderCarriage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqUnderCarriage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqUnderCarriage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqUnderCarriage));
  WSToClientUnderCarriage_descriptor_ = file->message_type(9);
  static const int WSToClientUnderCarriage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientUnderCarriage, ret_),
  };
  WSToClientUnderCarriage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WSToClientUnderCarriage_descriptor_,
      WSToClientUnderCarriage::default_instance_,
      WSToClientUnderCarriage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientUnderCarriage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientUnderCarriage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WSToClientUnderCarriage));
  ClientReqUpCarriage_descriptor_ = file->message_type(10);
  static const int ClientReqUpCarriage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqUpCarriage, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqUpCarriage, coin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqUpCarriage, num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqUpCarriage, price_),
  };
  ClientReqUpCarriage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqUpCarriage_descriptor_,
      ClientReqUpCarriage::default_instance_,
      ClientReqUpCarriage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqUpCarriage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqUpCarriage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqUpCarriage));
  WSToClientUpCarriage_descriptor_ = file->message_type(11);
  static const int WSToClientUpCarriage_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientUpCarriage, ret_),
  };
  WSToClientUpCarriage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WSToClientUpCarriage_descriptor_,
      WSToClientUpCarriage::default_instance_,
      WSToClientUpCarriage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientUpCarriage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientUpCarriage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WSToClientUpCarriage));
  WSToClientEarnings_descriptor_ = file->message_type(12);
  static const int WSToClientEarnings_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientEarnings, earnings_),
  };
  WSToClientEarnings_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WSToClientEarnings_descriptor_,
      WSToClientEarnings::default_instance_,
      WSToClientEarnings_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientEarnings, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientEarnings, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WSToClientEarnings));
  Earnings_descriptor_ = file->message_type(13);
  static const int Earnings_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Earnings, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Earnings, coin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Earnings, num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Earnings, earningsprice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Earnings, blocks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Earnings, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Earnings, charname_),
  };
  Earnings_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Earnings_descriptor_,
      Earnings::default_instance_,
      Earnings_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Earnings, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Earnings, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Earnings));
  WSReqGameMarketInfo_descriptor_ = file->message_type(14);
  static const int WSReqGameMarketInfo_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSReqGameMarketInfo, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSReqGameMarketInfo, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSReqGameMarketInfo, num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSReqGameMarketInfo, price_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSReqGameMarketInfo, coin_),
  };
  WSReqGameMarketInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WSReqGameMarketInfo_descriptor_,
      WSReqGameMarketInfo::default_instance_,
      WSReqGameMarketInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSReqGameMarketInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSReqGameMarketInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WSReqGameMarketInfo));
  GMRetGameMarketInfo_descriptor_ = file->message_type(15);
  static const int GMRetGameMarketInfo_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GMRetGameMarketInfo, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GMRetGameMarketInfo, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GMRetGameMarketInfo, num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GMRetGameMarketInfo, price_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GMRetGameMarketInfo, coin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GMRetGameMarketInfo, iteminfo_),
  };
  GMRetGameMarketInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GMRetGameMarketInfo_descriptor_,
      GMRetGameMarketInfo::default_instance_,
      GMRetGameMarketInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GMRetGameMarketInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GMRetGameMarketInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GMRetGameMarketInfo));
  EarningsInfo_descriptor_ = file->message_type(16);
  static const int EarningsInfo_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EarningsInfo, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EarningsInfo, rets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EarningsInfo, rett_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EarningsInfo, retfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EarningsInfo, iteminfo_),
  };
  EarningsInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EarningsInfo_descriptor_,
      EarningsInfo::default_instance_,
      EarningsInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EarningsInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EarningsInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EarningsInfo));
  ClientMarketUIState_descriptor_ = file->message_type(17);
  static const int ClientMarketUIState_offsets_[1] = {
  };
  ClientMarketUIState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientMarketUIState_descriptor_,
      ClientMarketUIState::default_instance_,
      ClientMarketUIState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientMarketUIState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientMarketUIState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientMarketUIState));
  WSToGMSellerUIState_descriptor_ = file->message_type(18);
  static const int WSToGMSellerUIState_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToGMSellerUIState, charid_),
  };
  WSToGMSellerUIState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WSToGMSellerUIState_descriptor_,
      WSToGMSellerUIState::default_instance_,
      WSToGMSellerUIState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToGMSellerUIState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToGMSellerUIState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WSToGMSellerUIState));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_Market_2fMarket_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqMarketInfo_descriptor_, &ClientReqMarketInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WSToClientMarketInfo_descriptor_, &WSToClientMarketInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientItemInfo_descriptor_, &ClientItemInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MarketInfo_descriptor_, &MarketInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqMarketShopping_descriptor_, &ClientReqMarketShopping::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WSToClientShopping_descriptor_, &WSToClientShopping::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WSToClientShopInfo_descriptor_, &WSToClientShopInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShopInfo_descriptor_, &ShopInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqUnderCarriage_descriptor_, &ClientReqUnderCarriage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WSToClientUnderCarriage_descriptor_, &WSToClientUnderCarriage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqUpCarriage_descriptor_, &ClientReqUpCarriage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WSToClientUpCarriage_descriptor_, &WSToClientUpCarriage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WSToClientEarnings_descriptor_, &WSToClientEarnings::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Earnings_descriptor_, &Earnings::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WSReqGameMarketInfo_descriptor_, &WSReqGameMarketInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GMRetGameMarketInfo_descriptor_, &GMRetGameMarketInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EarningsInfo_descriptor_, &EarningsInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientMarketUIState_descriptor_, &ClientMarketUIState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WSToGMSellerUIState_descriptor_, &WSToGMSellerUIState::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_Market_2fMarket_2eproto() {
  delete ClientReqMarketInfo::default_instance_;
  delete ClientReqMarketInfo_reflection_;
  delete WSToClientMarketInfo::default_instance_;
  delete WSToClientMarketInfo_reflection_;
  delete ClientItemInfo::default_instance_;
  delete ClientItemInfo_reflection_;
  delete MarketInfo::default_instance_;
  delete MarketInfo_reflection_;
  delete ClientReqMarketShopping::default_instance_;
  delete ClientReqMarketShopping_reflection_;
  delete WSToClientShopping::default_instance_;
  delete WSToClientShopping_reflection_;
  delete WSToClientShopInfo::default_instance_;
  delete WSToClientShopInfo_reflection_;
  delete ShopInfo::default_instance_;
  delete ShopInfo_reflection_;
  delete ClientReqUnderCarriage::default_instance_;
  delete ClientReqUnderCarriage_reflection_;
  delete WSToClientUnderCarriage::default_instance_;
  delete WSToClientUnderCarriage_reflection_;
  delete ClientReqUpCarriage::default_instance_;
  delete ClientReqUpCarriage_reflection_;
  delete WSToClientUpCarriage::default_instance_;
  delete WSToClientUpCarriage_reflection_;
  delete WSToClientEarnings::default_instance_;
  delete WSToClientEarnings_reflection_;
  delete Earnings::default_instance_;
  delete Earnings_reflection_;
  delete WSReqGameMarketInfo::default_instance_;
  delete WSReqGameMarketInfo_reflection_;
  delete GMRetGameMarketInfo::default_instance_;
  delete GMRetGameMarketInfo_reflection_;
  delete EarningsInfo::default_instance_;
  delete EarningsInfo_reflection_;
  delete ClientMarketUIState::default_instance_;
  delete ClientMarketUIState_reflection_;
  delete WSToGMSellerUIState::default_instance_;
  delete WSToGMSellerUIState_reflection_;
}

void protobuf_AddDesc_Market_2fMarket_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\023Market/Market.proto\022\016MarketMessInfo\"\202\001"
    "\n\023ClientReqMarketInfo\022\014\n\004page\030\001 \002(\005\022\017\n\007q"
    "uality\030\002 \001(\005\022\n\n\002lv\030\003 \001(\005\022\014\n\004coin\030\004 \001(\005\022\014"
    "\n\004type\030\005 \001(\005\022\022\n\nlittletype\030\006 \001(\005\022\020\n\010keyw"
    "orld\030\007 \001(\t\"f\n\024WSToClientMarketInfo\022\013\n\003re"
    "t\030\001 \002(\005\022\021\n\ttotalpage\030\002 \001(\005\022.\n\nmarkerinfo"
    "\030\003 \003(\0132\032.MarketMessInfo.MarketInfo\"\217\001\n\016C"
    "lientItemInfo\022\n\n\002id\030\001 \002(\005\022\014\n\004flag\030\002 \001(\r\022"
    "\017\n\007newattr\030\003 \003(\r\022\017\n\007stoneid\030\004 \003(\005\022\014\n\004tim"
    "e\030\005 \001(\r\022\013\n\003num\030\006 \001(\r\022\020\n\010inlayPos\030\007 \003(\005\022\024"
    "\n\014refineAttrLv\030\010 \003(\r\"\246\001\n\nMarketInfo\022\n\n\002i"
    "d\030\001 \002(\003\022\016\n\006charid\030\002 \001(\003\022\016\n\006itemid\030\003 \001(\005\022"
    "\013\n\003num\030\004 \001(\005\022\r\n\005price\030\005 \001(\005\022\014\n\004coin\030\006 \001("
    "\005\022\020\n\010charname\030\007 \001(\t\0220\n\010itemInfo\030\010 \001(\0132\036."
    "MarketMessInfo.ClientItemInfo\"%\n\027ClientR"
    "eqMarketShopping\022\n\n\002id\030\001 \002(\003\"!\n\022WSToClie"
    "ntShopping\022\013\n\003ret\030\001 \002(\005\"@\n\022WSToClientSho"
    "pInfo\022*\n\010shopinfo\030\001 \003(\0132\030.MarketMessInfo"
    ".ShopInfo\"\202\001\n\010ShopInfo\022\n\n\002id\030\001 \002(\003\022\016\n\006it"
    "emid\030\002 \001(\005\022\013\n\003num\030\003 \001(\005\022\r\n\005price\030\004 \001(\005\022\014"
    "\n\004coin\030\005 \001(\005\0220\n\010itemInfo\030\006 \001(\0132\036.MarketM"
    "essInfo.ClientItemInfo\"$\n\026ClientReqUnder"
    "Carriage\022\n\n\002id\030\001 \002(\003\"&\n\027WSToClientUnderC"
    "arriage\022\013\n\003ret\030\001 \002(\005\"O\n\023ClientReqUpCarri"
    "age\022\016\n\006itemid\030\001 \002(\005\022\014\n\004coin\030\002 \001(\005\022\013\n\003num"
    "\030\003 \001(\005\022\r\n\005price\030\004 \001(\005\"#\n\024WSToClientUpCar"
    "riage\022\013\n\003ret\030\001 \002(\005\"@\n\022WSToClientEarnings"
    "\022*\n\010earnings\030\001 \003(\0132\030.MarketMessInfo.Earn"
    "ings\"|\n\010Earnings\022\016\n\006itemid\030\001 \002(\005\022\014\n\004coin"
    "\030\002 \001(\005\022\013\n\003num\030\003 \001(\005\022\025\n\rearningsprice\030\004 \001"
    "(\005\022\016\n\006blocks\030\005 \001(\005\022\014\n\004time\030\006 \001(\003\022\020\n\010char"
    "name\030\007 \001(\t\"_\n\023WSReqGameMarketInfo\022\016\n\006cha"
    "rid\030\001 \001(\003\022\016\n\006itemid\030\002 \001(\005\022\013\n\003num\030\003 \001(\005\022\r"
    "\n\005price\030\004 \001(\005\022\014\n\004coin\030\005 \001(\005\"\216\001\n\023GMRetGam"
    "eMarketInfo\022\013\n\003ret\030\001 \002(\005\022\016\n\006itemid\030\002 \002(\005"
    "\022\013\n\003num\030\003 \001(\005\022\r\n\005price\030\004 \001(\005\022\014\n\004coin\030\005 \001"
    "(\005\0220\n\010itemInfo\030\006 \001(\0132\036.MarketMessInfo.Cl"
    "ientItemInfo\"{\n\014EarningsInfo\022\016\n\006charId\030\001"
    " \002(\003\022\014\n\004rets\030\002 \001(\005\022\014\n\004rett\030\003 \001(\005\022\r\n\005retf"
    "o\030\004 \001(\005\0220\n\010itemInfo\030\005 \001(\0132\036.MarketMessIn"
    "fo.ClientItemInfo\"\025\n\023ClientMarketUIState"
    "\"%\n\023WSToGMSellerUIState\022\016\n\006charID\030\001 \002(\003", 1679);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "Market/Market.proto", &protobuf_RegisterTypes);
  ClientReqMarketInfo::default_instance_ = new ClientReqMarketInfo();
  WSToClientMarketInfo::default_instance_ = new WSToClientMarketInfo();
  ClientItemInfo::default_instance_ = new ClientItemInfo();
  MarketInfo::default_instance_ = new MarketInfo();
  ClientReqMarketShopping::default_instance_ = new ClientReqMarketShopping();
  WSToClientShopping::default_instance_ = new WSToClientShopping();
  WSToClientShopInfo::default_instance_ = new WSToClientShopInfo();
  ShopInfo::default_instance_ = new ShopInfo();
  ClientReqUnderCarriage::default_instance_ = new ClientReqUnderCarriage();
  WSToClientUnderCarriage::default_instance_ = new WSToClientUnderCarriage();
  ClientReqUpCarriage::default_instance_ = new ClientReqUpCarriage();
  WSToClientUpCarriage::default_instance_ = new WSToClientUpCarriage();
  WSToClientEarnings::default_instance_ = new WSToClientEarnings();
  Earnings::default_instance_ = new Earnings();
  WSReqGameMarketInfo::default_instance_ = new WSReqGameMarketInfo();
  GMRetGameMarketInfo::default_instance_ = new GMRetGameMarketInfo();
  EarningsInfo::default_instance_ = new EarningsInfo();
  ClientMarketUIState::default_instance_ = new ClientMarketUIState();
  WSToGMSellerUIState::default_instance_ = new WSToGMSellerUIState();
  ClientReqMarketInfo::default_instance_->InitAsDefaultInstance();
  WSToClientMarketInfo::default_instance_->InitAsDefaultInstance();
  ClientItemInfo::default_instance_->InitAsDefaultInstance();
  MarketInfo::default_instance_->InitAsDefaultInstance();
  ClientReqMarketShopping::default_instance_->InitAsDefaultInstance();
  WSToClientShopping::default_instance_->InitAsDefaultInstance();
  WSToClientShopInfo::default_instance_->InitAsDefaultInstance();
  ShopInfo::default_instance_->InitAsDefaultInstance();
  ClientReqUnderCarriage::default_instance_->InitAsDefaultInstance();
  WSToClientUnderCarriage::default_instance_->InitAsDefaultInstance();
  ClientReqUpCarriage::default_instance_->InitAsDefaultInstance();
  WSToClientUpCarriage::default_instance_->InitAsDefaultInstance();
  WSToClientEarnings::default_instance_->InitAsDefaultInstance();
  Earnings::default_instance_->InitAsDefaultInstance();
  WSReqGameMarketInfo::default_instance_->InitAsDefaultInstance();
  GMRetGameMarketInfo::default_instance_->InitAsDefaultInstance();
  EarningsInfo::default_instance_->InitAsDefaultInstance();
  ClientMarketUIState::default_instance_->InitAsDefaultInstance();
  WSToGMSellerUIState::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Market_2fMarket_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Market_2fMarket_2eproto {
  StaticDescriptorInitializer_Market_2fMarket_2eproto() {
    protobuf_AddDesc_Market_2fMarket_2eproto();
  }
} static_descriptor_initializer_Market_2fMarket_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int ClientReqMarketInfo::kPageFieldNumber;
const int ClientReqMarketInfo::kQualityFieldNumber;
const int ClientReqMarketInfo::kLvFieldNumber;
const int ClientReqMarketInfo::kCoinFieldNumber;
const int ClientReqMarketInfo::kTypeFieldNumber;
const int ClientReqMarketInfo::kLittletypeFieldNumber;
const int ClientReqMarketInfo::kKeyworldFieldNumber;
#endif  // !_MSC_VER

ClientReqMarketInfo::ClientReqMarketInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqMarketInfo::InitAsDefaultInstance() {
}

ClientReqMarketInfo::ClientReqMarketInfo(const ClientReqMarketInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqMarketInfo::SharedCtor() {
  _cached_size_ = 0;
  page_ = 0;
  quality_ = 0;
  lv_ = 0;
  coin_ = 0;
  type_ = 0;
  littletype_ = 0;
  keyworld_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqMarketInfo::~ClientReqMarketInfo() {
  SharedDtor();
}

void ClientReqMarketInfo::SharedDtor() {
  if (keyworld_ != &::google::protobuf::internal::kEmptyString) {
    delete keyworld_;
  }
  if (this != default_instance_) {
  }
}

void ClientReqMarketInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqMarketInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqMarketInfo_descriptor_;
}

const ClientReqMarketInfo& ClientReqMarketInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

ClientReqMarketInfo* ClientReqMarketInfo::default_instance_ = NULL;

ClientReqMarketInfo* ClientReqMarketInfo::New() const {
  return new ClientReqMarketInfo;
}

void ClientReqMarketInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    page_ = 0;
    quality_ = 0;
    lv_ = 0;
    coin_ = 0;
    type_ = 0;
    littletype_ = 0;
    if (has_keyworld()) {
      if (keyworld_ != &::google::protobuf::internal::kEmptyString) {
        keyworld_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqMarketInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 page = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &page_)));
          set_has_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_quality;
        break;
      }

      // optional int32 quality = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_quality:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &quality_)));
          set_has_quality();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_lv;
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lv_)));
          set_has_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_coin;
        break;
      }

      // optional int32 coin = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_coin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &coin_)));
          set_has_coin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_type;
        break;
      }

      // optional int32 type = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_littletype;
        break;
      }

      // optional int32 littletype = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_littletype:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &littletype_)));
          set_has_littletype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_keyworld;
        break;
      }

      // optional string keyworld = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_keyworld:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_keyworld()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->keyworld().data(), this->keyworld().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqMarketInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 page = 1;
  if (has_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->page(), output);
  }

  // optional int32 quality = 2;
  if (has_quality()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->quality(), output);
  }

  // optional int32 lv = 3;
  if (has_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lv(), output);
  }

  // optional int32 coin = 4;
  if (has_coin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->coin(), output);
  }

  // optional int32 type = 5;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->type(), output);
  }

  // optional int32 littletype = 6;
  if (has_littletype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->littletype(), output);
  }

  // optional string keyworld = 7;
  if (has_keyworld()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->keyworld().data(), this->keyworld().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->keyworld(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqMarketInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 page = 1;
  if (has_page()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->page(), target);
  }

  // optional int32 quality = 2;
  if (has_quality()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->quality(), target);
  }

  // optional int32 lv = 3;
  if (has_lv()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lv(), target);
  }

  // optional int32 coin = 4;
  if (has_coin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->coin(), target);
  }

  // optional int32 type = 5;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->type(), target);
  }

  // optional int32 littletype = 6;
  if (has_littletype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->littletype(), target);
  }

  // optional string keyworld = 7;
  if (has_keyworld()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->keyworld().data(), this->keyworld().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->keyworld(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqMarketInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 page = 1;
    if (has_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->page());
    }

    // optional int32 quality = 2;
    if (has_quality()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->quality());
    }

    // optional int32 lv = 3;
    if (has_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lv());
    }

    // optional int32 coin = 4;
    if (has_coin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->coin());
    }

    // optional int32 type = 5;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 littletype = 6;
    if (has_littletype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->littletype());
    }

    // optional string keyworld = 7;
    if (has_keyworld()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->keyworld());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqMarketInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqMarketInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqMarketInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqMarketInfo::MergeFrom(const ClientReqMarketInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_page()) {
      set_page(from.page());
    }
    if (from.has_quality()) {
      set_quality(from.quality());
    }
    if (from.has_lv()) {
      set_lv(from.lv());
    }
    if (from.has_coin()) {
      set_coin(from.coin());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_littletype()) {
      set_littletype(from.littletype());
    }
    if (from.has_keyworld()) {
      set_keyworld(from.keyworld());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqMarketInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqMarketInfo::CopyFrom(const ClientReqMarketInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqMarketInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqMarketInfo::Swap(ClientReqMarketInfo* other) {
  if (other != this) {
    std::swap(page_, other->page_);
    std::swap(quality_, other->quality_);
    std::swap(lv_, other->lv_);
    std::swap(coin_, other->coin_);
    std::swap(type_, other->type_);
    std::swap(littletype_, other->littletype_);
    std::swap(keyworld_, other->keyworld_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqMarketInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqMarketInfo_descriptor_;
  metadata.reflection = ClientReqMarketInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WSToClientMarketInfo::kRetFieldNumber;
const int WSToClientMarketInfo::kTotalpageFieldNumber;
const int WSToClientMarketInfo::kMarkerinfoFieldNumber;
#endif  // !_MSC_VER

WSToClientMarketInfo::WSToClientMarketInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WSToClientMarketInfo::InitAsDefaultInstance() {
}

WSToClientMarketInfo::WSToClientMarketInfo(const WSToClientMarketInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WSToClientMarketInfo::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  totalpage_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WSToClientMarketInfo::~WSToClientMarketInfo() {
  SharedDtor();
}

void WSToClientMarketInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WSToClientMarketInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WSToClientMarketInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WSToClientMarketInfo_descriptor_;
}

const WSToClientMarketInfo& WSToClientMarketInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

WSToClientMarketInfo* WSToClientMarketInfo::default_instance_ = NULL;

WSToClientMarketInfo* WSToClientMarketInfo::New() const {
  return new WSToClientMarketInfo;
}

void WSToClientMarketInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
    totalpage_ = 0;
  }
  markerinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WSToClientMarketInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_totalpage;
        break;
      }

      // optional int32 totalpage = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_totalpage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &totalpage_)));
          set_has_totalpage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_markerinfo;
        break;
      }

      // repeated .MarketMessInfo.MarketInfo markerinfo = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_markerinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_markerinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_markerinfo;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WSToClientMarketInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  // optional int32 totalpage = 2;
  if (has_totalpage()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->totalpage(), output);
  }

  // repeated .MarketMessInfo.MarketInfo markerinfo = 3;
  for (int i = 0; i < this->markerinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->markerinfo(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WSToClientMarketInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  // optional int32 totalpage = 2;
  if (has_totalpage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->totalpage(), target);
  }

  // repeated .MarketMessInfo.MarketInfo markerinfo = 3;
  for (int i = 0; i < this->markerinfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->markerinfo(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WSToClientMarketInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional int32 totalpage = 2;
    if (has_totalpage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->totalpage());
    }

  }
  // repeated .MarketMessInfo.MarketInfo markerinfo = 3;
  total_size += 1 * this->markerinfo_size();
  for (int i = 0; i < this->markerinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->markerinfo(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WSToClientMarketInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WSToClientMarketInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WSToClientMarketInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WSToClientMarketInfo::MergeFrom(const WSToClientMarketInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  markerinfo_.MergeFrom(from.markerinfo_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_totalpage()) {
      set_totalpage(from.totalpage());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WSToClientMarketInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WSToClientMarketInfo::CopyFrom(const WSToClientMarketInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WSToClientMarketInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < markerinfo_size(); i++) {
    if (!this->markerinfo(i).IsInitialized()) return false;
  }
  return true;
}

void WSToClientMarketInfo::Swap(WSToClientMarketInfo* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(totalpage_, other->totalpage_);
    markerinfo_.Swap(&other->markerinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WSToClientMarketInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WSToClientMarketInfo_descriptor_;
  metadata.reflection = WSToClientMarketInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientItemInfo::kIdFieldNumber;
const int ClientItemInfo::kFlagFieldNumber;
const int ClientItemInfo::kNewattrFieldNumber;
const int ClientItemInfo::kStoneidFieldNumber;
const int ClientItemInfo::kTimeFieldNumber;
const int ClientItemInfo::kNumFieldNumber;
const int ClientItemInfo::kInlayPosFieldNumber;
const int ClientItemInfo::kRefineAttrLvFieldNumber;
#endif  // !_MSC_VER

ClientItemInfo::ClientItemInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientItemInfo::InitAsDefaultInstance() {
}

ClientItemInfo::ClientItemInfo(const ClientItemInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientItemInfo::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  flag_ = 0u;
  time_ = 0u;
  num_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientItemInfo::~ClientItemInfo() {
  SharedDtor();
}

void ClientItemInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientItemInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientItemInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientItemInfo_descriptor_;
}

const ClientItemInfo& ClientItemInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

ClientItemInfo* ClientItemInfo::default_instance_ = NULL;

ClientItemInfo* ClientItemInfo::New() const {
  return new ClientItemInfo;
}

void ClientItemInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    flag_ = 0u;
    time_ = 0u;
    num_ = 0u;
  }
  newattr_.Clear();
  stoneid_.Clear();
  inlaypos_.Clear();
  refineattrlv_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientItemInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_flag;
        break;
      }

      // optional uint32 flag = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flag_)));
          set_has_flag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_newattr;
        break;
      }

      // repeated uint32 newattr = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_newattr:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 24, input, this->mutable_newattr())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_newattr())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_newattr;
        if (input->ExpectTag(32)) goto parse_stoneid;
        break;
      }

      // repeated int32 stoneid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_stoneid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 32, input, this->mutable_stoneid())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_stoneid())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_stoneid;
        if (input->ExpectTag(40)) goto parse_time;
        break;
      }

      // optional uint32 time = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_num;
        break;
      }

      // optional uint32 num = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_inlayPos;
        break;
      }

      // repeated int32 inlayPos = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_inlayPos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 56, input, this->mutable_inlaypos())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_inlaypos())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_inlayPos;
        if (input->ExpectTag(64)) goto parse_refineAttrLv;
        break;
      }

      // repeated uint32 refineAttrLv = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_refineAttrLv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 64, input, this->mutable_refineattrlv())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_refineattrlv())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_refineAttrLv;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientItemInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional uint32 flag = 2;
  if (has_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->flag(), output);
  }

  // repeated uint32 newattr = 3;
  for (int i = 0; i < this->newattr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      3, this->newattr(i), output);
  }

  // repeated int32 stoneid = 4;
  for (int i = 0; i < this->stoneid_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      4, this->stoneid(i), output);
  }

  // optional uint32 time = 5;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->time(), output);
  }

  // optional uint32 num = 6;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->num(), output);
  }

  // repeated int32 inlayPos = 7;
  for (int i = 0; i < this->inlaypos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      7, this->inlaypos(i), output);
  }

  // repeated uint32 refineAttrLv = 8;
  for (int i = 0; i < this->refineattrlv_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      8, this->refineattrlv(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientItemInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional uint32 flag = 2;
  if (has_flag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->flag(), target);
  }

  // repeated uint32 newattr = 3;
  for (int i = 0; i < this->newattr_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(3, this->newattr(i), target);
  }

  // repeated int32 stoneid = 4;
  for (int i = 0; i < this->stoneid_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(4, this->stoneid(i), target);
  }

  // optional uint32 time = 5;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->time(), target);
  }

  // optional uint32 num = 6;
  if (has_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->num(), target);
  }

  // repeated int32 inlayPos = 7;
  for (int i = 0; i < this->inlaypos_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(7, this->inlaypos(i), target);
  }

  // repeated uint32 refineAttrLv = 8;
  for (int i = 0; i < this->refineattrlv_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(8, this->refineattrlv(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientItemInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional uint32 flag = 2;
    if (has_flag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flag());
    }

    // optional uint32 time = 5;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

    // optional uint32 num = 6;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num());
    }

  }
  // repeated uint32 newattr = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->newattr_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->newattr(i));
    }
    total_size += 1 * this->newattr_size() + data_size;
  }

  // repeated int32 stoneid = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->stoneid_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->stoneid(i));
    }
    total_size += 1 * this->stoneid_size() + data_size;
  }

  // repeated int32 inlayPos = 7;
  {
    int data_size = 0;
    for (int i = 0; i < this->inlaypos_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->inlaypos(i));
    }
    total_size += 1 * this->inlaypos_size() + data_size;
  }

  // repeated uint32 refineAttrLv = 8;
  {
    int data_size = 0;
    for (int i = 0; i < this->refineattrlv_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->refineattrlv(i));
    }
    total_size += 1 * this->refineattrlv_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientItemInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientItemInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientItemInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientItemInfo::MergeFrom(const ClientItemInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  newattr_.MergeFrom(from.newattr_);
  stoneid_.MergeFrom(from.stoneid_);
  inlaypos_.MergeFrom(from.inlaypos_);
  refineattrlv_.MergeFrom(from.refineattrlv_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_flag()) {
      set_flag(from.flag());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientItemInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientItemInfo::CopyFrom(const ClientItemInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientItemInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientItemInfo::Swap(ClientItemInfo* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(flag_, other->flag_);
    newattr_.Swap(&other->newattr_);
    stoneid_.Swap(&other->stoneid_);
    std::swap(time_, other->time_);
    std::swap(num_, other->num_);
    inlaypos_.Swap(&other->inlaypos_);
    refineattrlv_.Swap(&other->refineattrlv_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientItemInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientItemInfo_descriptor_;
  metadata.reflection = ClientItemInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MarketInfo::kIdFieldNumber;
const int MarketInfo::kCharidFieldNumber;
const int MarketInfo::kItemidFieldNumber;
const int MarketInfo::kNumFieldNumber;
const int MarketInfo::kPriceFieldNumber;
const int MarketInfo::kCoinFieldNumber;
const int MarketInfo::kCharnameFieldNumber;
const int MarketInfo::kItemInfoFieldNumber;
#endif  // !_MSC_VER

MarketInfo::MarketInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MarketInfo::InitAsDefaultInstance() {
  iteminfo_ = const_cast< ::MarketMessInfo::ClientItemInfo*>(&::MarketMessInfo::ClientItemInfo::default_instance());
}

MarketInfo::MarketInfo(const MarketInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MarketInfo::SharedCtor() {
  _cached_size_ = 0;
  id_ = GOOGLE_LONGLONG(0);
  charid_ = GOOGLE_LONGLONG(0);
  itemid_ = 0;
  num_ = 0;
  price_ = 0;
  coin_ = 0;
  charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  iteminfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MarketInfo::~MarketInfo() {
  SharedDtor();
}

void MarketInfo::SharedDtor() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (this != default_instance_) {
    delete iteminfo_;
  }
}

void MarketInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MarketInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MarketInfo_descriptor_;
}

const MarketInfo& MarketInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

MarketInfo* MarketInfo::default_instance_ = NULL;

MarketInfo* MarketInfo::New() const {
  return new MarketInfo;
}

void MarketInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = GOOGLE_LONGLONG(0);
    charid_ = GOOGLE_LONGLONG(0);
    itemid_ = 0;
    num_ = 0;
    price_ = 0;
    coin_ = 0;
    if (has_charname()) {
      if (charname_ != &::google::protobuf::internal::kEmptyString) {
        charname_->clear();
      }
    }
    if (has_iteminfo()) {
      if (iteminfo_ != NULL) iteminfo_->::MarketMessInfo::ClientItemInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MarketInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_charid;
        break;
      }

      // optional int64 charid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_itemid;
        break;
      }

      // optional int32 itemid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_itemid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_num;
        break;
      }

      // optional int32 num = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_price;
        break;
      }

      // optional int32 price = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_coin;
        break;
      }

      // optional int32 coin = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_coin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &coin_)));
          set_has_coin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_charname;
        break;
      }

      // optional string charname = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_charname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_charname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->charname().data(), this->charname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_itemInfo;
        break;
      }

      // optional .MarketMessInfo.ClientItemInfo itemInfo = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_itemInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_iteminfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MarketInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->id(), output);
  }

  // optional int64 charid = 2;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->charid(), output);
  }

  // optional int32 itemid = 3;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->itemid(), output);
  }

  // optional int32 num = 4;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->num(), output);
  }

  // optional int32 price = 5;
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->price(), output);
  }

  // optional int32 coin = 6;
  if (has_coin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->coin(), output);
  }

  // optional string charname = 7;
  if (has_charname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->charname().data(), this->charname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->charname(), output);
  }

  // optional .MarketMessInfo.ClientItemInfo itemInfo = 8;
  if (has_iteminfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->iteminfo(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MarketInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->id(), target);
  }

  // optional int64 charid = 2;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->charid(), target);
  }

  // optional int32 itemid = 3;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->itemid(), target);
  }

  // optional int32 num = 4;
  if (has_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->num(), target);
  }

  // optional int32 price = 5;
  if (has_price()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->price(), target);
  }

  // optional int32 coin = 6;
  if (has_coin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->coin(), target);
  }

  // optional string charname = 7;
  if (has_charname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->charname().data(), this->charname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->charname(), target);
  }

  // optional .MarketMessInfo.ClientItemInfo itemInfo = 8;
  if (has_iteminfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->iteminfo(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MarketInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->id());
    }

    // optional int64 charid = 2;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

    // optional int32 itemid = 3;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional int32 num = 4;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

    // optional int32 price = 5;
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->price());
    }

    // optional int32 coin = 6;
    if (has_coin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->coin());
    }

    // optional string charname = 7;
    if (has_charname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->charname());
    }

    // optional .MarketMessInfo.ClientItemInfo itemInfo = 8;
    if (has_iteminfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->iteminfo());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MarketInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MarketInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MarketInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MarketInfo::MergeFrom(const MarketInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
    if (from.has_coin()) {
      set_coin(from.coin());
    }
    if (from.has_charname()) {
      set_charname(from.charname());
    }
    if (from.has_iteminfo()) {
      mutable_iteminfo()->::MarketMessInfo::ClientItemInfo::MergeFrom(from.iteminfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MarketInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MarketInfo::CopyFrom(const MarketInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MarketInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_iteminfo()) {
    if (!this->iteminfo().IsInitialized()) return false;
  }
  return true;
}

void MarketInfo::Swap(MarketInfo* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(charid_, other->charid_);
    std::swap(itemid_, other->itemid_);
    std::swap(num_, other->num_);
    std::swap(price_, other->price_);
    std::swap(coin_, other->coin_);
    std::swap(charname_, other->charname_);
    std::swap(iteminfo_, other->iteminfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MarketInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MarketInfo_descriptor_;
  metadata.reflection = MarketInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqMarketShopping::kIdFieldNumber;
#endif  // !_MSC_VER

ClientReqMarketShopping::ClientReqMarketShopping()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqMarketShopping::InitAsDefaultInstance() {
}

ClientReqMarketShopping::ClientReqMarketShopping(const ClientReqMarketShopping& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqMarketShopping::SharedCtor() {
  _cached_size_ = 0;
  id_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqMarketShopping::~ClientReqMarketShopping() {
  SharedDtor();
}

void ClientReqMarketShopping::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqMarketShopping::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqMarketShopping::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqMarketShopping_descriptor_;
}

const ClientReqMarketShopping& ClientReqMarketShopping::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

ClientReqMarketShopping* ClientReqMarketShopping::default_instance_ = NULL;

ClientReqMarketShopping* ClientReqMarketShopping::New() const {
  return new ClientReqMarketShopping;
}

void ClientReqMarketShopping::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqMarketShopping::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqMarketShopping::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqMarketShopping::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqMarketShopping::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqMarketShopping::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqMarketShopping* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqMarketShopping*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqMarketShopping::MergeFrom(const ClientReqMarketShopping& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqMarketShopping::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqMarketShopping::CopyFrom(const ClientReqMarketShopping& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqMarketShopping::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqMarketShopping::Swap(ClientReqMarketShopping* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqMarketShopping::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqMarketShopping_descriptor_;
  metadata.reflection = ClientReqMarketShopping_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WSToClientShopping::kRetFieldNumber;
#endif  // !_MSC_VER

WSToClientShopping::WSToClientShopping()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WSToClientShopping::InitAsDefaultInstance() {
}

WSToClientShopping::WSToClientShopping(const WSToClientShopping& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WSToClientShopping::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WSToClientShopping::~WSToClientShopping() {
  SharedDtor();
}

void WSToClientShopping::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WSToClientShopping::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WSToClientShopping::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WSToClientShopping_descriptor_;
}

const WSToClientShopping& WSToClientShopping::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

WSToClientShopping* WSToClientShopping::default_instance_ = NULL;

WSToClientShopping* WSToClientShopping::New() const {
  return new WSToClientShopping;
}

void WSToClientShopping::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WSToClientShopping::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WSToClientShopping::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WSToClientShopping::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WSToClientShopping::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WSToClientShopping::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WSToClientShopping* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WSToClientShopping*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WSToClientShopping::MergeFrom(const WSToClientShopping& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WSToClientShopping::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WSToClientShopping::CopyFrom(const WSToClientShopping& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WSToClientShopping::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void WSToClientShopping::Swap(WSToClientShopping* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WSToClientShopping::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WSToClientShopping_descriptor_;
  metadata.reflection = WSToClientShopping_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WSToClientShopInfo::kShopinfoFieldNumber;
#endif  // !_MSC_VER

WSToClientShopInfo::WSToClientShopInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WSToClientShopInfo::InitAsDefaultInstance() {
}

WSToClientShopInfo::WSToClientShopInfo(const WSToClientShopInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WSToClientShopInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WSToClientShopInfo::~WSToClientShopInfo() {
  SharedDtor();
}

void WSToClientShopInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WSToClientShopInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WSToClientShopInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WSToClientShopInfo_descriptor_;
}

const WSToClientShopInfo& WSToClientShopInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

WSToClientShopInfo* WSToClientShopInfo::default_instance_ = NULL;

WSToClientShopInfo* WSToClientShopInfo::New() const {
  return new WSToClientShopInfo;
}

void WSToClientShopInfo::Clear() {
  shopinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WSToClientShopInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .MarketMessInfo.ShopInfo shopinfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_shopinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_shopinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_shopinfo;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WSToClientShopInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .MarketMessInfo.ShopInfo shopinfo = 1;
  for (int i = 0; i < this->shopinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->shopinfo(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WSToClientShopInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .MarketMessInfo.ShopInfo shopinfo = 1;
  for (int i = 0; i < this->shopinfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->shopinfo(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WSToClientShopInfo::ByteSize() const {
  int total_size = 0;

  // repeated .MarketMessInfo.ShopInfo shopinfo = 1;
  total_size += 1 * this->shopinfo_size();
  for (int i = 0; i < this->shopinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->shopinfo(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WSToClientShopInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WSToClientShopInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WSToClientShopInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WSToClientShopInfo::MergeFrom(const WSToClientShopInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  shopinfo_.MergeFrom(from.shopinfo_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WSToClientShopInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WSToClientShopInfo::CopyFrom(const WSToClientShopInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WSToClientShopInfo::IsInitialized() const {

  for (int i = 0; i < shopinfo_size(); i++) {
    if (!this->shopinfo(i).IsInitialized()) return false;
  }
  return true;
}

void WSToClientShopInfo::Swap(WSToClientShopInfo* other) {
  if (other != this) {
    shopinfo_.Swap(&other->shopinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WSToClientShopInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WSToClientShopInfo_descriptor_;
  metadata.reflection = WSToClientShopInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShopInfo::kIdFieldNumber;
const int ShopInfo::kItemidFieldNumber;
const int ShopInfo::kNumFieldNumber;
const int ShopInfo::kPriceFieldNumber;
const int ShopInfo::kCoinFieldNumber;
const int ShopInfo::kItemInfoFieldNumber;
#endif  // !_MSC_VER

ShopInfo::ShopInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ShopInfo::InitAsDefaultInstance() {
  iteminfo_ = const_cast< ::MarketMessInfo::ClientItemInfo*>(&::MarketMessInfo::ClientItemInfo::default_instance());
}

ShopInfo::ShopInfo(const ShopInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ShopInfo::SharedCtor() {
  _cached_size_ = 0;
  id_ = GOOGLE_LONGLONG(0);
  itemid_ = 0;
  num_ = 0;
  price_ = 0;
  coin_ = 0;
  iteminfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShopInfo::~ShopInfo() {
  SharedDtor();
}

void ShopInfo::SharedDtor() {
  if (this != default_instance_) {
    delete iteminfo_;
  }
}

void ShopInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShopInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShopInfo_descriptor_;
}

const ShopInfo& ShopInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

ShopInfo* ShopInfo::default_instance_ = NULL;

ShopInfo* ShopInfo::New() const {
  return new ShopInfo;
}

void ShopInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = GOOGLE_LONGLONG(0);
    itemid_ = 0;
    num_ = 0;
    price_ = 0;
    coin_ = 0;
    if (has_iteminfo()) {
      if (iteminfo_ != NULL) iteminfo_->::MarketMessInfo::ClientItemInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShopInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_itemid;
        break;
      }

      // optional int32 itemid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_itemid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_num;
        break;
      }

      // optional int32 num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_price;
        break;
      }

      // optional int32 price = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_coin;
        break;
      }

      // optional int32 coin = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_coin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &coin_)));
          set_has_coin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_itemInfo;
        break;
      }

      // optional .MarketMessInfo.ClientItemInfo itemInfo = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_itemInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_iteminfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShopInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->id(), output);
  }

  // optional int32 itemid = 2;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->itemid(), output);
  }

  // optional int32 num = 3;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->num(), output);
  }

  // optional int32 price = 4;
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->price(), output);
  }

  // optional int32 coin = 5;
  if (has_coin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->coin(), output);
  }

  // optional .MarketMessInfo.ClientItemInfo itemInfo = 6;
  if (has_iteminfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->iteminfo(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ShopInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->id(), target);
  }

  // optional int32 itemid = 2;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->itemid(), target);
  }

  // optional int32 num = 3;
  if (has_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->num(), target);
  }

  // optional int32 price = 4;
  if (has_price()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->price(), target);
  }

  // optional int32 coin = 5;
  if (has_coin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->coin(), target);
  }

  // optional .MarketMessInfo.ClientItemInfo itemInfo = 6;
  if (has_iteminfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->iteminfo(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ShopInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->id());
    }

    // optional int32 itemid = 2;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional int32 num = 3;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

    // optional int32 price = 4;
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->price());
    }

    // optional int32 coin = 5;
    if (has_coin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->coin());
    }

    // optional .MarketMessInfo.ClientItemInfo itemInfo = 6;
    if (has_iteminfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->iteminfo());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShopInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShopInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShopInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShopInfo::MergeFrom(const ShopInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
    if (from.has_coin()) {
      set_coin(from.coin());
    }
    if (from.has_iteminfo()) {
      mutable_iteminfo()->::MarketMessInfo::ClientItemInfo::MergeFrom(from.iteminfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShopInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShopInfo::CopyFrom(const ShopInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShopInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_iteminfo()) {
    if (!this->iteminfo().IsInitialized()) return false;
  }
  return true;
}

void ShopInfo::Swap(ShopInfo* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(itemid_, other->itemid_);
    std::swap(num_, other->num_);
    std::swap(price_, other->price_);
    std::swap(coin_, other->coin_);
    std::swap(iteminfo_, other->iteminfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShopInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShopInfo_descriptor_;
  metadata.reflection = ShopInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqUnderCarriage::kIdFieldNumber;
#endif  // !_MSC_VER

ClientReqUnderCarriage::ClientReqUnderCarriage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqUnderCarriage::InitAsDefaultInstance() {
}

ClientReqUnderCarriage::ClientReqUnderCarriage(const ClientReqUnderCarriage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqUnderCarriage::SharedCtor() {
  _cached_size_ = 0;
  id_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqUnderCarriage::~ClientReqUnderCarriage() {
  SharedDtor();
}

void ClientReqUnderCarriage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqUnderCarriage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqUnderCarriage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqUnderCarriage_descriptor_;
}

const ClientReqUnderCarriage& ClientReqUnderCarriage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

ClientReqUnderCarriage* ClientReqUnderCarriage::default_instance_ = NULL;

ClientReqUnderCarriage* ClientReqUnderCarriage::New() const {
  return new ClientReqUnderCarriage;
}

void ClientReqUnderCarriage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqUnderCarriage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqUnderCarriage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqUnderCarriage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqUnderCarriage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqUnderCarriage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqUnderCarriage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqUnderCarriage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqUnderCarriage::MergeFrom(const ClientReqUnderCarriage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqUnderCarriage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqUnderCarriage::CopyFrom(const ClientReqUnderCarriage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqUnderCarriage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqUnderCarriage::Swap(ClientReqUnderCarriage* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqUnderCarriage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqUnderCarriage_descriptor_;
  metadata.reflection = ClientReqUnderCarriage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WSToClientUnderCarriage::kRetFieldNumber;
#endif  // !_MSC_VER

WSToClientUnderCarriage::WSToClientUnderCarriage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WSToClientUnderCarriage::InitAsDefaultInstance() {
}

WSToClientUnderCarriage::WSToClientUnderCarriage(const WSToClientUnderCarriage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WSToClientUnderCarriage::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WSToClientUnderCarriage::~WSToClientUnderCarriage() {
  SharedDtor();
}

void WSToClientUnderCarriage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WSToClientUnderCarriage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WSToClientUnderCarriage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WSToClientUnderCarriage_descriptor_;
}

const WSToClientUnderCarriage& WSToClientUnderCarriage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

WSToClientUnderCarriage* WSToClientUnderCarriage::default_instance_ = NULL;

WSToClientUnderCarriage* WSToClientUnderCarriage::New() const {
  return new WSToClientUnderCarriage;
}

void WSToClientUnderCarriage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WSToClientUnderCarriage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WSToClientUnderCarriage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WSToClientUnderCarriage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WSToClientUnderCarriage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WSToClientUnderCarriage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WSToClientUnderCarriage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WSToClientUnderCarriage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WSToClientUnderCarriage::MergeFrom(const WSToClientUnderCarriage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WSToClientUnderCarriage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WSToClientUnderCarriage::CopyFrom(const WSToClientUnderCarriage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WSToClientUnderCarriage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void WSToClientUnderCarriage::Swap(WSToClientUnderCarriage* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WSToClientUnderCarriage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WSToClientUnderCarriage_descriptor_;
  metadata.reflection = WSToClientUnderCarriage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqUpCarriage::kItemidFieldNumber;
const int ClientReqUpCarriage::kCoinFieldNumber;
const int ClientReqUpCarriage::kNumFieldNumber;
const int ClientReqUpCarriage::kPriceFieldNumber;
#endif  // !_MSC_VER

ClientReqUpCarriage::ClientReqUpCarriage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqUpCarriage::InitAsDefaultInstance() {
}

ClientReqUpCarriage::ClientReqUpCarriage(const ClientReqUpCarriage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqUpCarriage::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0;
  coin_ = 0;
  num_ = 0;
  price_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqUpCarriage::~ClientReqUpCarriage() {
  SharedDtor();
}

void ClientReqUpCarriage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqUpCarriage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqUpCarriage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqUpCarriage_descriptor_;
}

const ClientReqUpCarriage& ClientReqUpCarriage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

ClientReqUpCarriage* ClientReqUpCarriage::default_instance_ = NULL;

ClientReqUpCarriage* ClientReqUpCarriage::New() const {
  return new ClientReqUpCarriage;
}

void ClientReqUpCarriage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    itemid_ = 0;
    coin_ = 0;
    num_ = 0;
    price_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqUpCarriage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 itemid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_coin;
        break;
      }

      // optional int32 coin = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_coin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &coin_)));
          set_has_coin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_num;
        break;
      }

      // optional int32 num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_price;
        break;
      }

      // optional int32 price = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqUpCarriage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 itemid = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->itemid(), output);
  }

  // optional int32 coin = 2;
  if (has_coin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->coin(), output);
  }

  // optional int32 num = 3;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->num(), output);
  }

  // optional int32 price = 4;
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->price(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqUpCarriage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 itemid = 1;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->itemid(), target);
  }

  // optional int32 coin = 2;
  if (has_coin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->coin(), target);
  }

  // optional int32 num = 3;
  if (has_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->num(), target);
  }

  // optional int32 price = 4;
  if (has_price()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->price(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqUpCarriage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 itemid = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional int32 coin = 2;
    if (has_coin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->coin());
    }

    // optional int32 num = 3;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

    // optional int32 price = 4;
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->price());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqUpCarriage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqUpCarriage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqUpCarriage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqUpCarriage::MergeFrom(const ClientReqUpCarriage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_coin()) {
      set_coin(from.coin());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqUpCarriage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqUpCarriage::CopyFrom(const ClientReqUpCarriage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqUpCarriage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqUpCarriage::Swap(ClientReqUpCarriage* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(coin_, other->coin_);
    std::swap(num_, other->num_);
    std::swap(price_, other->price_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqUpCarriage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqUpCarriage_descriptor_;
  metadata.reflection = ClientReqUpCarriage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WSToClientUpCarriage::kRetFieldNumber;
#endif  // !_MSC_VER

WSToClientUpCarriage::WSToClientUpCarriage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WSToClientUpCarriage::InitAsDefaultInstance() {
}

WSToClientUpCarriage::WSToClientUpCarriage(const WSToClientUpCarriage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WSToClientUpCarriage::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WSToClientUpCarriage::~WSToClientUpCarriage() {
  SharedDtor();
}

void WSToClientUpCarriage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WSToClientUpCarriage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WSToClientUpCarriage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WSToClientUpCarriage_descriptor_;
}

const WSToClientUpCarriage& WSToClientUpCarriage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

WSToClientUpCarriage* WSToClientUpCarriage::default_instance_ = NULL;

WSToClientUpCarriage* WSToClientUpCarriage::New() const {
  return new WSToClientUpCarriage;
}

void WSToClientUpCarriage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WSToClientUpCarriage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WSToClientUpCarriage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WSToClientUpCarriage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WSToClientUpCarriage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WSToClientUpCarriage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WSToClientUpCarriage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WSToClientUpCarriage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WSToClientUpCarriage::MergeFrom(const WSToClientUpCarriage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WSToClientUpCarriage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WSToClientUpCarriage::CopyFrom(const WSToClientUpCarriage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WSToClientUpCarriage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void WSToClientUpCarriage::Swap(WSToClientUpCarriage* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WSToClientUpCarriage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WSToClientUpCarriage_descriptor_;
  metadata.reflection = WSToClientUpCarriage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WSToClientEarnings::kEarningsFieldNumber;
#endif  // !_MSC_VER

WSToClientEarnings::WSToClientEarnings()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WSToClientEarnings::InitAsDefaultInstance() {
}

WSToClientEarnings::WSToClientEarnings(const WSToClientEarnings& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WSToClientEarnings::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WSToClientEarnings::~WSToClientEarnings() {
  SharedDtor();
}

void WSToClientEarnings::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WSToClientEarnings::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WSToClientEarnings::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WSToClientEarnings_descriptor_;
}

const WSToClientEarnings& WSToClientEarnings::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

WSToClientEarnings* WSToClientEarnings::default_instance_ = NULL;

WSToClientEarnings* WSToClientEarnings::New() const {
  return new WSToClientEarnings;
}

void WSToClientEarnings::Clear() {
  earnings_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WSToClientEarnings::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .MarketMessInfo.Earnings earnings = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_earnings:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_earnings()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_earnings;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WSToClientEarnings::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .MarketMessInfo.Earnings earnings = 1;
  for (int i = 0; i < this->earnings_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->earnings(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WSToClientEarnings::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .MarketMessInfo.Earnings earnings = 1;
  for (int i = 0; i < this->earnings_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->earnings(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WSToClientEarnings::ByteSize() const {
  int total_size = 0;

  // repeated .MarketMessInfo.Earnings earnings = 1;
  total_size += 1 * this->earnings_size();
  for (int i = 0; i < this->earnings_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->earnings(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WSToClientEarnings::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WSToClientEarnings* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WSToClientEarnings*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WSToClientEarnings::MergeFrom(const WSToClientEarnings& from) {
  GOOGLE_CHECK_NE(&from, this);
  earnings_.MergeFrom(from.earnings_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WSToClientEarnings::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WSToClientEarnings::CopyFrom(const WSToClientEarnings& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WSToClientEarnings::IsInitialized() const {

  for (int i = 0; i < earnings_size(); i++) {
    if (!this->earnings(i).IsInitialized()) return false;
  }
  return true;
}

void WSToClientEarnings::Swap(WSToClientEarnings* other) {
  if (other != this) {
    earnings_.Swap(&other->earnings_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WSToClientEarnings::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WSToClientEarnings_descriptor_;
  metadata.reflection = WSToClientEarnings_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Earnings::kItemidFieldNumber;
const int Earnings::kCoinFieldNumber;
const int Earnings::kNumFieldNumber;
const int Earnings::kEarningspriceFieldNumber;
const int Earnings::kBlocksFieldNumber;
const int Earnings::kTimeFieldNumber;
const int Earnings::kCharnameFieldNumber;
#endif  // !_MSC_VER

Earnings::Earnings()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Earnings::InitAsDefaultInstance() {
}

Earnings::Earnings(const Earnings& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Earnings::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0;
  coin_ = 0;
  num_ = 0;
  earningsprice_ = 0;
  blocks_ = 0;
  time_ = GOOGLE_LONGLONG(0);
  charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Earnings::~Earnings() {
  SharedDtor();
}

void Earnings::SharedDtor() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (this != default_instance_) {
  }
}

void Earnings::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Earnings::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Earnings_descriptor_;
}

const Earnings& Earnings::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

Earnings* Earnings::default_instance_ = NULL;

Earnings* Earnings::New() const {
  return new Earnings;
}

void Earnings::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    itemid_ = 0;
    coin_ = 0;
    num_ = 0;
    earningsprice_ = 0;
    blocks_ = 0;
    time_ = GOOGLE_LONGLONG(0);
    if (has_charname()) {
      if (charname_ != &::google::protobuf::internal::kEmptyString) {
        charname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Earnings::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 itemid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_coin;
        break;
      }

      // optional int32 coin = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_coin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &coin_)));
          set_has_coin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_num;
        break;
      }

      // optional int32 num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_earningsprice;
        break;
      }

      // optional int32 earningsprice = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_earningsprice:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &earningsprice_)));
          set_has_earningsprice();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_blocks;
        break;
      }

      // optional int32 blocks = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blocks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &blocks_)));
          set_has_blocks();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_time;
        break;
      }

      // optional int64 time = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_charname;
        break;
      }

      // optional string charname = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_charname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_charname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->charname().data(), this->charname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Earnings::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 itemid = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->itemid(), output);
  }

  // optional int32 coin = 2;
  if (has_coin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->coin(), output);
  }

  // optional int32 num = 3;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->num(), output);
  }

  // optional int32 earningsprice = 4;
  if (has_earningsprice()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->earningsprice(), output);
  }

  // optional int32 blocks = 5;
  if (has_blocks()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->blocks(), output);
  }

  // optional int64 time = 6;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->time(), output);
  }

  // optional string charname = 7;
  if (has_charname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->charname().data(), this->charname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->charname(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Earnings::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 itemid = 1;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->itemid(), target);
  }

  // optional int32 coin = 2;
  if (has_coin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->coin(), target);
  }

  // optional int32 num = 3;
  if (has_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->num(), target);
  }

  // optional int32 earningsprice = 4;
  if (has_earningsprice()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->earningsprice(), target);
  }

  // optional int32 blocks = 5;
  if (has_blocks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->blocks(), target);
  }

  // optional int64 time = 6;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(6, this->time(), target);
  }

  // optional string charname = 7;
  if (has_charname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->charname().data(), this->charname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->charname(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Earnings::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 itemid = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional int32 coin = 2;
    if (has_coin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->coin());
    }

    // optional int32 num = 3;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

    // optional int32 earningsprice = 4;
    if (has_earningsprice()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->earningsprice());
    }

    // optional int32 blocks = 5;
    if (has_blocks()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->blocks());
    }

    // optional int64 time = 6;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time());
    }

    // optional string charname = 7;
    if (has_charname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->charname());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Earnings::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Earnings* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Earnings*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Earnings::MergeFrom(const Earnings& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_coin()) {
      set_coin(from.coin());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
    if (from.has_earningsprice()) {
      set_earningsprice(from.earningsprice());
    }
    if (from.has_blocks()) {
      set_blocks(from.blocks());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_charname()) {
      set_charname(from.charname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Earnings::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Earnings::CopyFrom(const Earnings& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Earnings::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Earnings::Swap(Earnings* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(coin_, other->coin_);
    std::swap(num_, other->num_);
    std::swap(earningsprice_, other->earningsprice_);
    std::swap(blocks_, other->blocks_);
    std::swap(time_, other->time_);
    std::swap(charname_, other->charname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Earnings::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Earnings_descriptor_;
  metadata.reflection = Earnings_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WSReqGameMarketInfo::kCharidFieldNumber;
const int WSReqGameMarketInfo::kItemidFieldNumber;
const int WSReqGameMarketInfo::kNumFieldNumber;
const int WSReqGameMarketInfo::kPriceFieldNumber;
const int WSReqGameMarketInfo::kCoinFieldNumber;
#endif  // !_MSC_VER

WSReqGameMarketInfo::WSReqGameMarketInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WSReqGameMarketInfo::InitAsDefaultInstance() {
}

WSReqGameMarketInfo::WSReqGameMarketInfo(const WSReqGameMarketInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WSReqGameMarketInfo::SharedCtor() {
  _cached_size_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  itemid_ = 0;
  num_ = 0;
  price_ = 0;
  coin_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WSReqGameMarketInfo::~WSReqGameMarketInfo() {
  SharedDtor();
}

void WSReqGameMarketInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WSReqGameMarketInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WSReqGameMarketInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WSReqGameMarketInfo_descriptor_;
}

const WSReqGameMarketInfo& WSReqGameMarketInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

WSReqGameMarketInfo* WSReqGameMarketInfo::default_instance_ = NULL;

WSReqGameMarketInfo* WSReqGameMarketInfo::New() const {
  return new WSReqGameMarketInfo;
}

void WSReqGameMarketInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = GOOGLE_LONGLONG(0);
    itemid_ = 0;
    num_ = 0;
    price_ = 0;
    coin_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WSReqGameMarketInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_itemid;
        break;
      }

      // optional int32 itemid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_itemid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_num;
        break;
      }

      // optional int32 num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_price;
        break;
      }

      // optional int32 price = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_coin;
        break;
      }

      // optional int32 coin = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_coin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &coin_)));
          set_has_coin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WSReqGameMarketInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->charid(), output);
  }

  // optional int32 itemid = 2;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->itemid(), output);
  }

  // optional int32 num = 3;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->num(), output);
  }

  // optional int32 price = 4;
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->price(), output);
  }

  // optional int32 coin = 5;
  if (has_coin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->coin(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WSReqGameMarketInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int64 charid = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->charid(), target);
  }

  // optional int32 itemid = 2;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->itemid(), target);
  }

  // optional int32 num = 3;
  if (has_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->num(), target);
  }

  // optional int32 price = 4;
  if (has_price()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->price(), target);
  }

  // optional int32 coin = 5;
  if (has_coin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->coin(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WSReqGameMarketInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

    // optional int32 itemid = 2;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional int32 num = 3;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

    // optional int32 price = 4;
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->price());
    }

    // optional int32 coin = 5;
    if (has_coin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->coin());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WSReqGameMarketInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WSReqGameMarketInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WSReqGameMarketInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WSReqGameMarketInfo::MergeFrom(const WSReqGameMarketInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
    if (from.has_coin()) {
      set_coin(from.coin());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WSReqGameMarketInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WSReqGameMarketInfo::CopyFrom(const WSReqGameMarketInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WSReqGameMarketInfo::IsInitialized() const {

  return true;
}

void WSReqGameMarketInfo::Swap(WSReqGameMarketInfo* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(itemid_, other->itemid_);
    std::swap(num_, other->num_);
    std::swap(price_, other->price_);
    std::swap(coin_, other->coin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WSReqGameMarketInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WSReqGameMarketInfo_descriptor_;
  metadata.reflection = WSReqGameMarketInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GMRetGameMarketInfo::kRetFieldNumber;
const int GMRetGameMarketInfo::kItemidFieldNumber;
const int GMRetGameMarketInfo::kNumFieldNumber;
const int GMRetGameMarketInfo::kPriceFieldNumber;
const int GMRetGameMarketInfo::kCoinFieldNumber;
const int GMRetGameMarketInfo::kItemInfoFieldNumber;
#endif  // !_MSC_VER

GMRetGameMarketInfo::GMRetGameMarketInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GMRetGameMarketInfo::InitAsDefaultInstance() {
  iteminfo_ = const_cast< ::MarketMessInfo::ClientItemInfo*>(&::MarketMessInfo::ClientItemInfo::default_instance());
}

GMRetGameMarketInfo::GMRetGameMarketInfo(const GMRetGameMarketInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GMRetGameMarketInfo::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  itemid_ = 0;
  num_ = 0;
  price_ = 0;
  coin_ = 0;
  iteminfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GMRetGameMarketInfo::~GMRetGameMarketInfo() {
  SharedDtor();
}

void GMRetGameMarketInfo::SharedDtor() {
  if (this != default_instance_) {
    delete iteminfo_;
  }
}

void GMRetGameMarketInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GMRetGameMarketInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GMRetGameMarketInfo_descriptor_;
}

const GMRetGameMarketInfo& GMRetGameMarketInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

GMRetGameMarketInfo* GMRetGameMarketInfo::default_instance_ = NULL;

GMRetGameMarketInfo* GMRetGameMarketInfo::New() const {
  return new GMRetGameMarketInfo;
}

void GMRetGameMarketInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
    itemid_ = 0;
    num_ = 0;
    price_ = 0;
    coin_ = 0;
    if (has_iteminfo()) {
      if (iteminfo_ != NULL) iteminfo_->::MarketMessInfo::ClientItemInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GMRetGameMarketInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_itemid;
        break;
      }

      // required int32 itemid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_itemid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_num;
        break;
      }

      // optional int32 num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_price;
        break;
      }

      // optional int32 price = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_coin;
        break;
      }

      // optional int32 coin = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_coin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &coin_)));
          set_has_coin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_itemInfo;
        break;
      }

      // optional .MarketMessInfo.ClientItemInfo itemInfo = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_itemInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_iteminfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GMRetGameMarketInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  // required int32 itemid = 2;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->itemid(), output);
  }

  // optional int32 num = 3;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->num(), output);
  }

  // optional int32 price = 4;
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->price(), output);
  }

  // optional int32 coin = 5;
  if (has_coin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->coin(), output);
  }

  // optional .MarketMessInfo.ClientItemInfo itemInfo = 6;
  if (has_iteminfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->iteminfo(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GMRetGameMarketInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  // required int32 itemid = 2;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->itemid(), target);
  }

  // optional int32 num = 3;
  if (has_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->num(), target);
  }

  // optional int32 price = 4;
  if (has_price()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->price(), target);
  }

  // optional int32 coin = 5;
  if (has_coin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->coin(), target);
  }

  // optional .MarketMessInfo.ClientItemInfo itemInfo = 6;
  if (has_iteminfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->iteminfo(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GMRetGameMarketInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // required int32 itemid = 2;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional int32 num = 3;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

    // optional int32 price = 4;
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->price());
    }

    // optional int32 coin = 5;
    if (has_coin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->coin());
    }

    // optional .MarketMessInfo.ClientItemInfo itemInfo = 6;
    if (has_iteminfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->iteminfo());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GMRetGameMarketInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GMRetGameMarketInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GMRetGameMarketInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GMRetGameMarketInfo::MergeFrom(const GMRetGameMarketInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
    if (from.has_coin()) {
      set_coin(from.coin());
    }
    if (from.has_iteminfo()) {
      mutable_iteminfo()->::MarketMessInfo::ClientItemInfo::MergeFrom(from.iteminfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GMRetGameMarketInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GMRetGameMarketInfo::CopyFrom(const GMRetGameMarketInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GMRetGameMarketInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_iteminfo()) {
    if (!this->iteminfo().IsInitialized()) return false;
  }
  return true;
}

void GMRetGameMarketInfo::Swap(GMRetGameMarketInfo* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(itemid_, other->itemid_);
    std::swap(num_, other->num_);
    std::swap(price_, other->price_);
    std::swap(coin_, other->coin_);
    std::swap(iteminfo_, other->iteminfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GMRetGameMarketInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GMRetGameMarketInfo_descriptor_;
  metadata.reflection = GMRetGameMarketInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EarningsInfo::kCharIdFieldNumber;
const int EarningsInfo::kRetsFieldNumber;
const int EarningsInfo::kRettFieldNumber;
const int EarningsInfo::kRetfoFieldNumber;
const int EarningsInfo::kItemInfoFieldNumber;
#endif  // !_MSC_VER

EarningsInfo::EarningsInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EarningsInfo::InitAsDefaultInstance() {
  iteminfo_ = const_cast< ::MarketMessInfo::ClientItemInfo*>(&::MarketMessInfo::ClientItemInfo::default_instance());
}

EarningsInfo::EarningsInfo(const EarningsInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EarningsInfo::SharedCtor() {
  _cached_size_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  rets_ = 0;
  rett_ = 0;
  retfo_ = 0;
  iteminfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EarningsInfo::~EarningsInfo() {
  SharedDtor();
}

void EarningsInfo::SharedDtor() {
  if (this != default_instance_) {
    delete iteminfo_;
  }
}

void EarningsInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EarningsInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EarningsInfo_descriptor_;
}

const EarningsInfo& EarningsInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

EarningsInfo* EarningsInfo::default_instance_ = NULL;

EarningsInfo* EarningsInfo::New() const {
  return new EarningsInfo;
}

void EarningsInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = GOOGLE_LONGLONG(0);
    rets_ = 0;
    rett_ = 0;
    retfo_ = 0;
    if (has_iteminfo()) {
      if (iteminfo_ != NULL) iteminfo_->::MarketMessInfo::ClientItemInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EarningsInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 charId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_rets;
        break;
      }

      // optional int32 rets = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rets:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rets_)));
          set_has_rets();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_rett;
        break;
      }

      // optional int32 rett = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rett:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rett_)));
          set_has_rett();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_retfo;
        break;
      }

      // optional int32 retfo = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_retfo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &retfo_)));
          set_has_retfo();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_itemInfo;
        break;
      }

      // optional .MarketMessInfo.ClientItemInfo itemInfo = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_itemInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_iteminfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EarningsInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 charId = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->charid(), output);
  }

  // optional int32 rets = 2;
  if (has_rets()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->rets(), output);
  }

  // optional int32 rett = 3;
  if (has_rett()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->rett(), output);
  }

  // optional int32 retfo = 4;
  if (has_retfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->retfo(), output);
  }

  // optional .MarketMessInfo.ClientItemInfo itemInfo = 5;
  if (has_iteminfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->iteminfo(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EarningsInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 charId = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->charid(), target);
  }

  // optional int32 rets = 2;
  if (has_rets()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->rets(), target);
  }

  // optional int32 rett = 3;
  if (has_rett()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->rett(), target);
  }

  // optional int32 retfo = 4;
  if (has_retfo()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->retfo(), target);
  }

  // optional .MarketMessInfo.ClientItemInfo itemInfo = 5;
  if (has_iteminfo()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->iteminfo(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EarningsInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 charId = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

    // optional int32 rets = 2;
    if (has_rets()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rets());
    }

    // optional int32 rett = 3;
    if (has_rett()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rett());
    }

    // optional int32 retfo = 4;
    if (has_retfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->retfo());
    }

    // optional .MarketMessInfo.ClientItemInfo itemInfo = 5;
    if (has_iteminfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->iteminfo());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EarningsInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EarningsInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EarningsInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EarningsInfo::MergeFrom(const EarningsInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_rets()) {
      set_rets(from.rets());
    }
    if (from.has_rett()) {
      set_rett(from.rett());
    }
    if (from.has_retfo()) {
      set_retfo(from.retfo());
    }
    if (from.has_iteminfo()) {
      mutable_iteminfo()->::MarketMessInfo::ClientItemInfo::MergeFrom(from.iteminfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EarningsInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EarningsInfo::CopyFrom(const EarningsInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EarningsInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_iteminfo()) {
    if (!this->iteminfo().IsInitialized()) return false;
  }
  return true;
}

void EarningsInfo::Swap(EarningsInfo* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(rets_, other->rets_);
    std::swap(rett_, other->rett_);
    std::swap(retfo_, other->retfo_);
    std::swap(iteminfo_, other->iteminfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EarningsInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EarningsInfo_descriptor_;
  metadata.reflection = EarningsInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ClientMarketUIState::ClientMarketUIState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientMarketUIState::InitAsDefaultInstance() {
}

ClientMarketUIState::ClientMarketUIState(const ClientMarketUIState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientMarketUIState::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientMarketUIState::~ClientMarketUIState() {
  SharedDtor();
}

void ClientMarketUIState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientMarketUIState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientMarketUIState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientMarketUIState_descriptor_;
}

const ClientMarketUIState& ClientMarketUIState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

ClientMarketUIState* ClientMarketUIState::default_instance_ = NULL;

ClientMarketUIState* ClientMarketUIState::New() const {
  return new ClientMarketUIState;
}

void ClientMarketUIState::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientMarketUIState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void ClientMarketUIState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientMarketUIState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientMarketUIState::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientMarketUIState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientMarketUIState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientMarketUIState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientMarketUIState::MergeFrom(const ClientMarketUIState& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientMarketUIState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientMarketUIState::CopyFrom(const ClientMarketUIState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientMarketUIState::IsInitialized() const {

  return true;
}

void ClientMarketUIState::Swap(ClientMarketUIState* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientMarketUIState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientMarketUIState_descriptor_;
  metadata.reflection = ClientMarketUIState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WSToGMSellerUIState::kCharIDFieldNumber;
#endif  // !_MSC_VER

WSToGMSellerUIState::WSToGMSellerUIState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WSToGMSellerUIState::InitAsDefaultInstance() {
}

WSToGMSellerUIState::WSToGMSellerUIState(const WSToGMSellerUIState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WSToGMSellerUIState::SharedCtor() {
  _cached_size_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WSToGMSellerUIState::~WSToGMSellerUIState() {
  SharedDtor();
}

void WSToGMSellerUIState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WSToGMSellerUIState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WSToGMSellerUIState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WSToGMSellerUIState_descriptor_;
}

const WSToGMSellerUIState& WSToGMSellerUIState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Market_2fMarket_2eproto();
  return *default_instance_;
}

WSToGMSellerUIState* WSToGMSellerUIState::default_instance_ = NULL;

WSToGMSellerUIState* WSToGMSellerUIState::New() const {
  return new WSToGMSellerUIState;
}

void WSToGMSellerUIState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WSToGMSellerUIState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 charID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WSToGMSellerUIState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 charID = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->charid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WSToGMSellerUIState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 charID = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->charid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WSToGMSellerUIState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 charID = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WSToGMSellerUIState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WSToGMSellerUIState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WSToGMSellerUIState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WSToGMSellerUIState::MergeFrom(const WSToGMSellerUIState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WSToGMSellerUIState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WSToGMSellerUIState::CopyFrom(const WSToGMSellerUIState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WSToGMSellerUIState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void WSToGMSellerUIState::Swap(WSToGMSellerUIState* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WSToGMSellerUIState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WSToGMSellerUIState_descriptor_;
  metadata.reflection = WSToGMSellerUIState_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace MarketMessInfo

// @@protoc_insertion_point(global_scope)

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CharLogin/PlayerInfo.proto

#ifndef PROTOBUF_CharLogin_2fPlayerInfo_2eproto__INCLUDED
#define PROTOBUF_CharLogin_2fPlayerInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "CharLogin/Vitality.pb.h"
#include "CharLogin/ChristmasDB.pb.h"
#include "Fashion/FashionMessage.pb.h"
#include "Map/SynchPath.pb.h"
// @@protoc_insertion_point(includes)

namespace PlayerInfo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

class PlayerInfo;
class ArenaDataInfo;
class ArenaInfo;
class ArenaBaseInfo;
class ArenaChallengeRank;
class ArenaHistoryReward;
class RingDBData;
class SaveTypeInfo;
class WSaveTypeInfo;
class BaseInfo;
class BattleInfo;
class QuestInfo;
class WeekQuestItem;
class WeekQuest;
class NewQuestInfo;
class ActiveQuest;
class DailyQuest;
class ClanQuest;
class CampQuest;
class POneTalentSkill;
class SkillInfo;
class BuffInfo;
class CDInfo;
class ChannelCD;
class ContainerInfo;
class PlayerTypeInfo;
class EquipQuickInfo;
class PackageInfo;
class StoreHouseInfo;
class MonitorInfo;
class SettingInfo;
class HorseInfo;
class SkinInfo;
class ItemInfo;
class AttrValue;
class QuickContainer;
class WPlayerInfo;
class FriendInfoList;
class FriendInfo;
class InstanceInfoList;
class InstanceDiffculty;
class InstanceVip;
class InstanceInfoTwoDays;
class PrestigeInfoList;
class PrestigeInfo;
class PrestigeContent;
class TitleInfoList;
class TitleInfo;
class TitleStatus;
class DestinationInfoList;
class DestinationInfo;
class DestinationContent;
class SignInInfo;
class CounterService;
class CounterServiceList;
class EscortInfo;
class DanLuInfo;
class PlayerVipInfo;
class PassivePlayerSkill;
class MagicWeapon;
class RandCJobLucky;
class RandCJobLucky_CJobItem;
class RandCJobLucky_CreatureCJob;
class LucklyTurntable;
class Activity;
class ActivityYellowVipReward;
class ActivityYellowVipRewardList;
class LineMapInfoList;
class LineMapInfo;
class GirlWarInfo;
class GirlWar;
class LessInfo;
class StoneInfo;
class StoneItem;
class DBAchShopInfo;
class DBAchShopItem;
class CampShopInfo;
class CampShopItem;
class FestivalInfo;
class festivalItem;
class MoneyInstance;
class ChallengeInstance;
class HeroInstanceData;
class BranchLineInfo;
class TotalBranchLineInfo;
class ClientIEInfo;
class OnceRewardInfo;
class GroupInstance;
class InstanceGroupList;
class EliteInstance;
class InstanceEliteList;
class CauchemarInstance;
class InstanceCauchemarList;
class AdvancedInstance;
class InstanceAdvancedList;
class BaseShopInfo;
class BaseShopInfoList;
class BaseShopInfoData;
class AnswerInfo;

// ===================================================================

class PlayerInfo : public ::google::protobuf::Message {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInfo& default_instance();

  void Swap(PlayerInfo* other);

  // implements Message ----------------------------------------------

  PlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PlayerInfo.BaseInfo bsinfo = 1;
  inline bool has_bsinfo() const;
  inline void clear_bsinfo();
  static const int kBsinfoFieldNumber = 1;
  inline const ::PlayerInfo::BaseInfo& bsinfo() const;
  inline ::PlayerInfo::BaseInfo* mutable_bsinfo();
  inline ::PlayerInfo::BaseInfo* release_bsinfo();
  inline void set_allocated_bsinfo(::PlayerInfo::BaseInfo* bsinfo);

  // optional .PlayerInfo.BattleInfo binfo = 2;
  inline bool has_binfo() const;
  inline void clear_binfo();
  static const int kBinfoFieldNumber = 2;
  inline const ::PlayerInfo::BattleInfo& binfo() const;
  inline ::PlayerInfo::BattleInfo* mutable_binfo();
  inline ::PlayerInfo::BattleInfo* release_binfo();
  inline void set_allocated_binfo(::PlayerInfo::BattleInfo* binfo);

  // optional .PlayerInfo.QuestInfo questinfo = 3;
  inline bool has_questinfo() const;
  inline void clear_questinfo();
  static const int kQuestinfoFieldNumber = 3;
  inline const ::PlayerInfo::QuestInfo& questinfo() const;
  inline ::PlayerInfo::QuestInfo* mutable_questinfo();
  inline ::PlayerInfo::QuestInfo* release_questinfo();
  inline void set_allocated_questinfo(::PlayerInfo::QuestInfo* questinfo);

  // optional .PlayerInfo.SkillInfo skill = 4;
  inline bool has_skill() const;
  inline void clear_skill();
  static const int kSkillFieldNumber = 4;
  inline const ::PlayerInfo::SkillInfo& skill() const;
  inline ::PlayerInfo::SkillInfo* mutable_skill();
  inline ::PlayerInfo::SkillInfo* release_skill();
  inline void set_allocated_skill(::PlayerInfo::SkillInfo* skill);

  // optional .PlayerInfo.CDInfo cd = 5;
  inline bool has_cd() const;
  inline void clear_cd();
  static const int kCdFieldNumber = 5;
  inline const ::PlayerInfo::CDInfo& cd() const;
  inline ::PlayerInfo::CDInfo* mutable_cd();
  inline ::PlayerInfo::CDInfo* release_cd();
  inline void set_allocated_cd(::PlayerInfo::CDInfo* cd);

  // optional .PlayerInfo.MonitorInfo mt = 6;
  inline bool has_mt() const;
  inline void clear_mt();
  static const int kMtFieldNumber = 6;
  inline const ::PlayerInfo::MonitorInfo& mt() const;
  inline ::PlayerInfo::MonitorInfo* mutable_mt();
  inline ::PlayerInfo::MonitorInfo* release_mt();
  inline void set_allocated_mt(::PlayerInfo::MonitorInfo* mt);

  // optional .PlayerInfo.EquipQuickInfo equipquick = 7;
  inline bool has_equipquick() const;
  inline void clear_equipquick();
  static const int kEquipquickFieldNumber = 7;
  inline const ::PlayerInfo::EquipQuickInfo& equipquick() const;
  inline ::PlayerInfo::EquipQuickInfo* mutable_equipquick();
  inline ::PlayerInfo::EquipQuickInfo* release_equipquick();
  inline void set_allocated_equipquick(::PlayerInfo::EquipQuickInfo* equipquick);

  // optional .PlayerInfo.GirlWarInfo girlwarinfo = 8;
  inline bool has_girlwarinfo() const;
  inline void clear_girlwarinfo();
  static const int kGirlwarinfoFieldNumber = 8;
  inline const ::PlayerInfo::GirlWarInfo& girlwarinfo() const;
  inline ::PlayerInfo::GirlWarInfo* mutable_girlwarinfo();
  inline ::PlayerInfo::GirlWarInfo* release_girlwarinfo();
  inline void set_allocated_girlwarinfo(::PlayerInfo::GirlWarInfo* girlwarinfo);

  // optional .PlayerInfo.CounterServiceList counter = 9;
  inline bool has_counter() const;
  inline void clear_counter();
  static const int kCounterFieldNumber = 9;
  inline const ::PlayerInfo::CounterServiceList& counter() const;
  inline ::PlayerInfo::CounterServiceList* mutable_counter();
  inline ::PlayerInfo::CounterServiceList* release_counter();
  inline void set_allocated_counter(::PlayerInfo::CounterServiceList* counter);

  // optional .PlayerInfo.HorseInfo horse = 10;
  inline bool has_horse() const;
  inline void clear_horse();
  static const int kHorseFieldNumber = 10;
  inline const ::PlayerInfo::HorseInfo& horse() const;
  inline ::PlayerInfo::HorseInfo* mutable_horse();
  inline ::PlayerInfo::HorseInfo* release_horse();
  inline void set_allocated_horse(::PlayerInfo::HorseInfo* horse);

  // optional .PlayerInfo.DanLuInfo danlu = 11;
  inline bool has_danlu() const;
  inline void clear_danlu();
  static const int kDanluFieldNumber = 11;
  inline const ::PlayerInfo::DanLuInfo& danlu() const;
  inline ::PlayerInfo::DanLuInfo* mutable_danlu();
  inline ::PlayerInfo::DanLuInfo* release_danlu();
  inline void set_allocated_danlu(::PlayerInfo::DanLuInfo* danlu);

  // optional .PlayerInfo.MagicWeapon magicw = 12;
  inline bool has_magicw() const;
  inline void clear_magicw();
  static const int kMagicwFieldNumber = 12;
  inline const ::PlayerInfo::MagicWeapon& magicw() const;
  inline ::PlayerInfo::MagicWeapon* mutable_magicw();
  inline ::PlayerInfo::MagicWeapon* release_magicw();
  inline void set_allocated_magicw(::PlayerInfo::MagicWeapon* magicw);

  // optional .PlayerInfo.RandCJobLucky cjob = 13;
  inline bool has_cjob() const;
  inline void clear_cjob();
  static const int kCjobFieldNumber = 13;
  inline const ::PlayerInfo::RandCJobLucky& cjob() const;
  inline ::PlayerInfo::RandCJobLucky* mutable_cjob();
  inline ::PlayerInfo::RandCJobLucky* release_cjob();
  inline void set_allocated_cjob(::PlayerInfo::RandCJobLucky* cjob);

  // optional .PlayerInfo.LucklyTurntable lucktable = 14;
  inline bool has_lucktable() const;
  inline void clear_lucktable();
  static const int kLucktableFieldNumber = 14;
  inline const ::PlayerInfo::LucklyTurntable& lucktable() const;
  inline ::PlayerInfo::LucklyTurntable* mutable_lucktable();
  inline ::PlayerInfo::LucklyTurntable* release_lucktable();
  inline void set_allocated_lucktable(::PlayerInfo::LucklyTurntable* lucktable);

  // optional .PlayerInfo.Activity activity = 15;
  inline bool has_activity() const;
  inline void clear_activity();
  static const int kActivityFieldNumber = 15;
  inline const ::PlayerInfo::Activity& activity() const;
  inline ::PlayerInfo::Activity* mutable_activity();
  inline ::PlayerInfo::Activity* release_activity();
  inline void set_allocated_activity(::PlayerInfo::Activity* activity);

  // optional .PlayerInfo.DestinationInfoList destination = 16;
  inline bool has_destination() const;
  inline void clear_destination();
  static const int kDestinationFieldNumber = 16;
  inline const ::PlayerInfo::DestinationInfoList& destination() const;
  inline ::PlayerInfo::DestinationInfoList* mutable_destination();
  inline ::PlayerInfo::DestinationInfoList* release_destination();
  inline void set_allocated_destination(::PlayerInfo::DestinationInfoList* destination);

  // optional .PlayerInfo.InstanceInfoTwoDays instanceList = 17;
  inline bool has_instancelist() const;
  inline void clear_instancelist();
  static const int kInstanceListFieldNumber = 17;
  inline const ::PlayerInfo::InstanceInfoTwoDays& instancelist() const;
  inline ::PlayerInfo::InstanceInfoTwoDays* mutable_instancelist();
  inline ::PlayerInfo::InstanceInfoTwoDays* release_instancelist();
  inline void set_allocated_instancelist(::PlayerInfo::InstanceInfoTwoDays* instancelist);

  // optional .PlayerInfo.SignInInfo signin = 18;
  inline bool has_signin() const;
  inline void clear_signin();
  static const int kSigninFieldNumber = 18;
  inline const ::PlayerInfo::SignInInfo& signin() const;
  inline ::PlayerInfo::SignInInfo* mutable_signin();
  inline ::PlayerInfo::SignInInfo* release_signin();
  inline void set_allocated_signin(::PlayerInfo::SignInInfo* signin);

  // optional .PlayerInfo.EscortInfo escort = 19;
  inline bool has_escort() const;
  inline void clear_escort();
  static const int kEscortFieldNumber = 19;
  inline const ::PlayerInfo::EscortInfo& escort() const;
  inline ::PlayerInfo::EscortInfo* mutable_escort();
  inline ::PlayerInfo::EscortInfo* release_escort();
  inline void set_allocated_escort(::PlayerInfo::EscortInfo* escort);

  // optional .PlayerInfo.PlayerVipInfo playerVip = 20;
  inline bool has_playervip() const;
  inline void clear_playervip();
  static const int kPlayerVipFieldNumber = 20;
  inline const ::PlayerInfo::PlayerVipInfo& playervip() const;
  inline ::PlayerInfo::PlayerVipInfo* mutable_playervip();
  inline ::PlayerInfo::PlayerVipInfo* release_playervip();
  inline void set_allocated_playervip(::PlayerInfo::PlayerVipInfo* playervip);

  // optional .PlayerInfo.PrestigeInfoList prestige = 21;
  inline bool has_prestige() const;
  inline void clear_prestige();
  static const int kPrestigeFieldNumber = 21;
  inline const ::PlayerInfo::PrestigeInfoList& prestige() const;
  inline ::PlayerInfo::PrestigeInfoList* mutable_prestige();
  inline ::PlayerInfo::PrestigeInfoList* release_prestige();
  inline void set_allocated_prestige(::PlayerInfo::PrestigeInfoList* prestige);

  // optional .PlayerInfo.TitleInfoList title = 22;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 22;
  inline const ::PlayerInfo::TitleInfoList& title() const;
  inline ::PlayerInfo::TitleInfoList* mutable_title();
  inline ::PlayerInfo::TitleInfoList* release_title();
  inline void set_allocated_title(::PlayerInfo::TitleInfoList* title);

  // optional .FashionMsgProto.FashionShow fashion = 23;
  inline bool has_fashion() const;
  inline void clear_fashion();
  static const int kFashionFieldNumber = 23;
  inline const ::FashionMsgProto::FashionShow& fashion() const;
  inline ::FashionMsgProto::FashionShow* mutable_fashion();
  inline ::FashionMsgProto::FashionShow* release_fashion();
  inline void set_allocated_fashion(::FashionMsgProto::FashionShow* fashion);

  // optional .VitalityProto.ProtoVitalityInfo vitality = 24;
  inline bool has_vitality() const;
  inline void clear_vitality();
  static const int kVitalityFieldNumber = 24;
  inline const ::VitalityProto::ProtoVitalityInfo& vitality() const;
  inline ::VitalityProto::ProtoVitalityInfo* mutable_vitality();
  inline ::VitalityProto::ProtoVitalityInfo* release_vitality();
  inline void set_allocated_vitality(::VitalityProto::ProtoVitalityInfo* vitality);

  // optional .PlayerInfo.CampShopInfo campShopData = 25;
  inline bool has_campshopdata() const;
  inline void clear_campshopdata();
  static const int kCampShopDataFieldNumber = 25;
  inline const ::PlayerInfo::CampShopInfo& campshopdata() const;
  inline ::PlayerInfo::CampShopInfo* mutable_campshopdata();
  inline ::PlayerInfo::CampShopInfo* release_campshopdata();
  inline void set_allocated_campshopdata(::PlayerInfo::CampShopInfo* campshopdata);

  // optional .PlayerInfo.FestivalInfo festivalData = 26;
  inline bool has_festivaldata() const;
  inline void clear_festivaldata();
  static const int kFestivalDataFieldNumber = 26;
  inline const ::PlayerInfo::FestivalInfo& festivaldata() const;
  inline ::PlayerInfo::FestivalInfo* mutable_festivaldata();
  inline ::PlayerInfo::FestivalInfo* release_festivaldata();
  inline void set_allocated_festivaldata(::PlayerInfo::FestivalInfo* festivaldata);

  // optional .PlayerInfo.MoneyInstance info = 27;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 27;
  inline const ::PlayerInfo::MoneyInstance& info() const;
  inline ::PlayerInfo::MoneyInstance* mutable_info();
  inline ::PlayerInfo::MoneyInstance* release_info();
  inline void set_allocated_info(::PlayerInfo::MoneyInstance* info);

  // optional .PlayerInfo.OnceRewardInfo onceReward = 28;
  inline bool has_oncereward() const;
  inline void clear_oncereward();
  static const int kOnceRewardFieldNumber = 28;
  inline const ::PlayerInfo::OnceRewardInfo& oncereward() const;
  inline ::PlayerInfo::OnceRewardInfo* mutable_oncereward();
  inline ::PlayerInfo::OnceRewardInfo* release_oncereward();
  inline void set_allocated_oncereward(::PlayerInfo::OnceRewardInfo* oncereward);

  // optional .PlayerInfo.RingDBData ringData = 29;
  inline bool has_ringdata() const;
  inline void clear_ringdata();
  static const int kRingDataFieldNumber = 29;
  inline const ::PlayerInfo::RingDBData& ringdata() const;
  inline ::PlayerInfo::RingDBData* mutable_ringdata();
  inline ::PlayerInfo::RingDBData* release_ringdata();
  inline void set_allocated_ringdata(::PlayerInfo::RingDBData* ringdata);

  // optional .PlayerInfo.GroupInstance groupInfo = 30;
  inline bool has_groupinfo() const;
  inline void clear_groupinfo();
  static const int kGroupInfoFieldNumber = 30;
  inline const ::PlayerInfo::GroupInstance& groupinfo() const;
  inline ::PlayerInfo::GroupInstance* mutable_groupinfo();
  inline ::PlayerInfo::GroupInstance* release_groupinfo();
  inline void set_allocated_groupinfo(::PlayerInfo::GroupInstance* groupinfo);

  // optional .ChristmasDB.ChristmasAllData christmasData = 31;
  inline bool has_christmasdata() const;
  inline void clear_christmasdata();
  static const int kChristmasDataFieldNumber = 31;
  inline const ::ChristmasDB::ChristmasAllData& christmasdata() const;
  inline ::ChristmasDB::ChristmasAllData* mutable_christmasdata();
  inline ::ChristmasDB::ChristmasAllData* release_christmasdata();
  inline void set_allocated_christmasdata(::ChristmasDB::ChristmasAllData* christmasdata);

  // optional .PlayerInfo.EliteInstance eliteInfo = 32;
  inline bool has_eliteinfo() const;
  inline void clear_eliteinfo();
  static const int kEliteInfoFieldNumber = 32;
  inline const ::PlayerInfo::EliteInstance& eliteinfo() const;
  inline ::PlayerInfo::EliteInstance* mutable_eliteinfo();
  inline ::PlayerInfo::EliteInstance* release_eliteinfo();
  inline void set_allocated_eliteinfo(::PlayerInfo::EliteInstance* eliteinfo);

  // optional .PlayerInfo.CauchemarInstance cauchemarInfo = 33;
  inline bool has_cauchemarinfo() const;
  inline void clear_cauchemarinfo();
  static const int kCauchemarInfoFieldNumber = 33;
  inline const ::PlayerInfo::CauchemarInstance& cauchemarinfo() const;
  inline ::PlayerInfo::CauchemarInstance* mutable_cauchemarinfo();
  inline ::PlayerInfo::CauchemarInstance* release_cauchemarinfo();
  inline void set_allocated_cauchemarinfo(::PlayerInfo::CauchemarInstance* cauchemarinfo);

  // optional .PlayerInfo.ArenaDataInfo arenaData = 34;
  inline bool has_arenadata() const;
  inline void clear_arenadata();
  static const int kArenaDataFieldNumber = 34;
  inline const ::PlayerInfo::ArenaDataInfo& arenadata() const;
  inline ::PlayerInfo::ArenaDataInfo* mutable_arenadata();
  inline ::PlayerInfo::ArenaDataInfo* release_arenadata();
  inline void set_allocated_arenadata(::PlayerInfo::ArenaDataInfo* arenadata);

  // optional .PlayerInfo.ChallengeInstance challengedata = 35;
  inline bool has_challengedata() const;
  inline void clear_challengedata();
  static const int kChallengedataFieldNumber = 35;
  inline const ::PlayerInfo::ChallengeInstance& challengedata() const;
  inline ::PlayerInfo::ChallengeInstance* mutable_challengedata();
  inline ::PlayerInfo::ChallengeInstance* release_challengedata();
  inline void set_allocated_challengedata(::PlayerInfo::ChallengeInstance* challengedata);

  // optional .PlayerInfo.HeroInstanceData herodata = 36;
  inline bool has_herodata() const;
  inline void clear_herodata();
  static const int kHerodataFieldNumber = 36;
  inline const ::PlayerInfo::HeroInstanceData& herodata() const;
  inline ::PlayerInfo::HeroInstanceData* mutable_herodata();
  inline ::PlayerInfo::HeroInstanceData* release_herodata();
  inline void set_allocated_herodata(::PlayerInfo::HeroInstanceData* herodata);

  // optional .PlayerInfo.MagicWeapon smagic = 37;
  inline bool has_smagic() const;
  inline void clear_smagic();
  static const int kSmagicFieldNumber = 37;
  inline const ::PlayerInfo::MagicWeapon& smagic() const;
  inline ::PlayerInfo::MagicWeapon* mutable_smagic();
  inline ::PlayerInfo::MagicWeapon* release_smagic();
  inline void set_allocated_smagic(::PlayerInfo::MagicWeapon* smagic);

  // optional .PlayerInfo.MagicWeapon heartmagic = 38;
  inline bool has_heartmagic() const;
  inline void clear_heartmagic();
  static const int kHeartmagicFieldNumber = 38;
  inline const ::PlayerInfo::MagicWeapon& heartmagic() const;
  inline ::PlayerInfo::MagicWeapon* mutable_heartmagic();
  inline ::PlayerInfo::MagicWeapon* release_heartmagic();
  inline void set_allocated_heartmagic(::PlayerInfo::MagicWeapon* heartmagic);

  // optional .PlayerInfo.AdvancedInstance advanced = 39;
  inline bool has_advanced() const;
  inline void clear_advanced();
  static const int kAdvancedFieldNumber = 39;
  inline const ::PlayerInfo::AdvancedInstance& advanced() const;
  inline ::PlayerInfo::AdvancedInstance* mutable_advanced();
  inline ::PlayerInfo::AdvancedInstance* release_advanced();
  inline void set_allocated_advanced(::PlayerInfo::AdvancedInstance* advanced);

  // optional .PlayerInfo.BaseShopInfo baseShopInfo = 40;
  inline bool has_baseshopinfo() const;
  inline void clear_baseshopinfo();
  static const int kBaseShopInfoFieldNumber = 40;
  inline const ::PlayerInfo::BaseShopInfo& baseshopinfo() const;
  inline ::PlayerInfo::BaseShopInfo* mutable_baseshopinfo();
  inline ::PlayerInfo::BaseShopInfo* release_baseshopinfo();
  inline void set_allocated_baseshopinfo(::PlayerInfo::BaseShopInfo* baseshopinfo);

  // optional .PlayerInfo.AnswerInfo answerInfo = 41;
  inline bool has_answerinfo() const;
  inline void clear_answerinfo();
  static const int kAnswerInfoFieldNumber = 41;
  inline const ::PlayerInfo::AnswerInfo& answerinfo() const;
  inline ::PlayerInfo::AnswerInfo* mutable_answerinfo();
  inline ::PlayerInfo::AnswerInfo* release_answerinfo();
  inline void set_allocated_answerinfo(::PlayerInfo::AnswerInfo* answerinfo);

  // @@protoc_insertion_point(class_scope:PlayerInfo.PlayerInfo)
 private:
  inline void set_has_bsinfo();
  inline void clear_has_bsinfo();
  inline void set_has_binfo();
  inline void clear_has_binfo();
  inline void set_has_questinfo();
  inline void clear_has_questinfo();
  inline void set_has_skill();
  inline void clear_has_skill();
  inline void set_has_cd();
  inline void clear_has_cd();
  inline void set_has_mt();
  inline void clear_has_mt();
  inline void set_has_equipquick();
  inline void clear_has_equipquick();
  inline void set_has_girlwarinfo();
  inline void clear_has_girlwarinfo();
  inline void set_has_counter();
  inline void clear_has_counter();
  inline void set_has_horse();
  inline void clear_has_horse();
  inline void set_has_danlu();
  inline void clear_has_danlu();
  inline void set_has_magicw();
  inline void clear_has_magicw();
  inline void set_has_cjob();
  inline void clear_has_cjob();
  inline void set_has_lucktable();
  inline void clear_has_lucktable();
  inline void set_has_activity();
  inline void clear_has_activity();
  inline void set_has_destination();
  inline void clear_has_destination();
  inline void set_has_instancelist();
  inline void clear_has_instancelist();
  inline void set_has_signin();
  inline void clear_has_signin();
  inline void set_has_escort();
  inline void clear_has_escort();
  inline void set_has_playervip();
  inline void clear_has_playervip();
  inline void set_has_prestige();
  inline void clear_has_prestige();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_fashion();
  inline void clear_has_fashion();
  inline void set_has_vitality();
  inline void clear_has_vitality();
  inline void set_has_campshopdata();
  inline void clear_has_campshopdata();
  inline void set_has_festivaldata();
  inline void clear_has_festivaldata();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_oncereward();
  inline void clear_has_oncereward();
  inline void set_has_ringdata();
  inline void clear_has_ringdata();
  inline void set_has_groupinfo();
  inline void clear_has_groupinfo();
  inline void set_has_christmasdata();
  inline void clear_has_christmasdata();
  inline void set_has_eliteinfo();
  inline void clear_has_eliteinfo();
  inline void set_has_cauchemarinfo();
  inline void clear_has_cauchemarinfo();
  inline void set_has_arenadata();
  inline void clear_has_arenadata();
  inline void set_has_challengedata();
  inline void clear_has_challengedata();
  inline void set_has_herodata();
  inline void clear_has_herodata();
  inline void set_has_smagic();
  inline void clear_has_smagic();
  inline void set_has_heartmagic();
  inline void clear_has_heartmagic();
  inline void set_has_advanced();
  inline void clear_has_advanced();
  inline void set_has_baseshopinfo();
  inline void clear_has_baseshopinfo();
  inline void set_has_answerinfo();
  inline void clear_has_answerinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PlayerInfo::BaseInfo* bsinfo_;
  ::PlayerInfo::BattleInfo* binfo_;
  ::PlayerInfo::QuestInfo* questinfo_;
  ::PlayerInfo::SkillInfo* skill_;
  ::PlayerInfo::CDInfo* cd_;
  ::PlayerInfo::MonitorInfo* mt_;
  ::PlayerInfo::EquipQuickInfo* equipquick_;
  ::PlayerInfo::GirlWarInfo* girlwarinfo_;
  ::PlayerInfo::CounterServiceList* counter_;
  ::PlayerInfo::HorseInfo* horse_;
  ::PlayerInfo::DanLuInfo* danlu_;
  ::PlayerInfo::MagicWeapon* magicw_;
  ::PlayerInfo::RandCJobLucky* cjob_;
  ::PlayerInfo::LucklyTurntable* lucktable_;
  ::PlayerInfo::Activity* activity_;
  ::PlayerInfo::DestinationInfoList* destination_;
  ::PlayerInfo::InstanceInfoTwoDays* instancelist_;
  ::PlayerInfo::SignInInfo* signin_;
  ::PlayerInfo::EscortInfo* escort_;
  ::PlayerInfo::PlayerVipInfo* playervip_;
  ::PlayerInfo::PrestigeInfoList* prestige_;
  ::PlayerInfo::TitleInfoList* title_;
  ::FashionMsgProto::FashionShow* fashion_;
  ::VitalityProto::ProtoVitalityInfo* vitality_;
  ::PlayerInfo::CampShopInfo* campshopdata_;
  ::PlayerInfo::FestivalInfo* festivaldata_;
  ::PlayerInfo::MoneyInstance* info_;
  ::PlayerInfo::OnceRewardInfo* oncereward_;
  ::PlayerInfo::RingDBData* ringdata_;
  ::PlayerInfo::GroupInstance* groupinfo_;
  ::ChristmasDB::ChristmasAllData* christmasdata_;
  ::PlayerInfo::EliteInstance* eliteinfo_;
  ::PlayerInfo::CauchemarInstance* cauchemarinfo_;
  ::PlayerInfo::ArenaDataInfo* arenadata_;
  ::PlayerInfo::ChallengeInstance* challengedata_;
  ::PlayerInfo::HeroInstanceData* herodata_;
  ::PlayerInfo::MagicWeapon* smagic_;
  ::PlayerInfo::MagicWeapon* heartmagic_;
  ::PlayerInfo::AdvancedInstance* advanced_;
  ::PlayerInfo::BaseShopInfo* baseshopinfo_;
  ::PlayerInfo::AnswerInfo* answerinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(41 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static PlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class ArenaDataInfo : public ::google::protobuf::Message {
 public:
  ArenaDataInfo();
  virtual ~ArenaDataInfo();

  ArenaDataInfo(const ArenaDataInfo& from);

  inline ArenaDataInfo& operator=(const ArenaDataInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArenaDataInfo& default_instance();

  void Swap(ArenaDataInfo* other);

  // implements Message ----------------------------------------------

  ArenaDataInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArenaDataInfo& from);
  void MergeFrom(const ArenaDataInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 canChallCnt = 1;
  inline bool has_canchallcnt() const;
  inline void clear_canchallcnt();
  static const int kCanChallCntFieldNumber = 1;
  inline ::google::protobuf::int32 canchallcnt() const;
  inline void set_canchallcnt(::google::protobuf::int32 value);

  // optional uint64 lastResetTime = 2;
  inline bool has_lastresettime() const;
  inline void clear_lastresettime();
  static const int kLastResetTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 lastresettime() const;
  inline void set_lastresettime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.ArenaDataInfo)
 private:
  inline void set_has_canchallcnt();
  inline void clear_has_canchallcnt();
  inline void set_has_lastresettime();
  inline void clear_has_lastresettime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 lastresettime_;
  ::google::protobuf::int32 canchallcnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static ArenaDataInfo* default_instance_;
};
// -------------------------------------------------------------------

class ArenaInfo : public ::google::protobuf::Message {
 public:
  ArenaInfo();
  virtual ~ArenaInfo();

  ArenaInfo(const ArenaInfo& from);

  inline ArenaInfo& operator=(const ArenaInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArenaInfo& default_instance();

  void Swap(ArenaInfo* other);

  // implements Message ----------------------------------------------

  ArenaInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArenaInfo& from);
  void MergeFrom(const ArenaInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // optional int32 CombatPower = 2;
  inline bool has_combatpower() const;
  inline void clear_combatpower();
  static const int kCombatPowerFieldNumber = 2;
  inline ::google::protobuf::int32 combatpower() const;
  inline void set_combatpower(::google::protobuf::int32 value);

  // optional int32 Ranking = 3;
  inline bool has_ranking() const;
  inline void clear_ranking();
  static const int kRankingFieldNumber = 3;
  inline ::google::protobuf::int32 ranking() const;
  inline void set_ranking(::google::protobuf::int32 value);

  // optional bool iswin = 4;
  inline bool has_iswin() const;
  inline void clear_iswin();
  static const int kIswinFieldNumber = 4;
  inline bool iswin() const;
  inline void set_iswin(bool value);

  // optional .PlayerInfo.ArenaBaseInfo abinfo = 5;
  inline bool has_abinfo() const;
  inline void clear_abinfo();
  static const int kAbinfoFieldNumber = 5;
  inline const ::PlayerInfo::ArenaBaseInfo& abinfo() const;
  inline ::PlayerInfo::ArenaBaseInfo* mutable_abinfo();
  inline ::PlayerInfo::ArenaBaseInfo* release_abinfo();
  inline void set_allocated_abinfo(::PlayerInfo::ArenaBaseInfo* abinfo);

  // optional .PlayerInfo.ArenaChallengeRank challengeRank = 6;
  inline bool has_challengerank() const;
  inline void clear_challengerank();
  static const int kChallengeRankFieldNumber = 6;
  inline const ::PlayerInfo::ArenaChallengeRank& challengerank() const;
  inline ::PlayerInfo::ArenaChallengeRank* mutable_challengerank();
  inline ::PlayerInfo::ArenaChallengeRank* release_challengerank();
  inline void set_allocated_challengerank(::PlayerInfo::ArenaChallengeRank* challengerank);

  // optional int32 challengeNum = 7;
  inline bool has_challengenum() const;
  inline void clear_challengenum();
  static const int kChallengeNumFieldNumber = 7;
  inline ::google::protobuf::int32 challengenum() const;
  inline void set_challengenum(::google::protobuf::int32 value);

  // optional .PlayerInfo.ArenaHistoryReward historyReward = 8;
  inline bool has_historyreward() const;
  inline void clear_historyreward();
  static const int kHistoryRewardFieldNumber = 8;
  inline const ::PlayerInfo::ArenaHistoryReward& historyreward() const;
  inline ::PlayerInfo::ArenaHistoryReward* mutable_historyreward();
  inline ::PlayerInfo::ArenaHistoryReward* release_historyreward();
  inline void set_allocated_historyreward(::PlayerInfo::ArenaHistoryReward* historyreward);

  // @@protoc_insertion_point(class_scope:PlayerInfo.ArenaInfo)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_combatpower();
  inline void clear_has_combatpower();
  inline void set_has_ranking();
  inline void clear_has_ranking();
  inline void set_has_iswin();
  inline void clear_has_iswin();
  inline void set_has_abinfo();
  inline void clear_has_abinfo();
  inline void set_has_challengerank();
  inline void clear_has_challengerank();
  inline void set_has_challengenum();
  inline void clear_has_challengenum();
  inline void set_has_historyreward();
  inline void clear_has_historyreward();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::google::protobuf::int32 combatpower_;
  ::google::protobuf::int32 ranking_;
  ::PlayerInfo::ArenaBaseInfo* abinfo_;
  bool iswin_;
  ::google::protobuf::int32 challengenum_;
  ::PlayerInfo::ArenaChallengeRank* challengerank_;
  ::PlayerInfo::ArenaHistoryReward* historyreward_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static ArenaInfo* default_instance_;
};
// -------------------------------------------------------------------

class ArenaBaseInfo : public ::google::protobuf::Message {
 public:
  ArenaBaseInfo();
  virtual ~ArenaBaseInfo();

  ArenaBaseInfo(const ArenaBaseInfo& from);

  inline ArenaBaseInfo& operator=(const ArenaBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArenaBaseInfo& default_instance();

  void Swap(ArenaBaseInfo* other);

  // implements Message ----------------------------------------------

  ArenaBaseInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArenaBaseInfo& from);
  void MergeFrom(const ArenaBaseInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string charname = 1;
  inline bool has_charname() const;
  inline void clear_charname();
  static const int kCharnameFieldNumber = 1;
  inline const ::std::string& charname() const;
  inline void set_charname(const ::std::string& value);
  inline void set_charname(const char* value);
  inline void set_charname(const char* value, size_t size);
  inline ::std::string* mutable_charname();
  inline ::std::string* release_charname();
  inline void set_allocated_charname(::std::string* charname);

  // optional int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 profession = 3;
  inline bool has_profession() const;
  inline void clear_profession();
  static const int kProfessionFieldNumber = 3;
  inline ::google::protobuf::int32 profession() const;
  inline void set_profession(::google::protobuf::int32 value);

  // optional int32 country = 4;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 4;
  inline ::google::protobuf::int32 country() const;
  inline void set_country(::google::protobuf::int32 value);

  // optional bool sex = 5;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 5;
  inline bool sex() const;
  inline void set_sex(bool value);

  // optional int32 titleid = 6;
  inline bool has_titleid() const;
  inline void clear_titleid();
  static const int kTitleidFieldNumber = 6;
  inline ::google::protobuf::int32 titleid() const;
  inline void set_titleid(::google::protobuf::int32 value);

  // optional string clanname = 7;
  inline bool has_clanname() const;
  inline void clear_clanname();
  static const int kClannameFieldNumber = 7;
  inline const ::std::string& clanname() const;
  inline void set_clanname(const ::std::string& value);
  inline void set_clanname(const char* value);
  inline void set_clanname(const char* value, size_t size);
  inline ::std::string* mutable_clanname();
  inline ::std::string* release_clanname();
  inline void set_allocated_clanname(::std::string* clanname);

  // optional int32 viplv = 8;
  inline bool has_viplv() const;
  inline void clear_viplv();
  static const int kViplvFieldNumber = 8;
  inline ::google::protobuf::int32 viplv() const;
  inline void set_viplv(::google::protobuf::int32 value);

  // optional int32 hpmax = 9;
  inline bool has_hpmax() const;
  inline void clear_hpmax();
  static const int kHpmaxFieldNumber = 9;
  inline ::google::protobuf::int32 hpmax() const;
  inline void set_hpmax(::google::protobuf::int32 value);

  // optional int32 mpmax = 10;
  inline bool has_mpmax() const;
  inline void clear_mpmax();
  static const int kMpmaxFieldNumber = 10;
  inline ::google::protobuf::int32 mpmax() const;
  inline void set_mpmax(::google::protobuf::int32 value);

  // optional int32 movespeed = 11;
  inline bool has_movespeed() const;
  inline void clear_movespeed();
  static const int kMovespeedFieldNumber = 11;
  inline ::google::protobuf::int32 movespeed() const;
  inline void set_movespeed(::google::protobuf::int32 value);

  // optional int32 phyattack = 12;
  inline bool has_phyattack() const;
  inline void clear_phyattack();
  static const int kPhyattackFieldNumber = 12;
  inline ::google::protobuf::int32 phyattack() const;
  inline void set_phyattack(::google::protobuf::int32 value);

  // optional int32 phyattackmax = 13;
  inline bool has_phyattackmax() const;
  inline void clear_phyattackmax();
  static const int kPhyattackmaxFieldNumber = 13;
  inline ::google::protobuf::int32 phyattackmax() const;
  inline void set_phyattackmax(::google::protobuf::int32 value);

  // optional int32 magicattack = 14;
  inline bool has_magicattack() const;
  inline void clear_magicattack();
  static const int kMagicattackFieldNumber = 14;
  inline ::google::protobuf::int32 magicattack() const;
  inline void set_magicattack(::google::protobuf::int32 value);

  // optional int32 magicattackmax = 15;
  inline bool has_magicattackmax() const;
  inline void clear_magicattackmax();
  static const int kMagicattackmaxFieldNumber = 15;
  inline ::google::protobuf::int32 magicattackmax() const;
  inline void set_magicattackmax(::google::protobuf::int32 value);

  // optional int32 phydefence = 16;
  inline bool has_phydefence() const;
  inline void clear_phydefence();
  static const int kPhydefenceFieldNumber = 16;
  inline ::google::protobuf::int32 phydefence() const;
  inline void set_phydefence(::google::protobuf::int32 value);

  // optional int32 magicdefence = 17;
  inline bool has_magicdefence() const;
  inline void clear_magicdefence();
  static const int kMagicdefenceFieldNumber = 17;
  inline ::google::protobuf::int32 magicdefence() const;
  inline void set_magicdefence(::google::protobuf::int32 value);

  // optional int32 hitrate = 18;
  inline bool has_hitrate() const;
  inline void clear_hitrate();
  static const int kHitrateFieldNumber = 18;
  inline ::google::protobuf::int32 hitrate() const;
  inline void set_hitrate(::google::protobuf::int32 value);

  // optional int32 avoidrate = 19;
  inline bool has_avoidrate() const;
  inline void clear_avoidrate();
  static const int kAvoidrateFieldNumber = 19;
  inline ::google::protobuf::int32 avoidrate() const;
  inline void set_avoidrate(::google::protobuf::int32 value);

  // optional int32 baselucky = 20;
  inline bool has_baselucky() const;
  inline void clear_baselucky();
  static const int kBaseluckyFieldNumber = 20;
  inline ::google::protobuf::int32 baselucky() const;
  inline void set_baselucky(::google::protobuf::int32 value);

  // optional int32 crackdownrate = 21;
  inline bool has_crackdownrate() const;
  inline void clear_crackdownrate();
  static const int kCrackdownrateFieldNumber = 21;
  inline ::google::protobuf::int32 crackdownrate() const;
  inline void set_crackdownrate(::google::protobuf::int32 value);

  // optional int32 baserte = 22;
  inline bool has_baserte() const;
  inline void clear_baserte();
  static const int kBaserteFieldNumber = 22;
  inline ::google::protobuf::int32 baserte() const;
  inline void set_baserte(::google::protobuf::int32 value);

  // optional int32 magicw = 23;
  inline bool has_magicw() const;
  inline void clear_magicw();
  static const int kMagicwFieldNumber = 23;
  inline ::google::protobuf::int32 magicw() const;
  inline void set_magicw(::google::protobuf::int32 value);

  // optional int32 suitrnt = 24;
  inline bool has_suitrnt() const;
  inline void clear_suitrnt();
  static const int kSuitrntFieldNumber = 24;
  inline ::google::protobuf::int32 suitrnt() const;
  inline void set_suitrnt(::google::protobuf::int32 value);

  // optional .PlayerSynch.EquipData mainEquip = 25;
  inline bool has_mainequip() const;
  inline void clear_mainequip();
  static const int kMainEquipFieldNumber = 25;
  inline const ::PlayerSynch::EquipData& mainequip() const;
  inline ::PlayerSynch::EquipData* mutable_mainequip();
  inline ::PlayerSynch::EquipData* release_mainequip();
  inline void set_allocated_mainequip(::PlayerSynch::EquipData* mainequip);

  // optional int32 costume = 26;
  inline bool has_costume() const;
  inline void clear_costume();
  static const int kCostumeFieldNumber = 26;
  inline ::google::protobuf::int32 costume() const;
  inline void set_costume(::google::protobuf::int32 value);

  // optional int32 horse = 27;
  inline bool has_horse() const;
  inline void clear_horse();
  static const int kHorseFieldNumber = 27;
  inline ::google::protobuf::int32 horse() const;
  inline void set_horse(::google::protobuf::int32 value);

  // repeated int32 skill = 28;
  inline int skill_size() const;
  inline void clear_skill();
  static const int kSkillFieldNumber = 28;
  inline ::google::protobuf::int32 skill(int index) const;
  inline void set_skill(int index, ::google::protobuf::int32 value);
  inline void add_skill(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      skill() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_skill();

  // optional int32 clanJob = 29;
  inline bool has_clanjob() const;
  inline void clear_clanjob();
  static const int kClanJobFieldNumber = 29;
  inline ::google::protobuf::int32 clanjob() const;
  inline void set_clanjob(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.ArenaBaseInfo)
 private:
  inline void set_has_charname();
  inline void clear_has_charname();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_profession();
  inline void clear_has_profession();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_titleid();
  inline void clear_has_titleid();
  inline void set_has_clanname();
  inline void clear_has_clanname();
  inline void set_has_viplv();
  inline void clear_has_viplv();
  inline void set_has_hpmax();
  inline void clear_has_hpmax();
  inline void set_has_mpmax();
  inline void clear_has_mpmax();
  inline void set_has_movespeed();
  inline void clear_has_movespeed();
  inline void set_has_phyattack();
  inline void clear_has_phyattack();
  inline void set_has_phyattackmax();
  inline void clear_has_phyattackmax();
  inline void set_has_magicattack();
  inline void clear_has_magicattack();
  inline void set_has_magicattackmax();
  inline void clear_has_magicattackmax();
  inline void set_has_phydefence();
  inline void clear_has_phydefence();
  inline void set_has_magicdefence();
  inline void clear_has_magicdefence();
  inline void set_has_hitrate();
  inline void clear_has_hitrate();
  inline void set_has_avoidrate();
  inline void clear_has_avoidrate();
  inline void set_has_baselucky();
  inline void clear_has_baselucky();
  inline void set_has_crackdownrate();
  inline void clear_has_crackdownrate();
  inline void set_has_baserte();
  inline void clear_has_baserte();
  inline void set_has_magicw();
  inline void clear_has_magicw();
  inline void set_has_suitrnt();
  inline void clear_has_suitrnt();
  inline void set_has_mainequip();
  inline void clear_has_mainequip();
  inline void set_has_costume();
  inline void clear_has_costume();
  inline void set_has_horse();
  inline void clear_has_horse();
  inline void set_has_clanjob();
  inline void clear_has_clanjob();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* charname_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 profession_;
  ::google::protobuf::int32 country_;
  bool sex_;
  ::std::string* clanname_;
  ::google::protobuf::int32 titleid_;
  ::google::protobuf::int32 viplv_;
  ::google::protobuf::int32 hpmax_;
  ::google::protobuf::int32 mpmax_;
  ::google::protobuf::int32 movespeed_;
  ::google::protobuf::int32 phyattack_;
  ::google::protobuf::int32 phyattackmax_;
  ::google::protobuf::int32 magicattack_;
  ::google::protobuf::int32 magicattackmax_;
  ::google::protobuf::int32 phydefence_;
  ::google::protobuf::int32 magicdefence_;
  ::google::protobuf::int32 hitrate_;
  ::google::protobuf::int32 avoidrate_;
  ::google::protobuf::int32 baselucky_;
  ::google::protobuf::int32 crackdownrate_;
  ::google::protobuf::int32 baserte_;
  ::google::protobuf::int32 magicw_;
  ::google::protobuf::int32 suitrnt_;
  ::PlayerSynch::EquipData* mainequip_;
  ::google::protobuf::int32 costume_;
  ::google::protobuf::int32 horse_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > skill_;
  ::google::protobuf::int32 clanjob_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(29 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static ArenaBaseInfo* default_instance_;
};
// -------------------------------------------------------------------

class ArenaChallengeRank : public ::google::protobuf::Message {
 public:
  ArenaChallengeRank();
  virtual ~ArenaChallengeRank();

  ArenaChallengeRank(const ArenaChallengeRank& from);

  inline ArenaChallengeRank& operator=(const ArenaChallengeRank& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArenaChallengeRank& default_instance();

  void Swap(ArenaChallengeRank* other);

  // implements Message ----------------------------------------------

  ArenaChallengeRank* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArenaChallengeRank& from);
  void MergeFrom(const ArenaChallengeRank& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 challengeRank = 1;
  inline int challengerank_size() const;
  inline void clear_challengerank();
  static const int kChallengeRankFieldNumber = 1;
  inline ::google::protobuf::int32 challengerank(int index) const;
  inline void set_challengerank(int index, ::google::protobuf::int32 value);
  inline void add_challengerank(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      challengerank() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_challengerank();

  // @@protoc_insertion_point(class_scope:PlayerInfo.ArenaChallengeRank)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > challengerank_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static ArenaChallengeRank* default_instance_;
};
// -------------------------------------------------------------------

class ArenaHistoryReward : public ::google::protobuf::Message {
 public:
  ArenaHistoryReward();
  virtual ~ArenaHistoryReward();

  ArenaHistoryReward(const ArenaHistoryReward& from);

  inline ArenaHistoryReward& operator=(const ArenaHistoryReward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArenaHistoryReward& default_instance();

  void Swap(ArenaHistoryReward* other);

  // implements Message ----------------------------------------------

  ArenaHistoryReward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArenaHistoryReward& from);
  void MergeFrom(const ArenaHistoryReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 reward = 1;
  inline int reward_size() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 1;
  inline ::google::protobuf::int32 reward(int index) const;
  inline void set_reward(int index, ::google::protobuf::int32 value);
  inline void add_reward(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      reward() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_reward();

  // repeated int32 havaReward = 2;
  inline int havareward_size() const;
  inline void clear_havareward();
  static const int kHavaRewardFieldNumber = 2;
  inline ::google::protobuf::int32 havareward(int index) const;
  inline void set_havareward(int index, ::google::protobuf::int32 value);
  inline void add_havareward(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      havareward() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_havareward();

  // @@protoc_insertion_point(class_scope:PlayerInfo.ArenaHistoryReward)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > reward_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > havareward_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static ArenaHistoryReward* default_instance_;
};
// -------------------------------------------------------------------

class RingDBData : public ::google::protobuf::Message {
 public:
  RingDBData();
  virtual ~RingDBData();

  RingDBData(const RingDBData& from);

  inline RingDBData& operator=(const RingDBData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RingDBData& default_instance();

  void Swap(RingDBData* other);

  // implements Message ----------------------------------------------

  RingDBData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RingDBData& from);
  void MergeFrom(const RingDBData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int32 reward = 3;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 3;
  inline ::google::protobuf::int32 reward() const;
  inline void set_reward(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.RingDBData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_reward();
  inline void clear_has_reward();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int32 reward_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static RingDBData* default_instance_;
};
// -------------------------------------------------------------------

class SaveTypeInfo : public ::google::protobuf::Message {
 public:
  SaveTypeInfo();
  virtual ~SaveTypeInfo();

  SaveTypeInfo(const SaveTypeInfo& from);

  inline SaveTypeInfo& operator=(const SaveTypeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SaveTypeInfo& default_instance();

  void Swap(SaveTypeInfo* other);

  // implements Message ----------------------------------------------

  SaveTypeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SaveTypeInfo& from);
  void MergeFrom(const SaveTypeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint64 type() const;
  inline void set_type(::google::protobuf::uint64 value);

  // required int64 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // required bool isdel = 3;
  inline bool has_isdel() const;
  inline void clear_isdel();
  static const int kIsdelFieldNumber = 3;
  inline bool isdel() const;
  inline void set_isdel(bool value);

  // optional .PlayerInfo.BaseInfo bsinfo = 4;
  inline bool has_bsinfo() const;
  inline void clear_bsinfo();
  static const int kBsinfoFieldNumber = 4;
  inline const ::PlayerInfo::BaseInfo& bsinfo() const;
  inline ::PlayerInfo::BaseInfo* mutable_bsinfo();
  inline ::PlayerInfo::BaseInfo* release_bsinfo();
  inline void set_allocated_bsinfo(::PlayerInfo::BaseInfo* bsinfo);

  // optional .PlayerInfo.BattleInfo binfo = 5;
  inline bool has_binfo() const;
  inline void clear_binfo();
  static const int kBinfoFieldNumber = 5;
  inline const ::PlayerInfo::BattleInfo& binfo() const;
  inline ::PlayerInfo::BattleInfo* mutable_binfo();
  inline ::PlayerInfo::BattleInfo* release_binfo();
  inline void set_allocated_binfo(::PlayerInfo::BattleInfo* binfo);

  // optional .PlayerInfo.QuestInfo questinfo = 6;
  inline bool has_questinfo() const;
  inline void clear_questinfo();
  static const int kQuestinfoFieldNumber = 6;
  inline const ::PlayerInfo::QuestInfo& questinfo() const;
  inline ::PlayerInfo::QuestInfo* mutable_questinfo();
  inline ::PlayerInfo::QuestInfo* release_questinfo();
  inline void set_allocated_questinfo(::PlayerInfo::QuestInfo* questinfo);

  // optional .PlayerInfo.SkillInfo skill = 7;
  inline bool has_skill() const;
  inline void clear_skill();
  static const int kSkillFieldNumber = 7;
  inline const ::PlayerInfo::SkillInfo& skill() const;
  inline ::PlayerInfo::SkillInfo* mutable_skill();
  inline ::PlayerInfo::SkillInfo* release_skill();
  inline void set_allocated_skill(::PlayerInfo::SkillInfo* skill);

  // optional .PlayerInfo.CDInfo cd = 8;
  inline bool has_cd() const;
  inline void clear_cd();
  static const int kCdFieldNumber = 8;
  inline const ::PlayerInfo::CDInfo& cd() const;
  inline ::PlayerInfo::CDInfo* mutable_cd();
  inline ::PlayerInfo::CDInfo* release_cd();
  inline void set_allocated_cd(::PlayerInfo::CDInfo* cd);

  // optional .PlayerInfo.PackageInfo package = 9;
  inline bool has_package() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 9;
  inline const ::PlayerInfo::PackageInfo& package() const;
  inline ::PlayerInfo::PackageInfo* mutable_package();
  inline ::PlayerInfo::PackageInfo* release_package();
  inline void set_allocated_package(::PlayerInfo::PackageInfo* package);

  // optional .PlayerInfo.StoreHouseInfo storehouse = 10;
  inline bool has_storehouse() const;
  inline void clear_storehouse();
  static const int kStorehouseFieldNumber = 10;
  inline const ::PlayerInfo::StoreHouseInfo& storehouse() const;
  inline ::PlayerInfo::StoreHouseInfo* mutable_storehouse();
  inline ::PlayerInfo::StoreHouseInfo* release_storehouse();
  inline void set_allocated_storehouse(::PlayerInfo::StoreHouseInfo* storehouse);

  // optional .PlayerInfo.EquipQuickInfo equipquick = 11;
  inline bool has_equipquick() const;
  inline void clear_equipquick();
  static const int kEquipquickFieldNumber = 11;
  inline const ::PlayerInfo::EquipQuickInfo& equipquick() const;
  inline ::PlayerInfo::EquipQuickInfo* mutable_equipquick();
  inline ::PlayerInfo::EquipQuickInfo* release_equipquick();
  inline void set_allocated_equipquick(::PlayerInfo::EquipQuickInfo* equipquick);

  // optional .PlayerInfo.MonitorInfo monitor = 12;
  inline bool has_monitor() const;
  inline void clear_monitor();
  static const int kMonitorFieldNumber = 12;
  inline const ::PlayerInfo::MonitorInfo& monitor() const;
  inline ::PlayerInfo::MonitorInfo* mutable_monitor();
  inline ::PlayerInfo::MonitorInfo* release_monitor();
  inline void set_allocated_monitor(::PlayerInfo::MonitorInfo* monitor);

  // optional .PlayerInfo.HorseInfo horse = 13;
  inline bool has_horse() const;
  inline void clear_horse();
  static const int kHorseFieldNumber = 13;
  inline const ::PlayerInfo::HorseInfo& horse() const;
  inline ::PlayerInfo::HorseInfo* mutable_horse();
  inline ::PlayerInfo::HorseInfo* release_horse();
  inline void set_allocated_horse(::PlayerInfo::HorseInfo* horse);

  // optional .PlayerInfo.InstanceInfoTwoDays instance = 14;
  inline bool has_instance() const;
  inline void clear_instance();
  static const int kInstanceFieldNumber = 14;
  inline const ::PlayerInfo::InstanceInfoTwoDays& instance() const;
  inline ::PlayerInfo::InstanceInfoTwoDays* mutable_instance();
  inline ::PlayerInfo::InstanceInfoTwoDays* release_instance();
  inline void set_allocated_instance(::PlayerInfo::InstanceInfoTwoDays* instance);

  // optional .PlayerInfo.PrestigeInfoList prestige = 15;
  inline bool has_prestige() const;
  inline void clear_prestige();
  static const int kPrestigeFieldNumber = 15;
  inline const ::PlayerInfo::PrestigeInfoList& prestige() const;
  inline ::PlayerInfo::PrestigeInfoList* mutable_prestige();
  inline ::PlayerInfo::PrestigeInfoList* release_prestige();
  inline void set_allocated_prestige(::PlayerInfo::PrestigeInfoList* prestige);

  // optional .PlayerInfo.SignInInfo signin = 16;
  inline bool has_signin() const;
  inline void clear_signin();
  static const int kSigninFieldNumber = 16;
  inline const ::PlayerInfo::SignInInfo& signin() const;
  inline ::PlayerInfo::SignInInfo* mutable_signin();
  inline ::PlayerInfo::SignInInfo* release_signin();
  inline void set_allocated_signin(::PlayerInfo::SignInInfo* signin);

  // optional .PlayerInfo.CounterServiceList counter = 17;
  inline bool has_counter() const;
  inline void clear_counter();
  static const int kCounterFieldNumber = 17;
  inline const ::PlayerInfo::CounterServiceList& counter() const;
  inline ::PlayerInfo::CounterServiceList* mutable_counter();
  inline ::PlayerInfo::CounterServiceList* release_counter();
  inline void set_allocated_counter(::PlayerInfo::CounterServiceList* counter);

  // optional .PlayerInfo.TitleInfoList titles = 18;
  inline bool has_titles() const;
  inline void clear_titles();
  static const int kTitlesFieldNumber = 18;
  inline const ::PlayerInfo::TitleInfoList& titles() const;
  inline ::PlayerInfo::TitleInfoList* mutable_titles();
  inline ::PlayerInfo::TitleInfoList* release_titles();
  inline void set_allocated_titles(::PlayerInfo::TitleInfoList* titles);

  // optional .PlayerInfo.EscortInfo escort = 19;
  inline bool has_escort() const;
  inline void clear_escort();
  static const int kEscortFieldNumber = 19;
  inline const ::PlayerInfo::EscortInfo& escort() const;
  inline ::PlayerInfo::EscortInfo* mutable_escort();
  inline ::PlayerInfo::EscortInfo* release_escort();
  inline void set_allocated_escort(::PlayerInfo::EscortInfo* escort);

  // optional .PlayerInfo.DanLuInfo danlu = 20;
  inline bool has_danlu() const;
  inline void clear_danlu();
  static const int kDanluFieldNumber = 20;
  inline const ::PlayerInfo::DanLuInfo& danlu() const;
  inline ::PlayerInfo::DanLuInfo* mutable_danlu();
  inline ::PlayerInfo::DanLuInfo* release_danlu();
  inline void set_allocated_danlu(::PlayerInfo::DanLuInfo* danlu);

  // optional .PlayerInfo.PlayerVipInfo vipinfo = 21;
  inline bool has_vipinfo() const;
  inline void clear_vipinfo();
  static const int kVipinfoFieldNumber = 21;
  inline const ::PlayerInfo::PlayerVipInfo& vipinfo() const;
  inline ::PlayerInfo::PlayerVipInfo* mutable_vipinfo();
  inline ::PlayerInfo::PlayerVipInfo* release_vipinfo();
  inline void set_allocated_vipinfo(::PlayerInfo::PlayerVipInfo* vipinfo);

  // optional .PlayerInfo.MagicWeapon magicw = 22;
  inline bool has_magicw() const;
  inline void clear_magicw();
  static const int kMagicwFieldNumber = 22;
  inline const ::PlayerInfo::MagicWeapon& magicw() const;
  inline ::PlayerInfo::MagicWeapon* mutable_magicw();
  inline ::PlayerInfo::MagicWeapon* release_magicw();
  inline void set_allocated_magicw(::PlayerInfo::MagicWeapon* magicw);

  // optional .PlayerInfo.RandCJobLucky cjob = 23;
  inline bool has_cjob() const;
  inline void clear_cjob();
  static const int kCjobFieldNumber = 23;
  inline const ::PlayerInfo::RandCJobLucky& cjob() const;
  inline ::PlayerInfo::RandCJobLucky* mutable_cjob();
  inline ::PlayerInfo::RandCJobLucky* release_cjob();
  inline void set_allocated_cjob(::PlayerInfo::RandCJobLucky* cjob);

  // optional .PlayerInfo.LucklyTurntable lucktable = 24;
  inline bool has_lucktable() const;
  inline void clear_lucktable();
  static const int kLucktableFieldNumber = 24;
  inline const ::PlayerInfo::LucklyTurntable& lucktable() const;
  inline ::PlayerInfo::LucklyTurntable* mutable_lucktable();
  inline ::PlayerInfo::LucklyTurntable* release_lucktable();
  inline void set_allocated_lucktable(::PlayerInfo::LucklyTurntable* lucktable);

  // optional .PlayerInfo.DestinationInfoList destination = 25;
  inline bool has_destination() const;
  inline void clear_destination();
  static const int kDestinationFieldNumber = 25;
  inline const ::PlayerInfo::DestinationInfoList& destination() const;
  inline ::PlayerInfo::DestinationInfoList* mutable_destination();
  inline ::PlayerInfo::DestinationInfoList* release_destination();
  inline void set_allocated_destination(::PlayerInfo::DestinationInfoList* destination);

  // optional .PlayerInfo.Activity activity = 26;
  inline bool has_activity() const;
  inline void clear_activity();
  static const int kActivityFieldNumber = 26;
  inline const ::PlayerInfo::Activity& activity() const;
  inline ::PlayerInfo::Activity* mutable_activity();
  inline ::PlayerInfo::Activity* release_activity();
  inline void set_allocated_activity(::PlayerInfo::Activity* activity);

  // optional .PlayerInfo.GirlWarInfo girlwar = 27;
  inline bool has_girlwar() const;
  inline void clear_girlwar();
  static const int kGirlwarFieldNumber = 27;
  inline const ::PlayerInfo::GirlWarInfo& girlwar() const;
  inline ::PlayerInfo::GirlWarInfo* mutable_girlwar();
  inline ::PlayerInfo::GirlWarInfo* release_girlwar();
  inline void set_allocated_girlwar(::PlayerInfo::GirlWarInfo* girlwar);

  // optional .FashionMsgProto.FashionShow fashion = 28;
  inline bool has_fashion() const;
  inline void clear_fashion();
  static const int kFashionFieldNumber = 28;
  inline const ::FashionMsgProto::FashionShow& fashion() const;
  inline ::FashionMsgProto::FashionShow* mutable_fashion();
  inline ::FashionMsgProto::FashionShow* release_fashion();
  inline void set_allocated_fashion(::FashionMsgProto::FashionShow* fashion);

  // optional .VitalityProto.ProtoVitalityInfo vitality = 29;
  inline bool has_vitality() const;
  inline void clear_vitality();
  static const int kVitalityFieldNumber = 29;
  inline const ::VitalityProto::ProtoVitalityInfo& vitality() const;
  inline ::VitalityProto::ProtoVitalityInfo* mutable_vitality();
  inline ::VitalityProto::ProtoVitalityInfo* release_vitality();
  inline void set_allocated_vitality(::VitalityProto::ProtoVitalityInfo* vitality);

  // optional .PlayerInfo.CampShopInfo CampData = 30;
  inline bool has_campdata() const;
  inline void clear_campdata();
  static const int kCampDataFieldNumber = 30;
  inline const ::PlayerInfo::CampShopInfo& campdata() const;
  inline ::PlayerInfo::CampShopInfo* mutable_campdata();
  inline ::PlayerInfo::CampShopInfo* release_campdata();
  inline void set_allocated_campdata(::PlayerInfo::CampShopInfo* campdata);

  // optional .PlayerInfo.FestivalInfo festivalData = 31;
  inline bool has_festivaldata() const;
  inline void clear_festivaldata();
  static const int kFestivalDataFieldNumber = 31;
  inline const ::PlayerInfo::FestivalInfo& festivaldata() const;
  inline ::PlayerInfo::FestivalInfo* mutable_festivaldata();
  inline ::PlayerInfo::FestivalInfo* release_festivaldata();
  inline void set_allocated_festivaldata(::PlayerInfo::FestivalInfo* festivaldata);

  // optional .PlayerInfo.MoneyInstance info = 32;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 32;
  inline const ::PlayerInfo::MoneyInstance& info() const;
  inline ::PlayerInfo::MoneyInstance* mutable_info();
  inline ::PlayerInfo::MoneyInstance* release_info();
  inline void set_allocated_info(::PlayerInfo::MoneyInstance* info);

  // optional .PlayerInfo.OnceRewardInfo onceReward = 33;
  inline bool has_oncereward() const;
  inline void clear_oncereward();
  static const int kOnceRewardFieldNumber = 33;
  inline const ::PlayerInfo::OnceRewardInfo& oncereward() const;
  inline ::PlayerInfo::OnceRewardInfo* mutable_oncereward();
  inline ::PlayerInfo::OnceRewardInfo* release_oncereward();
  inline void set_allocated_oncereward(::PlayerInfo::OnceRewardInfo* oncereward);

  // optional .PlayerInfo.RingDBData ringData = 34;
  inline bool has_ringdata() const;
  inline void clear_ringdata();
  static const int kRingDataFieldNumber = 34;
  inline const ::PlayerInfo::RingDBData& ringdata() const;
  inline ::PlayerInfo::RingDBData* mutable_ringdata();
  inline ::PlayerInfo::RingDBData* release_ringdata();
  inline void set_allocated_ringdata(::PlayerInfo::RingDBData* ringdata);

  // optional .PlayerInfo.GroupInstance groupInfo = 35;
  inline bool has_groupinfo() const;
  inline void clear_groupinfo();
  static const int kGroupInfoFieldNumber = 35;
  inline const ::PlayerInfo::GroupInstance& groupinfo() const;
  inline ::PlayerInfo::GroupInstance* mutable_groupinfo();
  inline ::PlayerInfo::GroupInstance* release_groupinfo();
  inline void set_allocated_groupinfo(::PlayerInfo::GroupInstance* groupinfo);

  // optional .ChristmasDB.ChristmasAllData christmasData = 36;
  inline bool has_christmasdata() const;
  inline void clear_christmasdata();
  static const int kChristmasDataFieldNumber = 36;
  inline const ::ChristmasDB::ChristmasAllData& christmasdata() const;
  inline ::ChristmasDB::ChristmasAllData* mutable_christmasdata();
  inline ::ChristmasDB::ChristmasAllData* release_christmasdata();
  inline void set_allocated_christmasdata(::ChristmasDB::ChristmasAllData* christmasdata);

  // optional .PlayerInfo.EliteInstance eliteInfo = 37;
  inline bool has_eliteinfo() const;
  inline void clear_eliteinfo();
  static const int kEliteInfoFieldNumber = 37;
  inline const ::PlayerInfo::EliteInstance& eliteinfo() const;
  inline ::PlayerInfo::EliteInstance* mutable_eliteinfo();
  inline ::PlayerInfo::EliteInstance* release_eliteinfo();
  inline void set_allocated_eliteinfo(::PlayerInfo::EliteInstance* eliteinfo);

  // optional .PlayerInfo.CauchemarInstance cauchemarInfo = 38;
  inline bool has_cauchemarinfo() const;
  inline void clear_cauchemarinfo();
  static const int kCauchemarInfoFieldNumber = 38;
  inline const ::PlayerInfo::CauchemarInstance& cauchemarinfo() const;
  inline ::PlayerInfo::CauchemarInstance* mutable_cauchemarinfo();
  inline ::PlayerInfo::CauchemarInstance* release_cauchemarinfo();
  inline void set_allocated_cauchemarinfo(::PlayerInfo::CauchemarInstance* cauchemarinfo);

  // optional .PlayerInfo.ArenaDataInfo arenaData = 39;
  inline bool has_arenadata() const;
  inline void clear_arenadata();
  static const int kArenaDataFieldNumber = 39;
  inline const ::PlayerInfo::ArenaDataInfo& arenadata() const;
  inline ::PlayerInfo::ArenaDataInfo* mutable_arenadata();
  inline ::PlayerInfo::ArenaDataInfo* release_arenadata();
  inline void set_allocated_arenadata(::PlayerInfo::ArenaDataInfo* arenadata);

  // optional .PlayerInfo.ChallengeInstance challengedata = 40;
  inline bool has_challengedata() const;
  inline void clear_challengedata();
  static const int kChallengedataFieldNumber = 40;
  inline const ::PlayerInfo::ChallengeInstance& challengedata() const;
  inline ::PlayerInfo::ChallengeInstance* mutable_challengedata();
  inline ::PlayerInfo::ChallengeInstance* release_challengedata();
  inline void set_allocated_challengedata(::PlayerInfo::ChallengeInstance* challengedata);

  // optional .PlayerInfo.HeroInstanceData herodata = 41;
  inline bool has_herodata() const;
  inline void clear_herodata();
  static const int kHerodataFieldNumber = 41;
  inline const ::PlayerInfo::HeroInstanceData& herodata() const;
  inline ::PlayerInfo::HeroInstanceData* mutable_herodata();
  inline ::PlayerInfo::HeroInstanceData* release_herodata();
  inline void set_allocated_herodata(::PlayerInfo::HeroInstanceData* herodata);

  // optional .PlayerInfo.MagicWeapon smagic = 42;
  inline bool has_smagic() const;
  inline void clear_smagic();
  static const int kSmagicFieldNumber = 42;
  inline const ::PlayerInfo::MagicWeapon& smagic() const;
  inline ::PlayerInfo::MagicWeapon* mutable_smagic();
  inline ::PlayerInfo::MagicWeapon* release_smagic();
  inline void set_allocated_smagic(::PlayerInfo::MagicWeapon* smagic);

  // optional .PlayerInfo.MagicWeapon heartmagic = 43;
  inline bool has_heartmagic() const;
  inline void clear_heartmagic();
  static const int kHeartmagicFieldNumber = 43;
  inline const ::PlayerInfo::MagicWeapon& heartmagic() const;
  inline ::PlayerInfo::MagicWeapon* mutable_heartmagic();
  inline ::PlayerInfo::MagicWeapon* release_heartmagic();
  inline void set_allocated_heartmagic(::PlayerInfo::MagicWeapon* heartmagic);

  // optional .PlayerInfo.AdvancedInstance advanced = 44;
  inline bool has_advanced() const;
  inline void clear_advanced();
  static const int kAdvancedFieldNumber = 44;
  inline const ::PlayerInfo::AdvancedInstance& advanced() const;
  inline ::PlayerInfo::AdvancedInstance* mutable_advanced();
  inline ::PlayerInfo::AdvancedInstance* release_advanced();
  inline void set_allocated_advanced(::PlayerInfo::AdvancedInstance* advanced);

  // optional .PlayerInfo.BaseShopInfo baseShopInfo = 45;
  inline bool has_baseshopinfo() const;
  inline void clear_baseshopinfo();
  static const int kBaseShopInfoFieldNumber = 45;
  inline const ::PlayerInfo::BaseShopInfo& baseshopinfo() const;
  inline ::PlayerInfo::BaseShopInfo* mutable_baseshopinfo();
  inline ::PlayerInfo::BaseShopInfo* release_baseshopinfo();
  inline void set_allocated_baseshopinfo(::PlayerInfo::BaseShopInfo* baseshopinfo);

  // optional .PlayerInfo.AnswerInfo answerInfo = 46;
  inline bool has_answerinfo() const;
  inline void clear_answerinfo();
  static const int kAnswerInfoFieldNumber = 46;
  inline const ::PlayerInfo::AnswerInfo& answerinfo() const;
  inline ::PlayerInfo::AnswerInfo* mutable_answerinfo();
  inline ::PlayerInfo::AnswerInfo* release_answerinfo();
  inline void set_allocated_answerinfo(::PlayerInfo::AnswerInfo* answerinfo);

  // @@protoc_insertion_point(class_scope:PlayerInfo.SaveTypeInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_isdel();
  inline void clear_has_isdel();
  inline void set_has_bsinfo();
  inline void clear_has_bsinfo();
  inline void set_has_binfo();
  inline void clear_has_binfo();
  inline void set_has_questinfo();
  inline void clear_has_questinfo();
  inline void set_has_skill();
  inline void clear_has_skill();
  inline void set_has_cd();
  inline void clear_has_cd();
  inline void set_has_package();
  inline void clear_has_package();
  inline void set_has_storehouse();
  inline void clear_has_storehouse();
  inline void set_has_equipquick();
  inline void clear_has_equipquick();
  inline void set_has_monitor();
  inline void clear_has_monitor();
  inline void set_has_horse();
  inline void clear_has_horse();
  inline void set_has_instance();
  inline void clear_has_instance();
  inline void set_has_prestige();
  inline void clear_has_prestige();
  inline void set_has_signin();
  inline void clear_has_signin();
  inline void set_has_counter();
  inline void clear_has_counter();
  inline void set_has_titles();
  inline void clear_has_titles();
  inline void set_has_escort();
  inline void clear_has_escort();
  inline void set_has_danlu();
  inline void clear_has_danlu();
  inline void set_has_vipinfo();
  inline void clear_has_vipinfo();
  inline void set_has_magicw();
  inline void clear_has_magicw();
  inline void set_has_cjob();
  inline void clear_has_cjob();
  inline void set_has_lucktable();
  inline void clear_has_lucktable();
  inline void set_has_destination();
  inline void clear_has_destination();
  inline void set_has_activity();
  inline void clear_has_activity();
  inline void set_has_girlwar();
  inline void clear_has_girlwar();
  inline void set_has_fashion();
  inline void clear_has_fashion();
  inline void set_has_vitality();
  inline void clear_has_vitality();
  inline void set_has_campdata();
  inline void clear_has_campdata();
  inline void set_has_festivaldata();
  inline void clear_has_festivaldata();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_oncereward();
  inline void clear_has_oncereward();
  inline void set_has_ringdata();
  inline void clear_has_ringdata();
  inline void set_has_groupinfo();
  inline void clear_has_groupinfo();
  inline void set_has_christmasdata();
  inline void clear_has_christmasdata();
  inline void set_has_eliteinfo();
  inline void clear_has_eliteinfo();
  inline void set_has_cauchemarinfo();
  inline void clear_has_cauchemarinfo();
  inline void set_has_arenadata();
  inline void clear_has_arenadata();
  inline void set_has_challengedata();
  inline void clear_has_challengedata();
  inline void set_has_herodata();
  inline void clear_has_herodata();
  inline void set_has_smagic();
  inline void clear_has_smagic();
  inline void set_has_heartmagic();
  inline void clear_has_heartmagic();
  inline void set_has_advanced();
  inline void clear_has_advanced();
  inline void set_has_baseshopinfo();
  inline void clear_has_baseshopinfo();
  inline void set_has_answerinfo();
  inline void clear_has_answerinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 type_;
  ::google::protobuf::int64 id_;
  ::PlayerInfo::BaseInfo* bsinfo_;
  ::PlayerInfo::BattleInfo* binfo_;
  ::PlayerInfo::QuestInfo* questinfo_;
  ::PlayerInfo::SkillInfo* skill_;
  ::PlayerInfo::CDInfo* cd_;
  ::PlayerInfo::PackageInfo* package_;
  ::PlayerInfo::StoreHouseInfo* storehouse_;
  ::PlayerInfo::EquipQuickInfo* equipquick_;
  ::PlayerInfo::MonitorInfo* monitor_;
  ::PlayerInfo::HorseInfo* horse_;
  ::PlayerInfo::InstanceInfoTwoDays* instance_;
  ::PlayerInfo::PrestigeInfoList* prestige_;
  ::PlayerInfo::SignInInfo* signin_;
  ::PlayerInfo::CounterServiceList* counter_;
  ::PlayerInfo::TitleInfoList* titles_;
  ::PlayerInfo::EscortInfo* escort_;
  ::PlayerInfo::DanLuInfo* danlu_;
  ::PlayerInfo::PlayerVipInfo* vipinfo_;
  ::PlayerInfo::MagicWeapon* magicw_;
  ::PlayerInfo::RandCJobLucky* cjob_;
  ::PlayerInfo::LucklyTurntable* lucktable_;
  ::PlayerInfo::DestinationInfoList* destination_;
  ::PlayerInfo::Activity* activity_;
  ::PlayerInfo::GirlWarInfo* girlwar_;
  ::FashionMsgProto::FashionShow* fashion_;
  ::VitalityProto::ProtoVitalityInfo* vitality_;
  ::PlayerInfo::CampShopInfo* campdata_;
  ::PlayerInfo::FestivalInfo* festivaldata_;
  ::PlayerInfo::MoneyInstance* info_;
  ::PlayerInfo::OnceRewardInfo* oncereward_;
  ::PlayerInfo::RingDBData* ringdata_;
  ::PlayerInfo::GroupInstance* groupinfo_;
  ::ChristmasDB::ChristmasAllData* christmasdata_;
  ::PlayerInfo::EliteInstance* eliteinfo_;
  ::PlayerInfo::CauchemarInstance* cauchemarinfo_;
  ::PlayerInfo::ArenaDataInfo* arenadata_;
  ::PlayerInfo::ChallengeInstance* challengedata_;
  ::PlayerInfo::HeroInstanceData* herodata_;
  ::PlayerInfo::MagicWeapon* smagic_;
  ::PlayerInfo::MagicWeapon* heartmagic_;
  ::PlayerInfo::AdvancedInstance* advanced_;
  ::PlayerInfo::BaseShopInfo* baseshopinfo_;
  ::PlayerInfo::AnswerInfo* answerinfo_;
  bool isdel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(46 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static SaveTypeInfo* default_instance_;
};
// -------------------------------------------------------------------

class WSaveTypeInfo : public ::google::protobuf::Message {
 public:
  WSaveTypeInfo();
  virtual ~WSaveTypeInfo();

  WSaveTypeInfo(const WSaveTypeInfo& from);

  inline WSaveTypeInfo& operator=(const WSaveTypeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WSaveTypeInfo& default_instance();

  void Swap(WSaveTypeInfo* other);

  // implements Message ----------------------------------------------

  WSaveTypeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WSaveTypeInfo& from);
  void MergeFrom(const WSaveTypeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint64 type() const;
  inline void set_type(::google::protobuf::uint64 value);

  // required int64 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // required bool isdel = 3;
  inline bool has_isdel() const;
  inline void clear_isdel();
  static const int kIsdelFieldNumber = 3;
  inline bool isdel() const;
  inline void set_isdel(bool value);

  // optional .PlayerInfo.FriendInfoList friendInfo = 4;
  inline bool has_friendinfo() const;
  inline void clear_friendinfo();
  static const int kFriendInfoFieldNumber = 4;
  inline const ::PlayerInfo::FriendInfoList& friendinfo() const;
  inline ::PlayerInfo::FriendInfoList* mutable_friendinfo();
  inline ::PlayerInfo::FriendInfoList* release_friendinfo();
  inline void set_allocated_friendinfo(::PlayerInfo::FriendInfoList* friendinfo);

  // @@protoc_insertion_point(class_scope:PlayerInfo.WSaveTypeInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_isdel();
  inline void clear_has_isdel();
  inline void set_has_friendinfo();
  inline void clear_has_friendinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 type_;
  ::google::protobuf::int64 id_;
  ::PlayerInfo::FriendInfoList* friendinfo_;
  bool isdel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static WSaveTypeInfo* default_instance_;
};
// -------------------------------------------------------------------

class BaseInfo : public ::google::protobuf::Message {
 public:
  BaseInfo();
  virtual ~BaseInfo();

  BaseInfo(const BaseInfo& from);

  inline BaseInfo& operator=(const BaseInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseInfo& default_instance();

  void Swap(BaseInfo* other);

  // implements Message ----------------------------------------------

  BaseInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BaseInfo& from);
  void MergeFrom(const BaseInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // required string charname = 2;
  inline bool has_charname() const;
  inline void clear_charname();
  static const int kCharnameFieldNumber = 2;
  inline const ::std::string& charname() const;
  inline void set_charname(const ::std::string& value);
  inline void set_charname(const char* value);
  inline void set_charname(const char* value, size_t size);
  inline ::std::string* mutable_charname();
  inline ::std::string* release_charname();
  inline void set_allocated_charname(::std::string* charname);

  // required int64 exp = 3;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 3;
  inline ::google::protobuf::int64 exp() const;
  inline void set_exp(::google::protobuf::int64 value);

  // required int32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required int32 money = 5;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 5;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // required int32 golden = 6;
  inline bool has_golden() const;
  inline void clear_golden();
  static const int kGoldenFieldNumber = 6;
  inline ::google::protobuf::int32 golden() const;
  inline void set_golden(::google::protobuf::int32 value);

  // required int32 bindgolden = 7;
  inline bool has_bindgolden() const;
  inline void clear_bindgolden();
  static const int kBindgoldenFieldNumber = 7;
  inline ::google::protobuf::int32 bindgolden() const;
  inline void set_bindgolden(::google::protobuf::int32 value);

  // required int64 deadtime = 8;
  inline bool has_deadtime() const;
  inline void clear_deadtime();
  static const int kDeadtimeFieldNumber = 8;
  inline ::google::protobuf::int64 deadtime() const;
  inline void set_deadtime(::google::protobuf::int64 value);

  // required bool sex = 9;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 9;
  inline bool sex() const;
  inline void set_sex(bool value);

  // required int32 profession = 10;
  inline bool has_profession() const;
  inline void clear_profession();
  static const int kProfessionFieldNumber = 10;
  inline ::google::protobuf::int32 profession() const;
  inline void set_profession(::google::protobuf::int32 value);

  // required int32 xpos = 11;
  inline bool has_xpos() const;
  inline void clear_xpos();
  static const int kXposFieldNumber = 11;
  inline ::google::protobuf::int32 xpos() const;
  inline void set_xpos(::google::protobuf::int32 value);

  // required int32 ypos = 12;
  inline bool has_ypos() const;
  inline void clear_ypos();
  static const int kYposFieldNumber = 12;
  inline ::google::protobuf::int32 ypos() const;
  inline void set_ypos(::google::protobuf::int32 value);

  // required int32 horse = 13;
  inline bool has_horse() const;
  inline void clear_horse();
  static const int kHorseFieldNumber = 13;
  inline ::google::protobuf::int32 horse() const;
  inline void set_horse(::google::protobuf::int32 value);

  // required int64 mapid = 14;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapidFieldNumber = 14;
  inline ::google::protobuf::int64 mapid() const;
  inline void set_mapid(::google::protobuf::int64 value);

  // required int32 country = 15;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 15;
  inline ::google::protobuf::int32 country() const;
  inline void set_country(::google::protobuf::int32 value);

  // required int32 charhead = 16;
  inline bool has_charhead() const;
  inline void clear_charhead();
  static const int kCharheadFieldNumber = 16;
  inline ::google::protobuf::int32 charhead() const;
  inline void set_charhead(::google::protobuf::int32 value);

  // optional int32 facontribution = 17;
  inline bool has_facontribution() const;
  inline void clear_facontribution();
  static const int kFacontributionFieldNumber = 17;
  inline ::google::protobuf::int32 facontribution() const;
  inline void set_facontribution(::google::protobuf::int32 value);

  // optional int32 faction = 18;
  inline bool has_faction() const;
  inline void clear_faction();
  static const int kFactionFieldNumber = 18;
  inline ::google::protobuf::int32 faction() const;
  inline void set_faction(::google::protobuf::int32 value);

  // optional int32 fajob = 19;
  inline bool has_fajob() const;
  inline void clear_fajob();
  static const int kFajobFieldNumber = 19;
  inline ::google::protobuf::int32 fajob() const;
  inline void set_fajob(::google::protobuf::int32 value);

  // required int64 mate = 20;
  inline bool has_mate() const;
  inline void clear_mate();
  static const int kMateFieldNumber = 20;
  inline ::google::protobuf::int64 mate() const;
  inline void set_mate(::google::protobuf::int64 value);

  // required int32 countryjob = 21;
  inline bool has_countryjob() const;
  inline void clear_countryjob();
  static const int kCountryjobFieldNumber = 21;
  inline ::google::protobuf::int32 countryjob() const;
  inline void set_countryjob(::google::protobuf::int32 value);

  // required int32 battlecontri = 22;
  inline bool has_battlecontri() const;
  inline void clear_battlecontri();
  static const int kBattlecontriFieldNumber = 22;
  inline ::google::protobuf::int32 battlecontri() const;
  inline void set_battlecontri(::google::protobuf::int32 value);

  // required int32 armyjob = 23;
  inline bool has_armyjob() const;
  inline void clear_armyjob();
  static const int kArmyjobFieldNumber = 23;
  inline ::google::protobuf::int32 armyjob() const;
  inline void set_armyjob(::google::protobuf::int32 value);

  // optional int32 countrycontri = 24;
  inline bool has_countrycontri() const;
  inline void clear_countrycontri();
  static const int kCountrycontriFieldNumber = 24;
  inline ::google::protobuf::int32 countrycontri() const;
  inline void set_countrycontri(::google::protobuf::int32 value);

  // optional int32 titleid = 25;
  inline bool has_titleid() const;
  inline void clear_titleid();
  static const int kTitleidFieldNumber = 25;
  inline ::google::protobuf::int32 titleid() const;
  inline void set_titleid(::google::protobuf::int32 value);

  // required int32 accounttype = 26;
  inline bool has_accounttype() const;
  inline void clear_accounttype();
  static const int kAccounttypeFieldNumber = 26;
  inline ::google::protobuf::int32 accounttype() const;
  inline void set_accounttype(::google::protobuf::int32 value);

  // required string openid = 27;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 27;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // required int32 serverid = 28;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServeridFieldNumber = 28;
  inline ::google::protobuf::int32 serverid() const;
  inline void set_serverid(::google::protobuf::int32 value);

  // required int32 sinvalue = 29;
  inline bool has_sinvalue() const;
  inline void clear_sinvalue();
  static const int kSinvalueFieldNumber = 29;
  inline ::google::protobuf::int32 sinvalue() const;
  inline void set_sinvalue(::google::protobuf::int32 value);

  // required int32 acupoint = 30;
  inline bool has_acupoint() const;
  inline void clear_acupoint();
  static const int kAcupointFieldNumber = 30;
  inline ::google::protobuf::int32 acupoint() const;
  inline void set_acupoint(::google::protobuf::int32 value);

  // required int32 settings = 31;
  inline bool has_settings() const;
  inline void clear_settings();
  static const int kSettingsFieldNumber = 31;
  inline ::google::protobuf::int32 settings() const;
  inline void set_settings(::google::protobuf::int32 value);

  // required int64 havetodo = 32;
  inline bool has_havetodo() const;
  inline void clear_havetodo();
  static const int kHavetodoFieldNumber = 32;
  inline ::google::protobuf::int64 havetodo() const;
  inline void set_havetodo(::google::protobuf::int64 value);

  // required int32 havetodoaward = 33;
  inline bool has_havetodoaward() const;
  inline void clear_havetodoaward();
  static const int kHavetodoawardFieldNumber = 33;
  inline ::google::protobuf::int32 havetodoaward() const;
  inline void set_havetodoaward(::google::protobuf::int32 value);

  // required int32 activites = 34;
  inline bool has_activites() const;
  inline void clear_activites();
  static const int kActivitesFieldNumber = 34;
  inline ::google::protobuf::int32 activites() const;
  inline void set_activites(::google::protobuf::int32 value);

  // required int32 activitesaward = 35;
  inline bool has_activitesaward() const;
  inline void clear_activitesaward();
  static const int kActivitesawardFieldNumber = 35;
  inline ::google::protobuf::int32 activitesaward() const;
  inline void set_activitesaward(::google::protobuf::int32 value);

  // required int64 offlineTime = 36;
  inline bool has_offlinetime() const;
  inline void clear_offlinetime();
  static const int kOfflineTimeFieldNumber = 36;
  inline ::google::protobuf::int64 offlinetime() const;
  inline void set_offlinetime(::google::protobuf::int64 value);

  // required int32 onlineReward = 37;
  inline bool has_onlinereward() const;
  inline void clear_onlinereward();
  static const int kOnlineRewardFieldNumber = 37;
  inline ::google::protobuf::int32 onlinereward() const;
  inline void set_onlinereward(::google::protobuf::int32 value);

  // required int64 onlineTime = 38;
  inline bool has_onlinetime() const;
  inline void clear_onlinetime();
  static const int kOnlineTimeFieldNumber = 38;
  inline ::google::protobuf::int64 onlinetime() const;
  inline void set_onlinetime(::google::protobuf::int64 value);

  // required int32 levelReward = 39;
  inline bool has_levelreward() const;
  inline void clear_levelreward();
  static const int kLevelRewardFieldNumber = 39;
  inline ::google::protobuf::int32 levelreward() const;
  inline void set_levelreward(::google::protobuf::int32 value);

  // required int32 prestige = 40;
  inline bool has_prestige() const;
  inline void clear_prestige();
  static const int kPrestigeFieldNumber = 40;
  inline ::google::protobuf::int32 prestige() const;
  inline void set_prestige(::google::protobuf::int32 value);

  // required int32 historyReward = 41;
  inline bool has_historyreward() const;
  inline void clear_historyreward();
  static const int kHistoryRewardFieldNumber = 41;
  inline ::google::protobuf::int32 historyreward() const;
  inline void set_historyreward(::google::protobuf::int32 value);

  // required int32 viplv = 42;
  inline bool has_viplv() const;
  inline void clear_viplv();
  static const int kViplvFieldNumber = 42;
  inline ::google::protobuf::int32 viplv() const;
  inline void set_viplv(::google::protobuf::int32 value);

  // required int32 continueanswer = 43;
  inline bool has_continueanswer() const;
  inline void clear_continueanswer();
  static const int kContinueanswerFieldNumber = 43;
  inline ::google::protobuf::int32 continueanswer() const;
  inline void set_continueanswer(::google::protobuf::int32 value);

  // required int32 rightanswer = 44;
  inline bool has_rightanswer() const;
  inline void clear_rightanswer();
  static const int kRightanswerFieldNumber = 44;
  inline ::google::protobuf::int32 rightanswer() const;
  inline void set_rightanswer(::google::protobuf::int32 value);

  // required int32 addupgolde = 45;
  inline bool has_addupgolde() const;
  inline void clear_addupgolde();
  static const int kAddupgoldeFieldNumber = 45;
  inline ::google::protobuf::int32 addupgolde() const;
  inline void set_addupgolde(::google::protobuf::int32 value);

  // optional string clanname = 46;
  inline bool has_clanname() const;
  inline void clear_clanname();
  static const int kClannameFieldNumber = 46;
  inline const ::std::string& clanname() const;
  inline void set_clanname(const ::std::string& value);
  inline void set_clanname(const char* value);
  inline void set_clanname(const char* value, size_t size);
  inline ::std::string* mutable_clanname();
  inline ::std::string* release_clanname();
  inline void set_allocated_clanname(::std::string* clanname);

  // optional int32 ranking = 47;
  inline bool has_ranking() const;
  inline void clear_ranking();
  static const int kRankingFieldNumber = 47;
  inline ::google::protobuf::int32 ranking() const;
  inline void set_ranking(::google::protobuf::int32 value);

  // optional int32 awardranking = 48;
  inline bool has_awardranking() const;
  inline void clear_awardranking();
  static const int kAwardrankingFieldNumber = 48;
  inline ::google::protobuf::int32 awardranking() const;
  inline void set_awardranking(::google::protobuf::int32 value);

  // optional int32 AntiAddictionState = 49;
  inline bool has_antiaddictionstate() const;
  inline void clear_antiaddictionstate();
  static const int kAntiAddictionStateFieldNumber = 49;
  inline ::google::protobuf::int32 antiaddictionstate() const;
  inline void set_antiaddictionstate(::google::protobuf::int32 value);

  // optional int32 AntiAddictionOnLineTime = 50;
  inline bool has_antiaddictiononlinetime() const;
  inline void clear_antiaddictiononlinetime();
  static const int kAntiAddictionOnLineTimeFieldNumber = 50;
  inline ::google::protobuf::int32 antiaddictiononlinetime() const;
  inline void set_antiaddictiononlinetime(::google::protobuf::int32 value);

  // optional int64 totalOnlineTime = 51;
  inline bool has_totalonlinetime() const;
  inline void clear_totalonlinetime();
  static const int kTotalOnlineTimeFieldNumber = 51;
  inline ::google::protobuf::int64 totalonlinetime() const;
  inline void set_totalonlinetime(::google::protobuf::int64 value);

  // optional int64 NextTalkTime = 52;
  inline bool has_nexttalktime() const;
  inline void clear_nexttalktime();
  static const int kNextTalkTimeFieldNumber = 52;
  inline ::google::protobuf::int64 nexttalktime() const;
  inline void set_nexttalktime(::google::protobuf::int64 value);

  // optional int32 treasonkingReward = 53;
  inline bool has_treasonkingreward() const;
  inline void clear_treasonkingreward();
  static const int kTreasonkingRewardFieldNumber = 53;
  inline ::google::protobuf::int32 treasonkingreward() const;
  inline void set_treasonkingreward(::google::protobuf::int32 value);

  // optional int32 practiceTime = 54;
  inline bool has_practicetime() const;
  inline void clear_practicetime();
  static const int kPracticeTimeFieldNumber = 54;
  inline ::google::protobuf::int32 practicetime() const;
  inline void set_practicetime(::google::protobuf::int32 value);

  // optional int32 score = 55;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 55;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // optional int32 pkType = 56;
  inline bool has_pktype() const;
  inline void clear_pktype();
  static const int kPkTypeFieldNumber = 56;
  inline ::google::protobuf::int32 pktype() const;
  inline void set_pktype(::google::protobuf::int32 value);

  // optional int32 clanicon = 57;
  inline bool has_clanicon() const;
  inline void clear_clanicon();
  static const int kClaniconFieldNumber = 57;
  inline ::google::protobuf::int32 clanicon() const;
  inline void set_clanicon(::google::protobuf::int32 value);

  // optional bytes loginIP = 58;
  inline bool has_loginip() const;
  inline void clear_loginip();
  static const int kLoginIPFieldNumber = 58;
  inline const ::std::string& loginip() const;
  inline void set_loginip(const ::std::string& value);
  inline void set_loginip(const char* value);
  inline void set_loginip(const void* value, size_t size);
  inline ::std::string* mutable_loginip();
  inline ::std::string* release_loginip();
  inline void set_allocated_loginip(::std::string* loginip);

  // optional int64 teamid = 59;
  inline bool has_teamid() const;
  inline void clear_teamid();
  static const int kTeamidFieldNumber = 59;
  inline ::google::protobuf::int64 teamid() const;
  inline void set_teamid(::google::protobuf::int64 value);

  // optional int32 fashionID = 60;
  inline bool has_fashionid() const;
  inline void clear_fashionid();
  static const int kFashionIDFieldNumber = 60;
  inline ::google::protobuf::int32 fashionid() const;
  inline void set_fashionid(::google::protobuf::int32 value);

  // optional int32 antiAddictionAddTime = 61;
  inline bool has_antiaddictionaddtime() const;
  inline void clear_antiaddictionaddtime();
  static const int kAntiAddictionAddTimeFieldNumber = 61;
  inline ::google::protobuf::int32 antiaddictionaddtime() const;
  inline void set_antiaddictionaddtime(::google::protobuf::int32 value);

  // optional int64 couple = 62;
  inline bool has_couple() const;
  inline void clear_couple();
  static const int kCoupleFieldNumber = 62;
  inline ::google::protobuf::int64 couple() const;
  inline void set_couple(::google::protobuf::int64 value);

  // optional int32 power = 63;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 63;
  inline ::google::protobuf::int32 power() const;
  inline void set_power(::google::protobuf::int32 value);

  // optional int32 fitch = 64;
  inline bool has_fitch() const;
  inline void clear_fitch();
  static const int kFitchFieldNumber = 64;
  inline ::google::protobuf::int32 fitch() const;
  inline void set_fitch(::google::protobuf::int32 value);

  // optional int32 weekContribute = 65;
  inline bool has_weekcontribute() const;
  inline void clear_weekcontribute();
  static const int kWeekContributeFieldNumber = 65;
  inline ::google::protobuf::int32 weekcontribute() const;
  inline void set_weekcontribute(::google::protobuf::int32 value);

  // optional int32 curContribute = 66;
  inline bool has_curcontribute() const;
  inline void clear_curcontribute();
  static const int kCurContributeFieldNumber = 66;
  inline ::google::protobuf::int32 curcontribute() const;
  inline void set_curcontribute(::google::protobuf::int32 value);

  // optional int32 KingRankFlag = 67;
  inline bool has_kingrankflag() const;
  inline void clear_kingrankflag();
  static const int kKingRankFlagFieldNumber = 67;
  inline ::google::protobuf::int32 kingrankflag() const;
  inline void set_kingrankflag(::google::protobuf::int32 value);

  // optional int32 credit = 68;
  inline bool has_credit() const;
  inline void clear_credit();
  static const int kCreditFieldNumber = 68;
  inline ::google::protobuf::int32 credit() const;
  inline void set_credit(::google::protobuf::int32 value);

  // optional int32 envelopeCount = 69;
  inline bool has_envelopecount() const;
  inline void clear_envelopecount();
  static const int kEnvelopeCountFieldNumber = 69;
  inline ::google::protobuf::int32 envelopecount() const;
  inline void set_envelopecount(::google::protobuf::int32 value);

  // optional int32 maxCanGetEnvelopeCount = 70;
  inline bool has_maxcangetenvelopecount() const;
  inline void clear_maxcangetenvelopecount();
  static const int kMaxCanGetEnvelopeCountFieldNumber = 70;
  inline ::google::protobuf::int32 maxcangetenvelopecount() const;
  inline void set_maxcangetenvelopecount(::google::protobuf::int32 value);

  // optional uint64 attributeClearTime = 71;
  inline bool has_attributecleartime() const;
  inline void clear_attributecleartime();
  static const int kAttributeClearTimeFieldNumber = 71;
  inline ::google::protobuf::uint64 attributecleartime() const;
  inline void set_attributecleartime(::google::protobuf::uint64 value);

  // optional int32 goldenCost = 72;
  inline bool has_goldencost() const;
  inline void clear_goldencost();
  static const int kGoldenCostFieldNumber = 72;
  inline ::google::protobuf::int32 goldencost() const;
  inline void set_goldencost(::google::protobuf::int32 value);

  // optional string openKey = 73;
  inline bool has_openkey() const;
  inline void clear_openkey();
  static const int kOpenKeyFieldNumber = 73;
  inline const ::std::string& openkey() const;
  inline void set_openkey(const ::std::string& value);
  inline void set_openkey(const char* value);
  inline void set_openkey(const char* value, size_t size);
  inline ::std::string* mutable_openkey();
  inline ::std::string* release_openkey();
  inline void set_allocated_openkey(::std::string* openkey);

  // optional string pf = 74;
  inline bool has_pf() const;
  inline void clear_pf();
  static const int kPfFieldNumber = 74;
  inline const ::std::string& pf() const;
  inline void set_pf(const ::std::string& value);
  inline void set_pf(const char* value);
  inline void set_pf(const char* value, size_t size);
  inline ::std::string* mutable_pf();
  inline ::std::string* release_pf();
  inline void set_allocated_pf(::std::string* pf);

  // optional string pfKey = 75;
  inline bool has_pfkey() const;
  inline void clear_pfkey();
  static const int kPfKeyFieldNumber = 75;
  inline const ::std::string& pfkey() const;
  inline void set_pfkey(const ::std::string& value);
  inline void set_pfkey(const char* value);
  inline void set_pfkey(const char* value, size_t size);
  inline ::std::string* mutable_pfkey();
  inline ::std::string* release_pfkey();
  inline void set_allocated_pfkey(::std::string* pfkey);

  // optional string couplename = 76;
  inline bool has_couplename() const;
  inline void clear_couplename();
  static const int kCouplenameFieldNumber = 76;
  inline const ::std::string& couplename() const;
  inline void set_couplename(const ::std::string& value);
  inline void set_couplename(const char* value);
  inline void set_couplename(const char* value, size_t size);
  inline ::std::string* mutable_couplename();
  inline ::std::string* release_couplename();
  inline void set_allocated_couplename(::std::string* couplename);

  // optional int32 mgicweaponPower = 77;
  inline bool has_mgicweaponpower() const;
  inline void clear_mgicweaponpower();
  static const int kMgicweaponPowerFieldNumber = 77;
  inline ::google::protobuf::int32 mgicweaponpower() const;
  inline void set_mgicweaponpower(::google::protobuf::int32 value);

  // optional int32 gourdExp = 78;
  inline bool has_gourdexp() const;
  inline void clear_gourdexp();
  static const int kGourdExpFieldNumber = 78;
  inline ::google::protobuf::int32 gourdexp() const;
  inline void set_gourdexp(::google::protobuf::int32 value);

  // optional int32 pvpflag = 79;
  inline bool has_pvpflag() const;
  inline void clear_pvpflag();
  static const int kPvpflagFieldNumber = 79;
  inline ::google::protobuf::int32 pvpflag() const;
  inline void set_pvpflag(::google::protobuf::int32 value);

  // optional int32 clientType = 80;
  inline bool has_clienttype() const;
  inline void clear_clienttype();
  static const int kClientTypeFieldNumber = 80;
  inline ::google::protobuf::int32 clienttype() const;
  inline void set_clienttype(::google::protobuf::int32 value);

  // optional int32 guide = 81;
  inline bool has_guide() const;
  inline void clear_guide();
  static const int kGuideFieldNumber = 81;
  inline ::google::protobuf::int32 guide() const;
  inline void set_guide(::google::protobuf::int32 value);

  // optional string source = 82;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 82;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  inline void set_allocated_source(::std::string* source);

  // optional int64 rechargetime = 83;
  inline bool has_rechargetime() const;
  inline void clear_rechargetime();
  static const int kRechargetimeFieldNumber = 83;
  inline ::google::protobuf::int64 rechargetime() const;
  inline void set_rechargetime(::google::protobuf::int64 value);

  // optional int64 challengemoney = 84;
  inline bool has_challengemoney() const;
  inline void clear_challengemoney();
  static const int kChallengemoneyFieldNumber = 84;
  inline ::google::protobuf::int64 challengemoney() const;
  inline void set_challengemoney(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.BaseInfo)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_charname();
  inline void clear_has_charname();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_golden();
  inline void clear_has_golden();
  inline void set_has_bindgolden();
  inline void clear_has_bindgolden();
  inline void set_has_deadtime();
  inline void clear_has_deadtime();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_profession();
  inline void clear_has_profession();
  inline void set_has_xpos();
  inline void clear_has_xpos();
  inline void set_has_ypos();
  inline void clear_has_ypos();
  inline void set_has_horse();
  inline void clear_has_horse();
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_charhead();
  inline void clear_has_charhead();
  inline void set_has_facontribution();
  inline void clear_has_facontribution();
  inline void set_has_faction();
  inline void clear_has_faction();
  inline void set_has_fajob();
  inline void clear_has_fajob();
  inline void set_has_mate();
  inline void clear_has_mate();
  inline void set_has_countryjob();
  inline void clear_has_countryjob();
  inline void set_has_battlecontri();
  inline void clear_has_battlecontri();
  inline void set_has_armyjob();
  inline void clear_has_armyjob();
  inline void set_has_countrycontri();
  inline void clear_has_countrycontri();
  inline void set_has_titleid();
  inline void clear_has_titleid();
  inline void set_has_accounttype();
  inline void clear_has_accounttype();
  inline void set_has_openid();
  inline void clear_has_openid();
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_sinvalue();
  inline void clear_has_sinvalue();
  inline void set_has_acupoint();
  inline void clear_has_acupoint();
  inline void set_has_settings();
  inline void clear_has_settings();
  inline void set_has_havetodo();
  inline void clear_has_havetodo();
  inline void set_has_havetodoaward();
  inline void clear_has_havetodoaward();
  inline void set_has_activites();
  inline void clear_has_activites();
  inline void set_has_activitesaward();
  inline void clear_has_activitesaward();
  inline void set_has_offlinetime();
  inline void clear_has_offlinetime();
  inline void set_has_onlinereward();
  inline void clear_has_onlinereward();
  inline void set_has_onlinetime();
  inline void clear_has_onlinetime();
  inline void set_has_levelreward();
  inline void clear_has_levelreward();
  inline void set_has_prestige();
  inline void clear_has_prestige();
  inline void set_has_historyreward();
  inline void clear_has_historyreward();
  inline void set_has_viplv();
  inline void clear_has_viplv();
  inline void set_has_continueanswer();
  inline void clear_has_continueanswer();
  inline void set_has_rightanswer();
  inline void clear_has_rightanswer();
  inline void set_has_addupgolde();
  inline void clear_has_addupgolde();
  inline void set_has_clanname();
  inline void clear_has_clanname();
  inline void set_has_ranking();
  inline void clear_has_ranking();
  inline void set_has_awardranking();
  inline void clear_has_awardranking();
  inline void set_has_antiaddictionstate();
  inline void clear_has_antiaddictionstate();
  inline void set_has_antiaddictiononlinetime();
  inline void clear_has_antiaddictiononlinetime();
  inline void set_has_totalonlinetime();
  inline void clear_has_totalonlinetime();
  inline void set_has_nexttalktime();
  inline void clear_has_nexttalktime();
  inline void set_has_treasonkingreward();
  inline void clear_has_treasonkingreward();
  inline void set_has_practicetime();
  inline void clear_has_practicetime();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_pktype();
  inline void clear_has_pktype();
  inline void set_has_clanicon();
  inline void clear_has_clanicon();
  inline void set_has_loginip();
  inline void clear_has_loginip();
  inline void set_has_teamid();
  inline void clear_has_teamid();
  inline void set_has_fashionid();
  inline void clear_has_fashionid();
  inline void set_has_antiaddictionaddtime();
  inline void clear_has_antiaddictionaddtime();
  inline void set_has_couple();
  inline void clear_has_couple();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_fitch();
  inline void clear_has_fitch();
  inline void set_has_weekcontribute();
  inline void clear_has_weekcontribute();
  inline void set_has_curcontribute();
  inline void clear_has_curcontribute();
  inline void set_has_kingrankflag();
  inline void clear_has_kingrankflag();
  inline void set_has_credit();
  inline void clear_has_credit();
  inline void set_has_envelopecount();
  inline void clear_has_envelopecount();
  inline void set_has_maxcangetenvelopecount();
  inline void clear_has_maxcangetenvelopecount();
  inline void set_has_attributecleartime();
  inline void clear_has_attributecleartime();
  inline void set_has_goldencost();
  inline void clear_has_goldencost();
  inline void set_has_openkey();
  inline void clear_has_openkey();
  inline void set_has_pf();
  inline void clear_has_pf();
  inline void set_has_pfkey();
  inline void clear_has_pfkey();
  inline void set_has_couplename();
  inline void clear_has_couplename();
  inline void set_has_mgicweaponpower();
  inline void clear_has_mgicweaponpower();
  inline void set_has_gourdexp();
  inline void clear_has_gourdexp();
  inline void set_has_pvpflag();
  inline void clear_has_pvpflag();
  inline void set_has_clienttype();
  inline void clear_has_clienttype();
  inline void set_has_guide();
  inline void clear_has_guide();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_rechargetime();
  inline void clear_has_rechargetime();
  inline void set_has_challengemoney();
  inline void clear_has_challengemoney();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::std::string* charname_;
  ::google::protobuf::int64 exp_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 golden_;
  ::google::protobuf::int32 bindgolden_;
  ::google::protobuf::int64 deadtime_;
  bool sex_;
  ::google::protobuf::int32 profession_;
  ::google::protobuf::int32 xpos_;
  ::google::protobuf::int32 ypos_;
  ::google::protobuf::int32 horse_;
  ::google::protobuf::int32 country_;
  ::google::protobuf::int64 mapid_;
  ::google::protobuf::int32 charhead_;
  ::google::protobuf::int32 facontribution_;
  ::google::protobuf::int32 faction_;
  ::google::protobuf::int32 fajob_;
  ::google::protobuf::int64 mate_;
  ::google::protobuf::int32 countryjob_;
  ::google::protobuf::int32 battlecontri_;
  ::google::protobuf::int32 armyjob_;
  ::google::protobuf::int32 countrycontri_;
  ::google::protobuf::int32 titleid_;
  ::google::protobuf::int32 accounttype_;
  ::std::string* openid_;
  ::google::protobuf::int32 serverid_;
  ::google::protobuf::int32 sinvalue_;
  ::google::protobuf::int32 acupoint_;
  ::google::protobuf::int32 settings_;
  ::google::protobuf::int64 havetodo_;
  ::google::protobuf::int32 havetodoaward_;
  ::google::protobuf::int32 activites_;
  ::google::protobuf::int32 activitesaward_;
  ::google::protobuf::int32 onlinereward_;
  ::google::protobuf::int64 offlinetime_;
  ::google::protobuf::int64 onlinetime_;
  ::google::protobuf::int32 levelreward_;
  ::google::protobuf::int32 prestige_;
  ::google::protobuf::int32 historyreward_;
  ::google::protobuf::int32 viplv_;
  ::google::protobuf::int32 continueanswer_;
  ::google::protobuf::int32 rightanswer_;
  ::google::protobuf::int32 addupgolde_;
  ::google::protobuf::int32 ranking_;
  ::std::string* clanname_;
  ::google::protobuf::int32 awardranking_;
  ::google::protobuf::int32 antiaddictionstate_;
  ::google::protobuf::int64 totalonlinetime_;
  ::google::protobuf::int32 antiaddictiononlinetime_;
  ::google::protobuf::int32 treasonkingreward_;
  ::google::protobuf::int64 nexttalktime_;
  ::google::protobuf::int32 practicetime_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 pktype_;
  ::google::protobuf::int32 clanicon_;
  ::std::string* loginip_;
  ::google::protobuf::int64 teamid_;
  ::google::protobuf::int32 fashionid_;
  ::google::protobuf::int32 antiaddictionaddtime_;
  ::google::protobuf::int64 couple_;
  ::google::protobuf::int32 power_;
  ::google::protobuf::int32 fitch_;
  ::google::protobuf::int32 weekcontribute_;
  ::google::protobuf::int32 curcontribute_;
  ::google::protobuf::int32 kingrankflag_;
  ::google::protobuf::int32 credit_;
  ::google::protobuf::int32 envelopecount_;
  ::google::protobuf::int32 maxcangetenvelopecount_;
  ::google::protobuf::uint64 attributecleartime_;
  ::std::string* openkey_;
  ::std::string* pf_;
  ::google::protobuf::int32 goldencost_;
  ::google::protobuf::int32 mgicweaponpower_;
  ::std::string* pfkey_;
  ::std::string* couplename_;
  ::google::protobuf::int32 gourdexp_;
  ::google::protobuf::int32 pvpflag_;
  ::google::protobuf::int32 clienttype_;
  ::google::protobuf::int32 guide_;
  ::std::string* source_;
  ::google::protobuf::int64 rechargetime_;
  ::google::protobuf::int64 challengemoney_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(84 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static BaseInfo* default_instance_;
};
// -------------------------------------------------------------------

class BattleInfo : public ::google::protobuf::Message {
 public:
  BattleInfo();
  virtual ~BattleInfo();

  BattleInfo(const BattleInfo& from);

  inline BattleInfo& operator=(const BattleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleInfo& default_instance();

  void Swap(BattleInfo* other);

  // implements Message ----------------------------------------------

  BattleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleInfo& from);
  void MergeFrom(const BattleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 hp = 1;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 1;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // required int32 hpmax = 2;
  inline bool has_hpmax() const;
  inline void clear_hpmax();
  static const int kHpmaxFieldNumber = 2;
  inline ::google::protobuf::int32 hpmax() const;
  inline void set_hpmax(::google::protobuf::int32 value);

  // required int32 mp = 3;
  inline bool has_mp() const;
  inline void clear_mp();
  static const int kMpFieldNumber = 3;
  inline ::google::protobuf::int32 mp() const;
  inline void set_mp(::google::protobuf::int32 value);

  // required int32 mpmax = 4;
  inline bool has_mpmax() const;
  inline void clear_mpmax();
  static const int kMpmaxFieldNumber = 4;
  inline ::google::protobuf::int32 mpmax() const;
  inline void set_mpmax(::google::protobuf::int32 value);

  // required int32 force = 5;
  inline bool has_force() const;
  inline void clear_force();
  static const int kForceFieldNumber = 5;
  inline ::google::protobuf::int32 force() const;
  inline void set_force(::google::protobuf::int32 value);

  // required int32 forcemax = 6;
  inline bool has_forcemax() const;
  inline void clear_forcemax();
  static const int kForcemaxFieldNumber = 6;
  inline ::google::protobuf::int32 forcemax() const;
  inline void set_forcemax(::google::protobuf::int32 value);

  // required int32 strength = 7;
  inline bool has_strength() const;
  inline void clear_strength();
  static const int kStrengthFieldNumber = 7;
  inline ::google::protobuf::int32 strength() const;
  inline void set_strength(::google::protobuf::int32 value);

  // required int32 cleverpower = 8;
  inline bool has_cleverpower() const;
  inline void clear_cleverpower();
  static const int kCleverpowerFieldNumber = 8;
  inline ::google::protobuf::int32 cleverpower() const;
  inline void set_cleverpower(::google::protobuf::int32 value);

  // optional int32 cleverair = 9;
  inline bool has_cleverair() const;
  inline void clear_cleverair();
  static const int kCleverairFieldNumber = 9;
  inline ::google::protobuf::int32 cleverair() const;
  inline void set_cleverair(::google::protobuf::int32 value);

  // required int32 physicalpower = 10;
  inline bool has_physicalpower() const;
  inline void clear_physicalpower();
  static const int kPhysicalpowerFieldNumber = 10;
  inline ::google::protobuf::int32 physicalpower() const;
  inline void set_physicalpower(::google::protobuf::int32 value);

  // required int32 patience = 11;
  inline bool has_patience() const;
  inline void clear_patience();
  static const int kPatienceFieldNumber = 11;
  inline ::google::protobuf::int32 patience() const;
  inline void set_patience(::google::protobuf::int32 value);

  // required int32 agility = 12;
  inline bool has_agility() const;
  inline void clear_agility();
  static const int kAgilityFieldNumber = 12;
  inline ::google::protobuf::int32 agility() const;
  inline void set_agility(::google::protobuf::int32 value);

  // required int32 pkcount = 13;
  inline bool has_pkcount() const;
  inline void clear_pkcount();
  static const int kPkcountFieldNumber = 13;
  inline ::google::protobuf::int32 pkcount() const;
  inline void set_pkcount(::google::protobuf::int32 value);

  // optional int32 power = 14;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 14;
  inline ::google::protobuf::int32 power() const;
  inline void set_power(::google::protobuf::int32 value);

  // optional int32 powermax = 15;
  inline bool has_powermax() const;
  inline void clear_powermax();
  static const int kPowermaxFieldNumber = 15;
  inline ::google::protobuf::int32 powermax() const;
  inline void set_powermax(::google::protobuf::int32 value);

  // optional int32 phyattack = 16;
  inline bool has_phyattack() const;
  inline void clear_phyattack();
  static const int kPhyattackFieldNumber = 16;
  inline ::google::protobuf::int32 phyattack() const;
  inline void set_phyattack(::google::protobuf::int32 value);

  // required int32 phyattackmax = 17;
  inline bool has_phyattackmax() const;
  inline void clear_phyattackmax();
  static const int kPhyattackmaxFieldNumber = 17;
  inline ::google::protobuf::int32 phyattackmax() const;
  inline void set_phyattackmax(::google::protobuf::int32 value);

  // required int32 phydefence = 18;
  inline bool has_phydefence() const;
  inline void clear_phydefence();
  static const int kPhydefenceFieldNumber = 18;
  inline ::google::protobuf::int32 phydefence() const;
  inline void set_phydefence(::google::protobuf::int32 value);

  // optional int32 magicattack = 19;
  inline bool has_magicattack() const;
  inline void clear_magicattack();
  static const int kMagicattackFieldNumber = 19;
  inline ::google::protobuf::int32 magicattack() const;
  inline void set_magicattack(::google::protobuf::int32 value);

  // optional int32 magicattackmax = 20;
  inline bool has_magicattackmax() const;
  inline void clear_magicattackmax();
  static const int kMagicattackmaxFieldNumber = 20;
  inline ::google::protobuf::int32 magicattackmax() const;
  inline void set_magicattackmax(::google::protobuf::int32 value);

  // optional int32 magicdefence = 21;
  inline bool has_magicdefence() const;
  inline void clear_magicdefence();
  static const int kMagicdefenceFieldNumber = 21;
  inline ::google::protobuf::int32 magicdefence() const;
  inline void set_magicdefence(::google::protobuf::int32 value);

  // required int32 hitrate = 22;
  inline bool has_hitrate() const;
  inline void clear_hitrate();
  static const int kHitrateFieldNumber = 22;
  inline ::google::protobuf::int32 hitrate() const;
  inline void set_hitrate(::google::protobuf::int32 value);

  // required int32 avoidrate = 23;
  inline bool has_avoidrate() const;
  inline void clear_avoidrate();
  static const int kAvoidrateFieldNumber = 23;
  inline ::google::protobuf::int32 avoidrate() const;
  inline void set_avoidrate(::google::protobuf::int32 value);

  // optional int32 baselucky = 24;
  inline bool has_baselucky() const;
  inline void clear_baselucky();
  static const int kBaseluckyFieldNumber = 24;
  inline ::google::protobuf::int32 baselucky() const;
  inline void set_baselucky(::google::protobuf::int32 value);

  // required int32 crackdownrate = 25;
  inline bool has_crackdownrate() const;
  inline void clear_crackdownrate();
  static const int kCrackdownrateFieldNumber = 25;
  inline ::google::protobuf::int32 crackdownrate() const;
  inline void set_crackdownrate(::google::protobuf::int32 value);

  // required int32 baserte = 26;
  inline bool has_baserte() const;
  inline void clear_baserte();
  static const int kBaserteFieldNumber = 26;
  inline ::google::protobuf::int32 baserte() const;
  inline void set_baserte(::google::protobuf::int32 value);

  // required int32 movespeed = 27;
  inline bool has_movespeed() const;
  inline void clear_movespeed();
  static const int kMovespeedFieldNumber = 27;
  inline ::google::protobuf::int32 movespeed() const;
  inline void set_movespeed(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.BattleInfo)
 private:
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_hpmax();
  inline void clear_has_hpmax();
  inline void set_has_mp();
  inline void clear_has_mp();
  inline void set_has_mpmax();
  inline void clear_has_mpmax();
  inline void set_has_force();
  inline void clear_has_force();
  inline void set_has_forcemax();
  inline void clear_has_forcemax();
  inline void set_has_strength();
  inline void clear_has_strength();
  inline void set_has_cleverpower();
  inline void clear_has_cleverpower();
  inline void set_has_cleverair();
  inline void clear_has_cleverair();
  inline void set_has_physicalpower();
  inline void clear_has_physicalpower();
  inline void set_has_patience();
  inline void clear_has_patience();
  inline void set_has_agility();
  inline void clear_has_agility();
  inline void set_has_pkcount();
  inline void clear_has_pkcount();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_powermax();
  inline void clear_has_powermax();
  inline void set_has_phyattack();
  inline void clear_has_phyattack();
  inline void set_has_phyattackmax();
  inline void clear_has_phyattackmax();
  inline void set_has_phydefence();
  inline void clear_has_phydefence();
  inline void set_has_magicattack();
  inline void clear_has_magicattack();
  inline void set_has_magicattackmax();
  inline void clear_has_magicattackmax();
  inline void set_has_magicdefence();
  inline void clear_has_magicdefence();
  inline void set_has_hitrate();
  inline void clear_has_hitrate();
  inline void set_has_avoidrate();
  inline void clear_has_avoidrate();
  inline void set_has_baselucky();
  inline void clear_has_baselucky();
  inline void set_has_crackdownrate();
  inline void clear_has_crackdownrate();
  inline void set_has_baserte();
  inline void clear_has_baserte();
  inline void set_has_movespeed();
  inline void clear_has_movespeed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 hpmax_;
  ::google::protobuf::int32 mp_;
  ::google::protobuf::int32 mpmax_;
  ::google::protobuf::int32 force_;
  ::google::protobuf::int32 forcemax_;
  ::google::protobuf::int32 strength_;
  ::google::protobuf::int32 cleverpower_;
  ::google::protobuf::int32 cleverair_;
  ::google::protobuf::int32 physicalpower_;
  ::google::protobuf::int32 patience_;
  ::google::protobuf::int32 agility_;
  ::google::protobuf::int32 pkcount_;
  ::google::protobuf::int32 power_;
  ::google::protobuf::int32 powermax_;
  ::google::protobuf::int32 phyattack_;
  ::google::protobuf::int32 phyattackmax_;
  ::google::protobuf::int32 phydefence_;
  ::google::protobuf::int32 magicattack_;
  ::google::protobuf::int32 magicattackmax_;
  ::google::protobuf::int32 magicdefence_;
  ::google::protobuf::int32 hitrate_;
  ::google::protobuf::int32 avoidrate_;
  ::google::protobuf::int32 baselucky_;
  ::google::protobuf::int32 crackdownrate_;
  ::google::protobuf::int32 baserte_;
  ::google::protobuf::int32 movespeed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(27 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static BattleInfo* default_instance_;
};
// -------------------------------------------------------------------

class QuestInfo : public ::google::protobuf::Message {
 public:
  QuestInfo();
  virtual ~QuestInfo();

  QuestInfo(const QuestInfo& from);

  inline QuestInfo& operator=(const QuestInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuestInfo& default_instance();

  void Swap(QuestInfo* other);

  // implements Message ----------------------------------------------

  QuestInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuestInfo& from);
  void MergeFrom(const QuestInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.ActiveQuest active = 1;
  inline int active_size() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  inline const ::PlayerInfo::ActiveQuest& active(int index) const;
  inline ::PlayerInfo::ActiveQuest* mutable_active(int index);
  inline ::PlayerInfo::ActiveQuest* add_active();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ActiveQuest >&
      active() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ActiveQuest >*
      mutable_active();

  // repeated .PlayerInfo.DailyQuest daily = 2;
  inline int daily_size() const;
  inline void clear_daily();
  static const int kDailyFieldNumber = 2;
  inline const ::PlayerInfo::DailyQuest& daily(int index) const;
  inline ::PlayerInfo::DailyQuest* mutable_daily(int index);
  inline ::PlayerInfo::DailyQuest* add_daily();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DailyQuest >&
      daily() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DailyQuest >*
      mutable_daily();

  // repeated .PlayerInfo.ClanQuest clan = 3;
  inline int clan_size() const;
  inline void clear_clan();
  static const int kClanFieldNumber = 3;
  inline const ::PlayerInfo::ClanQuest& clan(int index) const;
  inline ::PlayerInfo::ClanQuest* mutable_clan(int index);
  inline ::PlayerInfo::ClanQuest* add_clan();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ClanQuest >&
      clan() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ClanQuest >*
      mutable_clan();

  // optional int32 doclantime = 4;
  inline bool has_doclantime() const;
  inline void clear_doclantime();
  static const int kDoclantimeFieldNumber = 4;
  inline ::google::protobuf::int32 doclantime() const;
  inline void set_doclantime(::google::protobuf::int32 value);

  // optional int32 dailytime = 5;
  inline bool has_dailytime() const;
  inline void clear_dailytime();
  static const int kDailytimeFieldNumber = 5;
  inline ::google::protobuf::int32 dailytime() const;
  inline void set_dailytime(::google::protobuf::int32 value);

  // repeated .PlayerInfo.DailyQuest yesterdaydaily = 6;
  inline int yesterdaydaily_size() const;
  inline void clear_yesterdaydaily();
  static const int kYesterdaydailyFieldNumber = 6;
  inline const ::PlayerInfo::DailyQuest& yesterdaydaily(int index) const;
  inline ::PlayerInfo::DailyQuest* mutable_yesterdaydaily(int index);
  inline ::PlayerInfo::DailyQuest* add_yesterdaydaily();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DailyQuest >&
      yesterdaydaily() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DailyQuest >*
      mutable_yesterdaydaily();

  // repeated .PlayerInfo.ClanQuest yesterdayclan = 7;
  inline int yesterdayclan_size() const;
  inline void clear_yesterdayclan();
  static const int kYesterdayclanFieldNumber = 7;
  inline const ::PlayerInfo::ClanQuest& yesterdayclan(int index) const;
  inline ::PlayerInfo::ClanQuest* mutable_yesterdayclan(int index);
  inline ::PlayerInfo::ClanQuest* add_yesterdayclan();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ClanQuest >&
      yesterdayclan() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ClanQuest >*
      mutable_yesterdayclan();

  // optional bool allMainTaskHadCompFlag = 8;
  inline bool has_allmaintaskhadcompflag() const;
  inline void clear_allmaintaskhadcompflag();
  static const int kAllMainTaskHadCompFlagFieldNumber = 8;
  inline bool allmaintaskhadcompflag() const;
  inline void set_allmaintaskhadcompflag(bool value);

  // repeated .PlayerInfo.CampQuest ccampQuest = 9;
  inline int ccampquest_size() const;
  inline void clear_ccampquest();
  static const int kCcampQuestFieldNumber = 9;
  inline const ::PlayerInfo::CampQuest& ccampquest(int index) const;
  inline ::PlayerInfo::CampQuest* mutable_ccampquest(int index);
  inline ::PlayerInfo::CampQuest* add_ccampquest();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::CampQuest >&
      ccampquest() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::CampQuest >*
      mutable_ccampquest();

  // optional int32 doCamptime = 10;
  inline bool has_docamptime() const;
  inline void clear_docamptime();
  static const int kDoCamptimeFieldNumber = 10;
  inline ::google::protobuf::int32 docamptime() const;
  inline void set_docamptime(::google::protobuf::int32 value);

  // optional uint32 questGuideID = 11;
  inline bool has_questguideid() const;
  inline void clear_questguideid();
  static const int kQuestGuideIDFieldNumber = 11;
  inline ::google::protobuf::uint32 questguideid() const;
  inline void set_questguideid(::google::protobuf::uint32 value);

  // optional .PlayerInfo.WeekQuest weekquest = 12;
  inline bool has_weekquest() const;
  inline void clear_weekquest();
  static const int kWeekquestFieldNumber = 12;
  inline const ::PlayerInfo::WeekQuest& weekquest() const;
  inline ::PlayerInfo::WeekQuest* mutable_weekquest();
  inline ::PlayerInfo::WeekQuest* release_weekquest();
  inline void set_allocated_weekquest(::PlayerInfo::WeekQuest* weekquest);

  // repeated .PlayerInfo.CampQuest yesterdaycamp = 13;
  inline int yesterdaycamp_size() const;
  inline void clear_yesterdaycamp();
  static const int kYesterdaycampFieldNumber = 13;
  inline const ::PlayerInfo::CampQuest& yesterdaycamp(int index) const;
  inline ::PlayerInfo::CampQuest* mutable_yesterdaycamp(int index);
  inline ::PlayerInfo::CampQuest* add_yesterdaycamp();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::CampQuest >&
      yesterdaycamp() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::CampQuest >*
      mutable_yesterdaycamp();

  // optional int32 yesterdayWeekTimes = 14;
  inline bool has_yesterdayweektimes() const;
  inline void clear_yesterdayweektimes();
  static const int kYesterdayWeekTimesFieldNumber = 14;
  inline ::google::protobuf::int32 yesterdayweektimes() const;
  inline void set_yesterdayweektimes(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.QuestInfo)
 private:
  inline void set_has_doclantime();
  inline void clear_has_doclantime();
  inline void set_has_dailytime();
  inline void clear_has_dailytime();
  inline void set_has_allmaintaskhadcompflag();
  inline void clear_has_allmaintaskhadcompflag();
  inline void set_has_docamptime();
  inline void clear_has_docamptime();
  inline void set_has_questguideid();
  inline void clear_has_questguideid();
  inline void set_has_weekquest();
  inline void clear_has_weekquest();
  inline void set_has_yesterdayweektimes();
  inline void clear_has_yesterdayweektimes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ActiveQuest > active_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DailyQuest > daily_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ClanQuest > clan_;
  ::google::protobuf::int32 doclantime_;
  ::google::protobuf::int32 dailytime_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DailyQuest > yesterdaydaily_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ClanQuest > yesterdayclan_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::CampQuest > ccampquest_;
  bool allmaintaskhadcompflag_;
  ::google::protobuf::int32 docamptime_;
  ::PlayerInfo::WeekQuest* weekquest_;
  ::google::protobuf::uint32 questguideid_;
  ::google::protobuf::int32 yesterdayweektimes_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::CampQuest > yesterdaycamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static QuestInfo* default_instance_;
};
// -------------------------------------------------------------------

class WeekQuestItem : public ::google::protobuf::Message {
 public:
  WeekQuestItem();
  virtual ~WeekQuestItem();

  WeekQuestItem(const WeekQuestItem& from);

  inline WeekQuestItem& operator=(const WeekQuestItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeekQuestItem& default_instance();

  void Swap(WeekQuestItem* other);

  // implements Message ----------------------------------------------

  WeekQuestItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeekQuestItem& from);
  void MergeFrom(const WeekQuestItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 itemID = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIDFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 counts = 2;
  inline bool has_counts() const;
  inline void clear_counts();
  static const int kCountsFieldNumber = 2;
  inline ::google::protobuf::int32 counts() const;
  inline void set_counts(::google::protobuf::int32 value);

  // optional int32 bindType = 3;
  inline bool has_bindtype() const;
  inline void clear_bindtype();
  static const int kBindTypeFieldNumber = 3;
  inline ::google::protobuf::int32 bindtype() const;
  inline void set_bindtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.WeekQuestItem)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_counts();
  inline void clear_has_counts();
  inline void set_has_bindtype();
  inline void clear_has_bindtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 counts_;
  ::google::protobuf::int32 bindtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static WeekQuestItem* default_instance_;
};
// -------------------------------------------------------------------

class WeekQuest : public ::google::protobuf::Message {
 public:
  WeekQuest();
  virtual ~WeekQuest();

  WeekQuest(const WeekQuest& from);

  inline WeekQuest& operator=(const WeekQuest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeekQuest& default_instance();

  void Swap(WeekQuest* other);

  // implements Message ----------------------------------------------

  WeekQuest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeekQuest& from);
  void MergeFrom(const WeekQuest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional int32 times = 2;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 2;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // repeated .PlayerInfo.WeekQuestItem rewardIDs = 3;
  inline int rewardids_size() const;
  inline void clear_rewardids();
  static const int kRewardIDsFieldNumber = 3;
  inline const ::PlayerInfo::WeekQuestItem& rewardids(int index) const;
  inline ::PlayerInfo::WeekQuestItem* mutable_rewardids(int index);
  inline ::PlayerInfo::WeekQuestItem* add_rewardids();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::WeekQuestItem >&
      rewardids() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::WeekQuestItem >*
      mutable_rewardids();

  // repeated .PlayerInfo.WeekQuestItem endrewardIDs = 4;
  inline int endrewardids_size() const;
  inline void clear_endrewardids();
  static const int kEndrewardIDsFieldNumber = 4;
  inline const ::PlayerInfo::WeekQuestItem& endrewardids(int index) const;
  inline ::PlayerInfo::WeekQuestItem* mutable_endrewardids(int index);
  inline ::PlayerInfo::WeekQuestItem* add_endrewardids();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::WeekQuestItem >&
      endrewardids() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::WeekQuestItem >*
      mutable_endrewardids();

  // @@protoc_insertion_point(class_scope:PlayerInfo.WeekQuest)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_times();
  inline void clear_has_times();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::WeekQuestItem > rewardids_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::WeekQuestItem > endrewardids_;
  ::google::protobuf::int32 times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static WeekQuest* default_instance_;
};
// -------------------------------------------------------------------

class NewQuestInfo : public ::google::protobuf::Message {
 public:
  NewQuestInfo();
  virtual ~NewQuestInfo();

  NewQuestInfo(const NewQuestInfo& from);

  inline NewQuestInfo& operator=(const NewQuestInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewQuestInfo& default_instance();

  void Swap(NewQuestInfo* other);

  // implements Message ----------------------------------------------

  NewQuestInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewQuestInfo& from);
  void MergeFrom(const NewQuestInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .PlayerInfo.ActiveQuest qActive = 1;
  inline bool has_qactive() const;
  inline void clear_qactive();
  static const int kQActiveFieldNumber = 1;
  inline const ::PlayerInfo::ActiveQuest& qactive() const;
  inline ::PlayerInfo::ActiveQuest* mutable_qactive();
  inline ::PlayerInfo::ActiveQuest* release_qactive();
  inline void set_allocated_qactive(::PlayerInfo::ActiveQuest* qactive);

  // optional .PlayerInfo.DailyQuest qDaily = 2;
  inline bool has_qdaily() const;
  inline void clear_qdaily();
  static const int kQDailyFieldNumber = 2;
  inline const ::PlayerInfo::DailyQuest& qdaily() const;
  inline ::PlayerInfo::DailyQuest* mutable_qdaily();
  inline ::PlayerInfo::DailyQuest* release_qdaily();
  inline void set_allocated_qdaily(::PlayerInfo::DailyQuest* qdaily);

  // optional .PlayerInfo.ClanQuest qClan = 3;
  inline bool has_qclan() const;
  inline void clear_qclan();
  static const int kQClanFieldNumber = 3;
  inline const ::PlayerInfo::ClanQuest& qclan() const;
  inline ::PlayerInfo::ClanQuest* mutable_qclan();
  inline ::PlayerInfo::ClanQuest* release_qclan();
  inline void set_allocated_qclan(::PlayerInfo::ClanQuest* qclan);

  // optional .PlayerInfo.DailyQuest yesterdaydaily = 4;
  inline bool has_yesterdaydaily() const;
  inline void clear_yesterdaydaily();
  static const int kYesterdaydailyFieldNumber = 4;
  inline const ::PlayerInfo::DailyQuest& yesterdaydaily() const;
  inline ::PlayerInfo::DailyQuest* mutable_yesterdaydaily();
  inline ::PlayerInfo::DailyQuest* release_yesterdaydaily();
  inline void set_allocated_yesterdaydaily(::PlayerInfo::DailyQuest* yesterdaydaily);

  // optional .PlayerInfo.ClanQuest yesterdayclan = 5;
  inline bool has_yesterdayclan() const;
  inline void clear_yesterdayclan();
  static const int kYesterdayclanFieldNumber = 5;
  inline const ::PlayerInfo::ClanQuest& yesterdayclan() const;
  inline ::PlayerInfo::ClanQuest* mutable_yesterdayclan();
  inline ::PlayerInfo::ClanQuest* release_yesterdayclan();
  inline void set_allocated_yesterdayclan(::PlayerInfo::ClanQuest* yesterdayclan);

  // @@protoc_insertion_point(class_scope:PlayerInfo.NewQuestInfo)
 private:
  inline void set_has_qactive();
  inline void clear_has_qactive();
  inline void set_has_qdaily();
  inline void clear_has_qdaily();
  inline void set_has_qclan();
  inline void clear_has_qclan();
  inline void set_has_yesterdaydaily();
  inline void clear_has_yesterdaydaily();
  inline void set_has_yesterdayclan();
  inline void clear_has_yesterdayclan();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PlayerInfo::ActiveQuest* qactive_;
  ::PlayerInfo::DailyQuest* qdaily_;
  ::PlayerInfo::ClanQuest* qclan_;
  ::PlayerInfo::DailyQuest* yesterdaydaily_;
  ::PlayerInfo::ClanQuest* yesterdayclan_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static NewQuestInfo* default_instance_;
};
// -------------------------------------------------------------------

class ActiveQuest : public ::google::protobuf::Message {
 public:
  ActiveQuest();
  virtual ~ActiveQuest();

  ActiveQuest(const ActiveQuest& from);

  inline ActiveQuest& operator=(const ActiveQuest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActiveQuest& default_instance();

  void Swap(ActiveQuest* other);

  // implements Message ----------------------------------------------

  ActiveQuest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActiveQuest& from);
  void MergeFrom(const ActiveQuest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // required int32 ftarget = 3;
  inline bool has_ftarget() const;
  inline void clear_ftarget();
  static const int kFtargetFieldNumber = 3;
  inline ::google::protobuf::int32 ftarget() const;
  inline void set_ftarget(::google::protobuf::int32 value);

  // optional int32 starget = 4;
  inline bool has_starget() const;
  inline void clear_starget();
  static const int kStargetFieldNumber = 4;
  inline ::google::protobuf::int32 starget() const;
  inline void set_starget(::google::protobuf::int32 value);

  // optional int32 numlevel = 5;
  inline bool has_numlevel() const;
  inline void clear_numlevel();
  static const int kNumlevelFieldNumber = 5;
  inline ::google::protobuf::int32 numlevel() const;
  inline void set_numlevel(::google::protobuf::int32 value);

  // optional int32 rewardlevel = 6;
  inline bool has_rewardlevel() const;
  inline void clear_rewardlevel();
  static const int kRewardlevelFieldNumber = 6;
  inline ::google::protobuf::int32 rewardlevel() const;
  inline void set_rewardlevel(::google::protobuf::int32 value);

  // optional int32 times = 7;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 7;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.ActiveQuest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_ftarget();
  inline void clear_has_ftarget();
  inline void set_has_starget();
  inline void clear_has_starget();
  inline void set_has_numlevel();
  inline void clear_has_numlevel();
  inline void set_has_rewardlevel();
  inline void clear_has_rewardlevel();
  inline void set_has_times();
  inline void clear_has_times();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 ftarget_;
  ::google::protobuf::int32 starget_;
  ::google::protobuf::int32 numlevel_;
  ::google::protobuf::int32 rewardlevel_;
  ::google::protobuf::int32 times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static ActiveQuest* default_instance_;
};
// -------------------------------------------------------------------

class DailyQuest : public ::google::protobuf::Message {
 public:
  DailyQuest();
  virtual ~DailyQuest();

  DailyQuest(const DailyQuest& from);

  inline DailyQuest& operator=(const DailyQuest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DailyQuest& default_instance();

  void Swap(DailyQuest* other);

  // implements Message ----------------------------------------------

  DailyQuest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DailyQuest& from);
  void MergeFrom(const DailyQuest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 questid = 1;
  inline bool has_questid() const;
  inline void clear_questid();
  static const int kQuestidFieldNumber = 1;
  inline ::google::protobuf::int32 questid() const;
  inline void set_questid(::google::protobuf::int32 value);

  // required int32 numlevel = 2;
  inline bool has_numlevel() const;
  inline void clear_numlevel();
  static const int kNumlevelFieldNumber = 2;
  inline ::google::protobuf::int32 numlevel() const;
  inline void set_numlevel(::google::protobuf::int32 value);

  // required int32 rewardlevel = 3;
  inline bool has_rewardlevel() const;
  inline void clear_rewardlevel();
  static const int kRewardlevelFieldNumber = 3;
  inline ::google::protobuf::int32 rewardlevel() const;
  inline void set_rewardlevel(::google::protobuf::int32 value);

  // required int32 times = 4;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 4;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // optional float numCoefficient = 5;
  inline bool has_numcoefficient() const;
  inline void clear_numcoefficient();
  static const int kNumCoefficientFieldNumber = 5;
  inline float numcoefficient() const;
  inline void set_numcoefficient(float value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.DailyQuest)
 private:
  inline void set_has_questid();
  inline void clear_has_questid();
  inline void set_has_numlevel();
  inline void clear_has_numlevel();
  inline void set_has_rewardlevel();
  inline void clear_has_rewardlevel();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_numcoefficient();
  inline void clear_has_numcoefficient();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 questid_;
  ::google::protobuf::int32 numlevel_;
  ::google::protobuf::int32 rewardlevel_;
  ::google::protobuf::int32 times_;
  float numcoefficient_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static DailyQuest* default_instance_;
};
// -------------------------------------------------------------------

class ClanQuest : public ::google::protobuf::Message {
 public:
  ClanQuest();
  virtual ~ClanQuest();

  ClanQuest(const ClanQuest& from);

  inline ClanQuest& operator=(const ClanQuest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanQuest& default_instance();

  void Swap(ClanQuest* other);

  // implements Message ----------------------------------------------

  ClanQuest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanQuest& from);
  void MergeFrom(const ClanQuest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 questid = 1;
  inline bool has_questid() const;
  inline void clear_questid();
  static const int kQuestidFieldNumber = 1;
  inline ::google::protobuf::int32 questid() const;
  inline void set_questid(::google::protobuf::int32 value);

  // required int32 numlevel = 2;
  inline bool has_numlevel() const;
  inline void clear_numlevel();
  static const int kNumlevelFieldNumber = 2;
  inline ::google::protobuf::int32 numlevel() const;
  inline void set_numlevel(::google::protobuf::int32 value);

  // required int32 rewardlevel = 3;
  inline bool has_rewardlevel() const;
  inline void clear_rewardlevel();
  static const int kRewardlevelFieldNumber = 3;
  inline ::google::protobuf::int32 rewardlevel() const;
  inline void set_rewardlevel(::google::protobuf::int32 value);

  // required int32 times = 4;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 4;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // optional float numCoefficient = 5;
  inline bool has_numcoefficient() const;
  inline void clear_numcoefficient();
  static const int kNumCoefficientFieldNumber = 5;
  inline float numcoefficient() const;
  inline void set_numcoefficient(float value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.ClanQuest)
 private:
  inline void set_has_questid();
  inline void clear_has_questid();
  inline void set_has_numlevel();
  inline void clear_has_numlevel();
  inline void set_has_rewardlevel();
  inline void clear_has_rewardlevel();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_numcoefficient();
  inline void clear_has_numcoefficient();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 questid_;
  ::google::protobuf::int32 numlevel_;
  ::google::protobuf::int32 rewardlevel_;
  ::google::protobuf::int32 times_;
  float numcoefficient_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static ClanQuest* default_instance_;
};
// -------------------------------------------------------------------

class CampQuest : public ::google::protobuf::Message {
 public:
  CampQuest();
  virtual ~CampQuest();

  CampQuest(const CampQuest& from);

  inline CampQuest& operator=(const CampQuest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CampQuest& default_instance();

  void Swap(CampQuest* other);

  // implements Message ----------------------------------------------

  CampQuest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CampQuest& from);
  void MergeFrom(const CampQuest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 questid = 1;
  inline bool has_questid() const;
  inline void clear_questid();
  static const int kQuestidFieldNumber = 1;
  inline ::google::protobuf::int32 questid() const;
  inline void set_questid(::google::protobuf::int32 value);

  // required int32 numlevel = 2;
  inline bool has_numlevel() const;
  inline void clear_numlevel();
  static const int kNumlevelFieldNumber = 2;
  inline ::google::protobuf::int32 numlevel() const;
  inline void set_numlevel(::google::protobuf::int32 value);

  // required int32 rewardlevel = 3;
  inline bool has_rewardlevel() const;
  inline void clear_rewardlevel();
  static const int kRewardlevelFieldNumber = 3;
  inline ::google::protobuf::int32 rewardlevel() const;
  inline void set_rewardlevel(::google::protobuf::int32 value);

  // required int32 times = 4;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 4;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // optional float numCoefficient = 5;
  inline bool has_numcoefficient() const;
  inline void clear_numcoefficient();
  static const int kNumCoefficientFieldNumber = 5;
  inline float numcoefficient() const;
  inline void set_numcoefficient(float value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.CampQuest)
 private:
  inline void set_has_questid();
  inline void clear_has_questid();
  inline void set_has_numlevel();
  inline void clear_has_numlevel();
  inline void set_has_rewardlevel();
  inline void clear_has_rewardlevel();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_numcoefficient();
  inline void clear_has_numcoefficient();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 questid_;
  ::google::protobuf::int32 numlevel_;
  ::google::protobuf::int32 rewardlevel_;
  ::google::protobuf::int32 times_;
  float numcoefficient_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static CampQuest* default_instance_;
};
// -------------------------------------------------------------------

class POneTalentSkill : public ::google::protobuf::Message {
 public:
  POneTalentSkill();
  virtual ~POneTalentSkill();

  POneTalentSkill(const POneTalentSkill& from);

  inline POneTalentSkill& operator=(const POneTalentSkill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const POneTalentSkill& default_instance();

  void Swap(POneTalentSkill* other);

  // implements Message ----------------------------------------------

  POneTalentSkill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const POneTalentSkill& from);
  void MergeFrom(const POneTalentSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 talentID = 1;
  inline bool has_talentid() const;
  inline void clear_talentid();
  static const int kTalentIDFieldNumber = 1;
  inline ::google::protobuf::int32 talentid() const;
  inline void set_talentid(::google::protobuf::int32 value);

  // repeated int32 skillList = 2;
  inline int skilllist_size() const;
  inline void clear_skilllist();
  static const int kSkillListFieldNumber = 2;
  inline ::google::protobuf::int32 skilllist(int index) const;
  inline void set_skilllist(int index, ::google::protobuf::int32 value);
  inline void add_skilllist(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      skilllist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_skilllist();

  // @@protoc_insertion_point(class_scope:PlayerInfo.POneTalentSkill)
 private:
  inline void set_has_talentid();
  inline void clear_has_talentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > skilllist_;
  ::google::protobuf::int32 talentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static POneTalentSkill* default_instance_;
};
// -------------------------------------------------------------------

class SkillInfo : public ::google::protobuf::Message {
 public:
  SkillInfo();
  virtual ~SkillInfo();

  SkillInfo(const SkillInfo& from);

  inline SkillInfo& operator=(const SkillInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SkillInfo& default_instance();

  void Swap(SkillInfo* other);

  // implements Message ----------------------------------------------

  SkillInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkillInfo& from);
  void MergeFrom(const SkillInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 skillid = 1;
  inline int skillid_size() const;
  inline void clear_skillid();
  static const int kSkillidFieldNumber = 1;
  inline ::google::protobuf::int32 skillid(int index) const;
  inline void set_skillid(int index, ::google::protobuf::int32 value);
  inline void add_skillid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      skillid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_skillid();

  // repeated .PlayerInfo.BuffInfo buf = 2;
  inline int buf_size() const;
  inline void clear_buf();
  static const int kBufFieldNumber = 2;
  inline const ::PlayerInfo::BuffInfo& buf(int index) const;
  inline ::PlayerInfo::BuffInfo* mutable_buf(int index);
  inline ::PlayerInfo::BuffInfo* add_buf();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BuffInfo >&
      buf() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BuffInfo >*
      mutable_buf();

  // repeated .PlayerInfo.POneTalentSkill skillData = 3;
  inline int skilldata_size() const;
  inline void clear_skilldata();
  static const int kSkillDataFieldNumber = 3;
  inline const ::PlayerInfo::POneTalentSkill& skilldata(int index) const;
  inline ::PlayerInfo::POneTalentSkill* mutable_skilldata(int index);
  inline ::PlayerInfo::POneTalentSkill* add_skilldata();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::POneTalentSkill >&
      skilldata() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::POneTalentSkill >*
      mutable_skilldata();

  // optional int32 curTalent = 4;
  inline bool has_curtalent() const;
  inline void clear_curtalent();
  static const int kCurTalentFieldNumber = 4;
  inline ::google::protobuf::int32 curtalent() const;
  inline void set_curtalent(::google::protobuf::int32 value);

  // repeated int32 clanskills = 5;
  inline int clanskills_size() const;
  inline void clear_clanskills();
  static const int kClanskillsFieldNumber = 5;
  inline ::google::protobuf::int32 clanskills(int index) const;
  inline void set_clanskills(int index, ::google::protobuf::int32 value);
  inline void add_clanskills(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      clanskills() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_clanskills();

  // @@protoc_insertion_point(class_scope:PlayerInfo.SkillInfo)
 private:
  inline void set_has_curtalent();
  inline void clear_has_curtalent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > skillid_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BuffInfo > buf_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::POneTalentSkill > skilldata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > clanskills_;
  ::google::protobuf::int32 curtalent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static SkillInfo* default_instance_;
};
// -------------------------------------------------------------------

class BuffInfo : public ::google::protobuf::Message {
 public:
  BuffInfo();
  virtual ~BuffInfo();

  BuffInfo(const BuffInfo& from);

  inline BuffInfo& operator=(const BuffInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuffInfo& default_instance();

  void Swap(BuffInfo* other);

  // implements Message ----------------------------------------------

  BuffInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuffInfo& from);
  void MergeFrom(const BuffInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int64 endtime = 3;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 3;
  inline ::google::protobuf::int64 endtime() const;
  inline void set_endtime(::google::protobuf::int64 value);

  // optional int64 offtime = 4;
  inline bool has_offtime() const;
  inline void clear_offtime();
  static const int kOfftimeFieldNumber = 4;
  inline ::google::protobuf::int64 offtime() const;
  inline void set_offtime(::google::protobuf::int64 value);

  // optional bool isdel = 5;
  inline bool has_isdel() const;
  inline void clear_isdel();
  static const int kIsdelFieldNumber = 5;
  inline bool isdel() const;
  inline void set_isdel(bool value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.BuffInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_offtime();
  inline void clear_has_offtime();
  inline void set_has_isdel();
  inline void clear_has_isdel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int64 endtime_;
  ::google::protobuf::int64 offtime_;
  bool isdel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static BuffInfo* default_instance_;
};
// -------------------------------------------------------------------

class CDInfo : public ::google::protobuf::Message {
 public:
  CDInfo();
  virtual ~CDInfo();

  CDInfo(const CDInfo& from);

  inline CDInfo& operator=(const CDInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CDInfo& default_instance();

  void Swap(CDInfo* other);

  // implements Message ----------------------------------------------

  CDInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CDInfo& from);
  void MergeFrom(const CDInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.ChannelCD cd = 1;
  inline int cd_size() const;
  inline void clear_cd();
  static const int kCdFieldNumber = 1;
  inline const ::PlayerInfo::ChannelCD& cd(int index) const;
  inline ::PlayerInfo::ChannelCD* mutable_cd(int index);
  inline ::PlayerInfo::ChannelCD* add_cd();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ChannelCD >&
      cd() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ChannelCD >*
      mutable_cd();

  // @@protoc_insertion_point(class_scope:PlayerInfo.CDInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ChannelCD > cd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static CDInfo* default_instance_;
};
// -------------------------------------------------------------------

class ChannelCD : public ::google::protobuf::Message {
 public:
  ChannelCD();
  virtual ~ChannelCD();

  ChannelCD(const ChannelCD& from);

  inline ChannelCD& operator=(const ChannelCD& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelCD& default_instance();

  void Swap(ChannelCD* other);

  // implements Message ----------------------------------------------

  ChannelCD* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChannelCD& from);
  void MergeFrom(const ChannelCD& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int64 endtime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 2;
  inline ::google::protobuf::int64 endtime() const;
  inline void set_endtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.ChannelCD)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 endtime_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static ChannelCD* default_instance_;
};
// -------------------------------------------------------------------

class ContainerInfo : public ::google::protobuf::Message {
 public:
  ContainerInfo();
  virtual ~ContainerInfo();

  ContainerInfo(const ContainerInfo& from);

  inline ContainerInfo& operator=(const ContainerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContainerInfo& default_instance();

  void Swap(ContainerInfo* other);

  // implements Message ----------------------------------------------

  ContainerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContainerInfo& from);
  void MergeFrom(const ContainerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .PlayerInfo.PackageInfo package = 1;
  inline bool has_package() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 1;
  inline const ::PlayerInfo::PackageInfo& package() const;
  inline ::PlayerInfo::PackageInfo* mutable_package();
  inline ::PlayerInfo::PackageInfo* release_package();
  inline void set_allocated_package(::PlayerInfo::PackageInfo* package);

  // optional .PlayerInfo.StoreHouseInfo storehouse = 2;
  inline bool has_storehouse() const;
  inline void clear_storehouse();
  static const int kStorehouseFieldNumber = 2;
  inline const ::PlayerInfo::StoreHouseInfo& storehouse() const;
  inline ::PlayerInfo::StoreHouseInfo* mutable_storehouse();
  inline ::PlayerInfo::StoreHouseInfo* release_storehouse();
  inline void set_allocated_storehouse(::PlayerInfo::StoreHouseInfo* storehouse);

  // @@protoc_insertion_point(class_scope:PlayerInfo.ContainerInfo)
 private:
  inline void set_has_package();
  inline void clear_has_package();
  inline void set_has_storehouse();
  inline void clear_has_storehouse();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PlayerInfo::PackageInfo* package_;
  ::PlayerInfo::StoreHouseInfo* storehouse_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static ContainerInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayerTypeInfo : public ::google::protobuf::Message {
 public:
  PlayerTypeInfo();
  virtual ~PlayerTypeInfo();

  PlayerTypeInfo(const PlayerTypeInfo& from);

  inline PlayerTypeInfo& operator=(const PlayerTypeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerTypeInfo& default_instance();

  void Swap(PlayerTypeInfo* other);

  // implements Message ----------------------------------------------

  PlayerTypeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerTypeInfo& from);
  void MergeFrom(const PlayerTypeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 type = 1;
  inline int type_size() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type(int index) const;
  inline void set_type(int index, ::google::protobuf::int32 value);
  inline void add_type(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      type() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_type();

  // optional .PlayerInfo.HorseInfo horse = 2;
  inline bool has_horse() const;
  inline void clear_horse();
  static const int kHorseFieldNumber = 2;
  inline const ::PlayerInfo::HorseInfo& horse() const;
  inline ::PlayerInfo::HorseInfo* mutable_horse();
  inline ::PlayerInfo::HorseInfo* release_horse();
  inline void set_allocated_horse(::PlayerInfo::HorseInfo* horse);

  // optional .PlayerInfo.DanLuInfo danlu = 3;
  inline bool has_danlu() const;
  inline void clear_danlu();
  static const int kDanluFieldNumber = 3;
  inline const ::PlayerInfo::DanLuInfo& danlu() const;
  inline ::PlayerInfo::DanLuInfo* mutable_danlu();
  inline ::PlayerInfo::DanLuInfo* release_danlu();
  inline void set_allocated_danlu(::PlayerInfo::DanLuInfo* danlu);

  // optional .PlayerInfo.MagicWeapon magicw = 4;
  inline bool has_magicw() const;
  inline void clear_magicw();
  static const int kMagicwFieldNumber = 4;
  inline const ::PlayerInfo::MagicWeapon& magicw() const;
  inline ::PlayerInfo::MagicWeapon* mutable_magicw();
  inline ::PlayerInfo::MagicWeapon* release_magicw();
  inline void set_allocated_magicw(::PlayerInfo::MagicWeapon* magicw);

  // optional .PlayerInfo.RandCJobLucky cjob = 5;
  inline bool has_cjob() const;
  inline void clear_cjob();
  static const int kCjobFieldNumber = 5;
  inline const ::PlayerInfo::RandCJobLucky& cjob() const;
  inline ::PlayerInfo::RandCJobLucky* mutable_cjob();
  inline ::PlayerInfo::RandCJobLucky* release_cjob();
  inline void set_allocated_cjob(::PlayerInfo::RandCJobLucky* cjob);

  // optional .PlayerInfo.LucklyTurntable lucktable = 6;
  inline bool has_lucktable() const;
  inline void clear_lucktable();
  static const int kLucktableFieldNumber = 6;
  inline const ::PlayerInfo::LucklyTurntable& lucktable() const;
  inline ::PlayerInfo::LucklyTurntable* mutable_lucktable();
  inline ::PlayerInfo::LucklyTurntable* release_lucktable();
  inline void set_allocated_lucktable(::PlayerInfo::LucklyTurntable* lucktable);

  // optional .PlayerInfo.Activity activity = 7;
  inline bool has_activity() const;
  inline void clear_activity();
  static const int kActivityFieldNumber = 7;
  inline const ::PlayerInfo::Activity& activity() const;
  inline ::PlayerInfo::Activity* mutable_activity();
  inline ::PlayerInfo::Activity* release_activity();
  inline void set_allocated_activity(::PlayerInfo::Activity* activity);

  // optional .PlayerInfo.DestinationInfoList destination = 8;
  inline bool has_destination() const;
  inline void clear_destination();
  static const int kDestinationFieldNumber = 8;
  inline const ::PlayerInfo::DestinationInfoList& destination() const;
  inline ::PlayerInfo::DestinationInfoList* mutable_destination();
  inline ::PlayerInfo::DestinationInfoList* release_destination();
  inline void set_allocated_destination(::PlayerInfo::DestinationInfoList* destination);

  // @@protoc_insertion_point(class_scope:PlayerInfo.PlayerTypeInfo)
 private:
  inline void set_has_horse();
  inline void clear_has_horse();
  inline void set_has_danlu();
  inline void clear_has_danlu();
  inline void set_has_magicw();
  inline void clear_has_magicw();
  inline void set_has_cjob();
  inline void clear_has_cjob();
  inline void set_has_lucktable();
  inline void clear_has_lucktable();
  inline void set_has_activity();
  inline void clear_has_activity();
  inline void set_has_destination();
  inline void clear_has_destination();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > type_;
  ::PlayerInfo::HorseInfo* horse_;
  ::PlayerInfo::DanLuInfo* danlu_;
  ::PlayerInfo::MagicWeapon* magicw_;
  ::PlayerInfo::RandCJobLucky* cjob_;
  ::PlayerInfo::LucklyTurntable* lucktable_;
  ::PlayerInfo::Activity* activity_;
  ::PlayerInfo::DestinationInfoList* destination_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static PlayerTypeInfo* default_instance_;
};
// -------------------------------------------------------------------

class EquipQuickInfo : public ::google::protobuf::Message {
 public:
  EquipQuickInfo();
  virtual ~EquipQuickInfo();

  EquipQuickInfo(const EquipQuickInfo& from);

  inline EquipQuickInfo& operator=(const EquipQuickInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EquipQuickInfo& default_instance();

  void Swap(EquipQuickInfo* other);

  // implements Message ----------------------------------------------

  EquipQuickInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EquipQuickInfo& from);
  void MergeFrom(const EquipQuickInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.ItemInfo equip = 1;
  inline int equip_size() const;
  inline void clear_equip();
  static const int kEquipFieldNumber = 1;
  inline const ::PlayerInfo::ItemInfo& equip(int index) const;
  inline ::PlayerInfo::ItemInfo* mutable_equip(int index);
  inline ::PlayerInfo::ItemInfo* add_equip();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ItemInfo >&
      equip() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ItemInfo >*
      mutable_equip();

  // repeated .PlayerInfo.QuickContainer quick = 2;
  inline int quick_size() const;
  inline void clear_quick();
  static const int kQuickFieldNumber = 2;
  inline const ::PlayerInfo::QuickContainer& quick(int index) const;
  inline ::PlayerInfo::QuickContainer* mutable_quick(int index);
  inline ::PlayerInfo::QuickContainer* add_quick();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::QuickContainer >&
      quick() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::QuickContainer >*
      mutable_quick();

  // @@protoc_insertion_point(class_scope:PlayerInfo.EquipQuickInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ItemInfo > equip_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::QuickContainer > quick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static EquipQuickInfo* default_instance_;
};
// -------------------------------------------------------------------

class PackageInfo : public ::google::protobuf::Message {
 public:
  PackageInfo();
  virtual ~PackageInfo();

  PackageInfo(const PackageInfo& from);

  inline PackageInfo& operator=(const PackageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PackageInfo& default_instance();

  void Swap(PackageInfo* other);

  // implements Message ----------------------------------------------

  PackageInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PackageInfo& from);
  void MergeFrom(const PackageInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.ItemInfo package = 1;
  inline int package_size() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 1;
  inline const ::PlayerInfo::ItemInfo& package(int index) const;
  inline ::PlayerInfo::ItemInfo* mutable_package(int index);
  inline ::PlayerInfo::ItemInfo* add_package();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ItemInfo >&
      package() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ItemInfo >*
      mutable_package();

  // optional int32 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional int64 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.PackageInfo)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ItemInfo > package_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static PackageInfo* default_instance_;
};
// -------------------------------------------------------------------

class StoreHouseInfo : public ::google::protobuf::Message {
 public:
  StoreHouseInfo();
  virtual ~StoreHouseInfo();

  StoreHouseInfo(const StoreHouseInfo& from);

  inline StoreHouseInfo& operator=(const StoreHouseInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreHouseInfo& default_instance();

  void Swap(StoreHouseInfo* other);

  // implements Message ----------------------------------------------

  StoreHouseInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreHouseInfo& from);
  void MergeFrom(const StoreHouseInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.ItemInfo storehouse = 1;
  inline int storehouse_size() const;
  inline void clear_storehouse();
  static const int kStorehouseFieldNumber = 1;
  inline const ::PlayerInfo::ItemInfo& storehouse(int index) const;
  inline ::PlayerInfo::ItemInfo* mutable_storehouse(int index);
  inline ::PlayerInfo::ItemInfo* add_storehouse();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ItemInfo >&
      storehouse() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ItemInfo >*
      mutable_storehouse();

  // optional int32 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // optional int64 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.StoreHouseInfo)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ItemInfo > storehouse_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static StoreHouseInfo* default_instance_;
};
// -------------------------------------------------------------------

class MonitorInfo : public ::google::protobuf::Message {
 public:
  MonitorInfo();
  virtual ~MonitorInfo();

  MonitorInfo(const MonitorInfo& from);

  inline MonitorInfo& operator=(const MonitorInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MonitorInfo& default_instance();

  void Swap(MonitorInfo* other);

  // implements Message ----------------------------------------------

  MonitorInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MonitorInfo& from);
  void MergeFrom(const MonitorInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bool attackskill = 1;
  inline int attackskill_size() const;
  inline void clear_attackskill();
  static const int kAttackskillFieldNumber = 1;
  inline bool attackskill(int index) const;
  inline void set_attackskill(int index, bool value);
  inline void add_attackskill(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      attackskill() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_attackskill();

  // repeated int64 skillid = 2;
  inline int skillid_size() const;
  inline void clear_skillid();
  static const int kSkillidFieldNumber = 2;
  inline ::google::protobuf::int64 skillid(int index) const;
  inline void set_skillid(int index, ::google::protobuf::int64 value);
  inline void add_skillid(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      skillid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_skillid();

  // optional bool ispickequip = 3;
  inline bool has_ispickequip() const;
  inline void clear_ispickequip();
  static const int kIspickequipFieldNumber = 3;
  inline bool ispickequip() const;
  inline void set_ispickequip(bool value);

  // optional int32 quality = 4;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 4;
  inline ::google::protobuf::int32 quality() const;
  inline void set_quality(::google::protobuf::int32 value);

  // optional int32 profession = 5;
  inline bool has_profession() const;
  inline void clear_profession();
  static const int kProfessionFieldNumber = 5;
  inline ::google::protobuf::int32 profession() const;
  inline void set_profession(::google::protobuf::int32 value);

  // optional bool ispickstone = 6;
  inline bool has_ispickstone() const;
  inline void clear_ispickstone();
  static const int kIspickstoneFieldNumber = 6;
  inline bool ispickstone() const;
  inline void set_ispickstone(bool value);

  // optional bool ispickconsume = 7;
  inline bool has_ispickconsume() const;
  inline void clear_ispickconsume();
  static const int kIspickconsumeFieldNumber = 7;
  inline bool ispickconsume() const;
  inline void set_ispickconsume(bool value);

  // optional bool ispickmoney = 8;
  inline bool has_ispickmoney() const;
  inline void clear_ispickmoney();
  static const int kIspickmoneyFieldNumber = 8;
  inline bool ispickmoney() const;
  inline void set_ispickmoney(bool value);

  // optional bool ispickother = 9;
  inline bool has_ispickother() const;
  inline void clear_ispickother();
  static const int kIspickotherFieldNumber = 9;
  inline bool ispickother() const;
  inline void set_ispickother(bool value);

  // optional bool isgroup = 10;
  inline bool has_isgroup() const;
  inline void clear_isgroup();
  static const int kIsgroupFieldNumber = 10;
  inline bool isgroup() const;
  inline void set_isgroup(bool value);

  // optional bool assistskill = 11;
  inline bool has_assistskill() const;
  inline void clear_assistskill();
  static const int kAssistskillFieldNumber = 11;
  inline bool assistskill() const;
  inline void set_assistskill(bool value);

  // optional bool isbuyhp = 12;
  inline bool has_isbuyhp() const;
  inline void clear_isbuyhp();
  static const int kIsbuyhpFieldNumber = 12;
  inline bool isbuyhp() const;
  inline void set_isbuyhp(bool value);

  // optional int32 hpbuytype = 13;
  inline bool has_hpbuytype() const;
  inline void clear_hpbuytype();
  static const int kHpbuytypeFieldNumber = 13;
  inline ::google::protobuf::int32 hpbuytype() const;
  inline void set_hpbuytype(::google::protobuf::int32 value);

  // optional bool isbuymp = 14;
  inline bool has_isbuymp() const;
  inline void clear_isbuymp();
  static const int kIsbuympFieldNumber = 14;
  inline bool isbuymp() const;
  inline void set_isbuymp(bool value);

  // optional int32 mpbuytype = 15;
  inline bool has_mpbuytype() const;
  inline void clear_mpbuytype();
  static const int kMpbuytypeFieldNumber = 15;
  inline ::google::protobuf::int32 mpbuytype() const;
  inline void set_mpbuytype(::google::protobuf::int32 value);

  // optional bool isrevalsit = 16;
  inline bool has_isrevalsit() const;
  inline void clear_isrevalsit();
  static const int kIsrevalsitFieldNumber = 16;
  inline bool isrevalsit() const;
  inline void set_isrevalsit(bool value);

  // optional bool isuseexp = 17;
  inline bool has_isuseexp() const;
  inline void clear_isuseexp();
  static const int kIsuseexpFieldNumber = 17;
  inline bool isuseexp() const;
  inline void set_isuseexp(bool value);

  // optional int32 hp = 18;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 18;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // optional bool hpuse = 19;
  inline bool has_hpuse() const;
  inline void clear_hpuse();
  static const int kHpuseFieldNumber = 19;
  inline bool hpuse() const;
  inline void set_hpuse(bool value);

  // optional int32 mp = 20;
  inline bool has_mp() const;
  inline void clear_mp();
  static const int kMpFieldNumber = 20;
  inline ::google::protobuf::int32 mp() const;
  inline void set_mp(::google::protobuf::int32 value);

  // optional bool mpuse = 21;
  inline bool has_mpuse() const;
  inline void clear_mpuse();
  static const int kMpuseFieldNumber = 21;
  inline bool mpuse() const;
  inline void set_mpuse(bool value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.MonitorInfo)
 private:
  inline void set_has_ispickequip();
  inline void clear_has_ispickequip();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_profession();
  inline void clear_has_profession();
  inline void set_has_ispickstone();
  inline void clear_has_ispickstone();
  inline void set_has_ispickconsume();
  inline void clear_has_ispickconsume();
  inline void set_has_ispickmoney();
  inline void clear_has_ispickmoney();
  inline void set_has_ispickother();
  inline void clear_has_ispickother();
  inline void set_has_isgroup();
  inline void clear_has_isgroup();
  inline void set_has_assistskill();
  inline void clear_has_assistskill();
  inline void set_has_isbuyhp();
  inline void clear_has_isbuyhp();
  inline void set_has_hpbuytype();
  inline void clear_has_hpbuytype();
  inline void set_has_isbuymp();
  inline void clear_has_isbuymp();
  inline void set_has_mpbuytype();
  inline void clear_has_mpbuytype();
  inline void set_has_isrevalsit();
  inline void clear_has_isrevalsit();
  inline void set_has_isuseexp();
  inline void clear_has_isuseexp();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_hpuse();
  inline void clear_has_hpuse();
  inline void set_has_mp();
  inline void clear_has_mp();
  inline void set_has_mpuse();
  inline void clear_has_mpuse();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< bool > attackskill_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > skillid_;
  ::google::protobuf::int32 quality_;
  ::google::protobuf::int32 profession_;
  bool ispickequip_;
  bool ispickstone_;
  bool ispickconsume_;
  bool ispickmoney_;
  bool ispickother_;
  bool isgroup_;
  bool assistskill_;
  bool isbuyhp_;
  ::google::protobuf::int32 hpbuytype_;
  ::google::protobuf::int32 mpbuytype_;
  bool isbuymp_;
  bool isrevalsit_;
  bool isuseexp_;
  bool hpuse_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 mp_;
  bool mpuse_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static MonitorInfo* default_instance_;
};
// -------------------------------------------------------------------

class SettingInfo : public ::google::protobuf::Message {
 public:
  SettingInfo();
  virtual ~SettingInfo();

  SettingInfo(const SettingInfo& from);

  inline SettingInfo& operator=(const SettingInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SettingInfo& default_instance();

  void Swap(SettingInfo* other);

  // implements Message ----------------------------------------------

  SettingInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SettingInfo& from);
  void MergeFrom(const SettingInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 type = 1;
  inline int type_size() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type(int index) const;
  inline void set_type(int index, ::google::protobuf::int32 value);
  inline void add_type(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      type() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_type();

  // repeated int32 value = 2;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value(int index) const;
  inline void set_value(int index, ::google::protobuf::int32 value);
  inline void add_value(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      value() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:PlayerInfo.SettingInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static SettingInfo* default_instance_;
};
// -------------------------------------------------------------------

class HorseInfo : public ::google::protobuf::Message {
 public:
  HorseInfo();
  virtual ~HorseInfo();

  HorseInfo(const HorseInfo& from);

  inline HorseInfo& operator=(const HorseInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HorseInfo& default_instance();

  void Swap(HorseInfo* other);

  // implements Message ----------------------------------------------

  HorseInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HorseInfo& from);
  void MergeFrom(const HorseInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 mid = 2;
  inline bool has_mid() const;
  inline void clear_mid();
  static const int kMidFieldNumber = 2;
  inline ::google::protobuf::int32 mid() const;
  inline void set_mid(::google::protobuf::int32 value);

  // optional int32 exp = 3;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 3;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // repeated .PlayerInfo.SkinInfo skinIDList = 4;
  inline int skinidlist_size() const;
  inline void clear_skinidlist();
  static const int kSkinIDListFieldNumber = 4;
  inline const ::PlayerInfo::SkinInfo& skinidlist(int index) const;
  inline ::PlayerInfo::SkinInfo* mutable_skinidlist(int index);
  inline ::PlayerInfo::SkinInfo* add_skinidlist();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::SkinInfo >&
      skinidlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::SkinInfo >*
      mutable_skinidlist();

  // @@protoc_insertion_point(class_scope:PlayerInfo.HorseInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_mid();
  inline void clear_has_mid();
  inline void set_has_exp();
  inline void clear_has_exp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 mid_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::SkinInfo > skinidlist_;
  ::google::protobuf::int32 exp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static HorseInfo* default_instance_;
};
// -------------------------------------------------------------------

class SkinInfo : public ::google::protobuf::Message {
 public:
  SkinInfo();
  virtual ~SkinInfo();

  SkinInfo(const SkinInfo& from);

  inline SkinInfo& operator=(const SkinInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SkinInfo& default_instance();

  void Swap(SkinInfo* other);

  // implements Message ----------------------------------------------

  SkinInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkinInfo& from);
  void MergeFrom(const SkinInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 skinID = 1;
  inline bool has_skinid() const;
  inline void clear_skinid();
  static const int kSkinIDFieldNumber = 1;
  inline ::google::protobuf::int32 skinid() const;
  inline void set_skinid(::google::protobuf::int32 value);

  // optional int64 endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::int64 endtime() const;
  inline void set_endtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.SkinInfo)
 private:
  inline void set_has_skinid();
  inline void clear_has_skinid();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 endtime_;
  ::google::protobuf::int32 skinid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static SkinInfo* default_instance_;
};
// -------------------------------------------------------------------

class ItemInfo : public ::google::protobuf::Message {
 public:
  ItemInfo();
  virtual ~ItemInfo();

  ItemInfo(const ItemInfo& from);

  inline ItemInfo& operator=(const ItemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemInfo& default_instance();

  void Swap(ItemInfo* other);

  // implements Message ----------------------------------------------

  ItemInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemInfo& from);
  void MergeFrom(const ItemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional uint32 flag = 2;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 2;
  inline ::google::protobuf::uint32 flag() const;
  inline void set_flag(::google::protobuf::uint32 value);

  // repeated uint32 newattr = 3;
  inline int newattr_size() const;
  inline void clear_newattr();
  static const int kNewattrFieldNumber = 3;
  inline ::google::protobuf::uint32 newattr(int index) const;
  inline void set_newattr(int index, ::google::protobuf::uint32 value);
  inline void add_newattr(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      newattr() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_newattr();

  // repeated int32 stoneid = 4;
  inline int stoneid_size() const;
  inline void clear_stoneid();
  static const int kStoneidFieldNumber = 4;
  inline ::google::protobuf::int32 stoneid(int index) const;
  inline void set_stoneid(int index, ::google::protobuf::int32 value);
  inline void add_stoneid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      stoneid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_stoneid();

  // optional int64 endtime = 5;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 5;
  inline ::google::protobuf::int64 endtime() const;
  inline void set_endtime(::google::protobuf::int64 value);

  // optional int32 num = 6;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 6;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // repeated int32 inlayPos = 7;
  inline int inlaypos_size() const;
  inline void clear_inlaypos();
  static const int kInlayPosFieldNumber = 7;
  inline ::google::protobuf::int32 inlaypos(int index) const;
  inline void set_inlaypos(int index, ::google::protobuf::int32 value);
  inline void add_inlaypos(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      inlaypos() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_inlaypos();

  // repeated uint32 refineAttrLv = 8;
  inline int refineattrlv_size() const;
  inline void clear_refineattrlv();
  static const int kRefineAttrLvFieldNumber = 8;
  inline ::google::protobuf::uint32 refineattrlv(int index) const;
  inline void set_refineattrlv(int index, ::google::protobuf::uint32 value);
  inline void add_refineattrlv(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      refineattrlv() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_refineattrlv();

  // @@protoc_insertion_point(class_scope:PlayerInfo.ItemInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::uint32 flag_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > newattr_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > stoneid_;
  ::google::protobuf::int64 endtime_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > inlaypos_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > refineattrlv_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static ItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class AttrValue : public ::google::protobuf::Message {
 public:
  AttrValue();
  virtual ~AttrValue();

  AttrValue(const AttrValue& from);

  inline AttrValue& operator=(const AttrValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AttrValue& default_instance();

  void Swap(AttrValue* other);

  // implements Message ----------------------------------------------

  AttrValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AttrValue& from);
  void MergeFrom(const AttrValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.AttrValue)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static AttrValue* default_instance_;
};
// -------------------------------------------------------------------

class QuickContainer : public ::google::protobuf::Message {
 public:
  QuickContainer();
  virtual ~QuickContainer();

  QuickContainer(const QuickContainer& from);

  inline QuickContainer& operator=(const QuickContainer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuickContainer& default_instance();

  void Swap(QuickContainer* other);

  // implements Message ----------------------------------------------

  QuickContainer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuickContainer& from);
  void MergeFrom(const QuickContainer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.QuickContainer)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static QuickContainer* default_instance_;
};
// -------------------------------------------------------------------

class WPlayerInfo : public ::google::protobuf::Message {
 public:
  WPlayerInfo();
  virtual ~WPlayerInfo();

  WPlayerInfo(const WPlayerInfo& from);

  inline WPlayerInfo& operator=(const WPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WPlayerInfo& default_instance();

  void Swap(WPlayerInfo* other);

  // implements Message ----------------------------------------------

  WPlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WPlayerInfo& from);
  void MergeFrom(const WPlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .PlayerInfo.FriendInfoList friendlist = 1;
  inline bool has_friendlist() const;
  inline void clear_friendlist();
  static const int kFriendlistFieldNumber = 1;
  inline const ::PlayerInfo::FriendInfoList& friendlist() const;
  inline ::PlayerInfo::FriendInfoList* mutable_friendlist();
  inline ::PlayerInfo::FriendInfoList* release_friendlist();
  inline void set_allocated_friendlist(::PlayerInfo::FriendInfoList* friendlist);

  // @@protoc_insertion_point(class_scope:PlayerInfo.WPlayerInfo)
 private:
  inline void set_has_friendlist();
  inline void clear_has_friendlist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PlayerInfo::FriendInfoList* friendlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static WPlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class FriendInfoList : public ::google::protobuf::Message {
 public:
  FriendInfoList();
  virtual ~FriendInfoList();

  FriendInfoList(const FriendInfoList& from);

  inline FriendInfoList& operator=(const FriendInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FriendInfoList& default_instance();

  void Swap(FriendInfoList* other);

  // implements Message ----------------------------------------------

  FriendInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FriendInfoList& from);
  void MergeFrom(const FriendInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.FriendInfo friends = 1;
  inline int friends_size() const;
  inline void clear_friends();
  static const int kFriendsFieldNumber = 1;
  inline const ::PlayerInfo::FriendInfo& friends(int index) const;
  inline ::PlayerInfo::FriendInfo* mutable_friends(int index);
  inline ::PlayerInfo::FriendInfo* add_friends();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::FriendInfo >&
      friends() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::FriendInfo >*
      mutable_friends();

  // repeated int64 inwho = 2;
  inline int inwho_size() const;
  inline void clear_inwho();
  static const int kInwhoFieldNumber = 2;
  inline ::google::protobuf::int64 inwho(int index) const;
  inline void set_inwho(int index, ::google::protobuf::int64 value);
  inline void add_inwho(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      inwho() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_inwho();

  // optional int32 m_ReceiveCounts = 3;
  inline bool has_m_receivecounts() const;
  inline void clear_m_receivecounts();
  static const int kMReceiveCountsFieldNumber = 3;
  inline ::google::protobuf::int32 m_receivecounts() const;
  inline void set_m_receivecounts(::google::protobuf::int32 value);

  // optional int32 m_SendCounts = 4;
  inline bool has_m_sendcounts() const;
  inline void clear_m_sendcounts();
  static const int kMSendCountsFieldNumber = 4;
  inline ::google::protobuf::int32 m_sendcounts() const;
  inline void set_m_sendcounts(::google::protobuf::int32 value);

  // optional int64 m_ResetTime = 5;
  inline bool has_m_resettime() const;
  inline void clear_m_resettime();
  static const int kMResetTimeFieldNumber = 5;
  inline ::google::protobuf::int64 m_resettime() const;
  inline void set_m_resettime(::google::protobuf::int64 value);

  // optional int64 m_marryId = 6;
  inline bool has_m_marryid() const;
  inline void clear_m_marryid();
  static const int kMMarryIdFieldNumber = 6;
  inline ::google::protobuf::int64 m_marryid() const;
  inline void set_m_marryid(::google::protobuf::int64 value);

  // repeated int64 m_Invited = 7;
  inline int m_invited_size() const;
  inline void clear_m_invited();
  static const int kMInvitedFieldNumber = 7;
  inline ::google::protobuf::int64 m_invited(int index) const;
  inline void set_m_invited(int index, ::google::protobuf::int64 value);
  inline void add_m_invited(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      m_invited() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_m_invited();

  // @@protoc_insertion_point(class_scope:PlayerInfo.FriendInfoList)
 private:
  inline void set_has_m_receivecounts();
  inline void clear_has_m_receivecounts();
  inline void set_has_m_sendcounts();
  inline void clear_has_m_sendcounts();
  inline void set_has_m_resettime();
  inline void clear_has_m_resettime();
  inline void set_has_m_marryid();
  inline void clear_has_m_marryid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::FriendInfo > friends_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > inwho_;
  ::google::protobuf::int32 m_receivecounts_;
  ::google::protobuf::int32 m_sendcounts_;
  ::google::protobuf::int64 m_resettime_;
  ::google::protobuf::int64 m_marryid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > m_invited_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static FriendInfoList* default_instance_;
};
// -------------------------------------------------------------------

class FriendInfo : public ::google::protobuf::Message {
 public:
  FriendInfo();
  virtual ~FriendInfo();

  FriendInfo(const FriendInfo& from);

  inline FriendInfo& operator=(const FriendInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FriendInfo& default_instance();

  void Swap(FriendInfo* other);

  // implements Message ----------------------------------------------

  FriendInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FriendInfo& from);
  void MergeFrom(const FriendInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int64 charid = 2;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 2;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // required string friendname = 3;
  inline bool has_friendname() const;
  inline void clear_friendname();
  static const int kFriendnameFieldNumber = 3;
  inline const ::std::string& friendname() const;
  inline void set_friendname(const ::std::string& value);
  inline void set_friendname(const char* value);
  inline void set_friendname(const char* value, size_t size);
  inline ::std::string* mutable_friendname();
  inline ::std::string* release_friendname();
  inline void set_allocated_friendname(::std::string* friendname);

  // required int32 lv = 4;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 4;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // optional int32 profession = 5;
  inline bool has_profession() const;
  inline void clear_profession();
  static const int kProfessionFieldNumber = 5;
  inline ::google::protobuf::int32 profession() const;
  inline void set_profession(::google::protobuf::int32 value);

  // optional int32 hatred = 6;
  inline bool has_hatred() const;
  inline void clear_hatred();
  static const int kHatredFieldNumber = 6;
  inline ::google::protobuf::int32 hatred() const;
  inline void set_hatred(::google::protobuf::int32 value);

  // optional int32 cohesion = 7;
  inline bool has_cohesion() const;
  inline void clear_cohesion();
  static const int kCohesionFieldNumber = 7;
  inline ::google::protobuf::int32 cohesion() const;
  inline void set_cohesion(::google::protobuf::int32 value);

  // optional int32 vipLevel = 8;
  inline bool has_viplevel() const;
  inline void clear_viplevel();
  static const int kVipLevelFieldNumber = 8;
  inline ::google::protobuf::int32 viplevel() const;
  inline void set_viplevel(::google::protobuf::int32 value);

  // optional int32 fighting = 9;
  inline bool has_fighting() const;
  inline void clear_fighting();
  static const int kFightingFieldNumber = 9;
  inline ::google::protobuf::int32 fighting() const;
  inline void set_fighting(::google::protobuf::int32 value);

  // optional int32 sex = 10;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 10;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.FriendInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_friendname();
  inline void clear_has_friendname();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_profession();
  inline void clear_has_profession();
  inline void set_has_hatred();
  inline void clear_has_hatred();
  inline void set_has_cohesion();
  inline void clear_has_cohesion();
  inline void set_has_viplevel();
  inline void clear_has_viplevel();
  inline void set_has_fighting();
  inline void clear_has_fighting();
  inline void set_has_sex();
  inline void clear_has_sex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 lv_;
  ::std::string* friendname_;
  ::google::protobuf::int32 profession_;
  ::google::protobuf::int32 hatred_;
  ::google::protobuf::int32 cohesion_;
  ::google::protobuf::int32 viplevel_;
  ::google::protobuf::int32 fighting_;
  ::google::protobuf::int32 sex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static FriendInfo* default_instance_;
};
// -------------------------------------------------------------------

class InstanceInfoList : public ::google::protobuf::Message {
 public:
  InstanceInfoList();
  virtual ~InstanceInfoList();

  InstanceInfoList(const InstanceInfoList& from);

  inline InstanceInfoList& operator=(const InstanceInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceInfoList& default_instance();

  void Swap(InstanceInfoList* other);

  // implements Message ----------------------------------------------

  InstanceInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceInfoList& from);
  void MergeFrom(const InstanceInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.InstanceDiffculty diffcultyInfo = 1;
  inline int diffcultyinfo_size() const;
  inline void clear_diffcultyinfo();
  static const int kDiffcultyInfoFieldNumber = 1;
  inline const ::PlayerInfo::InstanceDiffculty& diffcultyinfo(int index) const;
  inline ::PlayerInfo::InstanceDiffculty* mutable_diffcultyinfo(int index);
  inline ::PlayerInfo::InstanceDiffculty* add_diffcultyinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceDiffculty >&
      diffcultyinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceDiffculty >*
      mutable_diffcultyinfo();

  // repeated .PlayerInfo.InstanceVip vipInfo = 2;
  inline int vipinfo_size() const;
  inline void clear_vipinfo();
  static const int kVipInfoFieldNumber = 2;
  inline const ::PlayerInfo::InstanceVip& vipinfo(int index) const;
  inline ::PlayerInfo::InstanceVip* mutable_vipinfo(int index);
  inline ::PlayerInfo::InstanceVip* add_vipinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceVip >&
      vipinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceVip >*
      mutable_vipinfo();

  // repeated .PlayerInfo.InstanceDiffculty expInfo = 3;
  inline int expinfo_size() const;
  inline void clear_expinfo();
  static const int kExpInfoFieldNumber = 3;
  inline const ::PlayerInfo::InstanceDiffculty& expinfo(int index) const;
  inline ::PlayerInfo::InstanceDiffculty* mutable_expinfo(int index);
  inline ::PlayerInfo::InstanceDiffculty* add_expinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceDiffculty >&
      expinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceDiffculty >*
      mutable_expinfo();

  // repeated .PlayerInfo.InstanceDiffculty moneyInfo = 4;
  inline int moneyinfo_size() const;
  inline void clear_moneyinfo();
  static const int kMoneyInfoFieldNumber = 4;
  inline const ::PlayerInfo::InstanceDiffculty& moneyinfo(int index) const;
  inline ::PlayerInfo::InstanceDiffculty* mutable_moneyinfo(int index);
  inline ::PlayerInfo::InstanceDiffculty* add_moneyinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceDiffculty >&
      moneyinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceDiffculty >*
      mutable_moneyinfo();

  // @@protoc_insertion_point(class_scope:PlayerInfo.InstanceInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceDiffculty > diffcultyinfo_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceVip > vipinfo_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceDiffculty > expinfo_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceDiffculty > moneyinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static InstanceInfoList* default_instance_;
};
// -------------------------------------------------------------------

class InstanceDiffculty : public ::google::protobuf::Message {
 public:
  InstanceDiffculty();
  virtual ~InstanceDiffculty();

  InstanceDiffculty(const InstanceDiffculty& from);

  inline InstanceDiffculty& operator=(const InstanceDiffculty& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceDiffculty& default_instance();

  void Swap(InstanceDiffculty* other);

  // implements Message ----------------------------------------------

  InstanceDiffculty* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceDiffculty& from);
  void MergeFrom(const InstanceDiffculty& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 mapId = 1;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // optional int32 pass = 2;
  inline bool has_pass() const;
  inline void clear_pass();
  static const int kPassFieldNumber = 2;
  inline ::google::protobuf::int32 pass() const;
  inline void set_pass(::google::protobuf::int32 value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // optional int32 reset = 5;
  inline bool has_reset() const;
  inline void clear_reset();
  static const int kResetFieldNumber = 5;
  inline ::google::protobuf::int32 reset() const;
  inline void set_reset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.InstanceDiffculty)
 private:
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_pass();
  inline void clear_has_pass();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_reset();
  inline void clear_has_reset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 mapid_;
  ::google::protobuf::int32 pass_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 reset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static InstanceDiffculty* default_instance_;
};
// -------------------------------------------------------------------

class InstanceVip : public ::google::protobuf::Message {
 public:
  InstanceVip();
  virtual ~InstanceVip();

  InstanceVip(const InstanceVip& from);

  inline InstanceVip& operator=(const InstanceVip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceVip& default_instance();

  void Swap(InstanceVip* other);

  // implements Message ----------------------------------------------

  InstanceVip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceVip& from);
  void MergeFrom(const InstanceVip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 mapId = 1;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // optional int32 pass = 2;
  inline bool has_pass() const;
  inline void clear_pass();
  static const int kPassFieldNumber = 2;
  inline ::google::protobuf::int32 pass() const;
  inline void set_pass(::google::protobuf::int32 value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int64 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.InstanceVip)
 private:
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_pass();
  inline void clear_has_pass();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 mapid_;
  ::google::protobuf::int32 pass_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static InstanceVip* default_instance_;
};
// -------------------------------------------------------------------

class InstanceInfoTwoDays : public ::google::protobuf::Message {
 public:
  InstanceInfoTwoDays();
  virtual ~InstanceInfoTwoDays();

  InstanceInfoTwoDays(const InstanceInfoTwoDays& from);

  inline InstanceInfoTwoDays& operator=(const InstanceInfoTwoDays& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceInfoTwoDays& default_instance();

  void Swap(InstanceInfoTwoDays* other);

  // implements Message ----------------------------------------------

  InstanceInfoTwoDays* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceInfoTwoDays& from);
  void MergeFrom(const InstanceInfoTwoDays& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .PlayerInfo.InstanceInfoList todayinfo = 1;
  inline bool has_todayinfo() const;
  inline void clear_todayinfo();
  static const int kTodayinfoFieldNumber = 1;
  inline const ::PlayerInfo::InstanceInfoList& todayinfo() const;
  inline ::PlayerInfo::InstanceInfoList* mutable_todayinfo();
  inline ::PlayerInfo::InstanceInfoList* release_todayinfo();
  inline void set_allocated_todayinfo(::PlayerInfo::InstanceInfoList* todayinfo);

  // optional .PlayerInfo.InstanceInfoList yesterdayinfo = 2;
  inline bool has_yesterdayinfo() const;
  inline void clear_yesterdayinfo();
  static const int kYesterdayinfoFieldNumber = 2;
  inline const ::PlayerInfo::InstanceInfoList& yesterdayinfo() const;
  inline ::PlayerInfo::InstanceInfoList* mutable_yesterdayinfo();
  inline ::PlayerInfo::InstanceInfoList* release_yesterdayinfo();
  inline void set_allocated_yesterdayinfo(::PlayerInfo::InstanceInfoList* yesterdayinfo);

  // @@protoc_insertion_point(class_scope:PlayerInfo.InstanceInfoTwoDays)
 private:
  inline void set_has_todayinfo();
  inline void clear_has_todayinfo();
  inline void set_has_yesterdayinfo();
  inline void clear_has_yesterdayinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PlayerInfo::InstanceInfoList* todayinfo_;
  ::PlayerInfo::InstanceInfoList* yesterdayinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static InstanceInfoTwoDays* default_instance_;
};
// -------------------------------------------------------------------

class PrestigeInfoList : public ::google::protobuf::Message {
 public:
  PrestigeInfoList();
  virtual ~PrestigeInfoList();

  PrestigeInfoList(const PrestigeInfoList& from);

  inline PrestigeInfoList& operator=(const PrestigeInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrestigeInfoList& default_instance();

  void Swap(PrestigeInfoList* other);

  // implements Message ----------------------------------------------

  PrestigeInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrestigeInfoList& from);
  void MergeFrom(const PrestigeInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .PlayerInfo.PrestigeInfo info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::PlayerInfo::PrestigeInfo& info() const;
  inline ::PlayerInfo::PrestigeInfo* mutable_info();
  inline ::PlayerInfo::PrestigeInfo* release_info();
  inline void set_allocated_info(::PlayerInfo::PrestigeInfo* info);

  // optional .PlayerInfo.DBAchShopInfo shop = 2;
  inline bool has_shop() const;
  inline void clear_shop();
  static const int kShopFieldNumber = 2;
  inline const ::PlayerInfo::DBAchShopInfo& shop() const;
  inline ::PlayerInfo::DBAchShopInfo* mutable_shop();
  inline ::PlayerInfo::DBAchShopInfo* release_shop();
  inline void set_allocated_shop(::PlayerInfo::DBAchShopInfo* shop);

  // @@protoc_insertion_point(class_scope:PlayerInfo.PrestigeInfoList)
 private:
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_shop();
  inline void clear_has_shop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PlayerInfo::PrestigeInfo* info_;
  ::PlayerInfo::DBAchShopInfo* shop_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static PrestigeInfoList* default_instance_;
};
// -------------------------------------------------------------------

class PrestigeInfo : public ::google::protobuf::Message {
 public:
  PrestigeInfo();
  virtual ~PrestigeInfo();

  PrestigeInfo(const PrestigeInfo& from);

  inline PrestigeInfo& operator=(const PrestigeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrestigeInfo& default_instance();

  void Swap(PrestigeInfo* other);

  // implements Message ----------------------------------------------

  PrestigeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrestigeInfo& from);
  void MergeFrom(const PrestigeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.PrestigeContent prestigeinfos = 1;
  inline int prestigeinfos_size() const;
  inline void clear_prestigeinfos();
  static const int kPrestigeinfosFieldNumber = 1;
  inline const ::PlayerInfo::PrestigeContent& prestigeinfos(int index) const;
  inline ::PlayerInfo::PrestigeContent* mutable_prestigeinfos(int index);
  inline ::PlayerInfo::PrestigeContent* add_prestigeinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::PrestigeContent >&
      prestigeinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::PrestigeContent >*
      mutable_prestigeinfos();

  // @@protoc_insertion_point(class_scope:PlayerInfo.PrestigeInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::PrestigeContent > prestigeinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static PrestigeInfo* default_instance_;
};
// -------------------------------------------------------------------

class PrestigeContent : public ::google::protobuf::Message {
 public:
  PrestigeContent();
  virtual ~PrestigeContent();

  PrestigeContent(const PrestigeContent& from);

  inline PrestigeContent& operator=(const PrestigeContent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrestigeContent& default_instance();

  void Swap(PrestigeContent* other);

  // implements Message ----------------------------------------------

  PrestigeContent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrestigeContent& from);
  void MergeFrom(const PrestigeContent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 prestigeType = 1;
  inline bool has_prestigetype() const;
  inline void clear_prestigetype();
  static const int kPrestigeTypeFieldNumber = 1;
  inline ::google::protobuf::int32 prestigetype() const;
  inline void set_prestigetype(::google::protobuf::int32 value);

  // required int32 prestigeID = 2;
  inline bool has_prestigeid() const;
  inline void clear_prestigeid();
  static const int kPrestigeIDFieldNumber = 2;
  inline ::google::protobuf::int32 prestigeid() const;
  inline void set_prestigeid(::google::protobuf::int32 value);

  // required int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // required int32 isComplete = 4;
  inline bool has_iscomplete() const;
  inline void clear_iscomplete();
  static const int kIsCompleteFieldNumber = 4;
  inline ::google::protobuf::int32 iscomplete() const;
  inline void set_iscomplete(::google::protobuf::int32 value);

  // required int32 hadGet = 5;
  inline bool has_hadget() const;
  inline void clear_hadget();
  static const int kHadGetFieldNumber = 5;
  inline ::google::protobuf::int32 hadget() const;
  inline void set_hadget(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.PrestigeContent)
 private:
  inline void set_has_prestigetype();
  inline void clear_has_prestigetype();
  inline void set_has_prestigeid();
  inline void clear_has_prestigeid();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_iscomplete();
  inline void clear_has_iscomplete();
  inline void set_has_hadget();
  inline void clear_has_hadget();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 prestigetype_;
  ::google::protobuf::int32 prestigeid_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 iscomplete_;
  ::google::protobuf::int32 hadget_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static PrestigeContent* default_instance_;
};
// -------------------------------------------------------------------

class TitleInfoList : public ::google::protobuf::Message {
 public:
  TitleInfoList();
  virtual ~TitleInfoList();

  TitleInfoList(const TitleInfoList& from);

  inline TitleInfoList& operator=(const TitleInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TitleInfoList& default_instance();

  void Swap(TitleInfoList* other);

  // implements Message ----------------------------------------------

  TitleInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TitleInfoList& from);
  void MergeFrom(const TitleInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .PlayerInfo.TitleInfo info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::PlayerInfo::TitleInfo& info() const;
  inline ::PlayerInfo::TitleInfo* mutable_info();
  inline ::PlayerInfo::TitleInfo* release_info();
  inline void set_allocated_info(::PlayerInfo::TitleInfo* info);

  // @@protoc_insertion_point(class_scope:PlayerInfo.TitleInfoList)
 private:
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PlayerInfo::TitleInfo* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static TitleInfoList* default_instance_;
};
// -------------------------------------------------------------------

class TitleInfo : public ::google::protobuf::Message {
 public:
  TitleInfo();
  virtual ~TitleInfo();

  TitleInfo(const TitleInfo& from);

  inline TitleInfo& operator=(const TitleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TitleInfo& default_instance();

  void Swap(TitleInfo* other);

  // implements Message ----------------------------------------------

  TitleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TitleInfo& from);
  void MergeFrom(const TitleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.TitleStatus titleinfo = 1;
  inline int titleinfo_size() const;
  inline void clear_titleinfo();
  static const int kTitleinfoFieldNumber = 1;
  inline const ::PlayerInfo::TitleStatus& titleinfo(int index) const;
  inline ::PlayerInfo::TitleStatus* mutable_titleinfo(int index);
  inline ::PlayerInfo::TitleStatus* add_titleinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::TitleStatus >&
      titleinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::TitleStatus >*
      mutable_titleinfo();

  // @@protoc_insertion_point(class_scope:PlayerInfo.TitleInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::TitleStatus > titleinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static TitleInfo* default_instance_;
};
// -------------------------------------------------------------------

class TitleStatus : public ::google::protobuf::Message {
 public:
  TitleStatus();
  virtual ~TitleStatus();

  TitleStatus(const TitleStatus& from);

  inline TitleStatus& operator=(const TitleStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TitleStatus& default_instance();

  void Swap(TitleStatus* other);

  // implements Message ----------------------------------------------

  TitleStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TitleStatus& from);
  void MergeFrom(const TitleStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 titleId = 1;
  inline bool has_titleid() const;
  inline void clear_titleid();
  static const int kTitleIdFieldNumber = 1;
  inline ::google::protobuf::int32 titleid() const;
  inline void set_titleid(::google::protobuf::int32 value);

  // required int32 titleStatus = 2;
  inline bool has_titlestatus() const;
  inline void clear_titlestatus();
  static const int kTitleStatusFieldNumber = 2;
  inline ::google::protobuf::int32 titlestatus() const;
  inline void set_titlestatus(::google::protobuf::int32 value);

  // required int32 titleActive = 3;
  inline bool has_titleactive() const;
  inline void clear_titleactive();
  static const int kTitleActiveFieldNumber = 3;
  inline ::google::protobuf::int32 titleactive() const;
  inline void set_titleactive(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.TitleStatus)
 private:
  inline void set_has_titleid();
  inline void clear_has_titleid();
  inline void set_has_titlestatus();
  inline void clear_has_titlestatus();
  inline void set_has_titleactive();
  inline void clear_has_titleactive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 titleid_;
  ::google::protobuf::int32 titlestatus_;
  ::google::protobuf::int32 titleactive_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static TitleStatus* default_instance_;
};
// -------------------------------------------------------------------

class DestinationInfoList : public ::google::protobuf::Message {
 public:
  DestinationInfoList();
  virtual ~DestinationInfoList();

  DestinationInfoList(const DestinationInfoList& from);

  inline DestinationInfoList& operator=(const DestinationInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DestinationInfoList& default_instance();

  void Swap(DestinationInfoList* other);

  // implements Message ----------------------------------------------

  DestinationInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DestinationInfoList& from);
  void MergeFrom(const DestinationInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .PlayerInfo.DestinationInfo info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::PlayerInfo::DestinationInfo& info() const;
  inline ::PlayerInfo::DestinationInfo* mutable_info();
  inline ::PlayerInfo::DestinationInfo* release_info();
  inline void set_allocated_info(::PlayerInfo::DestinationInfo* info);

  // @@protoc_insertion_point(class_scope:PlayerInfo.DestinationInfoList)
 private:
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PlayerInfo::DestinationInfo* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static DestinationInfoList* default_instance_;
};
// -------------------------------------------------------------------

class DestinationInfo : public ::google::protobuf::Message {
 public:
  DestinationInfo();
  virtual ~DestinationInfo();

  DestinationInfo(const DestinationInfo& from);

  inline DestinationInfo& operator=(const DestinationInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DestinationInfo& default_instance();

  void Swap(DestinationInfo* other);

  // implements Message ----------------------------------------------

  DestinationInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DestinationInfo& from);
  void MergeFrom(const DestinationInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.DestinationContent destinationinfos = 1;
  inline int destinationinfos_size() const;
  inline void clear_destinationinfos();
  static const int kDestinationinfosFieldNumber = 1;
  inline const ::PlayerInfo::DestinationContent& destinationinfos(int index) const;
  inline ::PlayerInfo::DestinationContent* mutable_destinationinfos(int index);
  inline ::PlayerInfo::DestinationContent* add_destinationinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DestinationContent >&
      destinationinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DestinationContent >*
      mutable_destinationinfos();

  // @@protoc_insertion_point(class_scope:PlayerInfo.DestinationInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DestinationContent > destinationinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static DestinationInfo* default_instance_;
};
// -------------------------------------------------------------------

class DestinationContent : public ::google::protobuf::Message {
 public:
  DestinationContent();
  virtual ~DestinationContent();

  DestinationContent(const DestinationContent& from);

  inline DestinationContent& operator=(const DestinationContent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DestinationContent& default_instance();

  void Swap(DestinationContent* other);

  // implements Message ----------------------------------------------

  DestinationContent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DestinationContent& from);
  void MergeFrom(const DestinationContent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 destinationID = 1;
  inline bool has_destinationid() const;
  inline void clear_destinationid();
  static const int kDestinationIDFieldNumber = 1;
  inline ::google::protobuf::int32 destinationid() const;
  inline void set_destinationid(::google::protobuf::int32 value);

  // optional int32 destinationType = 2;
  inline bool has_destinationtype() const;
  inline void clear_destinationtype();
  static const int kDestinationTypeFieldNumber = 2;
  inline ::google::protobuf::int32 destinationtype() const;
  inline void set_destinationtype(::google::protobuf::int32 value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 isComplete = 4;
  inline bool has_iscomplete() const;
  inline void clear_iscomplete();
  static const int kIsCompleteFieldNumber = 4;
  inline ::google::protobuf::int32 iscomplete() const;
  inline void set_iscomplete(::google::protobuf::int32 value);

  // optional int32 hadGet = 5;
  inline bool has_hadget() const;
  inline void clear_hadget();
  static const int kHadGetFieldNumber = 5;
  inline ::google::protobuf::int32 hadget() const;
  inline void set_hadget(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.DestinationContent)
 private:
  inline void set_has_destinationid();
  inline void clear_has_destinationid();
  inline void set_has_destinationtype();
  inline void clear_has_destinationtype();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_iscomplete();
  inline void clear_has_iscomplete();
  inline void set_has_hadget();
  inline void clear_has_hadget();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 destinationid_;
  ::google::protobuf::int32 destinationtype_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 iscomplete_;
  ::google::protobuf::int32 hadget_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static DestinationContent* default_instance_;
};
// -------------------------------------------------------------------

class SignInInfo : public ::google::protobuf::Message {
 public:
  SignInInfo();
  virtual ~SignInInfo();

  SignInInfo(const SignInInfo& from);

  inline SignInInfo& operator=(const SignInInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignInInfo& default_instance();

  void Swap(SignInInfo* other);

  // implements Message ----------------------------------------------

  SignInInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignInInfo& from);
  void MergeFrom(const SignInInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 SignIn = 1;
  inline bool has_signin() const;
  inline void clear_signin();
  static const int kSignInFieldNumber = 1;
  inline ::google::protobuf::int32 signin() const;
  inline void set_signin(::google::protobuf::int32 value);

  // optional int32 Reward = 2;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 2;
  inline ::google::protobuf::int32 reward() const;
  inline void set_reward(::google::protobuf::int32 value);

  // optional int32 totalLogin = 3;
  inline bool has_totallogin() const;
  inline void clear_totallogin();
  static const int kTotalLoginFieldNumber = 3;
  inline ::google::protobuf::int32 totallogin() const;
  inline void set_totallogin(::google::protobuf::int32 value);

  // optional int32 totalLoginReward = 4;
  inline bool has_totalloginreward() const;
  inline void clear_totalloginreward();
  static const int kTotalLoginRewardFieldNumber = 4;
  inline ::google::protobuf::int32 totalloginreward() const;
  inline void set_totalloginreward(::google::protobuf::int32 value);

  // optional bool firstChargeOverFlag = 5;
  inline bool has_firstchargeoverflag() const;
  inline void clear_firstchargeoverflag();
  static const int kFirstChargeOverFlagFieldNumber = 5;
  inline bool firstchargeoverflag() const;
  inline void set_firstchargeoverflag(bool value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.SignInInfo)
 private:
  inline void set_has_signin();
  inline void clear_has_signin();
  inline void set_has_reward();
  inline void clear_has_reward();
  inline void set_has_totallogin();
  inline void clear_has_totallogin();
  inline void set_has_totalloginreward();
  inline void clear_has_totalloginreward();
  inline void set_has_firstchargeoverflag();
  inline void clear_has_firstchargeoverflag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 signin_;
  ::google::protobuf::int32 reward_;
  ::google::protobuf::int32 totallogin_;
  ::google::protobuf::int32 totalloginreward_;
  bool firstchargeoverflag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static SignInInfo* default_instance_;
};
// -------------------------------------------------------------------

class CounterService : public ::google::protobuf::Message {
 public:
  CounterService();
  virtual ~CounterService();

  CounterService(const CounterService& from);

  inline CounterService& operator=(const CounterService& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CounterService& default_instance();

  void Swap(CounterService* other);

  // implements Message ----------------------------------------------

  CounterService* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CounterService& from);
  void MergeFrom(const CounterService& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 id = 1;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id(int index) const;
  inline void set_id(int index, ::google::protobuf::int32 value);
  inline void add_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id();

  // repeated int32 num = 2;
  inline int num_size() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num(int index) const;
  inline void set_num(int index, ::google::protobuf::int32 value);
  inline void add_num(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      num() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_num();

  // @@protoc_insertion_point(class_scope:PlayerInfo.CounterService)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static CounterService* default_instance_;
};
// -------------------------------------------------------------------

class CounterServiceList : public ::google::protobuf::Message {
 public:
  CounterServiceList();
  virtual ~CounterServiceList();

  CounterServiceList(const CounterServiceList& from);

  inline CounterServiceList& operator=(const CounterServiceList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CounterServiceList& default_instance();

  void Swap(CounterServiceList* other);

  // implements Message ----------------------------------------------

  CounterServiceList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CounterServiceList& from);
  void MergeFrom(const CounterServiceList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .PlayerInfo.CounterService counter = 1;
  inline bool has_counter() const;
  inline void clear_counter();
  static const int kCounterFieldNumber = 1;
  inline const ::PlayerInfo::CounterService& counter() const;
  inline ::PlayerInfo::CounterService* mutable_counter();
  inline ::PlayerInfo::CounterService* release_counter();
  inline void set_allocated_counter(::PlayerInfo::CounterService* counter);

  // optional .PlayerInfo.CounterService yesterdaycounter = 2;
  inline bool has_yesterdaycounter() const;
  inline void clear_yesterdaycounter();
  static const int kYesterdaycounterFieldNumber = 2;
  inline const ::PlayerInfo::CounterService& yesterdaycounter() const;
  inline ::PlayerInfo::CounterService* mutable_yesterdaycounter();
  inline ::PlayerInfo::CounterService* release_yesterdaycounter();
  inline void set_allocated_yesterdaycounter(::PlayerInfo::CounterService* yesterdaycounter);

  // optional int64 lastResetTime = 3;
  inline bool has_lastresettime() const;
  inline void clear_lastresettime();
  static const int kLastResetTimeFieldNumber = 3;
  inline ::google::protobuf::int64 lastresettime() const;
  inline void set_lastresettime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.CounterServiceList)
 private:
  inline void set_has_counter();
  inline void clear_has_counter();
  inline void set_has_yesterdaycounter();
  inline void clear_has_yesterdaycounter();
  inline void set_has_lastresettime();
  inline void clear_has_lastresettime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::PlayerInfo::CounterService* counter_;
  ::PlayerInfo::CounterService* yesterdaycounter_;
  ::google::protobuf::int64 lastresettime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static CounterServiceList* default_instance_;
};
// -------------------------------------------------------------------

class EscortInfo : public ::google::protobuf::Message {
 public:
  EscortInfo();
  virtual ~EscortInfo();

  EscortInfo(const EscortInfo& from);

  inline EscortInfo& operator=(const EscortInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EscortInfo& default_instance();

  void Swap(EscortInfo* other);

  // implements Message ----------------------------------------------

  EscortInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EscortInfo& from);
  void MergeFrom(const EscortInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 line = 1;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 1;
  inline ::google::protobuf::int32 line() const;
  inline void set_line(::google::protobuf::int32 value);

  // optional int32 quality = 2;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 2;
  inline ::google::protobuf::int32 quality() const;
  inline void set_quality(::google::protobuf::int32 value);

  // optional int32 robTimes = 3;
  inline bool has_robtimes() const;
  inline void clear_robtimes();
  static const int kRobTimesFieldNumber = 3;
  inline ::google::protobuf::int32 robtimes() const;
  inline void set_robtimes(::google::protobuf::int32 value);

  // optional int64 leftTimes = 4;
  inline bool has_lefttimes() const;
  inline void clear_lefttimes();
  static const int kLeftTimesFieldNumber = 4;
  inline ::google::protobuf::int64 lefttimes() const;
  inline void set_lefttimes(::google::protobuf::int64 value);

  // optional int64 speedlefttime = 5;
  inline bool has_speedlefttime() const;
  inline void clear_speedlefttime();
  static const int kSpeedlefttimeFieldNumber = 5;
  inline ::google::protobuf::int64 speedlefttime() const;
  inline void set_speedlefttime(::google::protobuf::int64 value);

  // optional int64 mapid = 6;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapidFieldNumber = 6;
  inline ::google::protobuf::int64 mapid() const;
  inline void set_mapid(::google::protobuf::int64 value);

  // optional int32 xpos = 7;
  inline bool has_xpos() const;
  inline void clear_xpos();
  static const int kXposFieldNumber = 7;
  inline ::google::protobuf::int32 xpos() const;
  inline void set_xpos(::google::protobuf::int32 value);

  // optional int32 ypos = 8;
  inline bool has_ypos() const;
  inline void clear_ypos();
  static const int kYposFieldNumber = 8;
  inline ::google::protobuf::int32 ypos() const;
  inline void set_ypos(::google::protobuf::int32 value);

  // optional int32 hp = 9;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 9;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // optional int32 num = 10;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 10;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 rewardExp = 11;
  inline bool has_rewardexp() const;
  inline void clear_rewardexp();
  static const int kRewardExpFieldNumber = 11;
  inline ::google::protobuf::int32 rewardexp() const;
  inline void set_rewardexp(::google::protobuf::int32 value);

  // optional int32 rewardMoney = 12;
  inline bool has_rewardmoney() const;
  inline void clear_rewardmoney();
  static const int kRewardMoneyFieldNumber = 12;
  inline ::google::protobuf::int32 rewardmoney() const;
  inline void set_rewardmoney(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.EscortInfo)
 private:
  inline void set_has_line();
  inline void clear_has_line();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_robtimes();
  inline void clear_has_robtimes();
  inline void set_has_lefttimes();
  inline void clear_has_lefttimes();
  inline void set_has_speedlefttime();
  inline void clear_has_speedlefttime();
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_xpos();
  inline void clear_has_xpos();
  inline void set_has_ypos();
  inline void clear_has_ypos();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_rewardexp();
  inline void clear_has_rewardexp();
  inline void set_has_rewardmoney();
  inline void clear_has_rewardmoney();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 line_;
  ::google::protobuf::int32 quality_;
  ::google::protobuf::int64 lefttimes_;
  ::google::protobuf::int64 speedlefttime_;
  ::google::protobuf::int32 robtimes_;
  ::google::protobuf::int32 xpos_;
  ::google::protobuf::int64 mapid_;
  ::google::protobuf::int32 ypos_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 rewardexp_;
  ::google::protobuf::int32 rewardmoney_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static EscortInfo* default_instance_;
};
// -------------------------------------------------------------------

class DanLuInfo : public ::google::protobuf::Message {
 public:
  DanLuInfo();
  virtual ~DanLuInfo();

  DanLuInfo(const DanLuInfo& from);

  inline DanLuInfo& operator=(const DanLuInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DanLuInfo& default_instance();

  void Swap(DanLuInfo* other);

  // implements Message ----------------------------------------------

  DanLuInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DanLuInfo& from);
  void MergeFrom(const DanLuInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 danluId = 1;
  inline bool has_danluid() const;
  inline void clear_danluid();
  static const int kDanluIdFieldNumber = 1;
  inline ::google::protobuf::int32 danluid() const;
  inline void set_danluid(::google::protobuf::int32 value);

  // optional int32 exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int32 point = 3;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 3;
  inline ::google::protobuf::int32 point() const;
  inline void set_point(::google::protobuf::int32 value);

  // repeated int32 itemID = 4;
  inline int itemid_size() const;
  inline void clear_itemid();
  static const int kItemIDFieldNumber = 4;
  inline ::google::protobuf::int32 itemid(int index) const;
  inline void set_itemid(int index, ::google::protobuf::int32 value);
  inline void add_itemid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      itemid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_itemid();

  // optional int32 produceNum = 5;
  inline bool has_producenum() const;
  inline void clear_producenum();
  static const int kProduceNumFieldNumber = 5;
  inline ::google::protobuf::int32 producenum() const;
  inline void set_producenum(::google::protobuf::int32 value);

  // repeated int32 itemPos = 6;
  inline int itempos_size() const;
  inline void clear_itempos();
  static const int kItemPosFieldNumber = 6;
  inline ::google::protobuf::int32 itempos(int index) const;
  inline void set_itempos(int index, ::google::protobuf::int32 value);
  inline void add_itempos(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      itempos() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_itempos();

  // repeated int32 itemNum = 7;
  inline int itemnum_size() const;
  inline void clear_itemnum();
  static const int kItemNumFieldNumber = 7;
  inline ::google::protobuf::int32 itemnum(int index) const;
  inline void set_itemnum(int index, ::google::protobuf::int32 value);
  inline void add_itemnum(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      itemnum() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_itemnum();

  // @@protoc_insertion_point(class_scope:PlayerInfo.DanLuInfo)
 private:
  inline void set_has_danluid();
  inline void clear_has_danluid();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_producenum();
  inline void clear_has_producenum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 danluid_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > itemid_;
  ::google::protobuf::int32 point_;
  ::google::protobuf::int32 producenum_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > itempos_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > itemnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static DanLuInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayerVipInfo : public ::google::protobuf::Message {
 public:
  PlayerVipInfo();
  virtual ~PlayerVipInfo();

  PlayerVipInfo(const PlayerVipInfo& from);

  inline PlayerVipInfo& operator=(const PlayerVipInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerVipInfo& default_instance();

  void Swap(PlayerVipInfo* other);

  // implements Message ----------------------------------------------

  PlayerVipInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerVipInfo& from);
  void MergeFrom(const PlayerVipInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 giftInfo = 1;
  inline bool has_giftinfo() const;
  inline void clear_giftinfo();
  static const int kGiftInfoFieldNumber = 1;
  inline ::google::protobuf::int32 giftinfo() const;
  inline void set_giftinfo(::google::protobuf::int32 value);

  // optional int32 vipAddUpGold = 2;
  inline bool has_vipaddupgold() const;
  inline void clear_vipaddupgold();
  static const int kVipAddUpGoldFieldNumber = 2;
  inline ::google::protobuf::int32 vipaddupgold() const;
  inline void set_vipaddupgold(::google::protobuf::int32 value);

  // optional int64 endTime = 3;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 3;
  inline ::google::protobuf::int64 endtime() const;
  inline void set_endtime(::google::protobuf::int64 value);

  // optional int32 day = 4;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 4;
  inline ::google::protobuf::int32 day() const;
  inline void set_day(::google::protobuf::int32 value);

  // optional int32 maxDay = 5;
  inline bool has_maxday() const;
  inline void clear_maxday();
  static const int kMaxDayFieldNumber = 5;
  inline ::google::protobuf::int32 maxday() const;
  inline void set_maxday(::google::protobuf::int32 value);

  // optional int64 lastTime = 6;
  inline bool has_lasttime() const;
  inline void clear_lasttime();
  static const int kLastTimeFieldNumber = 6;
  inline ::google::protobuf::int64 lasttime() const;
  inline void set_lasttime(::google::protobuf::int64 value);

  // repeated int64 item = 7;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 7;
  inline ::google::protobuf::int64 item(int index) const;
  inline void set_item(int index, ::google::protobuf::int64 value);
  inline void add_item(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      item() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_item();

  // optional int32 vipCardLv = 8;
  inline bool has_vipcardlv() const;
  inline void clear_vipcardlv();
  static const int kVipCardLvFieldNumber = 8;
  inline ::google::protobuf::int32 vipcardlv() const;
  inline void set_vipcardlv(::google::protobuf::int32 value);

  // optional int64 vipCardBeginTime = 9;
  inline bool has_vipcardbegintime() const;
  inline void clear_vipcardbegintime();
  static const int kVipCardBeginTimeFieldNumber = 9;
  inline ::google::protobuf::int64 vipcardbegintime() const;
  inline void set_vipcardbegintime(::google::protobuf::int64 value);

  // optional int64 valideSecs = 10;
  inline bool has_validesecs() const;
  inline void clear_validesecs();
  static const int kValideSecsFieldNumber = 10;
  inline ::google::protobuf::int64 validesecs() const;
  inline void set_validesecs(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.PlayerVipInfo)
 private:
  inline void set_has_giftinfo();
  inline void clear_has_giftinfo();
  inline void set_has_vipaddupgold();
  inline void clear_has_vipaddupgold();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_maxday();
  inline void clear_has_maxday();
  inline void set_has_lasttime();
  inline void clear_has_lasttime();
  inline void set_has_vipcardlv();
  inline void clear_has_vipcardlv();
  inline void set_has_vipcardbegintime();
  inline void clear_has_vipcardbegintime();
  inline void set_has_validesecs();
  inline void clear_has_validesecs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 giftinfo_;
  ::google::protobuf::int32 vipaddupgold_;
  ::google::protobuf::int64 endtime_;
  ::google::protobuf::int32 day_;
  ::google::protobuf::int32 maxday_;
  ::google::protobuf::int64 lasttime_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > item_;
  ::google::protobuf::int64 vipcardbegintime_;
  ::google::protobuf::int64 validesecs_;
  ::google::protobuf::int32 vipcardlv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static PlayerVipInfo* default_instance_;
};
// -------------------------------------------------------------------

class PassivePlayerSkill : public ::google::protobuf::Message {
 public:
  PassivePlayerSkill();
  virtual ~PassivePlayerSkill();

  PassivePlayerSkill(const PassivePlayerSkill& from);

  inline PassivePlayerSkill& operator=(const PassivePlayerSkill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PassivePlayerSkill& default_instance();

  void Swap(PassivePlayerSkill* other);

  // implements Message ----------------------------------------------

  PassivePlayerSkill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PassivePlayerSkill& from);
  void MergeFrom(const PassivePlayerSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional int32 skillid = 2;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillidFieldNumber = 2;
  inline ::google::protobuf::int32 skillid() const;
  inline void set_skillid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.PassivePlayerSkill)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_skillid();
  inline void clear_has_skillid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 skillid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static PassivePlayerSkill* default_instance_;
};
// -------------------------------------------------------------------

class MagicWeapon : public ::google::protobuf::Message {
 public:
  MagicWeapon();
  virtual ~MagicWeapon();

  MagicWeapon(const MagicWeapon& from);

  inline MagicWeapon& operator=(const MagicWeapon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MagicWeapon& default_instance();

  void Swap(MagicWeapon* other);

  // implements Message ----------------------------------------------

  MagicWeapon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MagicWeapon& from);
  void MergeFrom(const MagicWeapon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1 [default = 0];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // repeated int32 skillid = 3;
  inline int skillid_size() const;
  inline void clear_skillid();
  static const int kSkillidFieldNumber = 3;
  inline ::google::protobuf::int32 skillid(int index) const;
  inline void set_skillid(int index, ::google::protobuf::int32 value);
  inline void add_skillid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      skillid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_skillid();

  // optional int64 advancetime = 4;
  inline bool has_advancetime() const;
  inline void clear_advancetime();
  static const int kAdvancetimeFieldNumber = 4;
  inline ::google::protobuf::int64 advancetime() const;
  inline void set_advancetime(::google::protobuf::int64 value);

  // optional int32 tempID = 5;
  inline bool has_tempid() const;
  inline void clear_tempid();
  static const int kTempIDFieldNumber = 5;
  inline ::google::protobuf::int32 tempid() const;
  inline void set_tempid(::google::protobuf::int32 value);

  // optional int32 needtime = 6;
  inline bool has_needtime() const;
  inline void clear_needtime();
  static const int kNeedtimeFieldNumber = 6;
  inline ::google::protobuf::int32 needtime() const;
  inline void set_needtime(::google::protobuf::int32 value);

  // repeated .PlayerInfo.PassivePlayerSkill passiveSkillList = 7;
  inline int passiveskilllist_size() const;
  inline void clear_passiveskilllist();
  static const int kPassiveSkillListFieldNumber = 7;
  inline const ::PlayerInfo::PassivePlayerSkill& passiveskilllist(int index) const;
  inline ::PlayerInfo::PassivePlayerSkill* mutable_passiveskilllist(int index);
  inline ::PlayerInfo::PassivePlayerSkill* add_passiveskilllist();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::PassivePlayerSkill >&
      passiveskilllist() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::PassivePlayerSkill >*
      mutable_passiveskilllist();

  // optional bool firstReflush = 8;
  inline bool has_firstreflush() const;
  inline void clear_firstreflush();
  static const int kFirstReflushFieldNumber = 8;
  inline bool firstreflush() const;
  inline void set_firstreflush(bool value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.MagicWeapon)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_advancetime();
  inline void clear_has_advancetime();
  inline void set_has_tempid();
  inline void clear_has_tempid();
  inline void set_has_needtime();
  inline void clear_has_needtime();
  inline void set_has_firstreflush();
  inline void clear_has_firstreflush();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > skillid_;
  ::google::protobuf::int64 advancetime_;
  ::google::protobuf::int32 tempid_;
  ::google::protobuf::int32 needtime_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::PassivePlayerSkill > passiveskilllist_;
  bool firstreflush_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static MagicWeapon* default_instance_;
};
// -------------------------------------------------------------------

class RandCJobLucky_CJobItem : public ::google::protobuf::Message {
 public:
  RandCJobLucky_CJobItem();
  virtual ~RandCJobLucky_CJobItem();

  RandCJobLucky_CJobItem(const RandCJobLucky_CJobItem& from);

  inline RandCJobLucky_CJobItem& operator=(const RandCJobLucky_CJobItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandCJobLucky_CJobItem& default_instance();

  void Swap(RandCJobLucky_CJobItem* other);

  // implements Message ----------------------------------------------

  RandCJobLucky_CJobItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RandCJobLucky_CJobItem& from);
  void MergeFrom(const RandCJobLucky_CJobItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.RandCJobLucky.CJobItem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_exp();
  inline void clear_has_exp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 exp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static RandCJobLucky_CJobItem* default_instance_;
};
// -------------------------------------------------------------------

class RandCJobLucky_CreatureCJob : public ::google::protobuf::Message {
 public:
  RandCJobLucky_CreatureCJob();
  virtual ~RandCJobLucky_CreatureCJob();

  RandCJobLucky_CreatureCJob(const RandCJobLucky_CreatureCJob& from);

  inline RandCJobLucky_CreatureCJob& operator=(const RandCJobLucky_CreatureCJob& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandCJobLucky_CreatureCJob& default_instance();

  void Swap(RandCJobLucky_CreatureCJob* other);

  // implements Message ----------------------------------------------

  RandCJobLucky_CreatureCJob* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RandCJobLucky_CreatureCJob& from);
  void MergeFrom(const RandCJobLucky_CreatureCJob& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // repeated .PlayerInfo.RandCJobLucky.CJobItem item = 2;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::PlayerInfo::RandCJobLucky_CJobItem& item(int index) const;
  inline ::PlayerInfo::RandCJobLucky_CJobItem* mutable_item(int index);
  inline ::PlayerInfo::RandCJobLucky_CJobItem* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::RandCJobLucky_CJobItem >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::RandCJobLucky_CJobItem >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:PlayerInfo.RandCJobLucky.CreatureCJob)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::RandCJobLucky_CJobItem > item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static RandCJobLucky_CreatureCJob* default_instance_;
};
// -------------------------------------------------------------------

class RandCJobLucky : public ::google::protobuf::Message {
 public:
  RandCJobLucky();
  virtual ~RandCJobLucky();

  RandCJobLucky(const RandCJobLucky& from);

  inline RandCJobLucky& operator=(const RandCJobLucky& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RandCJobLucky& default_instance();

  void Swap(RandCJobLucky* other);

  // implements Message ----------------------------------------------

  RandCJobLucky* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RandCJobLucky& from);
  void MergeFrom(const RandCJobLucky& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RandCJobLucky_CJobItem CJobItem;
  typedef RandCJobLucky_CreatureCJob CreatureCJob;

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.RandCJobLucky.CJobItem package = 1;
  inline int package_size() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 1;
  inline const ::PlayerInfo::RandCJobLucky_CJobItem& package(int index) const;
  inline ::PlayerInfo::RandCJobLucky_CJobItem* mutable_package(int index);
  inline ::PlayerInfo::RandCJobLucky_CJobItem* add_package();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::RandCJobLucky_CJobItem >&
      package() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::RandCJobLucky_CJobItem >*
      mutable_package();

  // repeated int32 exampackage = 2;
  inline int exampackage_size() const;
  inline void clear_exampackage();
  static const int kExampackageFieldNumber = 2;
  inline ::google::protobuf::int32 exampackage(int index) const;
  inline void set_exampackage(int index, ::google::protobuf::int32 value);
  inline void add_exampackage(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      exampackage() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_exampackage();

  // repeated .PlayerInfo.RandCJobLucky.CreatureCJob rolepackage = 3;
  inline int rolepackage_size() const;
  inline void clear_rolepackage();
  static const int kRolepackageFieldNumber = 3;
  inline const ::PlayerInfo::RandCJobLucky_CreatureCJob& rolepackage(int index) const;
  inline ::PlayerInfo::RandCJobLucky_CreatureCJob* mutable_rolepackage(int index);
  inline ::PlayerInfo::RandCJobLucky_CreatureCJob* add_rolepackage();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::RandCJobLucky_CreatureCJob >&
      rolepackage() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::RandCJobLucky_CreatureCJob >*
      mutable_rolepackage();

  // optional int32 jobexp = 4;
  inline bool has_jobexp() const;
  inline void clear_jobexp();
  static const int kJobexpFieldNumber = 4;
  inline ::google::protobuf::int32 jobexp() const;
  inline void set_jobexp(::google::protobuf::int32 value);

  // optional int32 randNum = 5;
  inline bool has_randnum() const;
  inline void clear_randnum();
  static const int kRandNumFieldNumber = 5;
  inline ::google::protobuf::int32 randnum() const;
  inline void set_randnum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.RandCJobLucky)
 private:
  inline void set_has_jobexp();
  inline void clear_has_jobexp();
  inline void set_has_randnum();
  inline void clear_has_randnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::RandCJobLucky_CJobItem > package_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > exampackage_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::RandCJobLucky_CreatureCJob > rolepackage_;
  ::google::protobuf::int32 jobexp_;
  ::google::protobuf::int32 randnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static RandCJobLucky* default_instance_;
};
// -------------------------------------------------------------------

class LucklyTurntable : public ::google::protobuf::Message {
 public:
  LucklyTurntable();
  virtual ~LucklyTurntable();

  LucklyTurntable(const LucklyTurntable& from);

  inline LucklyTurntable& operator=(const LucklyTurntable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LucklyTurntable& default_instance();

  void Swap(LucklyTurntable* other);

  // implements Message ----------------------------------------------

  LucklyTurntable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LucklyTurntable& from);
  void MergeFrom(const LucklyTurntable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 tm = 1;
  inline bool has_tm() const;
  inline void clear_tm();
  static const int kTmFieldNumber = 1;
  inline ::google::protobuf::int64 tm() const;
  inline void set_tm(::google::protobuf::int64 value);

  // repeated int32 reawidList = 2;
  inline int reawidlist_size() const;
  inline void clear_reawidlist();
  static const int kReawidListFieldNumber = 2;
  inline ::google::protobuf::int32 reawidlist(int index) const;
  inline void set_reawidlist(int index, ::google::protobuf::int32 value);
  inline void add_reawidlist(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      reawidlist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_reawidlist();

  // repeated int32 itemid = 3;
  inline int itemid_size() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 3;
  inline ::google::protobuf::int32 itemid(int index) const;
  inline void set_itemid(int index, ::google::protobuf::int32 value);
  inline void add_itemid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      itemid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_itemid();

  // repeated int32 num = 4;
  inline int num_size() const;
  inline void clear_num();
  static const int kNumFieldNumber = 4;
  inline ::google::protobuf::int32 num(int index) const;
  inline void set_num(int index, ::google::protobuf::int32 value);
  inline void add_num(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      num() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_num();

  // repeated int32 id = 5;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 5;
  inline ::google::protobuf::int32 id(int index) const;
  inline void set_id(int index, ::google::protobuf::int32 value);
  inline void add_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id();

  // repeated int32 bindType = 6;
  inline int bindtype_size() const;
  inline void clear_bindtype();
  static const int kBindTypeFieldNumber = 6;
  inline ::google::protobuf::int32 bindtype(int index) const;
  inline void set_bindtype(int index, ::google::protobuf::int32 value);
  inline void add_bindtype(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      bindtype() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_bindtype();

  // @@protoc_insertion_point(class_scope:PlayerInfo.LucklyTurntable)
 private:
  inline void set_has_tm();
  inline void clear_has_tm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 tm_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > reawidlist_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > itemid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > num_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > bindtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static LucklyTurntable* default_instance_;
};
// -------------------------------------------------------------------

class Activity : public ::google::protobuf::Message {
 public:
  Activity();
  virtual ~Activity();

  Activity(const Activity& from);

  inline Activity& operator=(const Activity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Activity& default_instance();

  void Swap(Activity* other);

  // implements Message ----------------------------------------------

  Activity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Activity& from);
  void MergeFrom(const Activity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 curnode = 1;
  inline bool has_curnode() const;
  inline void clear_curnode();
  static const int kCurnodeFieldNumber = 1;
  inline ::google::protobuf::int32 curnode() const;
  inline void set_curnode(::google::protobuf::int32 value);

  // optional int32 preward = 2;
  inline bool has_preward() const;
  inline void clear_preward();
  static const int kPrewardFieldNumber = 2;
  inline ::google::protobuf::int32 preward() const;
  inline void set_preward(::google::protobuf::int32 value);

  // optional int32 pastnode = 3;
  inline bool has_pastnode() const;
  inline void clear_pastnode();
  static const int kPastnodeFieldNumber = 3;
  inline ::google::protobuf::int32 pastnode() const;
  inline void set_pastnode(::google::protobuf::int32 value);

  // optional int64 swapstime = 4;
  inline bool has_swapstime() const;
  inline void clear_swapstime();
  static const int kSwapstimeFieldNumber = 4;
  inline ::google::protobuf::int64 swapstime() const;
  inline void set_swapstime(::google::protobuf::int64 value);

  // repeated .PlayerInfo.ActivityYellowVipReward vipreward = 5;
  inline int vipreward_size() const;
  inline void clear_vipreward();
  static const int kViprewardFieldNumber = 5;
  inline const ::PlayerInfo::ActivityYellowVipReward& vipreward(int index) const;
  inline ::PlayerInfo::ActivityYellowVipReward* mutable_vipreward(int index);
  inline ::PlayerInfo::ActivityYellowVipReward* add_vipreward();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ActivityYellowVipReward >&
      vipreward() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ActivityYellowVipReward >*
      mutable_vipreward();

  // repeated int32 TreasonKingBestTime = 6;
  inline int treasonkingbesttime_size() const;
  inline void clear_treasonkingbesttime();
  static const int kTreasonKingBestTimeFieldNumber = 6;
  inline ::google::protobuf::int32 treasonkingbesttime(int index) const;
  inline void set_treasonkingbesttime(int index, ::google::protobuf::int32 value);
  inline void add_treasonkingbesttime(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      treasonkingbesttime() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_treasonkingbesttime();

  // @@protoc_insertion_point(class_scope:PlayerInfo.Activity)
 private:
  inline void set_has_curnode();
  inline void clear_has_curnode();
  inline void set_has_preward();
  inline void clear_has_preward();
  inline void set_has_pastnode();
  inline void clear_has_pastnode();
  inline void set_has_swapstime();
  inline void clear_has_swapstime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 curnode_;
  ::google::protobuf::int32 preward_;
  ::google::protobuf::int64 swapstime_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ActivityYellowVipReward > vipreward_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > treasonkingbesttime_;
  ::google::protobuf::int32 pastnode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static Activity* default_instance_;
};
// -------------------------------------------------------------------

class ActivityYellowVipReward : public ::google::protobuf::Message {
 public:
  ActivityYellowVipReward();
  virtual ~ActivityYellowVipReward();

  ActivityYellowVipReward(const ActivityYellowVipReward& from);

  inline ActivityYellowVipReward& operator=(const ActivityYellowVipReward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActivityYellowVipReward& default_instance();

  void Swap(ActivityYellowVipReward* other);

  // implements Message ----------------------------------------------

  ActivityYellowVipReward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActivityYellowVipReward& from);
  void MergeFrom(const ActivityYellowVipReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 activityId = 1;
  inline bool has_activityid() const;
  inline void clear_activityid();
  static const int kActivityIdFieldNumber = 1;
  inline ::google::protobuf::int32 activityid() const;
  inline void set_activityid(::google::protobuf::int32 value);

  // repeated .PlayerInfo.ActivityYellowVipRewardList rewardList = 2;
  inline int rewardlist_size() const;
  inline void clear_rewardlist();
  static const int kRewardListFieldNumber = 2;
  inline const ::PlayerInfo::ActivityYellowVipRewardList& rewardlist(int index) const;
  inline ::PlayerInfo::ActivityYellowVipRewardList* mutable_rewardlist(int index);
  inline ::PlayerInfo::ActivityYellowVipRewardList* add_rewardlist();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ActivityYellowVipRewardList >&
      rewardlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ActivityYellowVipRewardList >*
      mutable_rewardlist();

  // @@protoc_insertion_point(class_scope:PlayerInfo.ActivityYellowVipReward)
 private:
  inline void set_has_activityid();
  inline void clear_has_activityid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ActivityYellowVipRewardList > rewardlist_;
  ::google::protobuf::int32 activityid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static ActivityYellowVipReward* default_instance_;
};
// -------------------------------------------------------------------

class ActivityYellowVipRewardList : public ::google::protobuf::Message {
 public:
  ActivityYellowVipRewardList();
  virtual ~ActivityYellowVipRewardList();

  ActivityYellowVipRewardList(const ActivityYellowVipRewardList& from);

  inline ActivityYellowVipRewardList& operator=(const ActivityYellowVipRewardList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActivityYellowVipRewardList& default_instance();

  void Swap(ActivityYellowVipRewardList* other);

  // implements Message ----------------------------------------------

  ActivityYellowVipRewardList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActivityYellowVipRewardList& from);
  void MergeFrom(const ActivityYellowVipRewardList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.ActivityYellowVipRewardList)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static ActivityYellowVipRewardList* default_instance_;
};
// -------------------------------------------------------------------

class LineMapInfoList : public ::google::protobuf::Message {
 public:
  LineMapInfoList();
  virtual ~LineMapInfoList();

  LineMapInfoList(const LineMapInfoList& from);

  inline LineMapInfoList& operator=(const LineMapInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LineMapInfoList& default_instance();

  void Swap(LineMapInfoList* other);

  // implements Message ----------------------------------------------

  LineMapInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LineMapInfoList& from);
  void MergeFrom(const LineMapInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.LineMapInfo lineinfo = 1;
  inline int lineinfo_size() const;
  inline void clear_lineinfo();
  static const int kLineinfoFieldNumber = 1;
  inline const ::PlayerInfo::LineMapInfo& lineinfo(int index) const;
  inline ::PlayerInfo::LineMapInfo* mutable_lineinfo(int index);
  inline ::PlayerInfo::LineMapInfo* add_lineinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::LineMapInfo >&
      lineinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::LineMapInfo >*
      mutable_lineinfo();

  // required int64 mysecenceid = 2;
  inline bool has_mysecenceid() const;
  inline void clear_mysecenceid();
  static const int kMysecenceidFieldNumber = 2;
  inline ::google::protobuf::int64 mysecenceid() const;
  inline void set_mysecenceid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.LineMapInfoList)
 private:
  inline void set_has_mysecenceid();
  inline void clear_has_mysecenceid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::LineMapInfo > lineinfo_;
  ::google::protobuf::int64 mysecenceid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static LineMapInfoList* default_instance_;
};
// -------------------------------------------------------------------

class LineMapInfo : public ::google::protobuf::Message {
 public:
  LineMapInfo();
  virtual ~LineMapInfo();

  LineMapInfo(const LineMapInfo& from);

  inline LineMapInfo& operator=(const LineMapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LineMapInfo& default_instance();

  void Swap(LineMapInfo* other);

  // implements Message ----------------------------------------------

  LineMapInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LineMapInfo& from);
  void MergeFrom(const LineMapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 scenceid = 1;
  inline bool has_scenceid() const;
  inline void clear_scenceid();
  static const int kScenceidFieldNumber = 1;
  inline ::google::protobuf::int64 scenceid() const;
  inline void set_scenceid(::google::protobuf::int64 value);

  // required int32 playernum = 2;
  inline bool has_playernum() const;
  inline void clear_playernum();
  static const int kPlayernumFieldNumber = 2;
  inline ::google::protobuf::int32 playernum() const;
  inline void set_playernum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.LineMapInfo)
 private:
  inline void set_has_scenceid();
  inline void clear_has_scenceid();
  inline void set_has_playernum();
  inline void clear_has_playernum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 scenceid_;
  ::google::protobuf::int32 playernum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static LineMapInfo* default_instance_;
};
// -------------------------------------------------------------------

class GirlWarInfo : public ::google::protobuf::Message {
 public:
  GirlWarInfo();
  virtual ~GirlWarInfo();

  GirlWarInfo(const GirlWarInfo& from);

  inline GirlWarInfo& operator=(const GirlWarInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GirlWarInfo& default_instance();

  void Swap(GirlWarInfo* other);

  // implements Message ----------------------------------------------

  GirlWarInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GirlWarInfo& from);
  void MergeFrom(const GirlWarInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.GirlWar girlwar = 1;
  inline int girlwar_size() const;
  inline void clear_girlwar();
  static const int kGirlwarFieldNumber = 1;
  inline const ::PlayerInfo::GirlWar& girlwar(int index) const;
  inline ::PlayerInfo::GirlWar* mutable_girlwar(int index);
  inline ::PlayerInfo::GirlWar* add_girlwar();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::GirlWar >&
      girlwar() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::GirlWar >*
      mutable_girlwar();

  // @@protoc_insertion_point(class_scope:PlayerInfo.GirlWarInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::GirlWar > girlwar_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static GirlWarInfo* default_instance_;
};
// -------------------------------------------------------------------

class GirlWar : public ::google::protobuf::Message {
 public:
  GirlWar();
  virtual ~GirlWar();

  GirlWar(const GirlWar& from);

  inline GirlWar& operator=(const GirlWar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GirlWar& default_instance();

  void Swap(GirlWar* other);

  // implements Message ----------------------------------------------

  GirlWar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GirlWar& from);
  void MergeFrom(const GirlWar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional bytes name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 fightpower = 3;
  inline bool has_fightpower() const;
  inline void clear_fightpower();
  static const int kFightpowerFieldNumber = 3;
  inline ::google::protobuf::int32 fightpower() const;
  inline void set_fightpower(::google::protobuf::int32 value);

  // optional int64 exp = 4;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 4;
  inline ::google::protobuf::int64 exp() const;
  inline void set_exp(::google::protobuf::int64 value);

  // optional int32 level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 hp = 6;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 6;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // optional int32 phyattack = 7;
  inline bool has_phyattack() const;
  inline void clear_phyattack();
  static const int kPhyattackFieldNumber = 7;
  inline ::google::protobuf::int32 phyattack() const;
  inline void set_phyattack(::google::protobuf::int32 value);

  // optional int32 phyattackmax = 8;
  inline bool has_phyattackmax() const;
  inline void clear_phyattackmax();
  static const int kPhyattackmaxFieldNumber = 8;
  inline ::google::protobuf::int32 phyattackmax() const;
  inline void set_phyattackmax(::google::protobuf::int32 value);

  // optional int32 magicattack = 9;
  inline bool has_magicattack() const;
  inline void clear_magicattack();
  static const int kMagicattackFieldNumber = 9;
  inline ::google::protobuf::int32 magicattack() const;
  inline void set_magicattack(::google::protobuf::int32 value);

  // optional int32 magicattackmax = 10;
  inline bool has_magicattackmax() const;
  inline void clear_magicattackmax();
  static const int kMagicattackmaxFieldNumber = 10;
  inline ::google::protobuf::int32 magicattackmax() const;
  inline void set_magicattackmax(::google::protobuf::int32 value);

  // optional int32 phydefence = 11;
  inline bool has_phydefence() const;
  inline void clear_phydefence();
  static const int kPhydefenceFieldNumber = 11;
  inline ::google::protobuf::int32 phydefence() const;
  inline void set_phydefence(::google::protobuf::int32 value);

  // optional int32 hitrate = 12;
  inline bool has_hitrate() const;
  inline void clear_hitrate();
  static const int kHitrateFieldNumber = 12;
  inline ::google::protobuf::int32 hitrate() const;
  inline void set_hitrate(::google::protobuf::int32 value);

  // optional int32 avoidrate = 13;
  inline bool has_avoidrate() const;
  inline void clear_avoidrate();
  static const int kAvoidrateFieldNumber = 13;
  inline ::google::protobuf::int32 avoidrate() const;
  inline void set_avoidrate(::google::protobuf::int32 value);

  // optional int32 crit = 14;
  inline bool has_crit() const;
  inline void clear_crit();
  static const int kCritFieldNumber = 14;
  inline ::google::protobuf::int32 crit() const;
  inline void set_crit(::google::protobuf::int32 value);

  // optional int32 ung = 15;
  inline bool has_ung() const;
  inline void clear_ung();
  static const int kUngFieldNumber = 15;
  inline ::google::protobuf::int32 ung() const;
  inline void set_ung(::google::protobuf::int32 value);

  // optional int32 movespeed = 16;
  inline bool has_movespeed() const;
  inline void clear_movespeed();
  static const int kMovespeedFieldNumber = 16;
  inline ::google::protobuf::int32 movespeed() const;
  inline void set_movespeed(::google::protobuf::int32 value);

  // optional int64 deadTime = 17;
  inline bool has_deadtime() const;
  inline void clear_deadtime();
  static const int kDeadTimeFieldNumber = 17;
  inline ::google::protobuf::int64 deadtime() const;
  inline void set_deadtime(::google::protobuf::int64 value);

  // optional int32 starrank = 18;
  inline bool has_starrank() const;
  inline void clear_starrank();
  static const int kStarrankFieldNumber = 18;
  inline ::google::protobuf::int32 starrank() const;
  inline void set_starrank(::google::protobuf::int32 value);

  // optional int32 quality = 19;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 19;
  inline ::google::protobuf::int32 quality() const;
  inline void set_quality(::google::protobuf::int32 value);

  // optional int32 hpmax = 20;
  inline bool has_hpmax() const;
  inline void clear_hpmax();
  static const int kHpmaxFieldNumber = 20;
  inline ::google::protobuf::int32 hpmax() const;
  inline void set_hpmax(::google::protobuf::int32 value);

  // optional int32 skill1 = 21;
  inline bool has_skill1() const;
  inline void clear_skill1();
  static const int kSkill1FieldNumber = 21;
  inline ::google::protobuf::int32 skill1() const;
  inline void set_skill1(::google::protobuf::int32 value);

  // optional int32 skill2 = 22;
  inline bool has_skill2() const;
  inline void clear_skill2();
  static const int kSkill2FieldNumber = 22;
  inline ::google::protobuf::int32 skill2() const;
  inline void set_skill2(::google::protobuf::int32 value);

  // optional int32 skill3 = 23;
  inline bool has_skill3() const;
  inline void clear_skill3();
  static const int kSkill3FieldNumber = 23;
  inline ::google::protobuf::int32 skill3() const;
  inline void set_skill3(::google::protobuf::int32 value);

  // repeated int32 index = 24;
  inline int index_size() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 24;
  inline ::google::protobuf::int32 index(int index) const;
  inline void set_index(int index, ::google::protobuf::int32 value);
  inline void add_index(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      index() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_index();

  // repeated int32 equip = 25;
  inline int equip_size() const;
  inline void clear_equip();
  static const int kEquipFieldNumber = 25;
  inline ::google::protobuf::int32 equip(int index) const;
  inline void set_equip(int index, ::google::protobuf::int32 value);
  inline void add_equip(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      equip() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_equip();

  // optional bool iswar = 26;
  inline bool has_iswar() const;
  inline void clear_iswar();
  static const int kIswarFieldNumber = 26;
  inline bool iswar() const;
  inline void set_iswar(bool value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.GirlWar)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_fightpower();
  inline void clear_has_fightpower();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_phyattack();
  inline void clear_has_phyattack();
  inline void set_has_phyattackmax();
  inline void clear_has_phyattackmax();
  inline void set_has_magicattack();
  inline void clear_has_magicattack();
  inline void set_has_magicattackmax();
  inline void clear_has_magicattackmax();
  inline void set_has_phydefence();
  inline void clear_has_phydefence();
  inline void set_has_hitrate();
  inline void clear_has_hitrate();
  inline void set_has_avoidrate();
  inline void clear_has_avoidrate();
  inline void set_has_crit();
  inline void clear_has_crit();
  inline void set_has_ung();
  inline void clear_has_ung();
  inline void set_has_movespeed();
  inline void clear_has_movespeed();
  inline void set_has_deadtime();
  inline void clear_has_deadtime();
  inline void set_has_starrank();
  inline void clear_has_starrank();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_hpmax();
  inline void clear_has_hpmax();
  inline void set_has_skill1();
  inline void clear_has_skill1();
  inline void set_has_skill2();
  inline void clear_has_skill2();
  inline void set_has_skill3();
  inline void clear_has_skill3();
  inline void set_has_iswar();
  inline void clear_has_iswar();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 fightpower_;
  ::google::protobuf::int64 exp_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 phyattack_;
  ::google::protobuf::int32 phyattackmax_;
  ::google::protobuf::int32 magicattack_;
  ::google::protobuf::int32 magicattackmax_;
  ::google::protobuf::int32 phydefence_;
  ::google::protobuf::int32 hitrate_;
  ::google::protobuf::int32 avoidrate_;
  ::google::protobuf::int32 crit_;
  ::google::protobuf::int32 ung_;
  ::google::protobuf::int32 movespeed_;
  ::google::protobuf::int64 deadtime_;
  ::google::protobuf::int32 starrank_;
  ::google::protobuf::int32 quality_;
  ::google::protobuf::int32 hpmax_;
  ::google::protobuf::int32 skill1_;
  ::google::protobuf::int32 skill2_;
  ::google::protobuf::int32 skill3_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > index_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > equip_;
  bool iswar_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static GirlWar* default_instance_;
};
// -------------------------------------------------------------------

class LessInfo : public ::google::protobuf::Message {
 public:
  LessInfo();
  virtual ~LessInfo();

  LessInfo(const LessInfo& from);

  inline LessInfo& operator=(const LessInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LessInfo& default_instance();

  void Swap(LessInfo* other);

  // implements Message ----------------------------------------------

  LessInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LessInfo& from);
  void MergeFrom(const LessInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 type = 1;
  inline int type_size() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type(int index) const;
  inline void set_type(int index, ::google::protobuf::int32 value);
  inline void add_type(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      type() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_type();

  // optional .PlayerInfo.InstanceInfoTwoDays instanceList = 2;
  inline bool has_instancelist() const;
  inline void clear_instancelist();
  static const int kInstanceListFieldNumber = 2;
  inline const ::PlayerInfo::InstanceInfoTwoDays& instancelist() const;
  inline ::PlayerInfo::InstanceInfoTwoDays* mutable_instancelist();
  inline ::PlayerInfo::InstanceInfoTwoDays* release_instancelist();
  inline void set_allocated_instancelist(::PlayerInfo::InstanceInfoTwoDays* instancelist);

  // optional .PlayerInfo.SignInInfo signin = 3;
  inline bool has_signin() const;
  inline void clear_signin();
  static const int kSigninFieldNumber = 3;
  inline const ::PlayerInfo::SignInInfo& signin() const;
  inline ::PlayerInfo::SignInInfo* mutable_signin();
  inline ::PlayerInfo::SignInInfo* release_signin();
  inline void set_allocated_signin(::PlayerInfo::SignInInfo* signin);

  // optional .PlayerInfo.CounterServiceList counter = 4;
  inline bool has_counter() const;
  inline void clear_counter();
  static const int kCounterFieldNumber = 4;
  inline const ::PlayerInfo::CounterServiceList& counter() const;
  inline ::PlayerInfo::CounterServiceList* mutable_counter();
  inline ::PlayerInfo::CounterServiceList* release_counter();
  inline void set_allocated_counter(::PlayerInfo::CounterServiceList* counter);

  // optional .PlayerInfo.EscortInfo escort = 5;
  inline bool has_escort() const;
  inline void clear_escort();
  static const int kEscortFieldNumber = 5;
  inline const ::PlayerInfo::EscortInfo& escort() const;
  inline ::PlayerInfo::EscortInfo* mutable_escort();
  inline ::PlayerInfo::EscortInfo* release_escort();
  inline void set_allocated_escort(::PlayerInfo::EscortInfo* escort);

  // optional .PlayerInfo.PlayerVipInfo playerVip = 6;
  inline bool has_playervip() const;
  inline void clear_playervip();
  static const int kPlayerVipFieldNumber = 6;
  inline const ::PlayerInfo::PlayerVipInfo& playervip() const;
  inline ::PlayerInfo::PlayerVipInfo* mutable_playervip();
  inline ::PlayerInfo::PlayerVipInfo* release_playervip();
  inline void set_allocated_playervip(::PlayerInfo::PlayerVipInfo* playervip);

  // optional .PlayerInfo.PrestigeInfoList prestige = 7;
  inline bool has_prestige() const;
  inline void clear_prestige();
  static const int kPrestigeFieldNumber = 7;
  inline const ::PlayerInfo::PrestigeInfoList& prestige() const;
  inline ::PlayerInfo::PrestigeInfoList* mutable_prestige();
  inline ::PlayerInfo::PrestigeInfoList* release_prestige();
  inline void set_allocated_prestige(::PlayerInfo::PrestigeInfoList* prestige);

  // optional .PlayerInfo.TitleInfoList title = 8;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 8;
  inline const ::PlayerInfo::TitleInfoList& title() const;
  inline ::PlayerInfo::TitleInfoList* mutable_title();
  inline ::PlayerInfo::TitleInfoList* release_title();
  inline void set_allocated_title(::PlayerInfo::TitleInfoList* title);

  // optional .FashionMsgProto.FashionShow fashion = 9;
  inline bool has_fashion() const;
  inline void clear_fashion();
  static const int kFashionFieldNumber = 9;
  inline const ::FashionMsgProto::FashionShow& fashion() const;
  inline ::FashionMsgProto::FashionShow* mutable_fashion();
  inline ::FashionMsgProto::FashionShow* release_fashion();
  inline void set_allocated_fashion(::FashionMsgProto::FashionShow* fashion);

  // optional .VitalityProto.ProtoVitalityInfo vitality = 10;
  inline bool has_vitality() const;
  inline void clear_vitality();
  static const int kVitalityFieldNumber = 10;
  inline const ::VitalityProto::ProtoVitalityInfo& vitality() const;
  inline ::VitalityProto::ProtoVitalityInfo* mutable_vitality();
  inline ::VitalityProto::ProtoVitalityInfo* release_vitality();
  inline void set_allocated_vitality(::VitalityProto::ProtoVitalityInfo* vitality);

  // optional .PlayerInfo.CampShopInfo campShopData = 11;
  inline bool has_campshopdata() const;
  inline void clear_campshopdata();
  static const int kCampShopDataFieldNumber = 11;
  inline const ::PlayerInfo::CampShopInfo& campshopdata() const;
  inline ::PlayerInfo::CampShopInfo* mutable_campshopdata();
  inline ::PlayerInfo::CampShopInfo* release_campshopdata();
  inline void set_allocated_campshopdata(::PlayerInfo::CampShopInfo* campshopdata);

  // optional .PlayerInfo.FestivalInfo festivalData = 12;
  inline bool has_festivaldata() const;
  inline void clear_festivaldata();
  static const int kFestivalDataFieldNumber = 12;
  inline const ::PlayerInfo::FestivalInfo& festivaldata() const;
  inline ::PlayerInfo::FestivalInfo* mutable_festivaldata();
  inline ::PlayerInfo::FestivalInfo* release_festivaldata();
  inline void set_allocated_festivaldata(::PlayerInfo::FestivalInfo* festivaldata);

  // optional .PlayerInfo.MoneyInstance info = 13;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 13;
  inline const ::PlayerInfo::MoneyInstance& info() const;
  inline ::PlayerInfo::MoneyInstance* mutable_info();
  inline ::PlayerInfo::MoneyInstance* release_info();
  inline void set_allocated_info(::PlayerInfo::MoneyInstance* info);

  // @@protoc_insertion_point(class_scope:PlayerInfo.LessInfo)
 private:
  inline void set_has_instancelist();
  inline void clear_has_instancelist();
  inline void set_has_signin();
  inline void clear_has_signin();
  inline void set_has_counter();
  inline void clear_has_counter();
  inline void set_has_escort();
  inline void clear_has_escort();
  inline void set_has_playervip();
  inline void clear_has_playervip();
  inline void set_has_prestige();
  inline void clear_has_prestige();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_fashion();
  inline void clear_has_fashion();
  inline void set_has_vitality();
  inline void clear_has_vitality();
  inline void set_has_campshopdata();
  inline void clear_has_campshopdata();
  inline void set_has_festivaldata();
  inline void clear_has_festivaldata();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > type_;
  ::PlayerInfo::InstanceInfoTwoDays* instancelist_;
  ::PlayerInfo::SignInInfo* signin_;
  ::PlayerInfo::CounterServiceList* counter_;
  ::PlayerInfo::EscortInfo* escort_;
  ::PlayerInfo::PlayerVipInfo* playervip_;
  ::PlayerInfo::PrestigeInfoList* prestige_;
  ::PlayerInfo::TitleInfoList* title_;
  ::FashionMsgProto::FashionShow* fashion_;
  ::VitalityProto::ProtoVitalityInfo* vitality_;
  ::PlayerInfo::CampShopInfo* campshopdata_;
  ::PlayerInfo::FestivalInfo* festivaldata_;
  ::PlayerInfo::MoneyInstance* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static LessInfo* default_instance_;
};
// -------------------------------------------------------------------

class StoneInfo : public ::google::protobuf::Message {
 public:
  StoneInfo();
  virtual ~StoneInfo();

  StoneInfo(const StoneInfo& from);

  inline StoneInfo& operator=(const StoneInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StoneInfo& default_instance();

  void Swap(StoneInfo* other);

  // implements Message ----------------------------------------------

  StoneInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoneInfo& from);
  void MergeFrom(const StoneInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.StoneItem item = 1;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::PlayerInfo::StoneItem& item(int index) const;
  inline ::PlayerInfo::StoneItem* mutable_item(int index);
  inline ::PlayerInfo::StoneItem* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::StoneItem >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::StoneItem >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:PlayerInfo.StoneInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::StoneItem > item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static StoneInfo* default_instance_;
};
// -------------------------------------------------------------------

class StoneItem : public ::google::protobuf::Message {
 public:
  StoneItem();
  virtual ~StoneItem();

  StoneItem(const StoneItem& from);

  inline StoneItem& operator=(const StoneItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StoneItem& default_instance();

  void Swap(StoneItem* other);

  // implements Message ----------------------------------------------

  StoneItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoneItem& from);
  void MergeFrom(const StoneItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // repeated int32 stoneid = 2;
  inline int stoneid_size() const;
  inline void clear_stoneid();
  static const int kStoneidFieldNumber = 2;
  inline ::google::protobuf::int32 stoneid(int index) const;
  inline void set_stoneid(int index, ::google::protobuf::int32 value);
  inline void add_stoneid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      stoneid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_stoneid();

  // @@protoc_insertion_point(class_scope:PlayerInfo.StoneItem)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > stoneid_;
  ::google::protobuf::int32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static StoneItem* default_instance_;
};
// -------------------------------------------------------------------

class DBAchShopInfo : public ::google::protobuf::Message {
 public:
  DBAchShopInfo();
  virtual ~DBAchShopInfo();

  DBAchShopInfo(const DBAchShopInfo& from);

  inline DBAchShopInfo& operator=(const DBAchShopInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBAchShopInfo& default_instance();

  void Swap(DBAchShopInfo* other);

  // implements Message ----------------------------------------------

  DBAchShopInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBAchShopInfo& from);
  void MergeFrom(const DBAchShopInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // repeated .PlayerInfo.DBAchShopItem item = 2;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::PlayerInfo::DBAchShopItem& item(int index) const;
  inline ::PlayerInfo::DBAchShopItem* mutable_item(int index);
  inline ::PlayerInfo::DBAchShopItem* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DBAchShopItem >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DBAchShopItem >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:PlayerInfo.DBAchShopInfo)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DBAchShopItem > item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static DBAchShopInfo* default_instance_;
};
// -------------------------------------------------------------------

class DBAchShopItem : public ::google::protobuf::Message {
 public:
  DBAchShopItem();
  virtual ~DBAchShopItem();

  DBAchShopItem(const DBAchShopItem& from);

  inline DBAchShopItem& operator=(const DBAchShopItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBAchShopItem& default_instance();

  void Swap(DBAchShopItem* other);

  // implements Message ----------------------------------------------

  DBAchShopItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBAchShopItem& from);
  void MergeFrom(const DBAchShopItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // repeated int32 goodsid = 3;
  inline int goodsid_size() const;
  inline void clear_goodsid();
  static const int kGoodsidFieldNumber = 3;
  inline ::google::protobuf::int32 goodsid(int index) const;
  inline void set_goodsid(int index, ::google::protobuf::int32 value);
  inline void add_goodsid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      goodsid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_goodsid();

  // @@protoc_insertion_point(class_scope:PlayerInfo.DBAchShopItem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > goodsid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static DBAchShopItem* default_instance_;
};
// -------------------------------------------------------------------

class CampShopInfo : public ::google::protobuf::Message {
 public:
  CampShopInfo();
  virtual ~CampShopInfo();

  CampShopInfo(const CampShopInfo& from);

  inline CampShopInfo& operator=(const CampShopInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CampShopInfo& default_instance();

  void Swap(CampShopInfo* other);

  // implements Message ----------------------------------------------

  CampShopInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CampShopInfo& from);
  void MergeFrom(const CampShopInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // repeated .PlayerInfo.CampShopItem item = 2;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::PlayerInfo::CampShopItem& item(int index) const;
  inline ::PlayerInfo::CampShopItem* mutable_item(int index);
  inline ::PlayerInfo::CampShopItem* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::CampShopItem >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::CampShopItem >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:PlayerInfo.CampShopInfo)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::CampShopItem > item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static CampShopInfo* default_instance_;
};
// -------------------------------------------------------------------

class CampShopItem : public ::google::protobuf::Message {
 public:
  CampShopItem();
  virtual ~CampShopItem();

  CampShopItem(const CampShopItem& from);

  inline CampShopItem& operator=(const CampShopItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CampShopItem& default_instance();

  void Swap(CampShopItem* other);

  // implements Message ----------------------------------------------

  CampShopItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CampShopItem& from);
  void MergeFrom(const CampShopItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 nums = 2;
  inline bool has_nums() const;
  inline void clear_nums();
  static const int kNumsFieldNumber = 2;
  inline ::google::protobuf::int32 nums() const;
  inline void set_nums(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.CampShopItem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_nums();
  inline void clear_has_nums();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 nums_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static CampShopItem* default_instance_;
};
// -------------------------------------------------------------------

class FestivalInfo : public ::google::protobuf::Message {
 public:
  FestivalInfo();
  virtual ~FestivalInfo();

  FestivalInfo(const FestivalInfo& from);

  inline FestivalInfo& operator=(const FestivalInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FestivalInfo& default_instance();

  void Swap(FestivalInfo* other);

  // implements Message ----------------------------------------------

  FestivalInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FestivalInfo& from);
  void MergeFrom(const FestivalInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // repeated .PlayerInfo.festivalItem item = 2;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::PlayerInfo::festivalItem& item(int index) const;
  inline ::PlayerInfo::festivalItem* mutable_item(int index);
  inline ::PlayerInfo::festivalItem* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::festivalItem >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::festivalItem >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:PlayerInfo.FestivalInfo)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::festivalItem > item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static FestivalInfo* default_instance_;
};
// -------------------------------------------------------------------

class festivalItem : public ::google::protobuf::Message {
 public:
  festivalItem();
  virtual ~festivalItem();

  festivalItem(const festivalItem& from);

  inline festivalItem& operator=(const festivalItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const festivalItem& default_instance();

  void Swap(festivalItem* other);

  // implements Message ----------------------------------------------

  festivalItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const festivalItem& from);
  void MergeFrom(const festivalItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 nums = 2;
  inline bool has_nums() const;
  inline void clear_nums();
  static const int kNumsFieldNumber = 2;
  inline ::google::protobuf::int32 nums() const;
  inline void set_nums(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.festivalItem)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_nums();
  inline void clear_has_nums();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 nums_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static festivalItem* default_instance_;
};
// -------------------------------------------------------------------

class MoneyInstance : public ::google::protobuf::Message {
 public:
  MoneyInstance();
  virtual ~MoneyInstance();

  MoneyInstance(const MoneyInstance& from);

  inline MoneyInstance& operator=(const MoneyInstance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MoneyInstance& default_instance();

  void Swap(MoneyInstance* other);

  // implements Message ----------------------------------------------

  MoneyInstance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoneyInstance& from);
  void MergeFrom(const MoneyInstance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 mapId = 1;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // optional int32 pass = 2;
  inline bool has_pass() const;
  inline void clear_pass();
  static const int kPassFieldNumber = 2;
  inline ::google::protobuf::int32 pass() const;
  inline void set_pass(::google::protobuf::int32 value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 buytimes = 4;
  inline bool has_buytimes() const;
  inline void clear_buytimes();
  static const int kBuytimesFieldNumber = 4;
  inline ::google::protobuf::int32 buytimes() const;
  inline void set_buytimes(::google::protobuf::int32 value);

  // optional int32 reset = 5;
  inline bool has_reset() const;
  inline void clear_reset();
  static const int kResetFieldNumber = 5;
  inline ::google::protobuf::int32 reset() const;
  inline void set_reset(::google::protobuf::int32 value);

  // optional int64 updatetime = 6;
  inline bool has_updatetime() const;
  inline void clear_updatetime();
  static const int kUpdatetimeFieldNumber = 6;
  inline ::google::protobuf::int64 updatetime() const;
  inline void set_updatetime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.MoneyInstance)
 private:
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_pass();
  inline void clear_has_pass();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_buytimes();
  inline void clear_has_buytimes();
  inline void set_has_reset();
  inline void clear_has_reset();
  inline void set_has_updatetime();
  inline void clear_has_updatetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 mapid_;
  ::google::protobuf::int32 pass_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 buytimes_;
  ::google::protobuf::int64 updatetime_;
  ::google::protobuf::int32 reset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static MoneyInstance* default_instance_;
};
// -------------------------------------------------------------------

class ChallengeInstance : public ::google::protobuf::Message {
 public:
  ChallengeInstance();
  virtual ~ChallengeInstance();

  ChallengeInstance(const ChallengeInstance& from);

  inline ChallengeInstance& operator=(const ChallengeInstance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChallengeInstance& default_instance();

  void Swap(ChallengeInstance* other);

  // implements Message ----------------------------------------------

  ChallengeInstance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChallengeInstance& from);
  void MergeFrom(const ChallengeInstance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 layer = 1;
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 1;
  inline ::google::protobuf::int32 layer() const;
  inline void set_layer(::google::protobuf::int32 value);

  // optional int32 maxlayer = 2;
  inline bool has_maxlayer() const;
  inline void clear_maxlayer();
  static const int kMaxlayerFieldNumber = 2;
  inline ::google::protobuf::int32 maxlayer() const;
  inline void set_maxlayer(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.ChallengeInstance)
 private:
  inline void set_has_layer();
  inline void clear_has_layer();
  inline void set_has_maxlayer();
  inline void clear_has_maxlayer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 layer_;
  ::google::protobuf::int32 maxlayer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static ChallengeInstance* default_instance_;
};
// -------------------------------------------------------------------

class HeroInstanceData : public ::google::protobuf::Message {
 public:
  HeroInstanceData();
  virtual ~HeroInstanceData();

  HeroInstanceData(const HeroInstanceData& from);

  inline HeroInstanceData& operator=(const HeroInstanceData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeroInstanceData& default_instance();

  void Swap(HeroInstanceData* other);

  // implements Message ----------------------------------------------

  HeroInstanceData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeroInstanceData& from);
  void MergeFrom(const HeroInstanceData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 layer = 1;
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 1;
  inline ::google::protobuf::int32 layer() const;
  inline void set_layer(::google::protobuf::int32 value);

  // repeated int32 fetchs = 2;
  inline int fetchs_size() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::int32 fetchs(int index) const;
  inline void set_fetchs(int index, ::google::protobuf::int32 value);
  inline void add_fetchs(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      fetchs() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_fetchs();

  // @@protoc_insertion_point(class_scope:PlayerInfo.HeroInstanceData)
 private:
  inline void set_has_layer();
  inline void clear_has_layer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > fetchs_;
  ::google::protobuf::int32 layer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static HeroInstanceData* default_instance_;
};
// -------------------------------------------------------------------

class BranchLineInfo : public ::google::protobuf::Message {
 public:
  BranchLineInfo();
  virtual ~BranchLineInfo();

  BranchLineInfo(const BranchLineInfo& from);

  inline BranchLineInfo& operator=(const BranchLineInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BranchLineInfo& default_instance();

  void Swap(BranchLineInfo* other);

  // implements Message ----------------------------------------------

  BranchLineInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BranchLineInfo& from);
  void MergeFrom(const BranchLineInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.LineMapInfo info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::PlayerInfo::LineMapInfo& info(int index) const;
  inline ::PlayerInfo::LineMapInfo* mutable_info(int index);
  inline ::PlayerInfo::LineMapInfo* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::LineMapInfo >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::LineMapInfo >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:PlayerInfo.BranchLineInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::LineMapInfo > info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static BranchLineInfo* default_instance_;
};
// -------------------------------------------------------------------

class TotalBranchLineInfo : public ::google::protobuf::Message {
 public:
  TotalBranchLineInfo();
  virtual ~TotalBranchLineInfo();

  TotalBranchLineInfo(const TotalBranchLineInfo& from);

  inline TotalBranchLineInfo& operator=(const TotalBranchLineInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TotalBranchLineInfo& default_instance();

  void Swap(TotalBranchLineInfo* other);

  // implements Message ----------------------------------------------

  TotalBranchLineInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TotalBranchLineInfo& from);
  void MergeFrom(const TotalBranchLineInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.BranchLineInfo list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::PlayerInfo::BranchLineInfo& list(int index) const;
  inline ::PlayerInfo::BranchLineInfo* mutable_list(int index);
  inline ::PlayerInfo::BranchLineInfo* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BranchLineInfo >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BranchLineInfo >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:PlayerInfo.TotalBranchLineInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BranchLineInfo > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static TotalBranchLineInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClientIEInfo : public ::google::protobuf::Message {
 public:
  ClientIEInfo();
  virtual ~ClientIEInfo();

  ClientIEInfo(const ClientIEInfo& from);

  inline ClientIEInfo& operator=(const ClientIEInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientIEInfo& default_instance();

  void Swap(ClientIEInfo* other);

  // implements Message ----------------------------------------------

  ClientIEInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientIEInfo& from);
  void MergeFrom(const ClientIEInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:PlayerInfo.ClientIEInfo)
 private:
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static ClientIEInfo* default_instance_;
};
// -------------------------------------------------------------------

class OnceRewardInfo : public ::google::protobuf::Message {
 public:
  OnceRewardInfo();
  virtual ~OnceRewardInfo();

  OnceRewardInfo(const OnceRewardInfo& from);

  inline OnceRewardInfo& operator=(const OnceRewardInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnceRewardInfo& default_instance();

  void Swap(OnceRewardInfo* other);

  // implements Message ----------------------------------------------

  OnceRewardInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnceRewardInfo& from);
  void MergeFrom(const OnceRewardInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool microRewardFlag = 1;
  inline bool has_microrewardflag() const;
  inline void clear_microrewardflag();
  static const int kMicroRewardFlagFieldNumber = 1;
  inline bool microrewardflag() const;
  inline void set_microrewardflag(bool value);

  // optional bool firstChargeOverFlag = 2;
  inline bool has_firstchargeoverflag() const;
  inline void clear_firstchargeoverflag();
  static const int kFirstChargeOverFlagFieldNumber = 2;
  inline bool firstchargeoverflag() const;
  inline void set_firstchargeoverflag(bool value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.OnceRewardInfo)
 private:
  inline void set_has_microrewardflag();
  inline void clear_has_microrewardflag();
  inline void set_has_firstchargeoverflag();
  inline void clear_has_firstchargeoverflag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool microrewardflag_;
  bool firstchargeoverflag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static OnceRewardInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroupInstance : public ::google::protobuf::Message {
 public:
  GroupInstance();
  virtual ~GroupInstance();

  GroupInstance(const GroupInstance& from);

  inline GroupInstance& operator=(const GroupInstance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupInstance& default_instance();

  void Swap(GroupInstance* other);

  // implements Message ----------------------------------------------

  GroupInstance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupInstance& from);
  void MergeFrom(const GroupInstance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 timeReset = 1;
  inline bool has_timereset() const;
  inline void clear_timereset();
  static const int kTimeResetFieldNumber = 1;
  inline ::google::protobuf::int64 timereset() const;
  inline void set_timereset(::google::protobuf::int64 value);

  // repeated .PlayerInfo.InstanceGroupList groupList = 2;
  inline int grouplist_size() const;
  inline void clear_grouplist();
  static const int kGroupListFieldNumber = 2;
  inline const ::PlayerInfo::InstanceGroupList& grouplist(int index) const;
  inline ::PlayerInfo::InstanceGroupList* mutable_grouplist(int index);
  inline ::PlayerInfo::InstanceGroupList* add_grouplist();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceGroupList >&
      grouplist() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceGroupList >*
      mutable_grouplist();

  // @@protoc_insertion_point(class_scope:PlayerInfo.GroupInstance)
 private:
  inline void set_has_timereset();
  inline void clear_has_timereset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 timereset_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceGroupList > grouplist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static GroupInstance* default_instance_;
};
// -------------------------------------------------------------------

class InstanceGroupList : public ::google::protobuf::Message {
 public:
  InstanceGroupList();
  virtual ~InstanceGroupList();

  InstanceGroupList(const InstanceGroupList& from);

  inline InstanceGroupList& operator=(const InstanceGroupList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceGroupList& default_instance();

  void Swap(InstanceGroupList* other);

  // implements Message ----------------------------------------------

  InstanceGroupList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceGroupList& from);
  void MergeFrom(const InstanceGroupList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 mapId = 1;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // optional int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 vipnum = 3;
  inline bool has_vipnum() const;
  inline void clear_vipnum();
  static const int kVipnumFieldNumber = 3;
  inline ::google::protobuf::int32 vipnum() const;
  inline void set_vipnum(::google::protobuf::int32 value);

  // optional int32 buynum = 4;
  inline bool has_buynum() const;
  inline void clear_buynum();
  static const int kBuynumFieldNumber = 4;
  inline ::google::protobuf::int32 buynum() const;
  inline void set_buynum(::google::protobuf::int32 value);

  // optional int32 pass = 5;
  inline bool has_pass() const;
  inline void clear_pass();
  static const int kPassFieldNumber = 5;
  inline ::google::protobuf::int32 pass() const;
  inline void set_pass(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.InstanceGroupList)
 private:
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_vipnum();
  inline void clear_has_vipnum();
  inline void set_has_buynum();
  inline void clear_has_buynum();
  inline void set_has_pass();
  inline void clear_has_pass();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 mapid_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 vipnum_;
  ::google::protobuf::int32 buynum_;
  ::google::protobuf::int32 pass_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static InstanceGroupList* default_instance_;
};
// -------------------------------------------------------------------

class EliteInstance : public ::google::protobuf::Message {
 public:
  EliteInstance();
  virtual ~EliteInstance();

  EliteInstance(const EliteInstance& from);

  inline EliteInstance& operator=(const EliteInstance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EliteInstance& default_instance();

  void Swap(EliteInstance* other);

  // implements Message ----------------------------------------------

  EliteInstance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EliteInstance& from);
  void MergeFrom(const EliteInstance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.InstanceEliteList list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::PlayerInfo::InstanceEliteList& list(int index) const;
  inline ::PlayerInfo::InstanceEliteList* mutable_list(int index);
  inline ::PlayerInfo::InstanceEliteList* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceEliteList >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceEliteList >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:PlayerInfo.EliteInstance)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceEliteList > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static EliteInstance* default_instance_;
};
// -------------------------------------------------------------------

class InstanceEliteList : public ::google::protobuf::Message {
 public:
  InstanceEliteList();
  virtual ~InstanceEliteList();

  InstanceEliteList(const InstanceEliteList& from);

  inline InstanceEliteList& operator=(const InstanceEliteList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceEliteList& default_instance();

  void Swap(InstanceEliteList* other);

  // implements Message ----------------------------------------------

  InstanceEliteList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceEliteList& from);
  void MergeFrom(const InstanceEliteList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 mapId = 1;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // optional int32 pass = 2;
  inline bool has_pass() const;
  inline void clear_pass();
  static const int kPassFieldNumber = 2;
  inline ::google::protobuf::int32 pass() const;
  inline void set_pass(::google::protobuf::int32 value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // optional int32 reset = 5;
  inline bool has_reset() const;
  inline void clear_reset();
  static const int kResetFieldNumber = 5;
  inline ::google::protobuf::int32 reset() const;
  inline void set_reset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.InstanceEliteList)
 private:
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_pass();
  inline void clear_has_pass();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_reset();
  inline void clear_has_reset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 mapid_;
  ::google::protobuf::int32 pass_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 reset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static InstanceEliteList* default_instance_;
};
// -------------------------------------------------------------------

class CauchemarInstance : public ::google::protobuf::Message {
 public:
  CauchemarInstance();
  virtual ~CauchemarInstance();

  CauchemarInstance(const CauchemarInstance& from);

  inline CauchemarInstance& operator=(const CauchemarInstance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CauchemarInstance& default_instance();

  void Swap(CauchemarInstance* other);

  // implements Message ----------------------------------------------

  CauchemarInstance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CauchemarInstance& from);
  void MergeFrom(const CauchemarInstance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.InstanceCauchemarList list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::PlayerInfo::InstanceCauchemarList& list(int index) const;
  inline ::PlayerInfo::InstanceCauchemarList* mutable_list(int index);
  inline ::PlayerInfo::InstanceCauchemarList* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceCauchemarList >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceCauchemarList >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:PlayerInfo.CauchemarInstance)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceCauchemarList > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static CauchemarInstance* default_instance_;
};
// -------------------------------------------------------------------

class InstanceCauchemarList : public ::google::protobuf::Message {
 public:
  InstanceCauchemarList();
  virtual ~InstanceCauchemarList();

  InstanceCauchemarList(const InstanceCauchemarList& from);

  inline InstanceCauchemarList& operator=(const InstanceCauchemarList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceCauchemarList& default_instance();

  void Swap(InstanceCauchemarList* other);

  // implements Message ----------------------------------------------

  InstanceCauchemarList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceCauchemarList& from);
  void MergeFrom(const InstanceCauchemarList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 mapId = 1;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // optional int32 pass = 2;
  inline bool has_pass() const;
  inline void clear_pass();
  static const int kPassFieldNumber = 2;
  inline ::google::protobuf::int32 pass() const;
  inline void set_pass(::google::protobuf::int32 value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // optional int32 reset = 5;
  inline bool has_reset() const;
  inline void clear_reset();
  static const int kResetFieldNumber = 5;
  inline ::google::protobuf::int32 reset() const;
  inline void set_reset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.InstanceCauchemarList)
 private:
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_pass();
  inline void clear_has_pass();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_reset();
  inline void clear_has_reset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 mapid_;
  ::google::protobuf::int32 pass_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 reset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static InstanceCauchemarList* default_instance_;
};
// -------------------------------------------------------------------

class AdvancedInstance : public ::google::protobuf::Message {
 public:
  AdvancedInstance();
  virtual ~AdvancedInstance();

  AdvancedInstance(const AdvancedInstance& from);

  inline AdvancedInstance& operator=(const AdvancedInstance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdvancedInstance& default_instance();

  void Swap(AdvancedInstance* other);

  // implements Message ----------------------------------------------

  AdvancedInstance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdvancedInstance& from);
  void MergeFrom(const AdvancedInstance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .PlayerInfo.InstanceAdvancedList list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::PlayerInfo::InstanceAdvancedList& list(int index) const;
  inline ::PlayerInfo::InstanceAdvancedList* mutable_list(int index);
  inline ::PlayerInfo::InstanceAdvancedList* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceAdvancedList >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceAdvancedList >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:PlayerInfo.AdvancedInstance)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceAdvancedList > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static AdvancedInstance* default_instance_;
};
// -------------------------------------------------------------------

class InstanceAdvancedList : public ::google::protobuf::Message {
 public:
  InstanceAdvancedList();
  virtual ~InstanceAdvancedList();

  InstanceAdvancedList(const InstanceAdvancedList& from);

  inline InstanceAdvancedList& operator=(const InstanceAdvancedList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstanceAdvancedList& default_instance();

  void Swap(InstanceAdvancedList* other);

  // implements Message ----------------------------------------------

  InstanceAdvancedList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstanceAdvancedList& from);
  void MergeFrom(const InstanceAdvancedList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 mapId = 1;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // optional int32 pass = 2;
  inline bool has_pass() const;
  inline void clear_pass();
  static const int kPassFieldNumber = 2;
  inline ::google::protobuf::int32 pass() const;
  inline void set_pass(::google::protobuf::int32 value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // optional int32 reset = 5;
  inline bool has_reset() const;
  inline void clear_reset();
  static const int kResetFieldNumber = 5;
  inline ::google::protobuf::int32 reset() const;
  inline void set_reset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.InstanceAdvancedList)
 private:
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_pass();
  inline void clear_has_pass();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_reset();
  inline void clear_has_reset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 mapid_;
  ::google::protobuf::int32 pass_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 reset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static InstanceAdvancedList* default_instance_;
};
// -------------------------------------------------------------------

class BaseShopInfo : public ::google::protobuf::Message {
 public:
  BaseShopInfo();
  virtual ~BaseShopInfo();

  BaseShopInfo(const BaseShopInfo& from);

  inline BaseShopInfo& operator=(const BaseShopInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseShopInfo& default_instance();

  void Swap(BaseShopInfo* other);

  // implements Message ----------------------------------------------

  BaseShopInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BaseShopInfo& from);
  void MergeFrom(const BaseShopInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 flushTime = 1;
  inline bool has_flushtime() const;
  inline void clear_flushtime();
  static const int kFlushTimeFieldNumber = 1;
  inline ::google::protobuf::int64 flushtime() const;
  inline void set_flushtime(::google::protobuf::int64 value);

  // repeated .PlayerInfo.BaseShopInfoList list = 2;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 2;
  inline const ::PlayerInfo::BaseShopInfoList& list(int index) const;
  inline ::PlayerInfo::BaseShopInfoList* mutable_list(int index);
  inline ::PlayerInfo::BaseShopInfoList* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BaseShopInfoList >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BaseShopInfoList >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:PlayerInfo.BaseShopInfo)
 private:
  inline void set_has_flushtime();
  inline void clear_has_flushtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 flushtime_;
  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BaseShopInfoList > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static BaseShopInfo* default_instance_;
};
// -------------------------------------------------------------------

class BaseShopInfoList : public ::google::protobuf::Message {
 public:
  BaseShopInfoList();
  virtual ~BaseShopInfoList();

  BaseShopInfoList(const BaseShopInfoList& from);

  inline BaseShopInfoList& operator=(const BaseShopInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseShopInfoList& default_instance();

  void Swap(BaseShopInfoList* other);

  // implements Message ----------------------------------------------

  BaseShopInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BaseShopInfoList& from);
  void MergeFrom(const BaseShopInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated .PlayerInfo.BaseShopInfoData data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::PlayerInfo::BaseShopInfoData& data(int index) const;
  inline ::PlayerInfo::BaseShopInfoData* mutable_data(int index);
  inline ::PlayerInfo::BaseShopInfoData* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BaseShopInfoData >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BaseShopInfoData >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:PlayerInfo.BaseShopInfoList)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BaseShopInfoData > data_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static BaseShopInfoList* default_instance_;
};
// -------------------------------------------------------------------

class BaseShopInfoData : public ::google::protobuf::Message {
 public:
  BaseShopInfoData();
  virtual ~BaseShopInfoData();

  BaseShopInfoData(const BaseShopInfoData& from);

  inline BaseShopInfoData& operator=(const BaseShopInfoData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseShopInfoData& default_instance();

  void Swap(BaseShopInfoData* other);

  // implements Message ----------------------------------------------

  BaseShopInfoData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BaseShopInfoData& from);
  void MergeFrom(const BaseShopInfoData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 nums = 2;
  inline bool has_nums() const;
  inline void clear_nums();
  static const int kNumsFieldNumber = 2;
  inline ::google::protobuf::int32 nums() const;
  inline void set_nums(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PlayerInfo.BaseShopInfoData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_nums();
  inline void clear_has_nums();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 nums_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static BaseShopInfoData* default_instance_;
};
// -------------------------------------------------------------------

class AnswerInfo : public ::google::protobuf::Message {
 public:
  AnswerInfo();
  virtual ~AnswerInfo();

  AnswerInfo(const AnswerInfo& from);

  inline AnswerInfo& operator=(const AnswerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnswerInfo& default_instance();

  void Swap(AnswerInfo* other);

  // implements Message ----------------------------------------------

  AnswerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnswerInfo& from);
  void MergeFrom(const AnswerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 currentIndex = 1;
  inline bool has_currentindex() const;
  inline void clear_currentindex();
  static const int kCurrentIndexFieldNumber = 1;
  inline ::google::protobuf::int32 currentindex() const;
  inline void set_currentindex(::google::protobuf::int32 value);

  // optional int32 currentTitleID = 2;
  inline bool has_currenttitleid() const;
  inline void clear_currenttitleid();
  static const int kCurrentTitleIDFieldNumber = 2;
  inline ::google::protobuf::int32 currenttitleid() const;
  inline void set_currenttitleid(::google::protobuf::int32 value);

  // optional int32 rightCounts = 3;
  inline bool has_rightcounts() const;
  inline void clear_rightcounts();
  static const int kRightCountsFieldNumber = 3;
  inline ::google::protobuf::int32 rightcounts() const;
  inline void set_rightcounts(::google::protobuf::int32 value);

  // optional int32 wrongCounts = 4;
  inline bool has_wrongcounts() const;
  inline void clear_wrongcounts();
  static const int kWrongCountsFieldNumber = 4;
  inline ::google::protobuf::int32 wrongcounts() const;
  inline void set_wrongcounts(::google::protobuf::int32 value);

  // repeated int32 titleAnswerIds = 5;
  inline int titleanswerids_size() const;
  inline void clear_titleanswerids();
  static const int kTitleAnswerIdsFieldNumber = 5;
  inline ::google::protobuf::int32 titleanswerids(int index) const;
  inline void set_titleanswerids(int index, ::google::protobuf::int32 value);
  inline void add_titleanswerids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      titleanswerids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_titleanswerids();

  // @@protoc_insertion_point(class_scope:PlayerInfo.AnswerInfo)
 private:
  inline void set_has_currentindex();
  inline void clear_has_currentindex();
  inline void set_has_currenttitleid();
  inline void clear_has_currenttitleid();
  inline void set_has_rightcounts();
  inline void clear_has_rightcounts();
  inline void set_has_wrongcounts();
  inline void clear_has_wrongcounts();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 currentindex_;
  ::google::protobuf::int32 currenttitleid_;
  ::google::protobuf::int32 rightcounts_;
  ::google::protobuf::int32 wrongcounts_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > titleanswerids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fPlayerInfo_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fPlayerInfo_2eproto();

  void InitAsDefaultInstance();
  static AnswerInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// PlayerInfo

// required .PlayerInfo.BaseInfo bsinfo = 1;
inline bool PlayerInfo::has_bsinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfo::set_has_bsinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfo::clear_has_bsinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfo::clear_bsinfo() {
  if (bsinfo_ != NULL) bsinfo_->::PlayerInfo::BaseInfo::Clear();
  clear_has_bsinfo();
}
inline const ::PlayerInfo::BaseInfo& PlayerInfo::bsinfo() const {
  return bsinfo_ != NULL ? *bsinfo_ : *default_instance_->bsinfo_;
}
inline ::PlayerInfo::BaseInfo* PlayerInfo::mutable_bsinfo() {
  set_has_bsinfo();
  if (bsinfo_ == NULL) bsinfo_ = new ::PlayerInfo::BaseInfo;
  return bsinfo_;
}
inline ::PlayerInfo::BaseInfo* PlayerInfo::release_bsinfo() {
  clear_has_bsinfo();
  ::PlayerInfo::BaseInfo* temp = bsinfo_;
  bsinfo_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_bsinfo(::PlayerInfo::BaseInfo* bsinfo) {
  delete bsinfo_;
  bsinfo_ = bsinfo;
  if (bsinfo) {
    set_has_bsinfo();
  } else {
    clear_has_bsinfo();
  }
}

// optional .PlayerInfo.BattleInfo binfo = 2;
inline bool PlayerInfo::has_binfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfo::set_has_binfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfo::clear_has_binfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfo::clear_binfo() {
  if (binfo_ != NULL) binfo_->::PlayerInfo::BattleInfo::Clear();
  clear_has_binfo();
}
inline const ::PlayerInfo::BattleInfo& PlayerInfo::binfo() const {
  return binfo_ != NULL ? *binfo_ : *default_instance_->binfo_;
}
inline ::PlayerInfo::BattleInfo* PlayerInfo::mutable_binfo() {
  set_has_binfo();
  if (binfo_ == NULL) binfo_ = new ::PlayerInfo::BattleInfo;
  return binfo_;
}
inline ::PlayerInfo::BattleInfo* PlayerInfo::release_binfo() {
  clear_has_binfo();
  ::PlayerInfo::BattleInfo* temp = binfo_;
  binfo_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_binfo(::PlayerInfo::BattleInfo* binfo) {
  delete binfo_;
  binfo_ = binfo;
  if (binfo) {
    set_has_binfo();
  } else {
    clear_has_binfo();
  }
}

// optional .PlayerInfo.QuestInfo questinfo = 3;
inline bool PlayerInfo::has_questinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerInfo::set_has_questinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerInfo::clear_has_questinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerInfo::clear_questinfo() {
  if (questinfo_ != NULL) questinfo_->::PlayerInfo::QuestInfo::Clear();
  clear_has_questinfo();
}
inline const ::PlayerInfo::QuestInfo& PlayerInfo::questinfo() const {
  return questinfo_ != NULL ? *questinfo_ : *default_instance_->questinfo_;
}
inline ::PlayerInfo::QuestInfo* PlayerInfo::mutable_questinfo() {
  set_has_questinfo();
  if (questinfo_ == NULL) questinfo_ = new ::PlayerInfo::QuestInfo;
  return questinfo_;
}
inline ::PlayerInfo::QuestInfo* PlayerInfo::release_questinfo() {
  clear_has_questinfo();
  ::PlayerInfo::QuestInfo* temp = questinfo_;
  questinfo_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_questinfo(::PlayerInfo::QuestInfo* questinfo) {
  delete questinfo_;
  questinfo_ = questinfo;
  if (questinfo) {
    set_has_questinfo();
  } else {
    clear_has_questinfo();
  }
}

// optional .PlayerInfo.SkillInfo skill = 4;
inline bool PlayerInfo::has_skill() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerInfo::set_has_skill() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerInfo::clear_has_skill() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerInfo::clear_skill() {
  if (skill_ != NULL) skill_->::PlayerInfo::SkillInfo::Clear();
  clear_has_skill();
}
inline const ::PlayerInfo::SkillInfo& PlayerInfo::skill() const {
  return skill_ != NULL ? *skill_ : *default_instance_->skill_;
}
inline ::PlayerInfo::SkillInfo* PlayerInfo::mutable_skill() {
  set_has_skill();
  if (skill_ == NULL) skill_ = new ::PlayerInfo::SkillInfo;
  return skill_;
}
inline ::PlayerInfo::SkillInfo* PlayerInfo::release_skill() {
  clear_has_skill();
  ::PlayerInfo::SkillInfo* temp = skill_;
  skill_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_skill(::PlayerInfo::SkillInfo* skill) {
  delete skill_;
  skill_ = skill;
  if (skill) {
    set_has_skill();
  } else {
    clear_has_skill();
  }
}

// optional .PlayerInfo.CDInfo cd = 5;
inline bool PlayerInfo::has_cd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerInfo::set_has_cd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerInfo::clear_has_cd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerInfo::clear_cd() {
  if (cd_ != NULL) cd_->::PlayerInfo::CDInfo::Clear();
  clear_has_cd();
}
inline const ::PlayerInfo::CDInfo& PlayerInfo::cd() const {
  return cd_ != NULL ? *cd_ : *default_instance_->cd_;
}
inline ::PlayerInfo::CDInfo* PlayerInfo::mutable_cd() {
  set_has_cd();
  if (cd_ == NULL) cd_ = new ::PlayerInfo::CDInfo;
  return cd_;
}
inline ::PlayerInfo::CDInfo* PlayerInfo::release_cd() {
  clear_has_cd();
  ::PlayerInfo::CDInfo* temp = cd_;
  cd_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_cd(::PlayerInfo::CDInfo* cd) {
  delete cd_;
  cd_ = cd;
  if (cd) {
    set_has_cd();
  } else {
    clear_has_cd();
  }
}

// optional .PlayerInfo.MonitorInfo mt = 6;
inline bool PlayerInfo::has_mt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerInfo::set_has_mt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerInfo::clear_has_mt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerInfo::clear_mt() {
  if (mt_ != NULL) mt_->::PlayerInfo::MonitorInfo::Clear();
  clear_has_mt();
}
inline const ::PlayerInfo::MonitorInfo& PlayerInfo::mt() const {
  return mt_ != NULL ? *mt_ : *default_instance_->mt_;
}
inline ::PlayerInfo::MonitorInfo* PlayerInfo::mutable_mt() {
  set_has_mt();
  if (mt_ == NULL) mt_ = new ::PlayerInfo::MonitorInfo;
  return mt_;
}
inline ::PlayerInfo::MonitorInfo* PlayerInfo::release_mt() {
  clear_has_mt();
  ::PlayerInfo::MonitorInfo* temp = mt_;
  mt_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_mt(::PlayerInfo::MonitorInfo* mt) {
  delete mt_;
  mt_ = mt;
  if (mt) {
    set_has_mt();
  } else {
    clear_has_mt();
  }
}

// optional .PlayerInfo.EquipQuickInfo equipquick = 7;
inline bool PlayerInfo::has_equipquick() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerInfo::set_has_equipquick() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerInfo::clear_has_equipquick() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerInfo::clear_equipquick() {
  if (equipquick_ != NULL) equipquick_->::PlayerInfo::EquipQuickInfo::Clear();
  clear_has_equipquick();
}
inline const ::PlayerInfo::EquipQuickInfo& PlayerInfo::equipquick() const {
  return equipquick_ != NULL ? *equipquick_ : *default_instance_->equipquick_;
}
inline ::PlayerInfo::EquipQuickInfo* PlayerInfo::mutable_equipquick() {
  set_has_equipquick();
  if (equipquick_ == NULL) equipquick_ = new ::PlayerInfo::EquipQuickInfo;
  return equipquick_;
}
inline ::PlayerInfo::EquipQuickInfo* PlayerInfo::release_equipquick() {
  clear_has_equipquick();
  ::PlayerInfo::EquipQuickInfo* temp = equipquick_;
  equipquick_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_equipquick(::PlayerInfo::EquipQuickInfo* equipquick) {
  delete equipquick_;
  equipquick_ = equipquick;
  if (equipquick) {
    set_has_equipquick();
  } else {
    clear_has_equipquick();
  }
}

// optional .PlayerInfo.GirlWarInfo girlwarinfo = 8;
inline bool PlayerInfo::has_girlwarinfo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayerInfo::set_has_girlwarinfo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayerInfo::clear_has_girlwarinfo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayerInfo::clear_girlwarinfo() {
  if (girlwarinfo_ != NULL) girlwarinfo_->::PlayerInfo::GirlWarInfo::Clear();
  clear_has_girlwarinfo();
}
inline const ::PlayerInfo::GirlWarInfo& PlayerInfo::girlwarinfo() const {
  return girlwarinfo_ != NULL ? *girlwarinfo_ : *default_instance_->girlwarinfo_;
}
inline ::PlayerInfo::GirlWarInfo* PlayerInfo::mutable_girlwarinfo() {
  set_has_girlwarinfo();
  if (girlwarinfo_ == NULL) girlwarinfo_ = new ::PlayerInfo::GirlWarInfo;
  return girlwarinfo_;
}
inline ::PlayerInfo::GirlWarInfo* PlayerInfo::release_girlwarinfo() {
  clear_has_girlwarinfo();
  ::PlayerInfo::GirlWarInfo* temp = girlwarinfo_;
  girlwarinfo_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_girlwarinfo(::PlayerInfo::GirlWarInfo* girlwarinfo) {
  delete girlwarinfo_;
  girlwarinfo_ = girlwarinfo;
  if (girlwarinfo) {
    set_has_girlwarinfo();
  } else {
    clear_has_girlwarinfo();
  }
}

// optional .PlayerInfo.CounterServiceList counter = 9;
inline bool PlayerInfo::has_counter() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlayerInfo::set_has_counter() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlayerInfo::clear_has_counter() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlayerInfo::clear_counter() {
  if (counter_ != NULL) counter_->::PlayerInfo::CounterServiceList::Clear();
  clear_has_counter();
}
inline const ::PlayerInfo::CounterServiceList& PlayerInfo::counter() const {
  return counter_ != NULL ? *counter_ : *default_instance_->counter_;
}
inline ::PlayerInfo::CounterServiceList* PlayerInfo::mutable_counter() {
  set_has_counter();
  if (counter_ == NULL) counter_ = new ::PlayerInfo::CounterServiceList;
  return counter_;
}
inline ::PlayerInfo::CounterServiceList* PlayerInfo::release_counter() {
  clear_has_counter();
  ::PlayerInfo::CounterServiceList* temp = counter_;
  counter_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_counter(::PlayerInfo::CounterServiceList* counter) {
  delete counter_;
  counter_ = counter;
  if (counter) {
    set_has_counter();
  } else {
    clear_has_counter();
  }
}

// optional .PlayerInfo.HorseInfo horse = 10;
inline bool PlayerInfo::has_horse() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PlayerInfo::set_has_horse() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PlayerInfo::clear_has_horse() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PlayerInfo::clear_horse() {
  if (horse_ != NULL) horse_->::PlayerInfo::HorseInfo::Clear();
  clear_has_horse();
}
inline const ::PlayerInfo::HorseInfo& PlayerInfo::horse() const {
  return horse_ != NULL ? *horse_ : *default_instance_->horse_;
}
inline ::PlayerInfo::HorseInfo* PlayerInfo::mutable_horse() {
  set_has_horse();
  if (horse_ == NULL) horse_ = new ::PlayerInfo::HorseInfo;
  return horse_;
}
inline ::PlayerInfo::HorseInfo* PlayerInfo::release_horse() {
  clear_has_horse();
  ::PlayerInfo::HorseInfo* temp = horse_;
  horse_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_horse(::PlayerInfo::HorseInfo* horse) {
  delete horse_;
  horse_ = horse;
  if (horse) {
    set_has_horse();
  } else {
    clear_has_horse();
  }
}

// optional .PlayerInfo.DanLuInfo danlu = 11;
inline bool PlayerInfo::has_danlu() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PlayerInfo::set_has_danlu() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PlayerInfo::clear_has_danlu() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PlayerInfo::clear_danlu() {
  if (danlu_ != NULL) danlu_->::PlayerInfo::DanLuInfo::Clear();
  clear_has_danlu();
}
inline const ::PlayerInfo::DanLuInfo& PlayerInfo::danlu() const {
  return danlu_ != NULL ? *danlu_ : *default_instance_->danlu_;
}
inline ::PlayerInfo::DanLuInfo* PlayerInfo::mutable_danlu() {
  set_has_danlu();
  if (danlu_ == NULL) danlu_ = new ::PlayerInfo::DanLuInfo;
  return danlu_;
}
inline ::PlayerInfo::DanLuInfo* PlayerInfo::release_danlu() {
  clear_has_danlu();
  ::PlayerInfo::DanLuInfo* temp = danlu_;
  danlu_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_danlu(::PlayerInfo::DanLuInfo* danlu) {
  delete danlu_;
  danlu_ = danlu;
  if (danlu) {
    set_has_danlu();
  } else {
    clear_has_danlu();
  }
}

// optional .PlayerInfo.MagicWeapon magicw = 12;
inline bool PlayerInfo::has_magicw() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PlayerInfo::set_has_magicw() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PlayerInfo::clear_has_magicw() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PlayerInfo::clear_magicw() {
  if (magicw_ != NULL) magicw_->::PlayerInfo::MagicWeapon::Clear();
  clear_has_magicw();
}
inline const ::PlayerInfo::MagicWeapon& PlayerInfo::magicw() const {
  return magicw_ != NULL ? *magicw_ : *default_instance_->magicw_;
}
inline ::PlayerInfo::MagicWeapon* PlayerInfo::mutable_magicw() {
  set_has_magicw();
  if (magicw_ == NULL) magicw_ = new ::PlayerInfo::MagicWeapon;
  return magicw_;
}
inline ::PlayerInfo::MagicWeapon* PlayerInfo::release_magicw() {
  clear_has_magicw();
  ::PlayerInfo::MagicWeapon* temp = magicw_;
  magicw_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_magicw(::PlayerInfo::MagicWeapon* magicw) {
  delete magicw_;
  magicw_ = magicw;
  if (magicw) {
    set_has_magicw();
  } else {
    clear_has_magicw();
  }
}

// optional .PlayerInfo.RandCJobLucky cjob = 13;
inline bool PlayerInfo::has_cjob() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PlayerInfo::set_has_cjob() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PlayerInfo::clear_has_cjob() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PlayerInfo::clear_cjob() {
  if (cjob_ != NULL) cjob_->::PlayerInfo::RandCJobLucky::Clear();
  clear_has_cjob();
}
inline const ::PlayerInfo::RandCJobLucky& PlayerInfo::cjob() const {
  return cjob_ != NULL ? *cjob_ : *default_instance_->cjob_;
}
inline ::PlayerInfo::RandCJobLucky* PlayerInfo::mutable_cjob() {
  set_has_cjob();
  if (cjob_ == NULL) cjob_ = new ::PlayerInfo::RandCJobLucky;
  return cjob_;
}
inline ::PlayerInfo::RandCJobLucky* PlayerInfo::release_cjob() {
  clear_has_cjob();
  ::PlayerInfo::RandCJobLucky* temp = cjob_;
  cjob_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_cjob(::PlayerInfo::RandCJobLucky* cjob) {
  delete cjob_;
  cjob_ = cjob;
  if (cjob) {
    set_has_cjob();
  } else {
    clear_has_cjob();
  }
}

// optional .PlayerInfo.LucklyTurntable lucktable = 14;
inline bool PlayerInfo::has_lucktable() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PlayerInfo::set_has_lucktable() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PlayerInfo::clear_has_lucktable() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PlayerInfo::clear_lucktable() {
  if (lucktable_ != NULL) lucktable_->::PlayerInfo::LucklyTurntable::Clear();
  clear_has_lucktable();
}
inline const ::PlayerInfo::LucklyTurntable& PlayerInfo::lucktable() const {
  return lucktable_ != NULL ? *lucktable_ : *default_instance_->lucktable_;
}
inline ::PlayerInfo::LucklyTurntable* PlayerInfo::mutable_lucktable() {
  set_has_lucktable();
  if (lucktable_ == NULL) lucktable_ = new ::PlayerInfo::LucklyTurntable;
  return lucktable_;
}
inline ::PlayerInfo::LucklyTurntable* PlayerInfo::release_lucktable() {
  clear_has_lucktable();
  ::PlayerInfo::LucklyTurntable* temp = lucktable_;
  lucktable_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_lucktable(::PlayerInfo::LucklyTurntable* lucktable) {
  delete lucktable_;
  lucktable_ = lucktable;
  if (lucktable) {
    set_has_lucktable();
  } else {
    clear_has_lucktable();
  }
}

// optional .PlayerInfo.Activity activity = 15;
inline bool PlayerInfo::has_activity() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PlayerInfo::set_has_activity() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PlayerInfo::clear_has_activity() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PlayerInfo::clear_activity() {
  if (activity_ != NULL) activity_->::PlayerInfo::Activity::Clear();
  clear_has_activity();
}
inline const ::PlayerInfo::Activity& PlayerInfo::activity() const {
  return activity_ != NULL ? *activity_ : *default_instance_->activity_;
}
inline ::PlayerInfo::Activity* PlayerInfo::mutable_activity() {
  set_has_activity();
  if (activity_ == NULL) activity_ = new ::PlayerInfo::Activity;
  return activity_;
}
inline ::PlayerInfo::Activity* PlayerInfo::release_activity() {
  clear_has_activity();
  ::PlayerInfo::Activity* temp = activity_;
  activity_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_activity(::PlayerInfo::Activity* activity) {
  delete activity_;
  activity_ = activity;
  if (activity) {
    set_has_activity();
  } else {
    clear_has_activity();
  }
}

// optional .PlayerInfo.DestinationInfoList destination = 16;
inline bool PlayerInfo::has_destination() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PlayerInfo::set_has_destination() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PlayerInfo::clear_has_destination() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PlayerInfo::clear_destination() {
  if (destination_ != NULL) destination_->::PlayerInfo::DestinationInfoList::Clear();
  clear_has_destination();
}
inline const ::PlayerInfo::DestinationInfoList& PlayerInfo::destination() const {
  return destination_ != NULL ? *destination_ : *default_instance_->destination_;
}
inline ::PlayerInfo::DestinationInfoList* PlayerInfo::mutable_destination() {
  set_has_destination();
  if (destination_ == NULL) destination_ = new ::PlayerInfo::DestinationInfoList;
  return destination_;
}
inline ::PlayerInfo::DestinationInfoList* PlayerInfo::release_destination() {
  clear_has_destination();
  ::PlayerInfo::DestinationInfoList* temp = destination_;
  destination_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_destination(::PlayerInfo::DestinationInfoList* destination) {
  delete destination_;
  destination_ = destination;
  if (destination) {
    set_has_destination();
  } else {
    clear_has_destination();
  }
}

// optional .PlayerInfo.InstanceInfoTwoDays instanceList = 17;
inline bool PlayerInfo::has_instancelist() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PlayerInfo::set_has_instancelist() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PlayerInfo::clear_has_instancelist() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PlayerInfo::clear_instancelist() {
  if (instancelist_ != NULL) instancelist_->::PlayerInfo::InstanceInfoTwoDays::Clear();
  clear_has_instancelist();
}
inline const ::PlayerInfo::InstanceInfoTwoDays& PlayerInfo::instancelist() const {
  return instancelist_ != NULL ? *instancelist_ : *default_instance_->instancelist_;
}
inline ::PlayerInfo::InstanceInfoTwoDays* PlayerInfo::mutable_instancelist() {
  set_has_instancelist();
  if (instancelist_ == NULL) instancelist_ = new ::PlayerInfo::InstanceInfoTwoDays;
  return instancelist_;
}
inline ::PlayerInfo::InstanceInfoTwoDays* PlayerInfo::release_instancelist() {
  clear_has_instancelist();
  ::PlayerInfo::InstanceInfoTwoDays* temp = instancelist_;
  instancelist_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_instancelist(::PlayerInfo::InstanceInfoTwoDays* instancelist) {
  delete instancelist_;
  instancelist_ = instancelist;
  if (instancelist) {
    set_has_instancelist();
  } else {
    clear_has_instancelist();
  }
}

// optional .PlayerInfo.SignInInfo signin = 18;
inline bool PlayerInfo::has_signin() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PlayerInfo::set_has_signin() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PlayerInfo::clear_has_signin() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PlayerInfo::clear_signin() {
  if (signin_ != NULL) signin_->::PlayerInfo::SignInInfo::Clear();
  clear_has_signin();
}
inline const ::PlayerInfo::SignInInfo& PlayerInfo::signin() const {
  return signin_ != NULL ? *signin_ : *default_instance_->signin_;
}
inline ::PlayerInfo::SignInInfo* PlayerInfo::mutable_signin() {
  set_has_signin();
  if (signin_ == NULL) signin_ = new ::PlayerInfo::SignInInfo;
  return signin_;
}
inline ::PlayerInfo::SignInInfo* PlayerInfo::release_signin() {
  clear_has_signin();
  ::PlayerInfo::SignInInfo* temp = signin_;
  signin_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_signin(::PlayerInfo::SignInInfo* signin) {
  delete signin_;
  signin_ = signin;
  if (signin) {
    set_has_signin();
  } else {
    clear_has_signin();
  }
}

// optional .PlayerInfo.EscortInfo escort = 19;
inline bool PlayerInfo::has_escort() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PlayerInfo::set_has_escort() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PlayerInfo::clear_has_escort() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PlayerInfo::clear_escort() {
  if (escort_ != NULL) escort_->::PlayerInfo::EscortInfo::Clear();
  clear_has_escort();
}
inline const ::PlayerInfo::EscortInfo& PlayerInfo::escort() const {
  return escort_ != NULL ? *escort_ : *default_instance_->escort_;
}
inline ::PlayerInfo::EscortInfo* PlayerInfo::mutable_escort() {
  set_has_escort();
  if (escort_ == NULL) escort_ = new ::PlayerInfo::EscortInfo;
  return escort_;
}
inline ::PlayerInfo::EscortInfo* PlayerInfo::release_escort() {
  clear_has_escort();
  ::PlayerInfo::EscortInfo* temp = escort_;
  escort_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_escort(::PlayerInfo::EscortInfo* escort) {
  delete escort_;
  escort_ = escort;
  if (escort) {
    set_has_escort();
  } else {
    clear_has_escort();
  }
}

// optional .PlayerInfo.PlayerVipInfo playerVip = 20;
inline bool PlayerInfo::has_playervip() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PlayerInfo::set_has_playervip() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PlayerInfo::clear_has_playervip() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PlayerInfo::clear_playervip() {
  if (playervip_ != NULL) playervip_->::PlayerInfo::PlayerVipInfo::Clear();
  clear_has_playervip();
}
inline const ::PlayerInfo::PlayerVipInfo& PlayerInfo::playervip() const {
  return playervip_ != NULL ? *playervip_ : *default_instance_->playervip_;
}
inline ::PlayerInfo::PlayerVipInfo* PlayerInfo::mutable_playervip() {
  set_has_playervip();
  if (playervip_ == NULL) playervip_ = new ::PlayerInfo::PlayerVipInfo;
  return playervip_;
}
inline ::PlayerInfo::PlayerVipInfo* PlayerInfo::release_playervip() {
  clear_has_playervip();
  ::PlayerInfo::PlayerVipInfo* temp = playervip_;
  playervip_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_playervip(::PlayerInfo::PlayerVipInfo* playervip) {
  delete playervip_;
  playervip_ = playervip;
  if (playervip) {
    set_has_playervip();
  } else {
    clear_has_playervip();
  }
}

// optional .PlayerInfo.PrestigeInfoList prestige = 21;
inline bool PlayerInfo::has_prestige() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PlayerInfo::set_has_prestige() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PlayerInfo::clear_has_prestige() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PlayerInfo::clear_prestige() {
  if (prestige_ != NULL) prestige_->::PlayerInfo::PrestigeInfoList::Clear();
  clear_has_prestige();
}
inline const ::PlayerInfo::PrestigeInfoList& PlayerInfo::prestige() const {
  return prestige_ != NULL ? *prestige_ : *default_instance_->prestige_;
}
inline ::PlayerInfo::PrestigeInfoList* PlayerInfo::mutable_prestige() {
  set_has_prestige();
  if (prestige_ == NULL) prestige_ = new ::PlayerInfo::PrestigeInfoList;
  return prestige_;
}
inline ::PlayerInfo::PrestigeInfoList* PlayerInfo::release_prestige() {
  clear_has_prestige();
  ::PlayerInfo::PrestigeInfoList* temp = prestige_;
  prestige_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_prestige(::PlayerInfo::PrestigeInfoList* prestige) {
  delete prestige_;
  prestige_ = prestige;
  if (prestige) {
    set_has_prestige();
  } else {
    clear_has_prestige();
  }
}

// optional .PlayerInfo.TitleInfoList title = 22;
inline bool PlayerInfo::has_title() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PlayerInfo::set_has_title() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PlayerInfo::clear_has_title() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PlayerInfo::clear_title() {
  if (title_ != NULL) title_->::PlayerInfo::TitleInfoList::Clear();
  clear_has_title();
}
inline const ::PlayerInfo::TitleInfoList& PlayerInfo::title() const {
  return title_ != NULL ? *title_ : *default_instance_->title_;
}
inline ::PlayerInfo::TitleInfoList* PlayerInfo::mutable_title() {
  set_has_title();
  if (title_ == NULL) title_ = new ::PlayerInfo::TitleInfoList;
  return title_;
}
inline ::PlayerInfo::TitleInfoList* PlayerInfo::release_title() {
  clear_has_title();
  ::PlayerInfo::TitleInfoList* temp = title_;
  title_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_title(::PlayerInfo::TitleInfoList* title) {
  delete title_;
  title_ = title;
  if (title) {
    set_has_title();
  } else {
    clear_has_title();
  }
}

// optional .FashionMsgProto.FashionShow fashion = 23;
inline bool PlayerInfo::has_fashion() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PlayerInfo::set_has_fashion() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PlayerInfo::clear_has_fashion() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PlayerInfo::clear_fashion() {
  if (fashion_ != NULL) fashion_->::FashionMsgProto::FashionShow::Clear();
  clear_has_fashion();
}
inline const ::FashionMsgProto::FashionShow& PlayerInfo::fashion() const {
  return fashion_ != NULL ? *fashion_ : *default_instance_->fashion_;
}
inline ::FashionMsgProto::FashionShow* PlayerInfo::mutable_fashion() {
  set_has_fashion();
  if (fashion_ == NULL) fashion_ = new ::FashionMsgProto::FashionShow;
  return fashion_;
}
inline ::FashionMsgProto::FashionShow* PlayerInfo::release_fashion() {
  clear_has_fashion();
  ::FashionMsgProto::FashionShow* temp = fashion_;
  fashion_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_fashion(::FashionMsgProto::FashionShow* fashion) {
  delete fashion_;
  fashion_ = fashion;
  if (fashion) {
    set_has_fashion();
  } else {
    clear_has_fashion();
  }
}

// optional .VitalityProto.ProtoVitalityInfo vitality = 24;
inline bool PlayerInfo::has_vitality() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PlayerInfo::set_has_vitality() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PlayerInfo::clear_has_vitality() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PlayerInfo::clear_vitality() {
  if (vitality_ != NULL) vitality_->::VitalityProto::ProtoVitalityInfo::Clear();
  clear_has_vitality();
}
inline const ::VitalityProto::ProtoVitalityInfo& PlayerInfo::vitality() const {
  return vitality_ != NULL ? *vitality_ : *default_instance_->vitality_;
}
inline ::VitalityProto::ProtoVitalityInfo* PlayerInfo::mutable_vitality() {
  set_has_vitality();
  if (vitality_ == NULL) vitality_ = new ::VitalityProto::ProtoVitalityInfo;
  return vitality_;
}
inline ::VitalityProto::ProtoVitalityInfo* PlayerInfo::release_vitality() {
  clear_has_vitality();
  ::VitalityProto::ProtoVitalityInfo* temp = vitality_;
  vitality_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_vitality(::VitalityProto::ProtoVitalityInfo* vitality) {
  delete vitality_;
  vitality_ = vitality;
  if (vitality) {
    set_has_vitality();
  } else {
    clear_has_vitality();
  }
}

// optional .PlayerInfo.CampShopInfo campShopData = 25;
inline bool PlayerInfo::has_campshopdata() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PlayerInfo::set_has_campshopdata() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PlayerInfo::clear_has_campshopdata() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PlayerInfo::clear_campshopdata() {
  if (campshopdata_ != NULL) campshopdata_->::PlayerInfo::CampShopInfo::Clear();
  clear_has_campshopdata();
}
inline const ::PlayerInfo::CampShopInfo& PlayerInfo::campshopdata() const {
  return campshopdata_ != NULL ? *campshopdata_ : *default_instance_->campshopdata_;
}
inline ::PlayerInfo::CampShopInfo* PlayerInfo::mutable_campshopdata() {
  set_has_campshopdata();
  if (campshopdata_ == NULL) campshopdata_ = new ::PlayerInfo::CampShopInfo;
  return campshopdata_;
}
inline ::PlayerInfo::CampShopInfo* PlayerInfo::release_campshopdata() {
  clear_has_campshopdata();
  ::PlayerInfo::CampShopInfo* temp = campshopdata_;
  campshopdata_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_campshopdata(::PlayerInfo::CampShopInfo* campshopdata) {
  delete campshopdata_;
  campshopdata_ = campshopdata;
  if (campshopdata) {
    set_has_campshopdata();
  } else {
    clear_has_campshopdata();
  }
}

// optional .PlayerInfo.FestivalInfo festivalData = 26;
inline bool PlayerInfo::has_festivaldata() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PlayerInfo::set_has_festivaldata() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PlayerInfo::clear_has_festivaldata() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PlayerInfo::clear_festivaldata() {
  if (festivaldata_ != NULL) festivaldata_->::PlayerInfo::FestivalInfo::Clear();
  clear_has_festivaldata();
}
inline const ::PlayerInfo::FestivalInfo& PlayerInfo::festivaldata() const {
  return festivaldata_ != NULL ? *festivaldata_ : *default_instance_->festivaldata_;
}
inline ::PlayerInfo::FestivalInfo* PlayerInfo::mutable_festivaldata() {
  set_has_festivaldata();
  if (festivaldata_ == NULL) festivaldata_ = new ::PlayerInfo::FestivalInfo;
  return festivaldata_;
}
inline ::PlayerInfo::FestivalInfo* PlayerInfo::release_festivaldata() {
  clear_has_festivaldata();
  ::PlayerInfo::FestivalInfo* temp = festivaldata_;
  festivaldata_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_festivaldata(::PlayerInfo::FestivalInfo* festivaldata) {
  delete festivaldata_;
  festivaldata_ = festivaldata;
  if (festivaldata) {
    set_has_festivaldata();
  } else {
    clear_has_festivaldata();
  }
}

// optional .PlayerInfo.MoneyInstance info = 27;
inline bool PlayerInfo::has_info() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PlayerInfo::set_has_info() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PlayerInfo::clear_has_info() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PlayerInfo::clear_info() {
  if (info_ != NULL) info_->::PlayerInfo::MoneyInstance::Clear();
  clear_has_info();
}
inline const ::PlayerInfo::MoneyInstance& PlayerInfo::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::PlayerInfo::MoneyInstance* PlayerInfo::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::PlayerInfo::MoneyInstance;
  return info_;
}
inline ::PlayerInfo::MoneyInstance* PlayerInfo::release_info() {
  clear_has_info();
  ::PlayerInfo::MoneyInstance* temp = info_;
  info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_info(::PlayerInfo::MoneyInstance* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional .PlayerInfo.OnceRewardInfo onceReward = 28;
inline bool PlayerInfo::has_oncereward() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PlayerInfo::set_has_oncereward() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PlayerInfo::clear_has_oncereward() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PlayerInfo::clear_oncereward() {
  if (oncereward_ != NULL) oncereward_->::PlayerInfo::OnceRewardInfo::Clear();
  clear_has_oncereward();
}
inline const ::PlayerInfo::OnceRewardInfo& PlayerInfo::oncereward() const {
  return oncereward_ != NULL ? *oncereward_ : *default_instance_->oncereward_;
}
inline ::PlayerInfo::OnceRewardInfo* PlayerInfo::mutable_oncereward() {
  set_has_oncereward();
  if (oncereward_ == NULL) oncereward_ = new ::PlayerInfo::OnceRewardInfo;
  return oncereward_;
}
inline ::PlayerInfo::OnceRewardInfo* PlayerInfo::release_oncereward() {
  clear_has_oncereward();
  ::PlayerInfo::OnceRewardInfo* temp = oncereward_;
  oncereward_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_oncereward(::PlayerInfo::OnceRewardInfo* oncereward) {
  delete oncereward_;
  oncereward_ = oncereward;
  if (oncereward) {
    set_has_oncereward();
  } else {
    clear_has_oncereward();
  }
}

// optional .PlayerInfo.RingDBData ringData = 29;
inline bool PlayerInfo::has_ringdata() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PlayerInfo::set_has_ringdata() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PlayerInfo::clear_has_ringdata() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PlayerInfo::clear_ringdata() {
  if (ringdata_ != NULL) ringdata_->::PlayerInfo::RingDBData::Clear();
  clear_has_ringdata();
}
inline const ::PlayerInfo::RingDBData& PlayerInfo::ringdata() const {
  return ringdata_ != NULL ? *ringdata_ : *default_instance_->ringdata_;
}
inline ::PlayerInfo::RingDBData* PlayerInfo::mutable_ringdata() {
  set_has_ringdata();
  if (ringdata_ == NULL) ringdata_ = new ::PlayerInfo::RingDBData;
  return ringdata_;
}
inline ::PlayerInfo::RingDBData* PlayerInfo::release_ringdata() {
  clear_has_ringdata();
  ::PlayerInfo::RingDBData* temp = ringdata_;
  ringdata_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_ringdata(::PlayerInfo::RingDBData* ringdata) {
  delete ringdata_;
  ringdata_ = ringdata;
  if (ringdata) {
    set_has_ringdata();
  } else {
    clear_has_ringdata();
  }
}

// optional .PlayerInfo.GroupInstance groupInfo = 30;
inline bool PlayerInfo::has_groupinfo() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PlayerInfo::set_has_groupinfo() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PlayerInfo::clear_has_groupinfo() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PlayerInfo::clear_groupinfo() {
  if (groupinfo_ != NULL) groupinfo_->::PlayerInfo::GroupInstance::Clear();
  clear_has_groupinfo();
}
inline const ::PlayerInfo::GroupInstance& PlayerInfo::groupinfo() const {
  return groupinfo_ != NULL ? *groupinfo_ : *default_instance_->groupinfo_;
}
inline ::PlayerInfo::GroupInstance* PlayerInfo::mutable_groupinfo() {
  set_has_groupinfo();
  if (groupinfo_ == NULL) groupinfo_ = new ::PlayerInfo::GroupInstance;
  return groupinfo_;
}
inline ::PlayerInfo::GroupInstance* PlayerInfo::release_groupinfo() {
  clear_has_groupinfo();
  ::PlayerInfo::GroupInstance* temp = groupinfo_;
  groupinfo_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_groupinfo(::PlayerInfo::GroupInstance* groupinfo) {
  delete groupinfo_;
  groupinfo_ = groupinfo;
  if (groupinfo) {
    set_has_groupinfo();
  } else {
    clear_has_groupinfo();
  }
}

// optional .ChristmasDB.ChristmasAllData christmasData = 31;
inline bool PlayerInfo::has_christmasdata() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PlayerInfo::set_has_christmasdata() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PlayerInfo::clear_has_christmasdata() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PlayerInfo::clear_christmasdata() {
  if (christmasdata_ != NULL) christmasdata_->::ChristmasDB::ChristmasAllData::Clear();
  clear_has_christmasdata();
}
inline const ::ChristmasDB::ChristmasAllData& PlayerInfo::christmasdata() const {
  return christmasdata_ != NULL ? *christmasdata_ : *default_instance_->christmasdata_;
}
inline ::ChristmasDB::ChristmasAllData* PlayerInfo::mutable_christmasdata() {
  set_has_christmasdata();
  if (christmasdata_ == NULL) christmasdata_ = new ::ChristmasDB::ChristmasAllData;
  return christmasdata_;
}
inline ::ChristmasDB::ChristmasAllData* PlayerInfo::release_christmasdata() {
  clear_has_christmasdata();
  ::ChristmasDB::ChristmasAllData* temp = christmasdata_;
  christmasdata_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_christmasdata(::ChristmasDB::ChristmasAllData* christmasdata) {
  delete christmasdata_;
  christmasdata_ = christmasdata;
  if (christmasdata) {
    set_has_christmasdata();
  } else {
    clear_has_christmasdata();
  }
}

// optional .PlayerInfo.EliteInstance eliteInfo = 32;
inline bool PlayerInfo::has_eliteinfo() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PlayerInfo::set_has_eliteinfo() {
  _has_bits_[0] |= 0x80000000u;
}
inline void PlayerInfo::clear_has_eliteinfo() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void PlayerInfo::clear_eliteinfo() {
  if (eliteinfo_ != NULL) eliteinfo_->::PlayerInfo::EliteInstance::Clear();
  clear_has_eliteinfo();
}
inline const ::PlayerInfo::EliteInstance& PlayerInfo::eliteinfo() const {
  return eliteinfo_ != NULL ? *eliteinfo_ : *default_instance_->eliteinfo_;
}
inline ::PlayerInfo::EliteInstance* PlayerInfo::mutable_eliteinfo() {
  set_has_eliteinfo();
  if (eliteinfo_ == NULL) eliteinfo_ = new ::PlayerInfo::EliteInstance;
  return eliteinfo_;
}
inline ::PlayerInfo::EliteInstance* PlayerInfo::release_eliteinfo() {
  clear_has_eliteinfo();
  ::PlayerInfo::EliteInstance* temp = eliteinfo_;
  eliteinfo_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_eliteinfo(::PlayerInfo::EliteInstance* eliteinfo) {
  delete eliteinfo_;
  eliteinfo_ = eliteinfo;
  if (eliteinfo) {
    set_has_eliteinfo();
  } else {
    clear_has_eliteinfo();
  }
}

// optional .PlayerInfo.CauchemarInstance cauchemarInfo = 33;
inline bool PlayerInfo::has_cauchemarinfo() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PlayerInfo::set_has_cauchemarinfo() {
  _has_bits_[1] |= 0x00000001u;
}
inline void PlayerInfo::clear_has_cauchemarinfo() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void PlayerInfo::clear_cauchemarinfo() {
  if (cauchemarinfo_ != NULL) cauchemarinfo_->::PlayerInfo::CauchemarInstance::Clear();
  clear_has_cauchemarinfo();
}
inline const ::PlayerInfo::CauchemarInstance& PlayerInfo::cauchemarinfo() const {
  return cauchemarinfo_ != NULL ? *cauchemarinfo_ : *default_instance_->cauchemarinfo_;
}
inline ::PlayerInfo::CauchemarInstance* PlayerInfo::mutable_cauchemarinfo() {
  set_has_cauchemarinfo();
  if (cauchemarinfo_ == NULL) cauchemarinfo_ = new ::PlayerInfo::CauchemarInstance;
  return cauchemarinfo_;
}
inline ::PlayerInfo::CauchemarInstance* PlayerInfo::release_cauchemarinfo() {
  clear_has_cauchemarinfo();
  ::PlayerInfo::CauchemarInstance* temp = cauchemarinfo_;
  cauchemarinfo_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_cauchemarinfo(::PlayerInfo::CauchemarInstance* cauchemarinfo) {
  delete cauchemarinfo_;
  cauchemarinfo_ = cauchemarinfo;
  if (cauchemarinfo) {
    set_has_cauchemarinfo();
  } else {
    clear_has_cauchemarinfo();
  }
}

// optional .PlayerInfo.ArenaDataInfo arenaData = 34;
inline bool PlayerInfo::has_arenadata() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PlayerInfo::set_has_arenadata() {
  _has_bits_[1] |= 0x00000002u;
}
inline void PlayerInfo::clear_has_arenadata() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void PlayerInfo::clear_arenadata() {
  if (arenadata_ != NULL) arenadata_->::PlayerInfo::ArenaDataInfo::Clear();
  clear_has_arenadata();
}
inline const ::PlayerInfo::ArenaDataInfo& PlayerInfo::arenadata() const {
  return arenadata_ != NULL ? *arenadata_ : *default_instance_->arenadata_;
}
inline ::PlayerInfo::ArenaDataInfo* PlayerInfo::mutable_arenadata() {
  set_has_arenadata();
  if (arenadata_ == NULL) arenadata_ = new ::PlayerInfo::ArenaDataInfo;
  return arenadata_;
}
inline ::PlayerInfo::ArenaDataInfo* PlayerInfo::release_arenadata() {
  clear_has_arenadata();
  ::PlayerInfo::ArenaDataInfo* temp = arenadata_;
  arenadata_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_arenadata(::PlayerInfo::ArenaDataInfo* arenadata) {
  delete arenadata_;
  arenadata_ = arenadata;
  if (arenadata) {
    set_has_arenadata();
  } else {
    clear_has_arenadata();
  }
}

// optional .PlayerInfo.ChallengeInstance challengedata = 35;
inline bool PlayerInfo::has_challengedata() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void PlayerInfo::set_has_challengedata() {
  _has_bits_[1] |= 0x00000004u;
}
inline void PlayerInfo::clear_has_challengedata() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void PlayerInfo::clear_challengedata() {
  if (challengedata_ != NULL) challengedata_->::PlayerInfo::ChallengeInstance::Clear();
  clear_has_challengedata();
}
inline const ::PlayerInfo::ChallengeInstance& PlayerInfo::challengedata() const {
  return challengedata_ != NULL ? *challengedata_ : *default_instance_->challengedata_;
}
inline ::PlayerInfo::ChallengeInstance* PlayerInfo::mutable_challengedata() {
  set_has_challengedata();
  if (challengedata_ == NULL) challengedata_ = new ::PlayerInfo::ChallengeInstance;
  return challengedata_;
}
inline ::PlayerInfo::ChallengeInstance* PlayerInfo::release_challengedata() {
  clear_has_challengedata();
  ::PlayerInfo::ChallengeInstance* temp = challengedata_;
  challengedata_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_challengedata(::PlayerInfo::ChallengeInstance* challengedata) {
  delete challengedata_;
  challengedata_ = challengedata;
  if (challengedata) {
    set_has_challengedata();
  } else {
    clear_has_challengedata();
  }
}

// optional .PlayerInfo.HeroInstanceData herodata = 36;
inline bool PlayerInfo::has_herodata() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void PlayerInfo::set_has_herodata() {
  _has_bits_[1] |= 0x00000008u;
}
inline void PlayerInfo::clear_has_herodata() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void PlayerInfo::clear_herodata() {
  if (herodata_ != NULL) herodata_->::PlayerInfo::HeroInstanceData::Clear();
  clear_has_herodata();
}
inline const ::PlayerInfo::HeroInstanceData& PlayerInfo::herodata() const {
  return herodata_ != NULL ? *herodata_ : *default_instance_->herodata_;
}
inline ::PlayerInfo::HeroInstanceData* PlayerInfo::mutable_herodata() {
  set_has_herodata();
  if (herodata_ == NULL) herodata_ = new ::PlayerInfo::HeroInstanceData;
  return herodata_;
}
inline ::PlayerInfo::HeroInstanceData* PlayerInfo::release_herodata() {
  clear_has_herodata();
  ::PlayerInfo::HeroInstanceData* temp = herodata_;
  herodata_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_herodata(::PlayerInfo::HeroInstanceData* herodata) {
  delete herodata_;
  herodata_ = herodata;
  if (herodata) {
    set_has_herodata();
  } else {
    clear_has_herodata();
  }
}

// optional .PlayerInfo.MagicWeapon smagic = 37;
inline bool PlayerInfo::has_smagic() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void PlayerInfo::set_has_smagic() {
  _has_bits_[1] |= 0x00000010u;
}
inline void PlayerInfo::clear_has_smagic() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void PlayerInfo::clear_smagic() {
  if (smagic_ != NULL) smagic_->::PlayerInfo::MagicWeapon::Clear();
  clear_has_smagic();
}
inline const ::PlayerInfo::MagicWeapon& PlayerInfo::smagic() const {
  return smagic_ != NULL ? *smagic_ : *default_instance_->smagic_;
}
inline ::PlayerInfo::MagicWeapon* PlayerInfo::mutable_smagic() {
  set_has_smagic();
  if (smagic_ == NULL) smagic_ = new ::PlayerInfo::MagicWeapon;
  return smagic_;
}
inline ::PlayerInfo::MagicWeapon* PlayerInfo::release_smagic() {
  clear_has_smagic();
  ::PlayerInfo::MagicWeapon* temp = smagic_;
  smagic_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_smagic(::PlayerInfo::MagicWeapon* smagic) {
  delete smagic_;
  smagic_ = smagic;
  if (smagic) {
    set_has_smagic();
  } else {
    clear_has_smagic();
  }
}

// optional .PlayerInfo.MagicWeapon heartmagic = 38;
inline bool PlayerInfo::has_heartmagic() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void PlayerInfo::set_has_heartmagic() {
  _has_bits_[1] |= 0x00000020u;
}
inline void PlayerInfo::clear_has_heartmagic() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void PlayerInfo::clear_heartmagic() {
  if (heartmagic_ != NULL) heartmagic_->::PlayerInfo::MagicWeapon::Clear();
  clear_has_heartmagic();
}
inline const ::PlayerInfo::MagicWeapon& PlayerInfo::heartmagic() const {
  return heartmagic_ != NULL ? *heartmagic_ : *default_instance_->heartmagic_;
}
inline ::PlayerInfo::MagicWeapon* PlayerInfo::mutable_heartmagic() {
  set_has_heartmagic();
  if (heartmagic_ == NULL) heartmagic_ = new ::PlayerInfo::MagicWeapon;
  return heartmagic_;
}
inline ::PlayerInfo::MagicWeapon* PlayerInfo::release_heartmagic() {
  clear_has_heartmagic();
  ::PlayerInfo::MagicWeapon* temp = heartmagic_;
  heartmagic_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_heartmagic(::PlayerInfo::MagicWeapon* heartmagic) {
  delete heartmagic_;
  heartmagic_ = heartmagic;
  if (heartmagic) {
    set_has_heartmagic();
  } else {
    clear_has_heartmagic();
  }
}

// optional .PlayerInfo.AdvancedInstance advanced = 39;
inline bool PlayerInfo::has_advanced() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void PlayerInfo::set_has_advanced() {
  _has_bits_[1] |= 0x00000040u;
}
inline void PlayerInfo::clear_has_advanced() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void PlayerInfo::clear_advanced() {
  if (advanced_ != NULL) advanced_->::PlayerInfo::AdvancedInstance::Clear();
  clear_has_advanced();
}
inline const ::PlayerInfo::AdvancedInstance& PlayerInfo::advanced() const {
  return advanced_ != NULL ? *advanced_ : *default_instance_->advanced_;
}
inline ::PlayerInfo::AdvancedInstance* PlayerInfo::mutable_advanced() {
  set_has_advanced();
  if (advanced_ == NULL) advanced_ = new ::PlayerInfo::AdvancedInstance;
  return advanced_;
}
inline ::PlayerInfo::AdvancedInstance* PlayerInfo::release_advanced() {
  clear_has_advanced();
  ::PlayerInfo::AdvancedInstance* temp = advanced_;
  advanced_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_advanced(::PlayerInfo::AdvancedInstance* advanced) {
  delete advanced_;
  advanced_ = advanced;
  if (advanced) {
    set_has_advanced();
  } else {
    clear_has_advanced();
  }
}

// optional .PlayerInfo.BaseShopInfo baseShopInfo = 40;
inline bool PlayerInfo::has_baseshopinfo() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void PlayerInfo::set_has_baseshopinfo() {
  _has_bits_[1] |= 0x00000080u;
}
inline void PlayerInfo::clear_has_baseshopinfo() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void PlayerInfo::clear_baseshopinfo() {
  if (baseshopinfo_ != NULL) baseshopinfo_->::PlayerInfo::BaseShopInfo::Clear();
  clear_has_baseshopinfo();
}
inline const ::PlayerInfo::BaseShopInfo& PlayerInfo::baseshopinfo() const {
  return baseshopinfo_ != NULL ? *baseshopinfo_ : *default_instance_->baseshopinfo_;
}
inline ::PlayerInfo::BaseShopInfo* PlayerInfo::mutable_baseshopinfo() {
  set_has_baseshopinfo();
  if (baseshopinfo_ == NULL) baseshopinfo_ = new ::PlayerInfo::BaseShopInfo;
  return baseshopinfo_;
}
inline ::PlayerInfo::BaseShopInfo* PlayerInfo::release_baseshopinfo() {
  clear_has_baseshopinfo();
  ::PlayerInfo::BaseShopInfo* temp = baseshopinfo_;
  baseshopinfo_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_baseshopinfo(::PlayerInfo::BaseShopInfo* baseshopinfo) {
  delete baseshopinfo_;
  baseshopinfo_ = baseshopinfo;
  if (baseshopinfo) {
    set_has_baseshopinfo();
  } else {
    clear_has_baseshopinfo();
  }
}

// optional .PlayerInfo.AnswerInfo answerInfo = 41;
inline bool PlayerInfo::has_answerinfo() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void PlayerInfo::set_has_answerinfo() {
  _has_bits_[1] |= 0x00000100u;
}
inline void PlayerInfo::clear_has_answerinfo() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void PlayerInfo::clear_answerinfo() {
  if (answerinfo_ != NULL) answerinfo_->::PlayerInfo::AnswerInfo::Clear();
  clear_has_answerinfo();
}
inline const ::PlayerInfo::AnswerInfo& PlayerInfo::answerinfo() const {
  return answerinfo_ != NULL ? *answerinfo_ : *default_instance_->answerinfo_;
}
inline ::PlayerInfo::AnswerInfo* PlayerInfo::mutable_answerinfo() {
  set_has_answerinfo();
  if (answerinfo_ == NULL) answerinfo_ = new ::PlayerInfo::AnswerInfo;
  return answerinfo_;
}
inline ::PlayerInfo::AnswerInfo* PlayerInfo::release_answerinfo() {
  clear_has_answerinfo();
  ::PlayerInfo::AnswerInfo* temp = answerinfo_;
  answerinfo_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_answerinfo(::PlayerInfo::AnswerInfo* answerinfo) {
  delete answerinfo_;
  answerinfo_ = answerinfo;
  if (answerinfo) {
    set_has_answerinfo();
  } else {
    clear_has_answerinfo();
  }
}

// -------------------------------------------------------------------

// ArenaDataInfo

// optional int32 canChallCnt = 1;
inline bool ArenaDataInfo::has_canchallcnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaDataInfo::set_has_canchallcnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaDataInfo::clear_has_canchallcnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaDataInfo::clear_canchallcnt() {
  canchallcnt_ = 0;
  clear_has_canchallcnt();
}
inline ::google::protobuf::int32 ArenaDataInfo::canchallcnt() const {
  return canchallcnt_;
}
inline void ArenaDataInfo::set_canchallcnt(::google::protobuf::int32 value) {
  set_has_canchallcnt();
  canchallcnt_ = value;
}

// optional uint64 lastResetTime = 2;
inline bool ArenaDataInfo::has_lastresettime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaDataInfo::set_has_lastresettime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaDataInfo::clear_has_lastresettime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaDataInfo::clear_lastresettime() {
  lastresettime_ = GOOGLE_ULONGLONG(0);
  clear_has_lastresettime();
}
inline ::google::protobuf::uint64 ArenaDataInfo::lastresettime() const {
  return lastresettime_;
}
inline void ArenaDataInfo::set_lastresettime(::google::protobuf::uint64 value) {
  set_has_lastresettime();
  lastresettime_ = value;
}

// -------------------------------------------------------------------

// ArenaInfo

// required int64 charid = 1;
inline bool ArenaInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaInfo::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 ArenaInfo::charid() const {
  return charid_;
}
inline void ArenaInfo::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// optional int32 CombatPower = 2;
inline bool ArenaInfo::has_combatpower() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaInfo::set_has_combatpower() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaInfo::clear_has_combatpower() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaInfo::clear_combatpower() {
  combatpower_ = 0;
  clear_has_combatpower();
}
inline ::google::protobuf::int32 ArenaInfo::combatpower() const {
  return combatpower_;
}
inline void ArenaInfo::set_combatpower(::google::protobuf::int32 value) {
  set_has_combatpower();
  combatpower_ = value;
}

// optional int32 Ranking = 3;
inline bool ArenaInfo::has_ranking() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArenaInfo::set_has_ranking() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArenaInfo::clear_has_ranking() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArenaInfo::clear_ranking() {
  ranking_ = 0;
  clear_has_ranking();
}
inline ::google::protobuf::int32 ArenaInfo::ranking() const {
  return ranking_;
}
inline void ArenaInfo::set_ranking(::google::protobuf::int32 value) {
  set_has_ranking();
  ranking_ = value;
}

// optional bool iswin = 4;
inline bool ArenaInfo::has_iswin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArenaInfo::set_has_iswin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArenaInfo::clear_has_iswin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArenaInfo::clear_iswin() {
  iswin_ = false;
  clear_has_iswin();
}
inline bool ArenaInfo::iswin() const {
  return iswin_;
}
inline void ArenaInfo::set_iswin(bool value) {
  set_has_iswin();
  iswin_ = value;
}

// optional .PlayerInfo.ArenaBaseInfo abinfo = 5;
inline bool ArenaInfo::has_abinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ArenaInfo::set_has_abinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ArenaInfo::clear_has_abinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ArenaInfo::clear_abinfo() {
  if (abinfo_ != NULL) abinfo_->::PlayerInfo::ArenaBaseInfo::Clear();
  clear_has_abinfo();
}
inline const ::PlayerInfo::ArenaBaseInfo& ArenaInfo::abinfo() const {
  return abinfo_ != NULL ? *abinfo_ : *default_instance_->abinfo_;
}
inline ::PlayerInfo::ArenaBaseInfo* ArenaInfo::mutable_abinfo() {
  set_has_abinfo();
  if (abinfo_ == NULL) abinfo_ = new ::PlayerInfo::ArenaBaseInfo;
  return abinfo_;
}
inline ::PlayerInfo::ArenaBaseInfo* ArenaInfo::release_abinfo() {
  clear_has_abinfo();
  ::PlayerInfo::ArenaBaseInfo* temp = abinfo_;
  abinfo_ = NULL;
  return temp;
}
inline void ArenaInfo::set_allocated_abinfo(::PlayerInfo::ArenaBaseInfo* abinfo) {
  delete abinfo_;
  abinfo_ = abinfo;
  if (abinfo) {
    set_has_abinfo();
  } else {
    clear_has_abinfo();
  }
}

// optional .PlayerInfo.ArenaChallengeRank challengeRank = 6;
inline bool ArenaInfo::has_challengerank() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ArenaInfo::set_has_challengerank() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ArenaInfo::clear_has_challengerank() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ArenaInfo::clear_challengerank() {
  if (challengerank_ != NULL) challengerank_->::PlayerInfo::ArenaChallengeRank::Clear();
  clear_has_challengerank();
}
inline const ::PlayerInfo::ArenaChallengeRank& ArenaInfo::challengerank() const {
  return challengerank_ != NULL ? *challengerank_ : *default_instance_->challengerank_;
}
inline ::PlayerInfo::ArenaChallengeRank* ArenaInfo::mutable_challengerank() {
  set_has_challengerank();
  if (challengerank_ == NULL) challengerank_ = new ::PlayerInfo::ArenaChallengeRank;
  return challengerank_;
}
inline ::PlayerInfo::ArenaChallengeRank* ArenaInfo::release_challengerank() {
  clear_has_challengerank();
  ::PlayerInfo::ArenaChallengeRank* temp = challengerank_;
  challengerank_ = NULL;
  return temp;
}
inline void ArenaInfo::set_allocated_challengerank(::PlayerInfo::ArenaChallengeRank* challengerank) {
  delete challengerank_;
  challengerank_ = challengerank;
  if (challengerank) {
    set_has_challengerank();
  } else {
    clear_has_challengerank();
  }
}

// optional int32 challengeNum = 7;
inline bool ArenaInfo::has_challengenum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ArenaInfo::set_has_challengenum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ArenaInfo::clear_has_challengenum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ArenaInfo::clear_challengenum() {
  challengenum_ = 0;
  clear_has_challengenum();
}
inline ::google::protobuf::int32 ArenaInfo::challengenum() const {
  return challengenum_;
}
inline void ArenaInfo::set_challengenum(::google::protobuf::int32 value) {
  set_has_challengenum();
  challengenum_ = value;
}

// optional .PlayerInfo.ArenaHistoryReward historyReward = 8;
inline bool ArenaInfo::has_historyreward() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ArenaInfo::set_has_historyreward() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ArenaInfo::clear_has_historyreward() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ArenaInfo::clear_historyreward() {
  if (historyreward_ != NULL) historyreward_->::PlayerInfo::ArenaHistoryReward::Clear();
  clear_has_historyreward();
}
inline const ::PlayerInfo::ArenaHistoryReward& ArenaInfo::historyreward() const {
  return historyreward_ != NULL ? *historyreward_ : *default_instance_->historyreward_;
}
inline ::PlayerInfo::ArenaHistoryReward* ArenaInfo::mutable_historyreward() {
  set_has_historyreward();
  if (historyreward_ == NULL) historyreward_ = new ::PlayerInfo::ArenaHistoryReward;
  return historyreward_;
}
inline ::PlayerInfo::ArenaHistoryReward* ArenaInfo::release_historyreward() {
  clear_has_historyreward();
  ::PlayerInfo::ArenaHistoryReward* temp = historyreward_;
  historyreward_ = NULL;
  return temp;
}
inline void ArenaInfo::set_allocated_historyreward(::PlayerInfo::ArenaHistoryReward* historyreward) {
  delete historyreward_;
  historyreward_ = historyreward;
  if (historyreward) {
    set_has_historyreward();
  } else {
    clear_has_historyreward();
  }
}

// -------------------------------------------------------------------

// ArenaBaseInfo

// required string charname = 1;
inline bool ArenaBaseInfo::has_charname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaBaseInfo::set_has_charname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaBaseInfo::clear_has_charname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaBaseInfo::clear_charname() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    charname_->clear();
  }
  clear_has_charname();
}
inline const ::std::string& ArenaBaseInfo::charname() const {
  return *charname_;
}
inline void ArenaBaseInfo::set_charname(const ::std::string& value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void ArenaBaseInfo::set_charname(const char* value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void ArenaBaseInfo::set_charname(const char* value, size_t size) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ArenaBaseInfo::mutable_charname() {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  return charname_;
}
inline ::std::string* ArenaBaseInfo::release_charname() {
  clear_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charname_;
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ArenaBaseInfo::set_allocated_charname(::std::string* charname) {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (charname) {
    set_has_charname();
    charname_ = charname;
  } else {
    clear_has_charname();
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 level = 2;
inline bool ArenaBaseInfo::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaBaseInfo::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaBaseInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaBaseInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 ArenaBaseInfo::level() const {
  return level_;
}
inline void ArenaBaseInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 profession = 3;
inline bool ArenaBaseInfo::has_profession() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArenaBaseInfo::set_has_profession() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArenaBaseInfo::clear_has_profession() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArenaBaseInfo::clear_profession() {
  profession_ = 0;
  clear_has_profession();
}
inline ::google::protobuf::int32 ArenaBaseInfo::profession() const {
  return profession_;
}
inline void ArenaBaseInfo::set_profession(::google::protobuf::int32 value) {
  set_has_profession();
  profession_ = value;
}

// optional int32 country = 4;
inline bool ArenaBaseInfo::has_country() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArenaBaseInfo::set_has_country() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArenaBaseInfo::clear_has_country() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArenaBaseInfo::clear_country() {
  country_ = 0;
  clear_has_country();
}
inline ::google::protobuf::int32 ArenaBaseInfo::country() const {
  return country_;
}
inline void ArenaBaseInfo::set_country(::google::protobuf::int32 value) {
  set_has_country();
  country_ = value;
}

// optional bool sex = 5;
inline bool ArenaBaseInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ArenaBaseInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ArenaBaseInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ArenaBaseInfo::clear_sex() {
  sex_ = false;
  clear_has_sex();
}
inline bool ArenaBaseInfo::sex() const {
  return sex_;
}
inline void ArenaBaseInfo::set_sex(bool value) {
  set_has_sex();
  sex_ = value;
}

// optional int32 titleid = 6;
inline bool ArenaBaseInfo::has_titleid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ArenaBaseInfo::set_has_titleid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ArenaBaseInfo::clear_has_titleid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ArenaBaseInfo::clear_titleid() {
  titleid_ = 0;
  clear_has_titleid();
}
inline ::google::protobuf::int32 ArenaBaseInfo::titleid() const {
  return titleid_;
}
inline void ArenaBaseInfo::set_titleid(::google::protobuf::int32 value) {
  set_has_titleid();
  titleid_ = value;
}

// optional string clanname = 7;
inline bool ArenaBaseInfo::has_clanname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ArenaBaseInfo::set_has_clanname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ArenaBaseInfo::clear_has_clanname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ArenaBaseInfo::clear_clanname() {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    clanname_->clear();
  }
  clear_has_clanname();
}
inline const ::std::string& ArenaBaseInfo::clanname() const {
  return *clanname_;
}
inline void ArenaBaseInfo::set_clanname(const ::std::string& value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void ArenaBaseInfo::set_clanname(const char* value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void ArenaBaseInfo::set_clanname(const char* value, size_t size) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ArenaBaseInfo::mutable_clanname() {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  return clanname_;
}
inline ::std::string* ArenaBaseInfo::release_clanname() {
  clear_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clanname_;
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ArenaBaseInfo::set_allocated_clanname(::std::string* clanname) {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    delete clanname_;
  }
  if (clanname) {
    set_has_clanname();
    clanname_ = clanname;
  } else {
    clear_has_clanname();
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 viplv = 8;
inline bool ArenaBaseInfo::has_viplv() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ArenaBaseInfo::set_has_viplv() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ArenaBaseInfo::clear_has_viplv() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ArenaBaseInfo::clear_viplv() {
  viplv_ = 0;
  clear_has_viplv();
}
inline ::google::protobuf::int32 ArenaBaseInfo::viplv() const {
  return viplv_;
}
inline void ArenaBaseInfo::set_viplv(::google::protobuf::int32 value) {
  set_has_viplv();
  viplv_ = value;
}

// optional int32 hpmax = 9;
inline bool ArenaBaseInfo::has_hpmax() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ArenaBaseInfo::set_has_hpmax() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ArenaBaseInfo::clear_has_hpmax() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ArenaBaseInfo::clear_hpmax() {
  hpmax_ = 0;
  clear_has_hpmax();
}
inline ::google::protobuf::int32 ArenaBaseInfo::hpmax() const {
  return hpmax_;
}
inline void ArenaBaseInfo::set_hpmax(::google::protobuf::int32 value) {
  set_has_hpmax();
  hpmax_ = value;
}

// optional int32 mpmax = 10;
inline bool ArenaBaseInfo::has_mpmax() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ArenaBaseInfo::set_has_mpmax() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ArenaBaseInfo::clear_has_mpmax() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ArenaBaseInfo::clear_mpmax() {
  mpmax_ = 0;
  clear_has_mpmax();
}
inline ::google::protobuf::int32 ArenaBaseInfo::mpmax() const {
  return mpmax_;
}
inline void ArenaBaseInfo::set_mpmax(::google::protobuf::int32 value) {
  set_has_mpmax();
  mpmax_ = value;
}

// optional int32 movespeed = 11;
inline bool ArenaBaseInfo::has_movespeed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ArenaBaseInfo::set_has_movespeed() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ArenaBaseInfo::clear_has_movespeed() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ArenaBaseInfo::clear_movespeed() {
  movespeed_ = 0;
  clear_has_movespeed();
}
inline ::google::protobuf::int32 ArenaBaseInfo::movespeed() const {
  return movespeed_;
}
inline void ArenaBaseInfo::set_movespeed(::google::protobuf::int32 value) {
  set_has_movespeed();
  movespeed_ = value;
}

// optional int32 phyattack = 12;
inline bool ArenaBaseInfo::has_phyattack() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ArenaBaseInfo::set_has_phyattack() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ArenaBaseInfo::clear_has_phyattack() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ArenaBaseInfo::clear_phyattack() {
  phyattack_ = 0;
  clear_has_phyattack();
}
inline ::google::protobuf::int32 ArenaBaseInfo::phyattack() const {
  return phyattack_;
}
inline void ArenaBaseInfo::set_phyattack(::google::protobuf::int32 value) {
  set_has_phyattack();
  phyattack_ = value;
}

// optional int32 phyattackmax = 13;
inline bool ArenaBaseInfo::has_phyattackmax() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ArenaBaseInfo::set_has_phyattackmax() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ArenaBaseInfo::clear_has_phyattackmax() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ArenaBaseInfo::clear_phyattackmax() {
  phyattackmax_ = 0;
  clear_has_phyattackmax();
}
inline ::google::protobuf::int32 ArenaBaseInfo::phyattackmax() const {
  return phyattackmax_;
}
inline void ArenaBaseInfo::set_phyattackmax(::google::protobuf::int32 value) {
  set_has_phyattackmax();
  phyattackmax_ = value;
}

// optional int32 magicattack = 14;
inline bool ArenaBaseInfo::has_magicattack() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ArenaBaseInfo::set_has_magicattack() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ArenaBaseInfo::clear_has_magicattack() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ArenaBaseInfo::clear_magicattack() {
  magicattack_ = 0;
  clear_has_magicattack();
}
inline ::google::protobuf::int32 ArenaBaseInfo::magicattack() const {
  return magicattack_;
}
inline void ArenaBaseInfo::set_magicattack(::google::protobuf::int32 value) {
  set_has_magicattack();
  magicattack_ = value;
}

// optional int32 magicattackmax = 15;
inline bool ArenaBaseInfo::has_magicattackmax() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ArenaBaseInfo::set_has_magicattackmax() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ArenaBaseInfo::clear_has_magicattackmax() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ArenaBaseInfo::clear_magicattackmax() {
  magicattackmax_ = 0;
  clear_has_magicattackmax();
}
inline ::google::protobuf::int32 ArenaBaseInfo::magicattackmax() const {
  return magicattackmax_;
}
inline void ArenaBaseInfo::set_magicattackmax(::google::protobuf::int32 value) {
  set_has_magicattackmax();
  magicattackmax_ = value;
}

// optional int32 phydefence = 16;
inline bool ArenaBaseInfo::has_phydefence() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ArenaBaseInfo::set_has_phydefence() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ArenaBaseInfo::clear_has_phydefence() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ArenaBaseInfo::clear_phydefence() {
  phydefence_ = 0;
  clear_has_phydefence();
}
inline ::google::protobuf::int32 ArenaBaseInfo::phydefence() const {
  return phydefence_;
}
inline void ArenaBaseInfo::set_phydefence(::google::protobuf::int32 value) {
  set_has_phydefence();
  phydefence_ = value;
}

// optional int32 magicdefence = 17;
inline bool ArenaBaseInfo::has_magicdefence() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ArenaBaseInfo::set_has_magicdefence() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ArenaBaseInfo::clear_has_magicdefence() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ArenaBaseInfo::clear_magicdefence() {
  magicdefence_ = 0;
  clear_has_magicdefence();
}
inline ::google::protobuf::int32 ArenaBaseInfo::magicdefence() const {
  return magicdefence_;
}
inline void ArenaBaseInfo::set_magicdefence(::google::protobuf::int32 value) {
  set_has_magicdefence();
  magicdefence_ = value;
}

// optional int32 hitrate = 18;
inline bool ArenaBaseInfo::has_hitrate() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ArenaBaseInfo::set_has_hitrate() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ArenaBaseInfo::clear_has_hitrate() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ArenaBaseInfo::clear_hitrate() {
  hitrate_ = 0;
  clear_has_hitrate();
}
inline ::google::protobuf::int32 ArenaBaseInfo::hitrate() const {
  return hitrate_;
}
inline void ArenaBaseInfo::set_hitrate(::google::protobuf::int32 value) {
  set_has_hitrate();
  hitrate_ = value;
}

// optional int32 avoidrate = 19;
inline bool ArenaBaseInfo::has_avoidrate() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ArenaBaseInfo::set_has_avoidrate() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ArenaBaseInfo::clear_has_avoidrate() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ArenaBaseInfo::clear_avoidrate() {
  avoidrate_ = 0;
  clear_has_avoidrate();
}
inline ::google::protobuf::int32 ArenaBaseInfo::avoidrate() const {
  return avoidrate_;
}
inline void ArenaBaseInfo::set_avoidrate(::google::protobuf::int32 value) {
  set_has_avoidrate();
  avoidrate_ = value;
}

// optional int32 baselucky = 20;
inline bool ArenaBaseInfo::has_baselucky() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ArenaBaseInfo::set_has_baselucky() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ArenaBaseInfo::clear_has_baselucky() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ArenaBaseInfo::clear_baselucky() {
  baselucky_ = 0;
  clear_has_baselucky();
}
inline ::google::protobuf::int32 ArenaBaseInfo::baselucky() const {
  return baselucky_;
}
inline void ArenaBaseInfo::set_baselucky(::google::protobuf::int32 value) {
  set_has_baselucky();
  baselucky_ = value;
}

// optional int32 crackdownrate = 21;
inline bool ArenaBaseInfo::has_crackdownrate() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ArenaBaseInfo::set_has_crackdownrate() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ArenaBaseInfo::clear_has_crackdownrate() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ArenaBaseInfo::clear_crackdownrate() {
  crackdownrate_ = 0;
  clear_has_crackdownrate();
}
inline ::google::protobuf::int32 ArenaBaseInfo::crackdownrate() const {
  return crackdownrate_;
}
inline void ArenaBaseInfo::set_crackdownrate(::google::protobuf::int32 value) {
  set_has_crackdownrate();
  crackdownrate_ = value;
}

// optional int32 baserte = 22;
inline bool ArenaBaseInfo::has_baserte() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ArenaBaseInfo::set_has_baserte() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ArenaBaseInfo::clear_has_baserte() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ArenaBaseInfo::clear_baserte() {
  baserte_ = 0;
  clear_has_baserte();
}
inline ::google::protobuf::int32 ArenaBaseInfo::baserte() const {
  return baserte_;
}
inline void ArenaBaseInfo::set_baserte(::google::protobuf::int32 value) {
  set_has_baserte();
  baserte_ = value;
}

// optional int32 magicw = 23;
inline bool ArenaBaseInfo::has_magicw() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ArenaBaseInfo::set_has_magicw() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ArenaBaseInfo::clear_has_magicw() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ArenaBaseInfo::clear_magicw() {
  magicw_ = 0;
  clear_has_magicw();
}
inline ::google::protobuf::int32 ArenaBaseInfo::magicw() const {
  return magicw_;
}
inline void ArenaBaseInfo::set_magicw(::google::protobuf::int32 value) {
  set_has_magicw();
  magicw_ = value;
}

// optional int32 suitrnt = 24;
inline bool ArenaBaseInfo::has_suitrnt() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ArenaBaseInfo::set_has_suitrnt() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ArenaBaseInfo::clear_has_suitrnt() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ArenaBaseInfo::clear_suitrnt() {
  suitrnt_ = 0;
  clear_has_suitrnt();
}
inline ::google::protobuf::int32 ArenaBaseInfo::suitrnt() const {
  return suitrnt_;
}
inline void ArenaBaseInfo::set_suitrnt(::google::protobuf::int32 value) {
  set_has_suitrnt();
  suitrnt_ = value;
}

// optional .PlayerSynch.EquipData mainEquip = 25;
inline bool ArenaBaseInfo::has_mainequip() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ArenaBaseInfo::set_has_mainequip() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ArenaBaseInfo::clear_has_mainequip() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ArenaBaseInfo::clear_mainequip() {
  if (mainequip_ != NULL) mainequip_->::PlayerSynch::EquipData::Clear();
  clear_has_mainequip();
}
inline const ::PlayerSynch::EquipData& ArenaBaseInfo::mainequip() const {
  return mainequip_ != NULL ? *mainequip_ : *default_instance_->mainequip_;
}
inline ::PlayerSynch::EquipData* ArenaBaseInfo::mutable_mainequip() {
  set_has_mainequip();
  if (mainequip_ == NULL) mainequip_ = new ::PlayerSynch::EquipData;
  return mainequip_;
}
inline ::PlayerSynch::EquipData* ArenaBaseInfo::release_mainequip() {
  clear_has_mainequip();
  ::PlayerSynch::EquipData* temp = mainequip_;
  mainequip_ = NULL;
  return temp;
}
inline void ArenaBaseInfo::set_allocated_mainequip(::PlayerSynch::EquipData* mainequip) {
  delete mainequip_;
  mainequip_ = mainequip;
  if (mainequip) {
    set_has_mainequip();
  } else {
    clear_has_mainequip();
  }
}

// optional int32 costume = 26;
inline bool ArenaBaseInfo::has_costume() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ArenaBaseInfo::set_has_costume() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ArenaBaseInfo::clear_has_costume() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ArenaBaseInfo::clear_costume() {
  costume_ = 0;
  clear_has_costume();
}
inline ::google::protobuf::int32 ArenaBaseInfo::costume() const {
  return costume_;
}
inline void ArenaBaseInfo::set_costume(::google::protobuf::int32 value) {
  set_has_costume();
  costume_ = value;
}

// optional int32 horse = 27;
inline bool ArenaBaseInfo::has_horse() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ArenaBaseInfo::set_has_horse() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ArenaBaseInfo::clear_has_horse() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ArenaBaseInfo::clear_horse() {
  horse_ = 0;
  clear_has_horse();
}
inline ::google::protobuf::int32 ArenaBaseInfo::horse() const {
  return horse_;
}
inline void ArenaBaseInfo::set_horse(::google::protobuf::int32 value) {
  set_has_horse();
  horse_ = value;
}

// repeated int32 skill = 28;
inline int ArenaBaseInfo::skill_size() const {
  return skill_.size();
}
inline void ArenaBaseInfo::clear_skill() {
  skill_.Clear();
}
inline ::google::protobuf::int32 ArenaBaseInfo::skill(int index) const {
  return skill_.Get(index);
}
inline void ArenaBaseInfo::set_skill(int index, ::google::protobuf::int32 value) {
  skill_.Set(index, value);
}
inline void ArenaBaseInfo::add_skill(::google::protobuf::int32 value) {
  skill_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ArenaBaseInfo::skill() const {
  return skill_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ArenaBaseInfo::mutable_skill() {
  return &skill_;
}

// optional int32 clanJob = 29;
inline bool ArenaBaseInfo::has_clanjob() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ArenaBaseInfo::set_has_clanjob() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ArenaBaseInfo::clear_has_clanjob() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ArenaBaseInfo::clear_clanjob() {
  clanjob_ = 0;
  clear_has_clanjob();
}
inline ::google::protobuf::int32 ArenaBaseInfo::clanjob() const {
  return clanjob_;
}
inline void ArenaBaseInfo::set_clanjob(::google::protobuf::int32 value) {
  set_has_clanjob();
  clanjob_ = value;
}

// -------------------------------------------------------------------

// ArenaChallengeRank

// repeated int32 challengeRank = 1;
inline int ArenaChallengeRank::challengerank_size() const {
  return challengerank_.size();
}
inline void ArenaChallengeRank::clear_challengerank() {
  challengerank_.Clear();
}
inline ::google::protobuf::int32 ArenaChallengeRank::challengerank(int index) const {
  return challengerank_.Get(index);
}
inline void ArenaChallengeRank::set_challengerank(int index, ::google::protobuf::int32 value) {
  challengerank_.Set(index, value);
}
inline void ArenaChallengeRank::add_challengerank(::google::protobuf::int32 value) {
  challengerank_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ArenaChallengeRank::challengerank() const {
  return challengerank_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ArenaChallengeRank::mutable_challengerank() {
  return &challengerank_;
}

// -------------------------------------------------------------------

// ArenaHistoryReward

// repeated int32 reward = 1;
inline int ArenaHistoryReward::reward_size() const {
  return reward_.size();
}
inline void ArenaHistoryReward::clear_reward() {
  reward_.Clear();
}
inline ::google::protobuf::int32 ArenaHistoryReward::reward(int index) const {
  return reward_.Get(index);
}
inline void ArenaHistoryReward::set_reward(int index, ::google::protobuf::int32 value) {
  reward_.Set(index, value);
}
inline void ArenaHistoryReward::add_reward(::google::protobuf::int32 value) {
  reward_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ArenaHistoryReward::reward() const {
  return reward_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ArenaHistoryReward::mutable_reward() {
  return &reward_;
}

// repeated int32 havaReward = 2;
inline int ArenaHistoryReward::havareward_size() const {
  return havareward_.size();
}
inline void ArenaHistoryReward::clear_havareward() {
  havareward_.Clear();
}
inline ::google::protobuf::int32 ArenaHistoryReward::havareward(int index) const {
  return havareward_.Get(index);
}
inline void ArenaHistoryReward::set_havareward(int index, ::google::protobuf::int32 value) {
  havareward_.Set(index, value);
}
inline void ArenaHistoryReward::add_havareward(::google::protobuf::int32 value) {
  havareward_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ArenaHistoryReward::havareward() const {
  return havareward_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ArenaHistoryReward::mutable_havareward() {
  return &havareward_;
}

// -------------------------------------------------------------------

// RingDBData

// optional int32 id = 1;
inline bool RingDBData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RingDBData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RingDBData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RingDBData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RingDBData::id() const {
  return id_;
}
inline void RingDBData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 exp = 2;
inline bool RingDBData::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RingDBData::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RingDBData::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RingDBData::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 RingDBData::exp() const {
  return exp_;
}
inline void RingDBData::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 reward = 3;
inline bool RingDBData::has_reward() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RingDBData::set_has_reward() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RingDBData::clear_has_reward() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RingDBData::clear_reward() {
  reward_ = 0;
  clear_has_reward();
}
inline ::google::protobuf::int32 RingDBData::reward() const {
  return reward_;
}
inline void RingDBData::set_reward(::google::protobuf::int32 value) {
  set_has_reward();
  reward_ = value;
}

// -------------------------------------------------------------------

// SaveTypeInfo

// required uint64 type = 1;
inline bool SaveTypeInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SaveTypeInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SaveTypeInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SaveTypeInfo::clear_type() {
  type_ = GOOGLE_ULONGLONG(0);
  clear_has_type();
}
inline ::google::protobuf::uint64 SaveTypeInfo::type() const {
  return type_;
}
inline void SaveTypeInfo::set_type(::google::protobuf::uint64 value) {
  set_has_type();
  type_ = value;
}

// required int64 id = 2;
inline bool SaveTypeInfo::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SaveTypeInfo::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SaveTypeInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SaveTypeInfo::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 SaveTypeInfo::id() const {
  return id_;
}
inline void SaveTypeInfo::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// required bool isdel = 3;
inline bool SaveTypeInfo::has_isdel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SaveTypeInfo::set_has_isdel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SaveTypeInfo::clear_has_isdel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SaveTypeInfo::clear_isdel() {
  isdel_ = false;
  clear_has_isdel();
}
inline bool SaveTypeInfo::isdel() const {
  return isdel_;
}
inline void SaveTypeInfo::set_isdel(bool value) {
  set_has_isdel();
  isdel_ = value;
}

// optional .PlayerInfo.BaseInfo bsinfo = 4;
inline bool SaveTypeInfo::has_bsinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SaveTypeInfo::set_has_bsinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SaveTypeInfo::clear_has_bsinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SaveTypeInfo::clear_bsinfo() {
  if (bsinfo_ != NULL) bsinfo_->::PlayerInfo::BaseInfo::Clear();
  clear_has_bsinfo();
}
inline const ::PlayerInfo::BaseInfo& SaveTypeInfo::bsinfo() const {
  return bsinfo_ != NULL ? *bsinfo_ : *default_instance_->bsinfo_;
}
inline ::PlayerInfo::BaseInfo* SaveTypeInfo::mutable_bsinfo() {
  set_has_bsinfo();
  if (bsinfo_ == NULL) bsinfo_ = new ::PlayerInfo::BaseInfo;
  return bsinfo_;
}
inline ::PlayerInfo::BaseInfo* SaveTypeInfo::release_bsinfo() {
  clear_has_bsinfo();
  ::PlayerInfo::BaseInfo* temp = bsinfo_;
  bsinfo_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_bsinfo(::PlayerInfo::BaseInfo* bsinfo) {
  delete bsinfo_;
  bsinfo_ = bsinfo;
  if (bsinfo) {
    set_has_bsinfo();
  } else {
    clear_has_bsinfo();
  }
}

// optional .PlayerInfo.BattleInfo binfo = 5;
inline bool SaveTypeInfo::has_binfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SaveTypeInfo::set_has_binfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SaveTypeInfo::clear_has_binfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SaveTypeInfo::clear_binfo() {
  if (binfo_ != NULL) binfo_->::PlayerInfo::BattleInfo::Clear();
  clear_has_binfo();
}
inline const ::PlayerInfo::BattleInfo& SaveTypeInfo::binfo() const {
  return binfo_ != NULL ? *binfo_ : *default_instance_->binfo_;
}
inline ::PlayerInfo::BattleInfo* SaveTypeInfo::mutable_binfo() {
  set_has_binfo();
  if (binfo_ == NULL) binfo_ = new ::PlayerInfo::BattleInfo;
  return binfo_;
}
inline ::PlayerInfo::BattleInfo* SaveTypeInfo::release_binfo() {
  clear_has_binfo();
  ::PlayerInfo::BattleInfo* temp = binfo_;
  binfo_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_binfo(::PlayerInfo::BattleInfo* binfo) {
  delete binfo_;
  binfo_ = binfo;
  if (binfo) {
    set_has_binfo();
  } else {
    clear_has_binfo();
  }
}

// optional .PlayerInfo.QuestInfo questinfo = 6;
inline bool SaveTypeInfo::has_questinfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SaveTypeInfo::set_has_questinfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SaveTypeInfo::clear_has_questinfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SaveTypeInfo::clear_questinfo() {
  if (questinfo_ != NULL) questinfo_->::PlayerInfo::QuestInfo::Clear();
  clear_has_questinfo();
}
inline const ::PlayerInfo::QuestInfo& SaveTypeInfo::questinfo() const {
  return questinfo_ != NULL ? *questinfo_ : *default_instance_->questinfo_;
}
inline ::PlayerInfo::QuestInfo* SaveTypeInfo::mutable_questinfo() {
  set_has_questinfo();
  if (questinfo_ == NULL) questinfo_ = new ::PlayerInfo::QuestInfo;
  return questinfo_;
}
inline ::PlayerInfo::QuestInfo* SaveTypeInfo::release_questinfo() {
  clear_has_questinfo();
  ::PlayerInfo::QuestInfo* temp = questinfo_;
  questinfo_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_questinfo(::PlayerInfo::QuestInfo* questinfo) {
  delete questinfo_;
  questinfo_ = questinfo;
  if (questinfo) {
    set_has_questinfo();
  } else {
    clear_has_questinfo();
  }
}

// optional .PlayerInfo.SkillInfo skill = 7;
inline bool SaveTypeInfo::has_skill() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SaveTypeInfo::set_has_skill() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SaveTypeInfo::clear_has_skill() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SaveTypeInfo::clear_skill() {
  if (skill_ != NULL) skill_->::PlayerInfo::SkillInfo::Clear();
  clear_has_skill();
}
inline const ::PlayerInfo::SkillInfo& SaveTypeInfo::skill() const {
  return skill_ != NULL ? *skill_ : *default_instance_->skill_;
}
inline ::PlayerInfo::SkillInfo* SaveTypeInfo::mutable_skill() {
  set_has_skill();
  if (skill_ == NULL) skill_ = new ::PlayerInfo::SkillInfo;
  return skill_;
}
inline ::PlayerInfo::SkillInfo* SaveTypeInfo::release_skill() {
  clear_has_skill();
  ::PlayerInfo::SkillInfo* temp = skill_;
  skill_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_skill(::PlayerInfo::SkillInfo* skill) {
  delete skill_;
  skill_ = skill;
  if (skill) {
    set_has_skill();
  } else {
    clear_has_skill();
  }
}

// optional .PlayerInfo.CDInfo cd = 8;
inline bool SaveTypeInfo::has_cd() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SaveTypeInfo::set_has_cd() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SaveTypeInfo::clear_has_cd() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SaveTypeInfo::clear_cd() {
  if (cd_ != NULL) cd_->::PlayerInfo::CDInfo::Clear();
  clear_has_cd();
}
inline const ::PlayerInfo::CDInfo& SaveTypeInfo::cd() const {
  return cd_ != NULL ? *cd_ : *default_instance_->cd_;
}
inline ::PlayerInfo::CDInfo* SaveTypeInfo::mutable_cd() {
  set_has_cd();
  if (cd_ == NULL) cd_ = new ::PlayerInfo::CDInfo;
  return cd_;
}
inline ::PlayerInfo::CDInfo* SaveTypeInfo::release_cd() {
  clear_has_cd();
  ::PlayerInfo::CDInfo* temp = cd_;
  cd_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_cd(::PlayerInfo::CDInfo* cd) {
  delete cd_;
  cd_ = cd;
  if (cd) {
    set_has_cd();
  } else {
    clear_has_cd();
  }
}

// optional .PlayerInfo.PackageInfo package = 9;
inline bool SaveTypeInfo::has_package() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SaveTypeInfo::set_has_package() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SaveTypeInfo::clear_has_package() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SaveTypeInfo::clear_package() {
  if (package_ != NULL) package_->::PlayerInfo::PackageInfo::Clear();
  clear_has_package();
}
inline const ::PlayerInfo::PackageInfo& SaveTypeInfo::package() const {
  return package_ != NULL ? *package_ : *default_instance_->package_;
}
inline ::PlayerInfo::PackageInfo* SaveTypeInfo::mutable_package() {
  set_has_package();
  if (package_ == NULL) package_ = new ::PlayerInfo::PackageInfo;
  return package_;
}
inline ::PlayerInfo::PackageInfo* SaveTypeInfo::release_package() {
  clear_has_package();
  ::PlayerInfo::PackageInfo* temp = package_;
  package_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_package(::PlayerInfo::PackageInfo* package) {
  delete package_;
  package_ = package;
  if (package) {
    set_has_package();
  } else {
    clear_has_package();
  }
}

// optional .PlayerInfo.StoreHouseInfo storehouse = 10;
inline bool SaveTypeInfo::has_storehouse() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SaveTypeInfo::set_has_storehouse() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SaveTypeInfo::clear_has_storehouse() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SaveTypeInfo::clear_storehouse() {
  if (storehouse_ != NULL) storehouse_->::PlayerInfo::StoreHouseInfo::Clear();
  clear_has_storehouse();
}
inline const ::PlayerInfo::StoreHouseInfo& SaveTypeInfo::storehouse() const {
  return storehouse_ != NULL ? *storehouse_ : *default_instance_->storehouse_;
}
inline ::PlayerInfo::StoreHouseInfo* SaveTypeInfo::mutable_storehouse() {
  set_has_storehouse();
  if (storehouse_ == NULL) storehouse_ = new ::PlayerInfo::StoreHouseInfo;
  return storehouse_;
}
inline ::PlayerInfo::StoreHouseInfo* SaveTypeInfo::release_storehouse() {
  clear_has_storehouse();
  ::PlayerInfo::StoreHouseInfo* temp = storehouse_;
  storehouse_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_storehouse(::PlayerInfo::StoreHouseInfo* storehouse) {
  delete storehouse_;
  storehouse_ = storehouse;
  if (storehouse) {
    set_has_storehouse();
  } else {
    clear_has_storehouse();
  }
}

// optional .PlayerInfo.EquipQuickInfo equipquick = 11;
inline bool SaveTypeInfo::has_equipquick() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SaveTypeInfo::set_has_equipquick() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SaveTypeInfo::clear_has_equipquick() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SaveTypeInfo::clear_equipquick() {
  if (equipquick_ != NULL) equipquick_->::PlayerInfo::EquipQuickInfo::Clear();
  clear_has_equipquick();
}
inline const ::PlayerInfo::EquipQuickInfo& SaveTypeInfo::equipquick() const {
  return equipquick_ != NULL ? *equipquick_ : *default_instance_->equipquick_;
}
inline ::PlayerInfo::EquipQuickInfo* SaveTypeInfo::mutable_equipquick() {
  set_has_equipquick();
  if (equipquick_ == NULL) equipquick_ = new ::PlayerInfo::EquipQuickInfo;
  return equipquick_;
}
inline ::PlayerInfo::EquipQuickInfo* SaveTypeInfo::release_equipquick() {
  clear_has_equipquick();
  ::PlayerInfo::EquipQuickInfo* temp = equipquick_;
  equipquick_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_equipquick(::PlayerInfo::EquipQuickInfo* equipquick) {
  delete equipquick_;
  equipquick_ = equipquick;
  if (equipquick) {
    set_has_equipquick();
  } else {
    clear_has_equipquick();
  }
}

// optional .PlayerInfo.MonitorInfo monitor = 12;
inline bool SaveTypeInfo::has_monitor() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SaveTypeInfo::set_has_monitor() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SaveTypeInfo::clear_has_monitor() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SaveTypeInfo::clear_monitor() {
  if (monitor_ != NULL) monitor_->::PlayerInfo::MonitorInfo::Clear();
  clear_has_monitor();
}
inline const ::PlayerInfo::MonitorInfo& SaveTypeInfo::monitor() const {
  return monitor_ != NULL ? *monitor_ : *default_instance_->monitor_;
}
inline ::PlayerInfo::MonitorInfo* SaveTypeInfo::mutable_monitor() {
  set_has_monitor();
  if (monitor_ == NULL) monitor_ = new ::PlayerInfo::MonitorInfo;
  return monitor_;
}
inline ::PlayerInfo::MonitorInfo* SaveTypeInfo::release_monitor() {
  clear_has_monitor();
  ::PlayerInfo::MonitorInfo* temp = monitor_;
  monitor_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_monitor(::PlayerInfo::MonitorInfo* monitor) {
  delete monitor_;
  monitor_ = monitor;
  if (monitor) {
    set_has_monitor();
  } else {
    clear_has_monitor();
  }
}

// optional .PlayerInfo.HorseInfo horse = 13;
inline bool SaveTypeInfo::has_horse() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SaveTypeInfo::set_has_horse() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SaveTypeInfo::clear_has_horse() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SaveTypeInfo::clear_horse() {
  if (horse_ != NULL) horse_->::PlayerInfo::HorseInfo::Clear();
  clear_has_horse();
}
inline const ::PlayerInfo::HorseInfo& SaveTypeInfo::horse() const {
  return horse_ != NULL ? *horse_ : *default_instance_->horse_;
}
inline ::PlayerInfo::HorseInfo* SaveTypeInfo::mutable_horse() {
  set_has_horse();
  if (horse_ == NULL) horse_ = new ::PlayerInfo::HorseInfo;
  return horse_;
}
inline ::PlayerInfo::HorseInfo* SaveTypeInfo::release_horse() {
  clear_has_horse();
  ::PlayerInfo::HorseInfo* temp = horse_;
  horse_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_horse(::PlayerInfo::HorseInfo* horse) {
  delete horse_;
  horse_ = horse;
  if (horse) {
    set_has_horse();
  } else {
    clear_has_horse();
  }
}

// optional .PlayerInfo.InstanceInfoTwoDays instance = 14;
inline bool SaveTypeInfo::has_instance() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SaveTypeInfo::set_has_instance() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SaveTypeInfo::clear_has_instance() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SaveTypeInfo::clear_instance() {
  if (instance_ != NULL) instance_->::PlayerInfo::InstanceInfoTwoDays::Clear();
  clear_has_instance();
}
inline const ::PlayerInfo::InstanceInfoTwoDays& SaveTypeInfo::instance() const {
  return instance_ != NULL ? *instance_ : *default_instance_->instance_;
}
inline ::PlayerInfo::InstanceInfoTwoDays* SaveTypeInfo::mutable_instance() {
  set_has_instance();
  if (instance_ == NULL) instance_ = new ::PlayerInfo::InstanceInfoTwoDays;
  return instance_;
}
inline ::PlayerInfo::InstanceInfoTwoDays* SaveTypeInfo::release_instance() {
  clear_has_instance();
  ::PlayerInfo::InstanceInfoTwoDays* temp = instance_;
  instance_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_instance(::PlayerInfo::InstanceInfoTwoDays* instance) {
  delete instance_;
  instance_ = instance;
  if (instance) {
    set_has_instance();
  } else {
    clear_has_instance();
  }
}

// optional .PlayerInfo.PrestigeInfoList prestige = 15;
inline bool SaveTypeInfo::has_prestige() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SaveTypeInfo::set_has_prestige() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SaveTypeInfo::clear_has_prestige() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SaveTypeInfo::clear_prestige() {
  if (prestige_ != NULL) prestige_->::PlayerInfo::PrestigeInfoList::Clear();
  clear_has_prestige();
}
inline const ::PlayerInfo::PrestigeInfoList& SaveTypeInfo::prestige() const {
  return prestige_ != NULL ? *prestige_ : *default_instance_->prestige_;
}
inline ::PlayerInfo::PrestigeInfoList* SaveTypeInfo::mutable_prestige() {
  set_has_prestige();
  if (prestige_ == NULL) prestige_ = new ::PlayerInfo::PrestigeInfoList;
  return prestige_;
}
inline ::PlayerInfo::PrestigeInfoList* SaveTypeInfo::release_prestige() {
  clear_has_prestige();
  ::PlayerInfo::PrestigeInfoList* temp = prestige_;
  prestige_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_prestige(::PlayerInfo::PrestigeInfoList* prestige) {
  delete prestige_;
  prestige_ = prestige;
  if (prestige) {
    set_has_prestige();
  } else {
    clear_has_prestige();
  }
}

// optional .PlayerInfo.SignInInfo signin = 16;
inline bool SaveTypeInfo::has_signin() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SaveTypeInfo::set_has_signin() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SaveTypeInfo::clear_has_signin() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SaveTypeInfo::clear_signin() {
  if (signin_ != NULL) signin_->::PlayerInfo::SignInInfo::Clear();
  clear_has_signin();
}
inline const ::PlayerInfo::SignInInfo& SaveTypeInfo::signin() const {
  return signin_ != NULL ? *signin_ : *default_instance_->signin_;
}
inline ::PlayerInfo::SignInInfo* SaveTypeInfo::mutable_signin() {
  set_has_signin();
  if (signin_ == NULL) signin_ = new ::PlayerInfo::SignInInfo;
  return signin_;
}
inline ::PlayerInfo::SignInInfo* SaveTypeInfo::release_signin() {
  clear_has_signin();
  ::PlayerInfo::SignInInfo* temp = signin_;
  signin_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_signin(::PlayerInfo::SignInInfo* signin) {
  delete signin_;
  signin_ = signin;
  if (signin) {
    set_has_signin();
  } else {
    clear_has_signin();
  }
}

// optional .PlayerInfo.CounterServiceList counter = 17;
inline bool SaveTypeInfo::has_counter() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SaveTypeInfo::set_has_counter() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SaveTypeInfo::clear_has_counter() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SaveTypeInfo::clear_counter() {
  if (counter_ != NULL) counter_->::PlayerInfo::CounterServiceList::Clear();
  clear_has_counter();
}
inline const ::PlayerInfo::CounterServiceList& SaveTypeInfo::counter() const {
  return counter_ != NULL ? *counter_ : *default_instance_->counter_;
}
inline ::PlayerInfo::CounterServiceList* SaveTypeInfo::mutable_counter() {
  set_has_counter();
  if (counter_ == NULL) counter_ = new ::PlayerInfo::CounterServiceList;
  return counter_;
}
inline ::PlayerInfo::CounterServiceList* SaveTypeInfo::release_counter() {
  clear_has_counter();
  ::PlayerInfo::CounterServiceList* temp = counter_;
  counter_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_counter(::PlayerInfo::CounterServiceList* counter) {
  delete counter_;
  counter_ = counter;
  if (counter) {
    set_has_counter();
  } else {
    clear_has_counter();
  }
}

// optional .PlayerInfo.TitleInfoList titles = 18;
inline bool SaveTypeInfo::has_titles() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SaveTypeInfo::set_has_titles() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SaveTypeInfo::clear_has_titles() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SaveTypeInfo::clear_titles() {
  if (titles_ != NULL) titles_->::PlayerInfo::TitleInfoList::Clear();
  clear_has_titles();
}
inline const ::PlayerInfo::TitleInfoList& SaveTypeInfo::titles() const {
  return titles_ != NULL ? *titles_ : *default_instance_->titles_;
}
inline ::PlayerInfo::TitleInfoList* SaveTypeInfo::mutable_titles() {
  set_has_titles();
  if (titles_ == NULL) titles_ = new ::PlayerInfo::TitleInfoList;
  return titles_;
}
inline ::PlayerInfo::TitleInfoList* SaveTypeInfo::release_titles() {
  clear_has_titles();
  ::PlayerInfo::TitleInfoList* temp = titles_;
  titles_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_titles(::PlayerInfo::TitleInfoList* titles) {
  delete titles_;
  titles_ = titles;
  if (titles) {
    set_has_titles();
  } else {
    clear_has_titles();
  }
}

// optional .PlayerInfo.EscortInfo escort = 19;
inline bool SaveTypeInfo::has_escort() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SaveTypeInfo::set_has_escort() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SaveTypeInfo::clear_has_escort() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SaveTypeInfo::clear_escort() {
  if (escort_ != NULL) escort_->::PlayerInfo::EscortInfo::Clear();
  clear_has_escort();
}
inline const ::PlayerInfo::EscortInfo& SaveTypeInfo::escort() const {
  return escort_ != NULL ? *escort_ : *default_instance_->escort_;
}
inline ::PlayerInfo::EscortInfo* SaveTypeInfo::mutable_escort() {
  set_has_escort();
  if (escort_ == NULL) escort_ = new ::PlayerInfo::EscortInfo;
  return escort_;
}
inline ::PlayerInfo::EscortInfo* SaveTypeInfo::release_escort() {
  clear_has_escort();
  ::PlayerInfo::EscortInfo* temp = escort_;
  escort_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_escort(::PlayerInfo::EscortInfo* escort) {
  delete escort_;
  escort_ = escort;
  if (escort) {
    set_has_escort();
  } else {
    clear_has_escort();
  }
}

// optional .PlayerInfo.DanLuInfo danlu = 20;
inline bool SaveTypeInfo::has_danlu() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SaveTypeInfo::set_has_danlu() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SaveTypeInfo::clear_has_danlu() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SaveTypeInfo::clear_danlu() {
  if (danlu_ != NULL) danlu_->::PlayerInfo::DanLuInfo::Clear();
  clear_has_danlu();
}
inline const ::PlayerInfo::DanLuInfo& SaveTypeInfo::danlu() const {
  return danlu_ != NULL ? *danlu_ : *default_instance_->danlu_;
}
inline ::PlayerInfo::DanLuInfo* SaveTypeInfo::mutable_danlu() {
  set_has_danlu();
  if (danlu_ == NULL) danlu_ = new ::PlayerInfo::DanLuInfo;
  return danlu_;
}
inline ::PlayerInfo::DanLuInfo* SaveTypeInfo::release_danlu() {
  clear_has_danlu();
  ::PlayerInfo::DanLuInfo* temp = danlu_;
  danlu_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_danlu(::PlayerInfo::DanLuInfo* danlu) {
  delete danlu_;
  danlu_ = danlu;
  if (danlu) {
    set_has_danlu();
  } else {
    clear_has_danlu();
  }
}

// optional .PlayerInfo.PlayerVipInfo vipinfo = 21;
inline bool SaveTypeInfo::has_vipinfo() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SaveTypeInfo::set_has_vipinfo() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SaveTypeInfo::clear_has_vipinfo() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SaveTypeInfo::clear_vipinfo() {
  if (vipinfo_ != NULL) vipinfo_->::PlayerInfo::PlayerVipInfo::Clear();
  clear_has_vipinfo();
}
inline const ::PlayerInfo::PlayerVipInfo& SaveTypeInfo::vipinfo() const {
  return vipinfo_ != NULL ? *vipinfo_ : *default_instance_->vipinfo_;
}
inline ::PlayerInfo::PlayerVipInfo* SaveTypeInfo::mutable_vipinfo() {
  set_has_vipinfo();
  if (vipinfo_ == NULL) vipinfo_ = new ::PlayerInfo::PlayerVipInfo;
  return vipinfo_;
}
inline ::PlayerInfo::PlayerVipInfo* SaveTypeInfo::release_vipinfo() {
  clear_has_vipinfo();
  ::PlayerInfo::PlayerVipInfo* temp = vipinfo_;
  vipinfo_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_vipinfo(::PlayerInfo::PlayerVipInfo* vipinfo) {
  delete vipinfo_;
  vipinfo_ = vipinfo;
  if (vipinfo) {
    set_has_vipinfo();
  } else {
    clear_has_vipinfo();
  }
}

// optional .PlayerInfo.MagicWeapon magicw = 22;
inline bool SaveTypeInfo::has_magicw() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SaveTypeInfo::set_has_magicw() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SaveTypeInfo::clear_has_magicw() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SaveTypeInfo::clear_magicw() {
  if (magicw_ != NULL) magicw_->::PlayerInfo::MagicWeapon::Clear();
  clear_has_magicw();
}
inline const ::PlayerInfo::MagicWeapon& SaveTypeInfo::magicw() const {
  return magicw_ != NULL ? *magicw_ : *default_instance_->magicw_;
}
inline ::PlayerInfo::MagicWeapon* SaveTypeInfo::mutable_magicw() {
  set_has_magicw();
  if (magicw_ == NULL) magicw_ = new ::PlayerInfo::MagicWeapon;
  return magicw_;
}
inline ::PlayerInfo::MagicWeapon* SaveTypeInfo::release_magicw() {
  clear_has_magicw();
  ::PlayerInfo::MagicWeapon* temp = magicw_;
  magicw_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_magicw(::PlayerInfo::MagicWeapon* magicw) {
  delete magicw_;
  magicw_ = magicw;
  if (magicw) {
    set_has_magicw();
  } else {
    clear_has_magicw();
  }
}

// optional .PlayerInfo.RandCJobLucky cjob = 23;
inline bool SaveTypeInfo::has_cjob() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SaveTypeInfo::set_has_cjob() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SaveTypeInfo::clear_has_cjob() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SaveTypeInfo::clear_cjob() {
  if (cjob_ != NULL) cjob_->::PlayerInfo::RandCJobLucky::Clear();
  clear_has_cjob();
}
inline const ::PlayerInfo::RandCJobLucky& SaveTypeInfo::cjob() const {
  return cjob_ != NULL ? *cjob_ : *default_instance_->cjob_;
}
inline ::PlayerInfo::RandCJobLucky* SaveTypeInfo::mutable_cjob() {
  set_has_cjob();
  if (cjob_ == NULL) cjob_ = new ::PlayerInfo::RandCJobLucky;
  return cjob_;
}
inline ::PlayerInfo::RandCJobLucky* SaveTypeInfo::release_cjob() {
  clear_has_cjob();
  ::PlayerInfo::RandCJobLucky* temp = cjob_;
  cjob_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_cjob(::PlayerInfo::RandCJobLucky* cjob) {
  delete cjob_;
  cjob_ = cjob;
  if (cjob) {
    set_has_cjob();
  } else {
    clear_has_cjob();
  }
}

// optional .PlayerInfo.LucklyTurntable lucktable = 24;
inline bool SaveTypeInfo::has_lucktable() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SaveTypeInfo::set_has_lucktable() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SaveTypeInfo::clear_has_lucktable() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SaveTypeInfo::clear_lucktable() {
  if (lucktable_ != NULL) lucktable_->::PlayerInfo::LucklyTurntable::Clear();
  clear_has_lucktable();
}
inline const ::PlayerInfo::LucklyTurntable& SaveTypeInfo::lucktable() const {
  return lucktable_ != NULL ? *lucktable_ : *default_instance_->lucktable_;
}
inline ::PlayerInfo::LucklyTurntable* SaveTypeInfo::mutable_lucktable() {
  set_has_lucktable();
  if (lucktable_ == NULL) lucktable_ = new ::PlayerInfo::LucklyTurntable;
  return lucktable_;
}
inline ::PlayerInfo::LucklyTurntable* SaveTypeInfo::release_lucktable() {
  clear_has_lucktable();
  ::PlayerInfo::LucklyTurntable* temp = lucktable_;
  lucktable_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_lucktable(::PlayerInfo::LucklyTurntable* lucktable) {
  delete lucktable_;
  lucktable_ = lucktable;
  if (lucktable) {
    set_has_lucktable();
  } else {
    clear_has_lucktable();
  }
}

// optional .PlayerInfo.DestinationInfoList destination = 25;
inline bool SaveTypeInfo::has_destination() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void SaveTypeInfo::set_has_destination() {
  _has_bits_[0] |= 0x01000000u;
}
inline void SaveTypeInfo::clear_has_destination() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void SaveTypeInfo::clear_destination() {
  if (destination_ != NULL) destination_->::PlayerInfo::DestinationInfoList::Clear();
  clear_has_destination();
}
inline const ::PlayerInfo::DestinationInfoList& SaveTypeInfo::destination() const {
  return destination_ != NULL ? *destination_ : *default_instance_->destination_;
}
inline ::PlayerInfo::DestinationInfoList* SaveTypeInfo::mutable_destination() {
  set_has_destination();
  if (destination_ == NULL) destination_ = new ::PlayerInfo::DestinationInfoList;
  return destination_;
}
inline ::PlayerInfo::DestinationInfoList* SaveTypeInfo::release_destination() {
  clear_has_destination();
  ::PlayerInfo::DestinationInfoList* temp = destination_;
  destination_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_destination(::PlayerInfo::DestinationInfoList* destination) {
  delete destination_;
  destination_ = destination;
  if (destination) {
    set_has_destination();
  } else {
    clear_has_destination();
  }
}

// optional .PlayerInfo.Activity activity = 26;
inline bool SaveTypeInfo::has_activity() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void SaveTypeInfo::set_has_activity() {
  _has_bits_[0] |= 0x02000000u;
}
inline void SaveTypeInfo::clear_has_activity() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void SaveTypeInfo::clear_activity() {
  if (activity_ != NULL) activity_->::PlayerInfo::Activity::Clear();
  clear_has_activity();
}
inline const ::PlayerInfo::Activity& SaveTypeInfo::activity() const {
  return activity_ != NULL ? *activity_ : *default_instance_->activity_;
}
inline ::PlayerInfo::Activity* SaveTypeInfo::mutable_activity() {
  set_has_activity();
  if (activity_ == NULL) activity_ = new ::PlayerInfo::Activity;
  return activity_;
}
inline ::PlayerInfo::Activity* SaveTypeInfo::release_activity() {
  clear_has_activity();
  ::PlayerInfo::Activity* temp = activity_;
  activity_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_activity(::PlayerInfo::Activity* activity) {
  delete activity_;
  activity_ = activity;
  if (activity) {
    set_has_activity();
  } else {
    clear_has_activity();
  }
}

// optional .PlayerInfo.GirlWarInfo girlwar = 27;
inline bool SaveTypeInfo::has_girlwar() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void SaveTypeInfo::set_has_girlwar() {
  _has_bits_[0] |= 0x04000000u;
}
inline void SaveTypeInfo::clear_has_girlwar() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void SaveTypeInfo::clear_girlwar() {
  if (girlwar_ != NULL) girlwar_->::PlayerInfo::GirlWarInfo::Clear();
  clear_has_girlwar();
}
inline const ::PlayerInfo::GirlWarInfo& SaveTypeInfo::girlwar() const {
  return girlwar_ != NULL ? *girlwar_ : *default_instance_->girlwar_;
}
inline ::PlayerInfo::GirlWarInfo* SaveTypeInfo::mutable_girlwar() {
  set_has_girlwar();
  if (girlwar_ == NULL) girlwar_ = new ::PlayerInfo::GirlWarInfo;
  return girlwar_;
}
inline ::PlayerInfo::GirlWarInfo* SaveTypeInfo::release_girlwar() {
  clear_has_girlwar();
  ::PlayerInfo::GirlWarInfo* temp = girlwar_;
  girlwar_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_girlwar(::PlayerInfo::GirlWarInfo* girlwar) {
  delete girlwar_;
  girlwar_ = girlwar;
  if (girlwar) {
    set_has_girlwar();
  } else {
    clear_has_girlwar();
  }
}

// optional .FashionMsgProto.FashionShow fashion = 28;
inline bool SaveTypeInfo::has_fashion() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void SaveTypeInfo::set_has_fashion() {
  _has_bits_[0] |= 0x08000000u;
}
inline void SaveTypeInfo::clear_has_fashion() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void SaveTypeInfo::clear_fashion() {
  if (fashion_ != NULL) fashion_->::FashionMsgProto::FashionShow::Clear();
  clear_has_fashion();
}
inline const ::FashionMsgProto::FashionShow& SaveTypeInfo::fashion() const {
  return fashion_ != NULL ? *fashion_ : *default_instance_->fashion_;
}
inline ::FashionMsgProto::FashionShow* SaveTypeInfo::mutable_fashion() {
  set_has_fashion();
  if (fashion_ == NULL) fashion_ = new ::FashionMsgProto::FashionShow;
  return fashion_;
}
inline ::FashionMsgProto::FashionShow* SaveTypeInfo::release_fashion() {
  clear_has_fashion();
  ::FashionMsgProto::FashionShow* temp = fashion_;
  fashion_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_fashion(::FashionMsgProto::FashionShow* fashion) {
  delete fashion_;
  fashion_ = fashion;
  if (fashion) {
    set_has_fashion();
  } else {
    clear_has_fashion();
  }
}

// optional .VitalityProto.ProtoVitalityInfo vitality = 29;
inline bool SaveTypeInfo::has_vitality() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void SaveTypeInfo::set_has_vitality() {
  _has_bits_[0] |= 0x10000000u;
}
inline void SaveTypeInfo::clear_has_vitality() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void SaveTypeInfo::clear_vitality() {
  if (vitality_ != NULL) vitality_->::VitalityProto::ProtoVitalityInfo::Clear();
  clear_has_vitality();
}
inline const ::VitalityProto::ProtoVitalityInfo& SaveTypeInfo::vitality() const {
  return vitality_ != NULL ? *vitality_ : *default_instance_->vitality_;
}
inline ::VitalityProto::ProtoVitalityInfo* SaveTypeInfo::mutable_vitality() {
  set_has_vitality();
  if (vitality_ == NULL) vitality_ = new ::VitalityProto::ProtoVitalityInfo;
  return vitality_;
}
inline ::VitalityProto::ProtoVitalityInfo* SaveTypeInfo::release_vitality() {
  clear_has_vitality();
  ::VitalityProto::ProtoVitalityInfo* temp = vitality_;
  vitality_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_vitality(::VitalityProto::ProtoVitalityInfo* vitality) {
  delete vitality_;
  vitality_ = vitality;
  if (vitality) {
    set_has_vitality();
  } else {
    clear_has_vitality();
  }
}

// optional .PlayerInfo.CampShopInfo CampData = 30;
inline bool SaveTypeInfo::has_campdata() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void SaveTypeInfo::set_has_campdata() {
  _has_bits_[0] |= 0x20000000u;
}
inline void SaveTypeInfo::clear_has_campdata() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void SaveTypeInfo::clear_campdata() {
  if (campdata_ != NULL) campdata_->::PlayerInfo::CampShopInfo::Clear();
  clear_has_campdata();
}
inline const ::PlayerInfo::CampShopInfo& SaveTypeInfo::campdata() const {
  return campdata_ != NULL ? *campdata_ : *default_instance_->campdata_;
}
inline ::PlayerInfo::CampShopInfo* SaveTypeInfo::mutable_campdata() {
  set_has_campdata();
  if (campdata_ == NULL) campdata_ = new ::PlayerInfo::CampShopInfo;
  return campdata_;
}
inline ::PlayerInfo::CampShopInfo* SaveTypeInfo::release_campdata() {
  clear_has_campdata();
  ::PlayerInfo::CampShopInfo* temp = campdata_;
  campdata_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_campdata(::PlayerInfo::CampShopInfo* campdata) {
  delete campdata_;
  campdata_ = campdata;
  if (campdata) {
    set_has_campdata();
  } else {
    clear_has_campdata();
  }
}

// optional .PlayerInfo.FestivalInfo festivalData = 31;
inline bool SaveTypeInfo::has_festivaldata() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void SaveTypeInfo::set_has_festivaldata() {
  _has_bits_[0] |= 0x40000000u;
}
inline void SaveTypeInfo::clear_has_festivaldata() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void SaveTypeInfo::clear_festivaldata() {
  if (festivaldata_ != NULL) festivaldata_->::PlayerInfo::FestivalInfo::Clear();
  clear_has_festivaldata();
}
inline const ::PlayerInfo::FestivalInfo& SaveTypeInfo::festivaldata() const {
  return festivaldata_ != NULL ? *festivaldata_ : *default_instance_->festivaldata_;
}
inline ::PlayerInfo::FestivalInfo* SaveTypeInfo::mutable_festivaldata() {
  set_has_festivaldata();
  if (festivaldata_ == NULL) festivaldata_ = new ::PlayerInfo::FestivalInfo;
  return festivaldata_;
}
inline ::PlayerInfo::FestivalInfo* SaveTypeInfo::release_festivaldata() {
  clear_has_festivaldata();
  ::PlayerInfo::FestivalInfo* temp = festivaldata_;
  festivaldata_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_festivaldata(::PlayerInfo::FestivalInfo* festivaldata) {
  delete festivaldata_;
  festivaldata_ = festivaldata;
  if (festivaldata) {
    set_has_festivaldata();
  } else {
    clear_has_festivaldata();
  }
}

// optional .PlayerInfo.MoneyInstance info = 32;
inline bool SaveTypeInfo::has_info() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void SaveTypeInfo::set_has_info() {
  _has_bits_[0] |= 0x80000000u;
}
inline void SaveTypeInfo::clear_has_info() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void SaveTypeInfo::clear_info() {
  if (info_ != NULL) info_->::PlayerInfo::MoneyInstance::Clear();
  clear_has_info();
}
inline const ::PlayerInfo::MoneyInstance& SaveTypeInfo::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::PlayerInfo::MoneyInstance* SaveTypeInfo::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::PlayerInfo::MoneyInstance;
  return info_;
}
inline ::PlayerInfo::MoneyInstance* SaveTypeInfo::release_info() {
  clear_has_info();
  ::PlayerInfo::MoneyInstance* temp = info_;
  info_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_info(::PlayerInfo::MoneyInstance* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional .PlayerInfo.OnceRewardInfo onceReward = 33;
inline bool SaveTypeInfo::has_oncereward() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void SaveTypeInfo::set_has_oncereward() {
  _has_bits_[1] |= 0x00000001u;
}
inline void SaveTypeInfo::clear_has_oncereward() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void SaveTypeInfo::clear_oncereward() {
  if (oncereward_ != NULL) oncereward_->::PlayerInfo::OnceRewardInfo::Clear();
  clear_has_oncereward();
}
inline const ::PlayerInfo::OnceRewardInfo& SaveTypeInfo::oncereward() const {
  return oncereward_ != NULL ? *oncereward_ : *default_instance_->oncereward_;
}
inline ::PlayerInfo::OnceRewardInfo* SaveTypeInfo::mutable_oncereward() {
  set_has_oncereward();
  if (oncereward_ == NULL) oncereward_ = new ::PlayerInfo::OnceRewardInfo;
  return oncereward_;
}
inline ::PlayerInfo::OnceRewardInfo* SaveTypeInfo::release_oncereward() {
  clear_has_oncereward();
  ::PlayerInfo::OnceRewardInfo* temp = oncereward_;
  oncereward_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_oncereward(::PlayerInfo::OnceRewardInfo* oncereward) {
  delete oncereward_;
  oncereward_ = oncereward;
  if (oncereward) {
    set_has_oncereward();
  } else {
    clear_has_oncereward();
  }
}

// optional .PlayerInfo.RingDBData ringData = 34;
inline bool SaveTypeInfo::has_ringdata() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void SaveTypeInfo::set_has_ringdata() {
  _has_bits_[1] |= 0x00000002u;
}
inline void SaveTypeInfo::clear_has_ringdata() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void SaveTypeInfo::clear_ringdata() {
  if (ringdata_ != NULL) ringdata_->::PlayerInfo::RingDBData::Clear();
  clear_has_ringdata();
}
inline const ::PlayerInfo::RingDBData& SaveTypeInfo::ringdata() const {
  return ringdata_ != NULL ? *ringdata_ : *default_instance_->ringdata_;
}
inline ::PlayerInfo::RingDBData* SaveTypeInfo::mutable_ringdata() {
  set_has_ringdata();
  if (ringdata_ == NULL) ringdata_ = new ::PlayerInfo::RingDBData;
  return ringdata_;
}
inline ::PlayerInfo::RingDBData* SaveTypeInfo::release_ringdata() {
  clear_has_ringdata();
  ::PlayerInfo::RingDBData* temp = ringdata_;
  ringdata_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_ringdata(::PlayerInfo::RingDBData* ringdata) {
  delete ringdata_;
  ringdata_ = ringdata;
  if (ringdata) {
    set_has_ringdata();
  } else {
    clear_has_ringdata();
  }
}

// optional .PlayerInfo.GroupInstance groupInfo = 35;
inline bool SaveTypeInfo::has_groupinfo() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void SaveTypeInfo::set_has_groupinfo() {
  _has_bits_[1] |= 0x00000004u;
}
inline void SaveTypeInfo::clear_has_groupinfo() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void SaveTypeInfo::clear_groupinfo() {
  if (groupinfo_ != NULL) groupinfo_->::PlayerInfo::GroupInstance::Clear();
  clear_has_groupinfo();
}
inline const ::PlayerInfo::GroupInstance& SaveTypeInfo::groupinfo() const {
  return groupinfo_ != NULL ? *groupinfo_ : *default_instance_->groupinfo_;
}
inline ::PlayerInfo::GroupInstance* SaveTypeInfo::mutable_groupinfo() {
  set_has_groupinfo();
  if (groupinfo_ == NULL) groupinfo_ = new ::PlayerInfo::GroupInstance;
  return groupinfo_;
}
inline ::PlayerInfo::GroupInstance* SaveTypeInfo::release_groupinfo() {
  clear_has_groupinfo();
  ::PlayerInfo::GroupInstance* temp = groupinfo_;
  groupinfo_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_groupinfo(::PlayerInfo::GroupInstance* groupinfo) {
  delete groupinfo_;
  groupinfo_ = groupinfo;
  if (groupinfo) {
    set_has_groupinfo();
  } else {
    clear_has_groupinfo();
  }
}

// optional .ChristmasDB.ChristmasAllData christmasData = 36;
inline bool SaveTypeInfo::has_christmasdata() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void SaveTypeInfo::set_has_christmasdata() {
  _has_bits_[1] |= 0x00000008u;
}
inline void SaveTypeInfo::clear_has_christmasdata() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void SaveTypeInfo::clear_christmasdata() {
  if (christmasdata_ != NULL) christmasdata_->::ChristmasDB::ChristmasAllData::Clear();
  clear_has_christmasdata();
}
inline const ::ChristmasDB::ChristmasAllData& SaveTypeInfo::christmasdata() const {
  return christmasdata_ != NULL ? *christmasdata_ : *default_instance_->christmasdata_;
}
inline ::ChristmasDB::ChristmasAllData* SaveTypeInfo::mutable_christmasdata() {
  set_has_christmasdata();
  if (christmasdata_ == NULL) christmasdata_ = new ::ChristmasDB::ChristmasAllData;
  return christmasdata_;
}
inline ::ChristmasDB::ChristmasAllData* SaveTypeInfo::release_christmasdata() {
  clear_has_christmasdata();
  ::ChristmasDB::ChristmasAllData* temp = christmasdata_;
  christmasdata_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_christmasdata(::ChristmasDB::ChristmasAllData* christmasdata) {
  delete christmasdata_;
  christmasdata_ = christmasdata;
  if (christmasdata) {
    set_has_christmasdata();
  } else {
    clear_has_christmasdata();
  }
}

// optional .PlayerInfo.EliteInstance eliteInfo = 37;
inline bool SaveTypeInfo::has_eliteinfo() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void SaveTypeInfo::set_has_eliteinfo() {
  _has_bits_[1] |= 0x00000010u;
}
inline void SaveTypeInfo::clear_has_eliteinfo() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void SaveTypeInfo::clear_eliteinfo() {
  if (eliteinfo_ != NULL) eliteinfo_->::PlayerInfo::EliteInstance::Clear();
  clear_has_eliteinfo();
}
inline const ::PlayerInfo::EliteInstance& SaveTypeInfo::eliteinfo() const {
  return eliteinfo_ != NULL ? *eliteinfo_ : *default_instance_->eliteinfo_;
}
inline ::PlayerInfo::EliteInstance* SaveTypeInfo::mutable_eliteinfo() {
  set_has_eliteinfo();
  if (eliteinfo_ == NULL) eliteinfo_ = new ::PlayerInfo::EliteInstance;
  return eliteinfo_;
}
inline ::PlayerInfo::EliteInstance* SaveTypeInfo::release_eliteinfo() {
  clear_has_eliteinfo();
  ::PlayerInfo::EliteInstance* temp = eliteinfo_;
  eliteinfo_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_eliteinfo(::PlayerInfo::EliteInstance* eliteinfo) {
  delete eliteinfo_;
  eliteinfo_ = eliteinfo;
  if (eliteinfo) {
    set_has_eliteinfo();
  } else {
    clear_has_eliteinfo();
  }
}

// optional .PlayerInfo.CauchemarInstance cauchemarInfo = 38;
inline bool SaveTypeInfo::has_cauchemarinfo() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void SaveTypeInfo::set_has_cauchemarinfo() {
  _has_bits_[1] |= 0x00000020u;
}
inline void SaveTypeInfo::clear_has_cauchemarinfo() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void SaveTypeInfo::clear_cauchemarinfo() {
  if (cauchemarinfo_ != NULL) cauchemarinfo_->::PlayerInfo::CauchemarInstance::Clear();
  clear_has_cauchemarinfo();
}
inline const ::PlayerInfo::CauchemarInstance& SaveTypeInfo::cauchemarinfo() const {
  return cauchemarinfo_ != NULL ? *cauchemarinfo_ : *default_instance_->cauchemarinfo_;
}
inline ::PlayerInfo::CauchemarInstance* SaveTypeInfo::mutable_cauchemarinfo() {
  set_has_cauchemarinfo();
  if (cauchemarinfo_ == NULL) cauchemarinfo_ = new ::PlayerInfo::CauchemarInstance;
  return cauchemarinfo_;
}
inline ::PlayerInfo::CauchemarInstance* SaveTypeInfo::release_cauchemarinfo() {
  clear_has_cauchemarinfo();
  ::PlayerInfo::CauchemarInstance* temp = cauchemarinfo_;
  cauchemarinfo_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_cauchemarinfo(::PlayerInfo::CauchemarInstance* cauchemarinfo) {
  delete cauchemarinfo_;
  cauchemarinfo_ = cauchemarinfo;
  if (cauchemarinfo) {
    set_has_cauchemarinfo();
  } else {
    clear_has_cauchemarinfo();
  }
}

// optional .PlayerInfo.ArenaDataInfo arenaData = 39;
inline bool SaveTypeInfo::has_arenadata() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void SaveTypeInfo::set_has_arenadata() {
  _has_bits_[1] |= 0x00000040u;
}
inline void SaveTypeInfo::clear_has_arenadata() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void SaveTypeInfo::clear_arenadata() {
  if (arenadata_ != NULL) arenadata_->::PlayerInfo::ArenaDataInfo::Clear();
  clear_has_arenadata();
}
inline const ::PlayerInfo::ArenaDataInfo& SaveTypeInfo::arenadata() const {
  return arenadata_ != NULL ? *arenadata_ : *default_instance_->arenadata_;
}
inline ::PlayerInfo::ArenaDataInfo* SaveTypeInfo::mutable_arenadata() {
  set_has_arenadata();
  if (arenadata_ == NULL) arenadata_ = new ::PlayerInfo::ArenaDataInfo;
  return arenadata_;
}
inline ::PlayerInfo::ArenaDataInfo* SaveTypeInfo::release_arenadata() {
  clear_has_arenadata();
  ::PlayerInfo::ArenaDataInfo* temp = arenadata_;
  arenadata_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_arenadata(::PlayerInfo::ArenaDataInfo* arenadata) {
  delete arenadata_;
  arenadata_ = arenadata;
  if (arenadata) {
    set_has_arenadata();
  } else {
    clear_has_arenadata();
  }
}

// optional .PlayerInfo.ChallengeInstance challengedata = 40;
inline bool SaveTypeInfo::has_challengedata() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void SaveTypeInfo::set_has_challengedata() {
  _has_bits_[1] |= 0x00000080u;
}
inline void SaveTypeInfo::clear_has_challengedata() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void SaveTypeInfo::clear_challengedata() {
  if (challengedata_ != NULL) challengedata_->::PlayerInfo::ChallengeInstance::Clear();
  clear_has_challengedata();
}
inline const ::PlayerInfo::ChallengeInstance& SaveTypeInfo::challengedata() const {
  return challengedata_ != NULL ? *challengedata_ : *default_instance_->challengedata_;
}
inline ::PlayerInfo::ChallengeInstance* SaveTypeInfo::mutable_challengedata() {
  set_has_challengedata();
  if (challengedata_ == NULL) challengedata_ = new ::PlayerInfo::ChallengeInstance;
  return challengedata_;
}
inline ::PlayerInfo::ChallengeInstance* SaveTypeInfo::release_challengedata() {
  clear_has_challengedata();
  ::PlayerInfo::ChallengeInstance* temp = challengedata_;
  challengedata_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_challengedata(::PlayerInfo::ChallengeInstance* challengedata) {
  delete challengedata_;
  challengedata_ = challengedata;
  if (challengedata) {
    set_has_challengedata();
  } else {
    clear_has_challengedata();
  }
}

// optional .PlayerInfo.HeroInstanceData herodata = 41;
inline bool SaveTypeInfo::has_herodata() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void SaveTypeInfo::set_has_herodata() {
  _has_bits_[1] |= 0x00000100u;
}
inline void SaveTypeInfo::clear_has_herodata() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void SaveTypeInfo::clear_herodata() {
  if (herodata_ != NULL) herodata_->::PlayerInfo::HeroInstanceData::Clear();
  clear_has_herodata();
}
inline const ::PlayerInfo::HeroInstanceData& SaveTypeInfo::herodata() const {
  return herodata_ != NULL ? *herodata_ : *default_instance_->herodata_;
}
inline ::PlayerInfo::HeroInstanceData* SaveTypeInfo::mutable_herodata() {
  set_has_herodata();
  if (herodata_ == NULL) herodata_ = new ::PlayerInfo::HeroInstanceData;
  return herodata_;
}
inline ::PlayerInfo::HeroInstanceData* SaveTypeInfo::release_herodata() {
  clear_has_herodata();
  ::PlayerInfo::HeroInstanceData* temp = herodata_;
  herodata_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_herodata(::PlayerInfo::HeroInstanceData* herodata) {
  delete herodata_;
  herodata_ = herodata;
  if (herodata) {
    set_has_herodata();
  } else {
    clear_has_herodata();
  }
}

// optional .PlayerInfo.MagicWeapon smagic = 42;
inline bool SaveTypeInfo::has_smagic() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void SaveTypeInfo::set_has_smagic() {
  _has_bits_[1] |= 0x00000200u;
}
inline void SaveTypeInfo::clear_has_smagic() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void SaveTypeInfo::clear_smagic() {
  if (smagic_ != NULL) smagic_->::PlayerInfo::MagicWeapon::Clear();
  clear_has_smagic();
}
inline const ::PlayerInfo::MagicWeapon& SaveTypeInfo::smagic() const {
  return smagic_ != NULL ? *smagic_ : *default_instance_->smagic_;
}
inline ::PlayerInfo::MagicWeapon* SaveTypeInfo::mutable_smagic() {
  set_has_smagic();
  if (smagic_ == NULL) smagic_ = new ::PlayerInfo::MagicWeapon;
  return smagic_;
}
inline ::PlayerInfo::MagicWeapon* SaveTypeInfo::release_smagic() {
  clear_has_smagic();
  ::PlayerInfo::MagicWeapon* temp = smagic_;
  smagic_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_smagic(::PlayerInfo::MagicWeapon* smagic) {
  delete smagic_;
  smagic_ = smagic;
  if (smagic) {
    set_has_smagic();
  } else {
    clear_has_smagic();
  }
}

// optional .PlayerInfo.MagicWeapon heartmagic = 43;
inline bool SaveTypeInfo::has_heartmagic() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void SaveTypeInfo::set_has_heartmagic() {
  _has_bits_[1] |= 0x00000400u;
}
inline void SaveTypeInfo::clear_has_heartmagic() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void SaveTypeInfo::clear_heartmagic() {
  if (heartmagic_ != NULL) heartmagic_->::PlayerInfo::MagicWeapon::Clear();
  clear_has_heartmagic();
}
inline const ::PlayerInfo::MagicWeapon& SaveTypeInfo::heartmagic() const {
  return heartmagic_ != NULL ? *heartmagic_ : *default_instance_->heartmagic_;
}
inline ::PlayerInfo::MagicWeapon* SaveTypeInfo::mutable_heartmagic() {
  set_has_heartmagic();
  if (heartmagic_ == NULL) heartmagic_ = new ::PlayerInfo::MagicWeapon;
  return heartmagic_;
}
inline ::PlayerInfo::MagicWeapon* SaveTypeInfo::release_heartmagic() {
  clear_has_heartmagic();
  ::PlayerInfo::MagicWeapon* temp = heartmagic_;
  heartmagic_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_heartmagic(::PlayerInfo::MagicWeapon* heartmagic) {
  delete heartmagic_;
  heartmagic_ = heartmagic;
  if (heartmagic) {
    set_has_heartmagic();
  } else {
    clear_has_heartmagic();
  }
}

// optional .PlayerInfo.AdvancedInstance advanced = 44;
inline bool SaveTypeInfo::has_advanced() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void SaveTypeInfo::set_has_advanced() {
  _has_bits_[1] |= 0x00000800u;
}
inline void SaveTypeInfo::clear_has_advanced() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void SaveTypeInfo::clear_advanced() {
  if (advanced_ != NULL) advanced_->::PlayerInfo::AdvancedInstance::Clear();
  clear_has_advanced();
}
inline const ::PlayerInfo::AdvancedInstance& SaveTypeInfo::advanced() const {
  return advanced_ != NULL ? *advanced_ : *default_instance_->advanced_;
}
inline ::PlayerInfo::AdvancedInstance* SaveTypeInfo::mutable_advanced() {
  set_has_advanced();
  if (advanced_ == NULL) advanced_ = new ::PlayerInfo::AdvancedInstance;
  return advanced_;
}
inline ::PlayerInfo::AdvancedInstance* SaveTypeInfo::release_advanced() {
  clear_has_advanced();
  ::PlayerInfo::AdvancedInstance* temp = advanced_;
  advanced_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_advanced(::PlayerInfo::AdvancedInstance* advanced) {
  delete advanced_;
  advanced_ = advanced;
  if (advanced) {
    set_has_advanced();
  } else {
    clear_has_advanced();
  }
}

// optional .PlayerInfo.BaseShopInfo baseShopInfo = 45;
inline bool SaveTypeInfo::has_baseshopinfo() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void SaveTypeInfo::set_has_baseshopinfo() {
  _has_bits_[1] |= 0x00001000u;
}
inline void SaveTypeInfo::clear_has_baseshopinfo() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void SaveTypeInfo::clear_baseshopinfo() {
  if (baseshopinfo_ != NULL) baseshopinfo_->::PlayerInfo::BaseShopInfo::Clear();
  clear_has_baseshopinfo();
}
inline const ::PlayerInfo::BaseShopInfo& SaveTypeInfo::baseshopinfo() const {
  return baseshopinfo_ != NULL ? *baseshopinfo_ : *default_instance_->baseshopinfo_;
}
inline ::PlayerInfo::BaseShopInfo* SaveTypeInfo::mutable_baseshopinfo() {
  set_has_baseshopinfo();
  if (baseshopinfo_ == NULL) baseshopinfo_ = new ::PlayerInfo::BaseShopInfo;
  return baseshopinfo_;
}
inline ::PlayerInfo::BaseShopInfo* SaveTypeInfo::release_baseshopinfo() {
  clear_has_baseshopinfo();
  ::PlayerInfo::BaseShopInfo* temp = baseshopinfo_;
  baseshopinfo_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_baseshopinfo(::PlayerInfo::BaseShopInfo* baseshopinfo) {
  delete baseshopinfo_;
  baseshopinfo_ = baseshopinfo;
  if (baseshopinfo) {
    set_has_baseshopinfo();
  } else {
    clear_has_baseshopinfo();
  }
}

// optional .PlayerInfo.AnswerInfo answerInfo = 46;
inline bool SaveTypeInfo::has_answerinfo() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void SaveTypeInfo::set_has_answerinfo() {
  _has_bits_[1] |= 0x00002000u;
}
inline void SaveTypeInfo::clear_has_answerinfo() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void SaveTypeInfo::clear_answerinfo() {
  if (answerinfo_ != NULL) answerinfo_->::PlayerInfo::AnswerInfo::Clear();
  clear_has_answerinfo();
}
inline const ::PlayerInfo::AnswerInfo& SaveTypeInfo::answerinfo() const {
  return answerinfo_ != NULL ? *answerinfo_ : *default_instance_->answerinfo_;
}
inline ::PlayerInfo::AnswerInfo* SaveTypeInfo::mutable_answerinfo() {
  set_has_answerinfo();
  if (answerinfo_ == NULL) answerinfo_ = new ::PlayerInfo::AnswerInfo;
  return answerinfo_;
}
inline ::PlayerInfo::AnswerInfo* SaveTypeInfo::release_answerinfo() {
  clear_has_answerinfo();
  ::PlayerInfo::AnswerInfo* temp = answerinfo_;
  answerinfo_ = NULL;
  return temp;
}
inline void SaveTypeInfo::set_allocated_answerinfo(::PlayerInfo::AnswerInfo* answerinfo) {
  delete answerinfo_;
  answerinfo_ = answerinfo;
  if (answerinfo) {
    set_has_answerinfo();
  } else {
    clear_has_answerinfo();
  }
}

// -------------------------------------------------------------------

// WSaveTypeInfo

// required uint64 type = 1;
inline bool WSaveTypeInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WSaveTypeInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WSaveTypeInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WSaveTypeInfo::clear_type() {
  type_ = GOOGLE_ULONGLONG(0);
  clear_has_type();
}
inline ::google::protobuf::uint64 WSaveTypeInfo::type() const {
  return type_;
}
inline void WSaveTypeInfo::set_type(::google::protobuf::uint64 value) {
  set_has_type();
  type_ = value;
}

// required int64 id = 2;
inline bool WSaveTypeInfo::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WSaveTypeInfo::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WSaveTypeInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WSaveTypeInfo::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 WSaveTypeInfo::id() const {
  return id_;
}
inline void WSaveTypeInfo::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// required bool isdel = 3;
inline bool WSaveTypeInfo::has_isdel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WSaveTypeInfo::set_has_isdel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WSaveTypeInfo::clear_has_isdel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WSaveTypeInfo::clear_isdel() {
  isdel_ = false;
  clear_has_isdel();
}
inline bool WSaveTypeInfo::isdel() const {
  return isdel_;
}
inline void WSaveTypeInfo::set_isdel(bool value) {
  set_has_isdel();
  isdel_ = value;
}

// optional .PlayerInfo.FriendInfoList friendInfo = 4;
inline bool WSaveTypeInfo::has_friendinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WSaveTypeInfo::set_has_friendinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WSaveTypeInfo::clear_has_friendinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WSaveTypeInfo::clear_friendinfo() {
  if (friendinfo_ != NULL) friendinfo_->::PlayerInfo::FriendInfoList::Clear();
  clear_has_friendinfo();
}
inline const ::PlayerInfo::FriendInfoList& WSaveTypeInfo::friendinfo() const {
  return friendinfo_ != NULL ? *friendinfo_ : *default_instance_->friendinfo_;
}
inline ::PlayerInfo::FriendInfoList* WSaveTypeInfo::mutable_friendinfo() {
  set_has_friendinfo();
  if (friendinfo_ == NULL) friendinfo_ = new ::PlayerInfo::FriendInfoList;
  return friendinfo_;
}
inline ::PlayerInfo::FriendInfoList* WSaveTypeInfo::release_friendinfo() {
  clear_has_friendinfo();
  ::PlayerInfo::FriendInfoList* temp = friendinfo_;
  friendinfo_ = NULL;
  return temp;
}
inline void WSaveTypeInfo::set_allocated_friendinfo(::PlayerInfo::FriendInfoList* friendinfo) {
  delete friendinfo_;
  friendinfo_ = friendinfo;
  if (friendinfo) {
    set_has_friendinfo();
  } else {
    clear_has_friendinfo();
  }
}

// -------------------------------------------------------------------

// BaseInfo

// required int64 charid = 1;
inline bool BaseInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseInfo::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 BaseInfo::charid() const {
  return charid_;
}
inline void BaseInfo::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// required string charname = 2;
inline bool BaseInfo::has_charname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BaseInfo::set_has_charname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BaseInfo::clear_has_charname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BaseInfo::clear_charname() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    charname_->clear();
  }
  clear_has_charname();
}
inline const ::std::string& BaseInfo::charname() const {
  return *charname_;
}
inline void BaseInfo::set_charname(const ::std::string& value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void BaseInfo::set_charname(const char* value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void BaseInfo::set_charname(const char* value, size_t size) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BaseInfo::mutable_charname() {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  return charname_;
}
inline ::std::string* BaseInfo::release_charname() {
  clear_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charname_;
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BaseInfo::set_allocated_charname(::std::string* charname) {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (charname) {
    set_has_charname();
    charname_ = charname;
  } else {
    clear_has_charname();
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 exp = 3;
inline bool BaseInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BaseInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BaseInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BaseInfo::clear_exp() {
  exp_ = GOOGLE_LONGLONG(0);
  clear_has_exp();
}
inline ::google::protobuf::int64 BaseInfo::exp() const {
  return exp_;
}
inline void BaseInfo::set_exp(::google::protobuf::int64 value) {
  set_has_exp();
  exp_ = value;
}

// required int32 level = 4;
inline bool BaseInfo::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BaseInfo::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BaseInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BaseInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 BaseInfo::level() const {
  return level_;
}
inline void BaseInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required int32 money = 5;
inline bool BaseInfo::has_money() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BaseInfo::set_has_money() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BaseInfo::clear_has_money() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BaseInfo::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 BaseInfo::money() const {
  return money_;
}
inline void BaseInfo::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// required int32 golden = 6;
inline bool BaseInfo::has_golden() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BaseInfo::set_has_golden() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BaseInfo::clear_has_golden() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BaseInfo::clear_golden() {
  golden_ = 0;
  clear_has_golden();
}
inline ::google::protobuf::int32 BaseInfo::golden() const {
  return golden_;
}
inline void BaseInfo::set_golden(::google::protobuf::int32 value) {
  set_has_golden();
  golden_ = value;
}

// required int32 bindgolden = 7;
inline bool BaseInfo::has_bindgolden() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BaseInfo::set_has_bindgolden() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BaseInfo::clear_has_bindgolden() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BaseInfo::clear_bindgolden() {
  bindgolden_ = 0;
  clear_has_bindgolden();
}
inline ::google::protobuf::int32 BaseInfo::bindgolden() const {
  return bindgolden_;
}
inline void BaseInfo::set_bindgolden(::google::protobuf::int32 value) {
  set_has_bindgolden();
  bindgolden_ = value;
}

// required int64 deadtime = 8;
inline bool BaseInfo::has_deadtime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BaseInfo::set_has_deadtime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BaseInfo::clear_has_deadtime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BaseInfo::clear_deadtime() {
  deadtime_ = GOOGLE_LONGLONG(0);
  clear_has_deadtime();
}
inline ::google::protobuf::int64 BaseInfo::deadtime() const {
  return deadtime_;
}
inline void BaseInfo::set_deadtime(::google::protobuf::int64 value) {
  set_has_deadtime();
  deadtime_ = value;
}

// required bool sex = 9;
inline bool BaseInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BaseInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BaseInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BaseInfo::clear_sex() {
  sex_ = false;
  clear_has_sex();
}
inline bool BaseInfo::sex() const {
  return sex_;
}
inline void BaseInfo::set_sex(bool value) {
  set_has_sex();
  sex_ = value;
}

// required int32 profession = 10;
inline bool BaseInfo::has_profession() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BaseInfo::set_has_profession() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BaseInfo::clear_has_profession() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BaseInfo::clear_profession() {
  profession_ = 0;
  clear_has_profession();
}
inline ::google::protobuf::int32 BaseInfo::profession() const {
  return profession_;
}
inline void BaseInfo::set_profession(::google::protobuf::int32 value) {
  set_has_profession();
  profession_ = value;
}

// required int32 xpos = 11;
inline bool BaseInfo::has_xpos() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BaseInfo::set_has_xpos() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BaseInfo::clear_has_xpos() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BaseInfo::clear_xpos() {
  xpos_ = 0;
  clear_has_xpos();
}
inline ::google::protobuf::int32 BaseInfo::xpos() const {
  return xpos_;
}
inline void BaseInfo::set_xpos(::google::protobuf::int32 value) {
  set_has_xpos();
  xpos_ = value;
}

// required int32 ypos = 12;
inline bool BaseInfo::has_ypos() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BaseInfo::set_has_ypos() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BaseInfo::clear_has_ypos() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BaseInfo::clear_ypos() {
  ypos_ = 0;
  clear_has_ypos();
}
inline ::google::protobuf::int32 BaseInfo::ypos() const {
  return ypos_;
}
inline void BaseInfo::set_ypos(::google::protobuf::int32 value) {
  set_has_ypos();
  ypos_ = value;
}

// required int32 horse = 13;
inline bool BaseInfo::has_horse() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BaseInfo::set_has_horse() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BaseInfo::clear_has_horse() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BaseInfo::clear_horse() {
  horse_ = 0;
  clear_has_horse();
}
inline ::google::protobuf::int32 BaseInfo::horse() const {
  return horse_;
}
inline void BaseInfo::set_horse(::google::protobuf::int32 value) {
  set_has_horse();
  horse_ = value;
}

// required int64 mapid = 14;
inline bool BaseInfo::has_mapid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BaseInfo::set_has_mapid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BaseInfo::clear_has_mapid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BaseInfo::clear_mapid() {
  mapid_ = GOOGLE_LONGLONG(0);
  clear_has_mapid();
}
inline ::google::protobuf::int64 BaseInfo::mapid() const {
  return mapid_;
}
inline void BaseInfo::set_mapid(::google::protobuf::int64 value) {
  set_has_mapid();
  mapid_ = value;
}

// required int32 country = 15;
inline bool BaseInfo::has_country() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BaseInfo::set_has_country() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BaseInfo::clear_has_country() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BaseInfo::clear_country() {
  country_ = 0;
  clear_has_country();
}
inline ::google::protobuf::int32 BaseInfo::country() const {
  return country_;
}
inline void BaseInfo::set_country(::google::protobuf::int32 value) {
  set_has_country();
  country_ = value;
}

// required int32 charhead = 16;
inline bool BaseInfo::has_charhead() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BaseInfo::set_has_charhead() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BaseInfo::clear_has_charhead() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BaseInfo::clear_charhead() {
  charhead_ = 0;
  clear_has_charhead();
}
inline ::google::protobuf::int32 BaseInfo::charhead() const {
  return charhead_;
}
inline void BaseInfo::set_charhead(::google::protobuf::int32 value) {
  set_has_charhead();
  charhead_ = value;
}

// optional int32 facontribution = 17;
inline bool BaseInfo::has_facontribution() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BaseInfo::set_has_facontribution() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BaseInfo::clear_has_facontribution() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BaseInfo::clear_facontribution() {
  facontribution_ = 0;
  clear_has_facontribution();
}
inline ::google::protobuf::int32 BaseInfo::facontribution() const {
  return facontribution_;
}
inline void BaseInfo::set_facontribution(::google::protobuf::int32 value) {
  set_has_facontribution();
  facontribution_ = value;
}

// optional int32 faction = 18;
inline bool BaseInfo::has_faction() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BaseInfo::set_has_faction() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BaseInfo::clear_has_faction() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BaseInfo::clear_faction() {
  faction_ = 0;
  clear_has_faction();
}
inline ::google::protobuf::int32 BaseInfo::faction() const {
  return faction_;
}
inline void BaseInfo::set_faction(::google::protobuf::int32 value) {
  set_has_faction();
  faction_ = value;
}

// optional int32 fajob = 19;
inline bool BaseInfo::has_fajob() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BaseInfo::set_has_fajob() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BaseInfo::clear_has_fajob() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BaseInfo::clear_fajob() {
  fajob_ = 0;
  clear_has_fajob();
}
inline ::google::protobuf::int32 BaseInfo::fajob() const {
  return fajob_;
}
inline void BaseInfo::set_fajob(::google::protobuf::int32 value) {
  set_has_fajob();
  fajob_ = value;
}

// required int64 mate = 20;
inline bool BaseInfo::has_mate() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BaseInfo::set_has_mate() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BaseInfo::clear_has_mate() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BaseInfo::clear_mate() {
  mate_ = GOOGLE_LONGLONG(0);
  clear_has_mate();
}
inline ::google::protobuf::int64 BaseInfo::mate() const {
  return mate_;
}
inline void BaseInfo::set_mate(::google::protobuf::int64 value) {
  set_has_mate();
  mate_ = value;
}

// required int32 countryjob = 21;
inline bool BaseInfo::has_countryjob() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BaseInfo::set_has_countryjob() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BaseInfo::clear_has_countryjob() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BaseInfo::clear_countryjob() {
  countryjob_ = 0;
  clear_has_countryjob();
}
inline ::google::protobuf::int32 BaseInfo::countryjob() const {
  return countryjob_;
}
inline void BaseInfo::set_countryjob(::google::protobuf::int32 value) {
  set_has_countryjob();
  countryjob_ = value;
}

// required int32 battlecontri = 22;
inline bool BaseInfo::has_battlecontri() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void BaseInfo::set_has_battlecontri() {
  _has_bits_[0] |= 0x00200000u;
}
inline void BaseInfo::clear_has_battlecontri() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void BaseInfo::clear_battlecontri() {
  battlecontri_ = 0;
  clear_has_battlecontri();
}
inline ::google::protobuf::int32 BaseInfo::battlecontri() const {
  return battlecontri_;
}
inline void BaseInfo::set_battlecontri(::google::protobuf::int32 value) {
  set_has_battlecontri();
  battlecontri_ = value;
}

// required int32 armyjob = 23;
inline bool BaseInfo::has_armyjob() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void BaseInfo::set_has_armyjob() {
  _has_bits_[0] |= 0x00400000u;
}
inline void BaseInfo::clear_has_armyjob() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void BaseInfo::clear_armyjob() {
  armyjob_ = 0;
  clear_has_armyjob();
}
inline ::google::protobuf::int32 BaseInfo::armyjob() const {
  return armyjob_;
}
inline void BaseInfo::set_armyjob(::google::protobuf::int32 value) {
  set_has_armyjob();
  armyjob_ = value;
}

// optional int32 countrycontri = 24;
inline bool BaseInfo::has_countrycontri() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void BaseInfo::set_has_countrycontri() {
  _has_bits_[0] |= 0x00800000u;
}
inline void BaseInfo::clear_has_countrycontri() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void BaseInfo::clear_countrycontri() {
  countrycontri_ = 0;
  clear_has_countrycontri();
}
inline ::google::protobuf::int32 BaseInfo::countrycontri() const {
  return countrycontri_;
}
inline void BaseInfo::set_countrycontri(::google::protobuf::int32 value) {
  set_has_countrycontri();
  countrycontri_ = value;
}

// optional int32 titleid = 25;
inline bool BaseInfo::has_titleid() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void BaseInfo::set_has_titleid() {
  _has_bits_[0] |= 0x01000000u;
}
inline void BaseInfo::clear_has_titleid() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void BaseInfo::clear_titleid() {
  titleid_ = 0;
  clear_has_titleid();
}
inline ::google::protobuf::int32 BaseInfo::titleid() const {
  return titleid_;
}
inline void BaseInfo::set_titleid(::google::protobuf::int32 value) {
  set_has_titleid();
  titleid_ = value;
}

// required int32 accounttype = 26;
inline bool BaseInfo::has_accounttype() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void BaseInfo::set_has_accounttype() {
  _has_bits_[0] |= 0x02000000u;
}
inline void BaseInfo::clear_has_accounttype() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void BaseInfo::clear_accounttype() {
  accounttype_ = 0;
  clear_has_accounttype();
}
inline ::google::protobuf::int32 BaseInfo::accounttype() const {
  return accounttype_;
}
inline void BaseInfo::set_accounttype(::google::protobuf::int32 value) {
  set_has_accounttype();
  accounttype_ = value;
}

// required string openid = 27;
inline bool BaseInfo::has_openid() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void BaseInfo::set_has_openid() {
  _has_bits_[0] |= 0x04000000u;
}
inline void BaseInfo::clear_has_openid() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void BaseInfo::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& BaseInfo::openid() const {
  return *openid_;
}
inline void BaseInfo::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void BaseInfo::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void BaseInfo::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BaseInfo::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* BaseInfo::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BaseInfo::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 serverid = 28;
inline bool BaseInfo::has_serverid() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void BaseInfo::set_has_serverid() {
  _has_bits_[0] |= 0x08000000u;
}
inline void BaseInfo::clear_has_serverid() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void BaseInfo::clear_serverid() {
  serverid_ = 0;
  clear_has_serverid();
}
inline ::google::protobuf::int32 BaseInfo::serverid() const {
  return serverid_;
}
inline void BaseInfo::set_serverid(::google::protobuf::int32 value) {
  set_has_serverid();
  serverid_ = value;
}

// required int32 sinvalue = 29;
inline bool BaseInfo::has_sinvalue() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void BaseInfo::set_has_sinvalue() {
  _has_bits_[0] |= 0x10000000u;
}
inline void BaseInfo::clear_has_sinvalue() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void BaseInfo::clear_sinvalue() {
  sinvalue_ = 0;
  clear_has_sinvalue();
}
inline ::google::protobuf::int32 BaseInfo::sinvalue() const {
  return sinvalue_;
}
inline void BaseInfo::set_sinvalue(::google::protobuf::int32 value) {
  set_has_sinvalue();
  sinvalue_ = value;
}

// required int32 acupoint = 30;
inline bool BaseInfo::has_acupoint() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void BaseInfo::set_has_acupoint() {
  _has_bits_[0] |= 0x20000000u;
}
inline void BaseInfo::clear_has_acupoint() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void BaseInfo::clear_acupoint() {
  acupoint_ = 0;
  clear_has_acupoint();
}
inline ::google::protobuf::int32 BaseInfo::acupoint() const {
  return acupoint_;
}
inline void BaseInfo::set_acupoint(::google::protobuf::int32 value) {
  set_has_acupoint();
  acupoint_ = value;
}

// required int32 settings = 31;
inline bool BaseInfo::has_settings() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void BaseInfo::set_has_settings() {
  _has_bits_[0] |= 0x40000000u;
}
inline void BaseInfo::clear_has_settings() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void BaseInfo::clear_settings() {
  settings_ = 0;
  clear_has_settings();
}
inline ::google::protobuf::int32 BaseInfo::settings() const {
  return settings_;
}
inline void BaseInfo::set_settings(::google::protobuf::int32 value) {
  set_has_settings();
  settings_ = value;
}

// required int64 havetodo = 32;
inline bool BaseInfo::has_havetodo() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void BaseInfo::set_has_havetodo() {
  _has_bits_[0] |= 0x80000000u;
}
inline void BaseInfo::clear_has_havetodo() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void BaseInfo::clear_havetodo() {
  havetodo_ = GOOGLE_LONGLONG(0);
  clear_has_havetodo();
}
inline ::google::protobuf::int64 BaseInfo::havetodo() const {
  return havetodo_;
}
inline void BaseInfo::set_havetodo(::google::protobuf::int64 value) {
  set_has_havetodo();
  havetodo_ = value;
}

// required int32 havetodoaward = 33;
inline bool BaseInfo::has_havetodoaward() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void BaseInfo::set_has_havetodoaward() {
  _has_bits_[1] |= 0x00000001u;
}
inline void BaseInfo::clear_has_havetodoaward() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void BaseInfo::clear_havetodoaward() {
  havetodoaward_ = 0;
  clear_has_havetodoaward();
}
inline ::google::protobuf::int32 BaseInfo::havetodoaward() const {
  return havetodoaward_;
}
inline void BaseInfo::set_havetodoaward(::google::protobuf::int32 value) {
  set_has_havetodoaward();
  havetodoaward_ = value;
}

// required int32 activites = 34;
inline bool BaseInfo::has_activites() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void BaseInfo::set_has_activites() {
  _has_bits_[1] |= 0x00000002u;
}
inline void BaseInfo::clear_has_activites() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void BaseInfo::clear_activites() {
  activites_ = 0;
  clear_has_activites();
}
inline ::google::protobuf::int32 BaseInfo::activites() const {
  return activites_;
}
inline void BaseInfo::set_activites(::google::protobuf::int32 value) {
  set_has_activites();
  activites_ = value;
}

// required int32 activitesaward = 35;
inline bool BaseInfo::has_activitesaward() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void BaseInfo::set_has_activitesaward() {
  _has_bits_[1] |= 0x00000004u;
}
inline void BaseInfo::clear_has_activitesaward() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void BaseInfo::clear_activitesaward() {
  activitesaward_ = 0;
  clear_has_activitesaward();
}
inline ::google::protobuf::int32 BaseInfo::activitesaward() const {
  return activitesaward_;
}
inline void BaseInfo::set_activitesaward(::google::protobuf::int32 value) {
  set_has_activitesaward();
  activitesaward_ = value;
}

// required int64 offlineTime = 36;
inline bool BaseInfo::has_offlinetime() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void BaseInfo::set_has_offlinetime() {
  _has_bits_[1] |= 0x00000008u;
}
inline void BaseInfo::clear_has_offlinetime() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void BaseInfo::clear_offlinetime() {
  offlinetime_ = GOOGLE_LONGLONG(0);
  clear_has_offlinetime();
}
inline ::google::protobuf::int64 BaseInfo::offlinetime() const {
  return offlinetime_;
}
inline void BaseInfo::set_offlinetime(::google::protobuf::int64 value) {
  set_has_offlinetime();
  offlinetime_ = value;
}

// required int32 onlineReward = 37;
inline bool BaseInfo::has_onlinereward() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void BaseInfo::set_has_onlinereward() {
  _has_bits_[1] |= 0x00000010u;
}
inline void BaseInfo::clear_has_onlinereward() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void BaseInfo::clear_onlinereward() {
  onlinereward_ = 0;
  clear_has_onlinereward();
}
inline ::google::protobuf::int32 BaseInfo::onlinereward() const {
  return onlinereward_;
}
inline void BaseInfo::set_onlinereward(::google::protobuf::int32 value) {
  set_has_onlinereward();
  onlinereward_ = value;
}

// required int64 onlineTime = 38;
inline bool BaseInfo::has_onlinetime() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void BaseInfo::set_has_onlinetime() {
  _has_bits_[1] |= 0x00000020u;
}
inline void BaseInfo::clear_has_onlinetime() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void BaseInfo::clear_onlinetime() {
  onlinetime_ = GOOGLE_LONGLONG(0);
  clear_has_onlinetime();
}
inline ::google::protobuf::int64 BaseInfo::onlinetime() const {
  return onlinetime_;
}
inline void BaseInfo::set_onlinetime(::google::protobuf::int64 value) {
  set_has_onlinetime();
  onlinetime_ = value;
}

// required int32 levelReward = 39;
inline bool BaseInfo::has_levelreward() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void BaseInfo::set_has_levelreward() {
  _has_bits_[1] |= 0x00000040u;
}
inline void BaseInfo::clear_has_levelreward() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void BaseInfo::clear_levelreward() {
  levelreward_ = 0;
  clear_has_levelreward();
}
inline ::google::protobuf::int32 BaseInfo::levelreward() const {
  return levelreward_;
}
inline void BaseInfo::set_levelreward(::google::protobuf::int32 value) {
  set_has_levelreward();
  levelreward_ = value;
}

// required int32 prestige = 40;
inline bool BaseInfo::has_prestige() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void BaseInfo::set_has_prestige() {
  _has_bits_[1] |= 0x00000080u;
}
inline void BaseInfo::clear_has_prestige() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void BaseInfo::clear_prestige() {
  prestige_ = 0;
  clear_has_prestige();
}
inline ::google::protobuf::int32 BaseInfo::prestige() const {
  return prestige_;
}
inline void BaseInfo::set_prestige(::google::protobuf::int32 value) {
  set_has_prestige();
  prestige_ = value;
}

// required int32 historyReward = 41;
inline bool BaseInfo::has_historyreward() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void BaseInfo::set_has_historyreward() {
  _has_bits_[1] |= 0x00000100u;
}
inline void BaseInfo::clear_has_historyreward() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void BaseInfo::clear_historyreward() {
  historyreward_ = 0;
  clear_has_historyreward();
}
inline ::google::protobuf::int32 BaseInfo::historyreward() const {
  return historyreward_;
}
inline void BaseInfo::set_historyreward(::google::protobuf::int32 value) {
  set_has_historyreward();
  historyreward_ = value;
}

// required int32 viplv = 42;
inline bool BaseInfo::has_viplv() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void BaseInfo::set_has_viplv() {
  _has_bits_[1] |= 0x00000200u;
}
inline void BaseInfo::clear_has_viplv() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void BaseInfo::clear_viplv() {
  viplv_ = 0;
  clear_has_viplv();
}
inline ::google::protobuf::int32 BaseInfo::viplv() const {
  return viplv_;
}
inline void BaseInfo::set_viplv(::google::protobuf::int32 value) {
  set_has_viplv();
  viplv_ = value;
}

// required int32 continueanswer = 43;
inline bool BaseInfo::has_continueanswer() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void BaseInfo::set_has_continueanswer() {
  _has_bits_[1] |= 0x00000400u;
}
inline void BaseInfo::clear_has_continueanswer() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void BaseInfo::clear_continueanswer() {
  continueanswer_ = 0;
  clear_has_continueanswer();
}
inline ::google::protobuf::int32 BaseInfo::continueanswer() const {
  return continueanswer_;
}
inline void BaseInfo::set_continueanswer(::google::protobuf::int32 value) {
  set_has_continueanswer();
  continueanswer_ = value;
}

// required int32 rightanswer = 44;
inline bool BaseInfo::has_rightanswer() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void BaseInfo::set_has_rightanswer() {
  _has_bits_[1] |= 0x00000800u;
}
inline void BaseInfo::clear_has_rightanswer() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void BaseInfo::clear_rightanswer() {
  rightanswer_ = 0;
  clear_has_rightanswer();
}
inline ::google::protobuf::int32 BaseInfo::rightanswer() const {
  return rightanswer_;
}
inline void BaseInfo::set_rightanswer(::google::protobuf::int32 value) {
  set_has_rightanswer();
  rightanswer_ = value;
}

// required int32 addupgolde = 45;
inline bool BaseInfo::has_addupgolde() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void BaseInfo::set_has_addupgolde() {
  _has_bits_[1] |= 0x00001000u;
}
inline void BaseInfo::clear_has_addupgolde() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void BaseInfo::clear_addupgolde() {
  addupgolde_ = 0;
  clear_has_addupgolde();
}
inline ::google::protobuf::int32 BaseInfo::addupgolde() const {
  return addupgolde_;
}
inline void BaseInfo::set_addupgolde(::google::protobuf::int32 value) {
  set_has_addupgolde();
  addupgolde_ = value;
}

// optional string clanname = 46;
inline bool BaseInfo::has_clanname() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void BaseInfo::set_has_clanname() {
  _has_bits_[1] |= 0x00002000u;
}
inline void BaseInfo::clear_has_clanname() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void BaseInfo::clear_clanname() {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    clanname_->clear();
  }
  clear_has_clanname();
}
inline const ::std::string& BaseInfo::clanname() const {
  return *clanname_;
}
inline void BaseInfo::set_clanname(const ::std::string& value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void BaseInfo::set_clanname(const char* value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void BaseInfo::set_clanname(const char* value, size_t size) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BaseInfo::mutable_clanname() {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  return clanname_;
}
inline ::std::string* BaseInfo::release_clanname() {
  clear_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clanname_;
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BaseInfo::set_allocated_clanname(::std::string* clanname) {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    delete clanname_;
  }
  if (clanname) {
    set_has_clanname();
    clanname_ = clanname;
  } else {
    clear_has_clanname();
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 ranking = 47;
inline bool BaseInfo::has_ranking() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void BaseInfo::set_has_ranking() {
  _has_bits_[1] |= 0x00004000u;
}
inline void BaseInfo::clear_has_ranking() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void BaseInfo::clear_ranking() {
  ranking_ = 0;
  clear_has_ranking();
}
inline ::google::protobuf::int32 BaseInfo::ranking() const {
  return ranking_;
}
inline void BaseInfo::set_ranking(::google::protobuf::int32 value) {
  set_has_ranking();
  ranking_ = value;
}

// optional int32 awardranking = 48;
inline bool BaseInfo::has_awardranking() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void BaseInfo::set_has_awardranking() {
  _has_bits_[1] |= 0x00008000u;
}
inline void BaseInfo::clear_has_awardranking() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void BaseInfo::clear_awardranking() {
  awardranking_ = 0;
  clear_has_awardranking();
}
inline ::google::protobuf::int32 BaseInfo::awardranking() const {
  return awardranking_;
}
inline void BaseInfo::set_awardranking(::google::protobuf::int32 value) {
  set_has_awardranking();
  awardranking_ = value;
}

// optional int32 AntiAddictionState = 49;
inline bool BaseInfo::has_antiaddictionstate() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void BaseInfo::set_has_antiaddictionstate() {
  _has_bits_[1] |= 0x00010000u;
}
inline void BaseInfo::clear_has_antiaddictionstate() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void BaseInfo::clear_antiaddictionstate() {
  antiaddictionstate_ = 0;
  clear_has_antiaddictionstate();
}
inline ::google::protobuf::int32 BaseInfo::antiaddictionstate() const {
  return antiaddictionstate_;
}
inline void BaseInfo::set_antiaddictionstate(::google::protobuf::int32 value) {
  set_has_antiaddictionstate();
  antiaddictionstate_ = value;
}

// optional int32 AntiAddictionOnLineTime = 50;
inline bool BaseInfo::has_antiaddictiononlinetime() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void BaseInfo::set_has_antiaddictiononlinetime() {
  _has_bits_[1] |= 0x00020000u;
}
inline void BaseInfo::clear_has_antiaddictiononlinetime() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void BaseInfo::clear_antiaddictiononlinetime() {
  antiaddictiononlinetime_ = 0;
  clear_has_antiaddictiononlinetime();
}
inline ::google::protobuf::int32 BaseInfo::antiaddictiononlinetime() const {
  return antiaddictiononlinetime_;
}
inline void BaseInfo::set_antiaddictiononlinetime(::google::protobuf::int32 value) {
  set_has_antiaddictiononlinetime();
  antiaddictiononlinetime_ = value;
}

// optional int64 totalOnlineTime = 51;
inline bool BaseInfo::has_totalonlinetime() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void BaseInfo::set_has_totalonlinetime() {
  _has_bits_[1] |= 0x00040000u;
}
inline void BaseInfo::clear_has_totalonlinetime() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void BaseInfo::clear_totalonlinetime() {
  totalonlinetime_ = GOOGLE_LONGLONG(0);
  clear_has_totalonlinetime();
}
inline ::google::protobuf::int64 BaseInfo::totalonlinetime() const {
  return totalonlinetime_;
}
inline void BaseInfo::set_totalonlinetime(::google::protobuf::int64 value) {
  set_has_totalonlinetime();
  totalonlinetime_ = value;
}

// optional int64 NextTalkTime = 52;
inline bool BaseInfo::has_nexttalktime() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void BaseInfo::set_has_nexttalktime() {
  _has_bits_[1] |= 0x00080000u;
}
inline void BaseInfo::clear_has_nexttalktime() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void BaseInfo::clear_nexttalktime() {
  nexttalktime_ = GOOGLE_LONGLONG(0);
  clear_has_nexttalktime();
}
inline ::google::protobuf::int64 BaseInfo::nexttalktime() const {
  return nexttalktime_;
}
inline void BaseInfo::set_nexttalktime(::google::protobuf::int64 value) {
  set_has_nexttalktime();
  nexttalktime_ = value;
}

// optional int32 treasonkingReward = 53;
inline bool BaseInfo::has_treasonkingreward() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void BaseInfo::set_has_treasonkingreward() {
  _has_bits_[1] |= 0x00100000u;
}
inline void BaseInfo::clear_has_treasonkingreward() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void BaseInfo::clear_treasonkingreward() {
  treasonkingreward_ = 0;
  clear_has_treasonkingreward();
}
inline ::google::protobuf::int32 BaseInfo::treasonkingreward() const {
  return treasonkingreward_;
}
inline void BaseInfo::set_treasonkingreward(::google::protobuf::int32 value) {
  set_has_treasonkingreward();
  treasonkingreward_ = value;
}

// optional int32 practiceTime = 54;
inline bool BaseInfo::has_practicetime() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void BaseInfo::set_has_practicetime() {
  _has_bits_[1] |= 0x00200000u;
}
inline void BaseInfo::clear_has_practicetime() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void BaseInfo::clear_practicetime() {
  practicetime_ = 0;
  clear_has_practicetime();
}
inline ::google::protobuf::int32 BaseInfo::practicetime() const {
  return practicetime_;
}
inline void BaseInfo::set_practicetime(::google::protobuf::int32 value) {
  set_has_practicetime();
  practicetime_ = value;
}

// optional int32 score = 55;
inline bool BaseInfo::has_score() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void BaseInfo::set_has_score() {
  _has_bits_[1] |= 0x00400000u;
}
inline void BaseInfo::clear_has_score() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void BaseInfo::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 BaseInfo::score() const {
  return score_;
}
inline void BaseInfo::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional int32 pkType = 56;
inline bool BaseInfo::has_pktype() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void BaseInfo::set_has_pktype() {
  _has_bits_[1] |= 0x00800000u;
}
inline void BaseInfo::clear_has_pktype() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void BaseInfo::clear_pktype() {
  pktype_ = 0;
  clear_has_pktype();
}
inline ::google::protobuf::int32 BaseInfo::pktype() const {
  return pktype_;
}
inline void BaseInfo::set_pktype(::google::protobuf::int32 value) {
  set_has_pktype();
  pktype_ = value;
}

// optional int32 clanicon = 57;
inline bool BaseInfo::has_clanicon() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void BaseInfo::set_has_clanicon() {
  _has_bits_[1] |= 0x01000000u;
}
inline void BaseInfo::clear_has_clanicon() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void BaseInfo::clear_clanicon() {
  clanicon_ = 0;
  clear_has_clanicon();
}
inline ::google::protobuf::int32 BaseInfo::clanicon() const {
  return clanicon_;
}
inline void BaseInfo::set_clanicon(::google::protobuf::int32 value) {
  set_has_clanicon();
  clanicon_ = value;
}

// optional bytes loginIP = 58;
inline bool BaseInfo::has_loginip() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void BaseInfo::set_has_loginip() {
  _has_bits_[1] |= 0x02000000u;
}
inline void BaseInfo::clear_has_loginip() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void BaseInfo::clear_loginip() {
  if (loginip_ != &::google::protobuf::internal::kEmptyString) {
    loginip_->clear();
  }
  clear_has_loginip();
}
inline const ::std::string& BaseInfo::loginip() const {
  return *loginip_;
}
inline void BaseInfo::set_loginip(const ::std::string& value) {
  set_has_loginip();
  if (loginip_ == &::google::protobuf::internal::kEmptyString) {
    loginip_ = new ::std::string;
  }
  loginip_->assign(value);
}
inline void BaseInfo::set_loginip(const char* value) {
  set_has_loginip();
  if (loginip_ == &::google::protobuf::internal::kEmptyString) {
    loginip_ = new ::std::string;
  }
  loginip_->assign(value);
}
inline void BaseInfo::set_loginip(const void* value, size_t size) {
  set_has_loginip();
  if (loginip_ == &::google::protobuf::internal::kEmptyString) {
    loginip_ = new ::std::string;
  }
  loginip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BaseInfo::mutable_loginip() {
  set_has_loginip();
  if (loginip_ == &::google::protobuf::internal::kEmptyString) {
    loginip_ = new ::std::string;
  }
  return loginip_;
}
inline ::std::string* BaseInfo::release_loginip() {
  clear_has_loginip();
  if (loginip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = loginip_;
    loginip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BaseInfo::set_allocated_loginip(::std::string* loginip) {
  if (loginip_ != &::google::protobuf::internal::kEmptyString) {
    delete loginip_;
  }
  if (loginip) {
    set_has_loginip();
    loginip_ = loginip;
  } else {
    clear_has_loginip();
    loginip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 teamid = 59;
inline bool BaseInfo::has_teamid() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void BaseInfo::set_has_teamid() {
  _has_bits_[1] |= 0x04000000u;
}
inline void BaseInfo::clear_has_teamid() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void BaseInfo::clear_teamid() {
  teamid_ = GOOGLE_LONGLONG(0);
  clear_has_teamid();
}
inline ::google::protobuf::int64 BaseInfo::teamid() const {
  return teamid_;
}
inline void BaseInfo::set_teamid(::google::protobuf::int64 value) {
  set_has_teamid();
  teamid_ = value;
}

// optional int32 fashionID = 60;
inline bool BaseInfo::has_fashionid() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void BaseInfo::set_has_fashionid() {
  _has_bits_[1] |= 0x08000000u;
}
inline void BaseInfo::clear_has_fashionid() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void BaseInfo::clear_fashionid() {
  fashionid_ = 0;
  clear_has_fashionid();
}
inline ::google::protobuf::int32 BaseInfo::fashionid() const {
  return fashionid_;
}
inline void BaseInfo::set_fashionid(::google::protobuf::int32 value) {
  set_has_fashionid();
  fashionid_ = value;
}

// optional int32 antiAddictionAddTime = 61;
inline bool BaseInfo::has_antiaddictionaddtime() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void BaseInfo::set_has_antiaddictionaddtime() {
  _has_bits_[1] |= 0x10000000u;
}
inline void BaseInfo::clear_has_antiaddictionaddtime() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void BaseInfo::clear_antiaddictionaddtime() {
  antiaddictionaddtime_ = 0;
  clear_has_antiaddictionaddtime();
}
inline ::google::protobuf::int32 BaseInfo::antiaddictionaddtime() const {
  return antiaddictionaddtime_;
}
inline void BaseInfo::set_antiaddictionaddtime(::google::protobuf::int32 value) {
  set_has_antiaddictionaddtime();
  antiaddictionaddtime_ = value;
}

// optional int64 couple = 62;
inline bool BaseInfo::has_couple() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void BaseInfo::set_has_couple() {
  _has_bits_[1] |= 0x20000000u;
}
inline void BaseInfo::clear_has_couple() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void BaseInfo::clear_couple() {
  couple_ = GOOGLE_LONGLONG(0);
  clear_has_couple();
}
inline ::google::protobuf::int64 BaseInfo::couple() const {
  return couple_;
}
inline void BaseInfo::set_couple(::google::protobuf::int64 value) {
  set_has_couple();
  couple_ = value;
}

// optional int32 power = 63;
inline bool BaseInfo::has_power() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void BaseInfo::set_has_power() {
  _has_bits_[1] |= 0x40000000u;
}
inline void BaseInfo::clear_has_power() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void BaseInfo::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline ::google::protobuf::int32 BaseInfo::power() const {
  return power_;
}
inline void BaseInfo::set_power(::google::protobuf::int32 value) {
  set_has_power();
  power_ = value;
}

// optional int32 fitch = 64;
inline bool BaseInfo::has_fitch() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void BaseInfo::set_has_fitch() {
  _has_bits_[1] |= 0x80000000u;
}
inline void BaseInfo::clear_has_fitch() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void BaseInfo::clear_fitch() {
  fitch_ = 0;
  clear_has_fitch();
}
inline ::google::protobuf::int32 BaseInfo::fitch() const {
  return fitch_;
}
inline void BaseInfo::set_fitch(::google::protobuf::int32 value) {
  set_has_fitch();
  fitch_ = value;
}

// optional int32 weekContribute = 65;
inline bool BaseInfo::has_weekcontribute() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void BaseInfo::set_has_weekcontribute() {
  _has_bits_[2] |= 0x00000001u;
}
inline void BaseInfo::clear_has_weekcontribute() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void BaseInfo::clear_weekcontribute() {
  weekcontribute_ = 0;
  clear_has_weekcontribute();
}
inline ::google::protobuf::int32 BaseInfo::weekcontribute() const {
  return weekcontribute_;
}
inline void BaseInfo::set_weekcontribute(::google::protobuf::int32 value) {
  set_has_weekcontribute();
  weekcontribute_ = value;
}

// optional int32 curContribute = 66;
inline bool BaseInfo::has_curcontribute() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void BaseInfo::set_has_curcontribute() {
  _has_bits_[2] |= 0x00000002u;
}
inline void BaseInfo::clear_has_curcontribute() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void BaseInfo::clear_curcontribute() {
  curcontribute_ = 0;
  clear_has_curcontribute();
}
inline ::google::protobuf::int32 BaseInfo::curcontribute() const {
  return curcontribute_;
}
inline void BaseInfo::set_curcontribute(::google::protobuf::int32 value) {
  set_has_curcontribute();
  curcontribute_ = value;
}

// optional int32 KingRankFlag = 67;
inline bool BaseInfo::has_kingrankflag() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void BaseInfo::set_has_kingrankflag() {
  _has_bits_[2] |= 0x00000004u;
}
inline void BaseInfo::clear_has_kingrankflag() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void BaseInfo::clear_kingrankflag() {
  kingrankflag_ = 0;
  clear_has_kingrankflag();
}
inline ::google::protobuf::int32 BaseInfo::kingrankflag() const {
  return kingrankflag_;
}
inline void BaseInfo::set_kingrankflag(::google::protobuf::int32 value) {
  set_has_kingrankflag();
  kingrankflag_ = value;
}

// optional int32 credit = 68;
inline bool BaseInfo::has_credit() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void BaseInfo::set_has_credit() {
  _has_bits_[2] |= 0x00000008u;
}
inline void BaseInfo::clear_has_credit() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void BaseInfo::clear_credit() {
  credit_ = 0;
  clear_has_credit();
}
inline ::google::protobuf::int32 BaseInfo::credit() const {
  return credit_;
}
inline void BaseInfo::set_credit(::google::protobuf::int32 value) {
  set_has_credit();
  credit_ = value;
}

// optional int32 envelopeCount = 69;
inline bool BaseInfo::has_envelopecount() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void BaseInfo::set_has_envelopecount() {
  _has_bits_[2] |= 0x00000010u;
}
inline void BaseInfo::clear_has_envelopecount() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void BaseInfo::clear_envelopecount() {
  envelopecount_ = 0;
  clear_has_envelopecount();
}
inline ::google::protobuf::int32 BaseInfo::envelopecount() const {
  return envelopecount_;
}
inline void BaseInfo::set_envelopecount(::google::protobuf::int32 value) {
  set_has_envelopecount();
  envelopecount_ = value;
}

// optional int32 maxCanGetEnvelopeCount = 70;
inline bool BaseInfo::has_maxcangetenvelopecount() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void BaseInfo::set_has_maxcangetenvelopecount() {
  _has_bits_[2] |= 0x00000020u;
}
inline void BaseInfo::clear_has_maxcangetenvelopecount() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void BaseInfo::clear_maxcangetenvelopecount() {
  maxcangetenvelopecount_ = 0;
  clear_has_maxcangetenvelopecount();
}
inline ::google::protobuf::int32 BaseInfo::maxcangetenvelopecount() const {
  return maxcangetenvelopecount_;
}
inline void BaseInfo::set_maxcangetenvelopecount(::google::protobuf::int32 value) {
  set_has_maxcangetenvelopecount();
  maxcangetenvelopecount_ = value;
}

// optional uint64 attributeClearTime = 71;
inline bool BaseInfo::has_attributecleartime() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void BaseInfo::set_has_attributecleartime() {
  _has_bits_[2] |= 0x00000040u;
}
inline void BaseInfo::clear_has_attributecleartime() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void BaseInfo::clear_attributecleartime() {
  attributecleartime_ = GOOGLE_ULONGLONG(0);
  clear_has_attributecleartime();
}
inline ::google::protobuf::uint64 BaseInfo::attributecleartime() const {
  return attributecleartime_;
}
inline void BaseInfo::set_attributecleartime(::google::protobuf::uint64 value) {
  set_has_attributecleartime();
  attributecleartime_ = value;
}

// optional int32 goldenCost = 72;
inline bool BaseInfo::has_goldencost() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void BaseInfo::set_has_goldencost() {
  _has_bits_[2] |= 0x00000080u;
}
inline void BaseInfo::clear_has_goldencost() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void BaseInfo::clear_goldencost() {
  goldencost_ = 0;
  clear_has_goldencost();
}
inline ::google::protobuf::int32 BaseInfo::goldencost() const {
  return goldencost_;
}
inline void BaseInfo::set_goldencost(::google::protobuf::int32 value) {
  set_has_goldencost();
  goldencost_ = value;
}

// optional string openKey = 73;
inline bool BaseInfo::has_openkey() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void BaseInfo::set_has_openkey() {
  _has_bits_[2] |= 0x00000100u;
}
inline void BaseInfo::clear_has_openkey() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void BaseInfo::clear_openkey() {
  if (openkey_ != &::google::protobuf::internal::kEmptyString) {
    openkey_->clear();
  }
  clear_has_openkey();
}
inline const ::std::string& BaseInfo::openkey() const {
  return *openkey_;
}
inline void BaseInfo::set_openkey(const ::std::string& value) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(value);
}
inline void BaseInfo::set_openkey(const char* value) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(value);
}
inline void BaseInfo::set_openkey(const char* value, size_t size) {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  openkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BaseInfo::mutable_openkey() {
  set_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    openkey_ = new ::std::string;
  }
  return openkey_;
}
inline ::std::string* BaseInfo::release_openkey() {
  clear_has_openkey();
  if (openkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openkey_;
    openkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BaseInfo::set_allocated_openkey(::std::string* openkey) {
  if (openkey_ != &::google::protobuf::internal::kEmptyString) {
    delete openkey_;
  }
  if (openkey) {
    set_has_openkey();
    openkey_ = openkey;
  } else {
    clear_has_openkey();
    openkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pf = 74;
inline bool BaseInfo::has_pf() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void BaseInfo::set_has_pf() {
  _has_bits_[2] |= 0x00000200u;
}
inline void BaseInfo::clear_has_pf() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void BaseInfo::clear_pf() {
  if (pf_ != &::google::protobuf::internal::kEmptyString) {
    pf_->clear();
  }
  clear_has_pf();
}
inline const ::std::string& BaseInfo::pf() const {
  return *pf_;
}
inline void BaseInfo::set_pf(const ::std::string& value) {
  set_has_pf();
  if (pf_ == &::google::protobuf::internal::kEmptyString) {
    pf_ = new ::std::string;
  }
  pf_->assign(value);
}
inline void BaseInfo::set_pf(const char* value) {
  set_has_pf();
  if (pf_ == &::google::protobuf::internal::kEmptyString) {
    pf_ = new ::std::string;
  }
  pf_->assign(value);
}
inline void BaseInfo::set_pf(const char* value, size_t size) {
  set_has_pf();
  if (pf_ == &::google::protobuf::internal::kEmptyString) {
    pf_ = new ::std::string;
  }
  pf_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BaseInfo::mutable_pf() {
  set_has_pf();
  if (pf_ == &::google::protobuf::internal::kEmptyString) {
    pf_ = new ::std::string;
  }
  return pf_;
}
inline ::std::string* BaseInfo::release_pf() {
  clear_has_pf();
  if (pf_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pf_;
    pf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BaseInfo::set_allocated_pf(::std::string* pf) {
  if (pf_ != &::google::protobuf::internal::kEmptyString) {
    delete pf_;
  }
  if (pf) {
    set_has_pf();
    pf_ = pf;
  } else {
    clear_has_pf();
    pf_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pfKey = 75;
inline bool BaseInfo::has_pfkey() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void BaseInfo::set_has_pfkey() {
  _has_bits_[2] |= 0x00000400u;
}
inline void BaseInfo::clear_has_pfkey() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void BaseInfo::clear_pfkey() {
  if (pfkey_ != &::google::protobuf::internal::kEmptyString) {
    pfkey_->clear();
  }
  clear_has_pfkey();
}
inline const ::std::string& BaseInfo::pfkey() const {
  return *pfkey_;
}
inline void BaseInfo::set_pfkey(const ::std::string& value) {
  set_has_pfkey();
  if (pfkey_ == &::google::protobuf::internal::kEmptyString) {
    pfkey_ = new ::std::string;
  }
  pfkey_->assign(value);
}
inline void BaseInfo::set_pfkey(const char* value) {
  set_has_pfkey();
  if (pfkey_ == &::google::protobuf::internal::kEmptyString) {
    pfkey_ = new ::std::string;
  }
  pfkey_->assign(value);
}
inline void BaseInfo::set_pfkey(const char* value, size_t size) {
  set_has_pfkey();
  if (pfkey_ == &::google::protobuf::internal::kEmptyString) {
    pfkey_ = new ::std::string;
  }
  pfkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BaseInfo::mutable_pfkey() {
  set_has_pfkey();
  if (pfkey_ == &::google::protobuf::internal::kEmptyString) {
    pfkey_ = new ::std::string;
  }
  return pfkey_;
}
inline ::std::string* BaseInfo::release_pfkey() {
  clear_has_pfkey();
  if (pfkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pfkey_;
    pfkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BaseInfo::set_allocated_pfkey(::std::string* pfkey) {
  if (pfkey_ != &::google::protobuf::internal::kEmptyString) {
    delete pfkey_;
  }
  if (pfkey) {
    set_has_pfkey();
    pfkey_ = pfkey;
  } else {
    clear_has_pfkey();
    pfkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string couplename = 76;
inline bool BaseInfo::has_couplename() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void BaseInfo::set_has_couplename() {
  _has_bits_[2] |= 0x00000800u;
}
inline void BaseInfo::clear_has_couplename() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void BaseInfo::clear_couplename() {
  if (couplename_ != &::google::protobuf::internal::kEmptyString) {
    couplename_->clear();
  }
  clear_has_couplename();
}
inline const ::std::string& BaseInfo::couplename() const {
  return *couplename_;
}
inline void BaseInfo::set_couplename(const ::std::string& value) {
  set_has_couplename();
  if (couplename_ == &::google::protobuf::internal::kEmptyString) {
    couplename_ = new ::std::string;
  }
  couplename_->assign(value);
}
inline void BaseInfo::set_couplename(const char* value) {
  set_has_couplename();
  if (couplename_ == &::google::protobuf::internal::kEmptyString) {
    couplename_ = new ::std::string;
  }
  couplename_->assign(value);
}
inline void BaseInfo::set_couplename(const char* value, size_t size) {
  set_has_couplename();
  if (couplename_ == &::google::protobuf::internal::kEmptyString) {
    couplename_ = new ::std::string;
  }
  couplename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BaseInfo::mutable_couplename() {
  set_has_couplename();
  if (couplename_ == &::google::protobuf::internal::kEmptyString) {
    couplename_ = new ::std::string;
  }
  return couplename_;
}
inline ::std::string* BaseInfo::release_couplename() {
  clear_has_couplename();
  if (couplename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = couplename_;
    couplename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BaseInfo::set_allocated_couplename(::std::string* couplename) {
  if (couplename_ != &::google::protobuf::internal::kEmptyString) {
    delete couplename_;
  }
  if (couplename) {
    set_has_couplename();
    couplename_ = couplename;
  } else {
    clear_has_couplename();
    couplename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 mgicweaponPower = 77;
inline bool BaseInfo::has_mgicweaponpower() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void BaseInfo::set_has_mgicweaponpower() {
  _has_bits_[2] |= 0x00001000u;
}
inline void BaseInfo::clear_has_mgicweaponpower() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void BaseInfo::clear_mgicweaponpower() {
  mgicweaponpower_ = 0;
  clear_has_mgicweaponpower();
}
inline ::google::protobuf::int32 BaseInfo::mgicweaponpower() const {
  return mgicweaponpower_;
}
inline void BaseInfo::set_mgicweaponpower(::google::protobuf::int32 value) {
  set_has_mgicweaponpower();
  mgicweaponpower_ = value;
}

// optional int32 gourdExp = 78;
inline bool BaseInfo::has_gourdexp() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void BaseInfo::set_has_gourdexp() {
  _has_bits_[2] |= 0x00002000u;
}
inline void BaseInfo::clear_has_gourdexp() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void BaseInfo::clear_gourdexp() {
  gourdexp_ = 0;
  clear_has_gourdexp();
}
inline ::google::protobuf::int32 BaseInfo::gourdexp() const {
  return gourdexp_;
}
inline void BaseInfo::set_gourdexp(::google::protobuf::int32 value) {
  set_has_gourdexp();
  gourdexp_ = value;
}

// optional int32 pvpflag = 79;
inline bool BaseInfo::has_pvpflag() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void BaseInfo::set_has_pvpflag() {
  _has_bits_[2] |= 0x00004000u;
}
inline void BaseInfo::clear_has_pvpflag() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void BaseInfo::clear_pvpflag() {
  pvpflag_ = 0;
  clear_has_pvpflag();
}
inline ::google::protobuf::int32 BaseInfo::pvpflag() const {
  return pvpflag_;
}
inline void BaseInfo::set_pvpflag(::google::protobuf::int32 value) {
  set_has_pvpflag();
  pvpflag_ = value;
}

// optional int32 clientType = 80;
inline bool BaseInfo::has_clienttype() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void BaseInfo::set_has_clienttype() {
  _has_bits_[2] |= 0x00008000u;
}
inline void BaseInfo::clear_has_clienttype() {
  _has_bits_[2] &= ~0x00008000u;
}
inline void BaseInfo::clear_clienttype() {
  clienttype_ = 0;
  clear_has_clienttype();
}
inline ::google::protobuf::int32 BaseInfo::clienttype() const {
  return clienttype_;
}
inline void BaseInfo::set_clienttype(::google::protobuf::int32 value) {
  set_has_clienttype();
  clienttype_ = value;
}

// optional int32 guide = 81;
inline bool BaseInfo::has_guide() const {
  return (_has_bits_[2] & 0x00010000u) != 0;
}
inline void BaseInfo::set_has_guide() {
  _has_bits_[2] |= 0x00010000u;
}
inline void BaseInfo::clear_has_guide() {
  _has_bits_[2] &= ~0x00010000u;
}
inline void BaseInfo::clear_guide() {
  guide_ = 0;
  clear_has_guide();
}
inline ::google::protobuf::int32 BaseInfo::guide() const {
  return guide_;
}
inline void BaseInfo::set_guide(::google::protobuf::int32 value) {
  set_has_guide();
  guide_ = value;
}

// optional string source = 82;
inline bool BaseInfo::has_source() const {
  return (_has_bits_[2] & 0x00020000u) != 0;
}
inline void BaseInfo::set_has_source() {
  _has_bits_[2] |= 0x00020000u;
}
inline void BaseInfo::clear_has_source() {
  _has_bits_[2] &= ~0x00020000u;
}
inline void BaseInfo::clear_source() {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& BaseInfo::source() const {
  return *source_;
}
inline void BaseInfo::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void BaseInfo::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(value);
}
inline void BaseInfo::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BaseInfo::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    source_ = new ::std::string;
  }
  return source_;
}
inline ::std::string* BaseInfo::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BaseInfo::set_allocated_source(::std::string* source) {
  if (source_ != &::google::protobuf::internal::kEmptyString) {
    delete source_;
  }
  if (source) {
    set_has_source();
    source_ = source;
  } else {
    clear_has_source();
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 rechargetime = 83;
inline bool BaseInfo::has_rechargetime() const {
  return (_has_bits_[2] & 0x00040000u) != 0;
}
inline void BaseInfo::set_has_rechargetime() {
  _has_bits_[2] |= 0x00040000u;
}
inline void BaseInfo::clear_has_rechargetime() {
  _has_bits_[2] &= ~0x00040000u;
}
inline void BaseInfo::clear_rechargetime() {
  rechargetime_ = GOOGLE_LONGLONG(0);
  clear_has_rechargetime();
}
inline ::google::protobuf::int64 BaseInfo::rechargetime() const {
  return rechargetime_;
}
inline void BaseInfo::set_rechargetime(::google::protobuf::int64 value) {
  set_has_rechargetime();
  rechargetime_ = value;
}

// optional int64 challengemoney = 84;
inline bool BaseInfo::has_challengemoney() const {
  return (_has_bits_[2] & 0x00080000u) != 0;
}
inline void BaseInfo::set_has_challengemoney() {
  _has_bits_[2] |= 0x00080000u;
}
inline void BaseInfo::clear_has_challengemoney() {
  _has_bits_[2] &= ~0x00080000u;
}
inline void BaseInfo::clear_challengemoney() {
  challengemoney_ = GOOGLE_LONGLONG(0);
  clear_has_challengemoney();
}
inline ::google::protobuf::int64 BaseInfo::challengemoney() const {
  return challengemoney_;
}
inline void BaseInfo::set_challengemoney(::google::protobuf::int64 value) {
  set_has_challengemoney();
  challengemoney_ = value;
}

// -------------------------------------------------------------------

// BattleInfo

// required int32 hp = 1;
inline bool BattleInfo::has_hp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleInfo::set_has_hp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleInfo::clear_has_hp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleInfo::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 BattleInfo::hp() const {
  return hp_;
}
inline void BattleInfo::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// required int32 hpmax = 2;
inline bool BattleInfo::has_hpmax() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleInfo::set_has_hpmax() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleInfo::clear_has_hpmax() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleInfo::clear_hpmax() {
  hpmax_ = 0;
  clear_has_hpmax();
}
inline ::google::protobuf::int32 BattleInfo::hpmax() const {
  return hpmax_;
}
inline void BattleInfo::set_hpmax(::google::protobuf::int32 value) {
  set_has_hpmax();
  hpmax_ = value;
}

// required int32 mp = 3;
inline bool BattleInfo::has_mp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleInfo::set_has_mp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleInfo::clear_has_mp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleInfo::clear_mp() {
  mp_ = 0;
  clear_has_mp();
}
inline ::google::protobuf::int32 BattleInfo::mp() const {
  return mp_;
}
inline void BattleInfo::set_mp(::google::protobuf::int32 value) {
  set_has_mp();
  mp_ = value;
}

// required int32 mpmax = 4;
inline bool BattleInfo::has_mpmax() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleInfo::set_has_mpmax() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleInfo::clear_has_mpmax() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleInfo::clear_mpmax() {
  mpmax_ = 0;
  clear_has_mpmax();
}
inline ::google::protobuf::int32 BattleInfo::mpmax() const {
  return mpmax_;
}
inline void BattleInfo::set_mpmax(::google::protobuf::int32 value) {
  set_has_mpmax();
  mpmax_ = value;
}

// required int32 force = 5;
inline bool BattleInfo::has_force() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleInfo::set_has_force() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleInfo::clear_has_force() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleInfo::clear_force() {
  force_ = 0;
  clear_has_force();
}
inline ::google::protobuf::int32 BattleInfo::force() const {
  return force_;
}
inline void BattleInfo::set_force(::google::protobuf::int32 value) {
  set_has_force();
  force_ = value;
}

// required int32 forcemax = 6;
inline bool BattleInfo::has_forcemax() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleInfo::set_has_forcemax() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleInfo::clear_has_forcemax() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleInfo::clear_forcemax() {
  forcemax_ = 0;
  clear_has_forcemax();
}
inline ::google::protobuf::int32 BattleInfo::forcemax() const {
  return forcemax_;
}
inline void BattleInfo::set_forcemax(::google::protobuf::int32 value) {
  set_has_forcemax();
  forcemax_ = value;
}

// required int32 strength = 7;
inline bool BattleInfo::has_strength() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BattleInfo::set_has_strength() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BattleInfo::clear_has_strength() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BattleInfo::clear_strength() {
  strength_ = 0;
  clear_has_strength();
}
inline ::google::protobuf::int32 BattleInfo::strength() const {
  return strength_;
}
inline void BattleInfo::set_strength(::google::protobuf::int32 value) {
  set_has_strength();
  strength_ = value;
}

// required int32 cleverpower = 8;
inline bool BattleInfo::has_cleverpower() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BattleInfo::set_has_cleverpower() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BattleInfo::clear_has_cleverpower() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BattleInfo::clear_cleverpower() {
  cleverpower_ = 0;
  clear_has_cleverpower();
}
inline ::google::protobuf::int32 BattleInfo::cleverpower() const {
  return cleverpower_;
}
inline void BattleInfo::set_cleverpower(::google::protobuf::int32 value) {
  set_has_cleverpower();
  cleverpower_ = value;
}

// optional int32 cleverair = 9;
inline bool BattleInfo::has_cleverair() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BattleInfo::set_has_cleverair() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BattleInfo::clear_has_cleverair() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BattleInfo::clear_cleverair() {
  cleverair_ = 0;
  clear_has_cleverair();
}
inline ::google::protobuf::int32 BattleInfo::cleverair() const {
  return cleverair_;
}
inline void BattleInfo::set_cleverair(::google::protobuf::int32 value) {
  set_has_cleverair();
  cleverair_ = value;
}

// required int32 physicalpower = 10;
inline bool BattleInfo::has_physicalpower() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BattleInfo::set_has_physicalpower() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BattleInfo::clear_has_physicalpower() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BattleInfo::clear_physicalpower() {
  physicalpower_ = 0;
  clear_has_physicalpower();
}
inline ::google::protobuf::int32 BattleInfo::physicalpower() const {
  return physicalpower_;
}
inline void BattleInfo::set_physicalpower(::google::protobuf::int32 value) {
  set_has_physicalpower();
  physicalpower_ = value;
}

// required int32 patience = 11;
inline bool BattleInfo::has_patience() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BattleInfo::set_has_patience() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BattleInfo::clear_has_patience() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BattleInfo::clear_patience() {
  patience_ = 0;
  clear_has_patience();
}
inline ::google::protobuf::int32 BattleInfo::patience() const {
  return patience_;
}
inline void BattleInfo::set_patience(::google::protobuf::int32 value) {
  set_has_patience();
  patience_ = value;
}

// required int32 agility = 12;
inline bool BattleInfo::has_agility() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BattleInfo::set_has_agility() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BattleInfo::clear_has_agility() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BattleInfo::clear_agility() {
  agility_ = 0;
  clear_has_agility();
}
inline ::google::protobuf::int32 BattleInfo::agility() const {
  return agility_;
}
inline void BattleInfo::set_agility(::google::protobuf::int32 value) {
  set_has_agility();
  agility_ = value;
}

// required int32 pkcount = 13;
inline bool BattleInfo::has_pkcount() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BattleInfo::set_has_pkcount() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BattleInfo::clear_has_pkcount() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BattleInfo::clear_pkcount() {
  pkcount_ = 0;
  clear_has_pkcount();
}
inline ::google::protobuf::int32 BattleInfo::pkcount() const {
  return pkcount_;
}
inline void BattleInfo::set_pkcount(::google::protobuf::int32 value) {
  set_has_pkcount();
  pkcount_ = value;
}

// optional int32 power = 14;
inline bool BattleInfo::has_power() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BattleInfo::set_has_power() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BattleInfo::clear_has_power() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BattleInfo::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline ::google::protobuf::int32 BattleInfo::power() const {
  return power_;
}
inline void BattleInfo::set_power(::google::protobuf::int32 value) {
  set_has_power();
  power_ = value;
}

// optional int32 powermax = 15;
inline bool BattleInfo::has_powermax() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BattleInfo::set_has_powermax() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BattleInfo::clear_has_powermax() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BattleInfo::clear_powermax() {
  powermax_ = 0;
  clear_has_powermax();
}
inline ::google::protobuf::int32 BattleInfo::powermax() const {
  return powermax_;
}
inline void BattleInfo::set_powermax(::google::protobuf::int32 value) {
  set_has_powermax();
  powermax_ = value;
}

// optional int32 phyattack = 16;
inline bool BattleInfo::has_phyattack() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BattleInfo::set_has_phyattack() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BattleInfo::clear_has_phyattack() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BattleInfo::clear_phyattack() {
  phyattack_ = 0;
  clear_has_phyattack();
}
inline ::google::protobuf::int32 BattleInfo::phyattack() const {
  return phyattack_;
}
inline void BattleInfo::set_phyattack(::google::protobuf::int32 value) {
  set_has_phyattack();
  phyattack_ = value;
}

// required int32 phyattackmax = 17;
inline bool BattleInfo::has_phyattackmax() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BattleInfo::set_has_phyattackmax() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BattleInfo::clear_has_phyattackmax() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BattleInfo::clear_phyattackmax() {
  phyattackmax_ = 0;
  clear_has_phyattackmax();
}
inline ::google::protobuf::int32 BattleInfo::phyattackmax() const {
  return phyattackmax_;
}
inline void BattleInfo::set_phyattackmax(::google::protobuf::int32 value) {
  set_has_phyattackmax();
  phyattackmax_ = value;
}

// required int32 phydefence = 18;
inline bool BattleInfo::has_phydefence() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BattleInfo::set_has_phydefence() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BattleInfo::clear_has_phydefence() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BattleInfo::clear_phydefence() {
  phydefence_ = 0;
  clear_has_phydefence();
}
inline ::google::protobuf::int32 BattleInfo::phydefence() const {
  return phydefence_;
}
inline void BattleInfo::set_phydefence(::google::protobuf::int32 value) {
  set_has_phydefence();
  phydefence_ = value;
}

// optional int32 magicattack = 19;
inline bool BattleInfo::has_magicattack() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BattleInfo::set_has_magicattack() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BattleInfo::clear_has_magicattack() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BattleInfo::clear_magicattack() {
  magicattack_ = 0;
  clear_has_magicattack();
}
inline ::google::protobuf::int32 BattleInfo::magicattack() const {
  return magicattack_;
}
inline void BattleInfo::set_magicattack(::google::protobuf::int32 value) {
  set_has_magicattack();
  magicattack_ = value;
}

// optional int32 magicattackmax = 20;
inline bool BattleInfo::has_magicattackmax() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BattleInfo::set_has_magicattackmax() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BattleInfo::clear_has_magicattackmax() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BattleInfo::clear_magicattackmax() {
  magicattackmax_ = 0;
  clear_has_magicattackmax();
}
inline ::google::protobuf::int32 BattleInfo::magicattackmax() const {
  return magicattackmax_;
}
inline void BattleInfo::set_magicattackmax(::google::protobuf::int32 value) {
  set_has_magicattackmax();
  magicattackmax_ = value;
}

// optional int32 magicdefence = 21;
inline bool BattleInfo::has_magicdefence() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BattleInfo::set_has_magicdefence() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BattleInfo::clear_has_magicdefence() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BattleInfo::clear_magicdefence() {
  magicdefence_ = 0;
  clear_has_magicdefence();
}
inline ::google::protobuf::int32 BattleInfo::magicdefence() const {
  return magicdefence_;
}
inline void BattleInfo::set_magicdefence(::google::protobuf::int32 value) {
  set_has_magicdefence();
  magicdefence_ = value;
}

// required int32 hitrate = 22;
inline bool BattleInfo::has_hitrate() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void BattleInfo::set_has_hitrate() {
  _has_bits_[0] |= 0x00200000u;
}
inline void BattleInfo::clear_has_hitrate() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void BattleInfo::clear_hitrate() {
  hitrate_ = 0;
  clear_has_hitrate();
}
inline ::google::protobuf::int32 BattleInfo::hitrate() const {
  return hitrate_;
}
inline void BattleInfo::set_hitrate(::google::protobuf::int32 value) {
  set_has_hitrate();
  hitrate_ = value;
}

// required int32 avoidrate = 23;
inline bool BattleInfo::has_avoidrate() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void BattleInfo::set_has_avoidrate() {
  _has_bits_[0] |= 0x00400000u;
}
inline void BattleInfo::clear_has_avoidrate() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void BattleInfo::clear_avoidrate() {
  avoidrate_ = 0;
  clear_has_avoidrate();
}
inline ::google::protobuf::int32 BattleInfo::avoidrate() const {
  return avoidrate_;
}
inline void BattleInfo::set_avoidrate(::google::protobuf::int32 value) {
  set_has_avoidrate();
  avoidrate_ = value;
}

// optional int32 baselucky = 24;
inline bool BattleInfo::has_baselucky() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void BattleInfo::set_has_baselucky() {
  _has_bits_[0] |= 0x00800000u;
}
inline void BattleInfo::clear_has_baselucky() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void BattleInfo::clear_baselucky() {
  baselucky_ = 0;
  clear_has_baselucky();
}
inline ::google::protobuf::int32 BattleInfo::baselucky() const {
  return baselucky_;
}
inline void BattleInfo::set_baselucky(::google::protobuf::int32 value) {
  set_has_baselucky();
  baselucky_ = value;
}

// required int32 crackdownrate = 25;
inline bool BattleInfo::has_crackdownrate() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void BattleInfo::set_has_crackdownrate() {
  _has_bits_[0] |= 0x01000000u;
}
inline void BattleInfo::clear_has_crackdownrate() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void BattleInfo::clear_crackdownrate() {
  crackdownrate_ = 0;
  clear_has_crackdownrate();
}
inline ::google::protobuf::int32 BattleInfo::crackdownrate() const {
  return crackdownrate_;
}
inline void BattleInfo::set_crackdownrate(::google::protobuf::int32 value) {
  set_has_crackdownrate();
  crackdownrate_ = value;
}

// required int32 baserte = 26;
inline bool BattleInfo::has_baserte() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void BattleInfo::set_has_baserte() {
  _has_bits_[0] |= 0x02000000u;
}
inline void BattleInfo::clear_has_baserte() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void BattleInfo::clear_baserte() {
  baserte_ = 0;
  clear_has_baserte();
}
inline ::google::protobuf::int32 BattleInfo::baserte() const {
  return baserte_;
}
inline void BattleInfo::set_baserte(::google::protobuf::int32 value) {
  set_has_baserte();
  baserte_ = value;
}

// required int32 movespeed = 27;
inline bool BattleInfo::has_movespeed() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void BattleInfo::set_has_movespeed() {
  _has_bits_[0] |= 0x04000000u;
}
inline void BattleInfo::clear_has_movespeed() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void BattleInfo::clear_movespeed() {
  movespeed_ = 0;
  clear_has_movespeed();
}
inline ::google::protobuf::int32 BattleInfo::movespeed() const {
  return movespeed_;
}
inline void BattleInfo::set_movespeed(::google::protobuf::int32 value) {
  set_has_movespeed();
  movespeed_ = value;
}

// -------------------------------------------------------------------

// QuestInfo

// repeated .PlayerInfo.ActiveQuest active = 1;
inline int QuestInfo::active_size() const {
  return active_.size();
}
inline void QuestInfo::clear_active() {
  active_.Clear();
}
inline const ::PlayerInfo::ActiveQuest& QuestInfo::active(int index) const {
  return active_.Get(index);
}
inline ::PlayerInfo::ActiveQuest* QuestInfo::mutable_active(int index) {
  return active_.Mutable(index);
}
inline ::PlayerInfo::ActiveQuest* QuestInfo::add_active() {
  return active_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ActiveQuest >&
QuestInfo::active() const {
  return active_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ActiveQuest >*
QuestInfo::mutable_active() {
  return &active_;
}

// repeated .PlayerInfo.DailyQuest daily = 2;
inline int QuestInfo::daily_size() const {
  return daily_.size();
}
inline void QuestInfo::clear_daily() {
  daily_.Clear();
}
inline const ::PlayerInfo::DailyQuest& QuestInfo::daily(int index) const {
  return daily_.Get(index);
}
inline ::PlayerInfo::DailyQuest* QuestInfo::mutable_daily(int index) {
  return daily_.Mutable(index);
}
inline ::PlayerInfo::DailyQuest* QuestInfo::add_daily() {
  return daily_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DailyQuest >&
QuestInfo::daily() const {
  return daily_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DailyQuest >*
QuestInfo::mutable_daily() {
  return &daily_;
}

// repeated .PlayerInfo.ClanQuest clan = 3;
inline int QuestInfo::clan_size() const {
  return clan_.size();
}
inline void QuestInfo::clear_clan() {
  clan_.Clear();
}
inline const ::PlayerInfo::ClanQuest& QuestInfo::clan(int index) const {
  return clan_.Get(index);
}
inline ::PlayerInfo::ClanQuest* QuestInfo::mutable_clan(int index) {
  return clan_.Mutable(index);
}
inline ::PlayerInfo::ClanQuest* QuestInfo::add_clan() {
  return clan_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ClanQuest >&
QuestInfo::clan() const {
  return clan_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ClanQuest >*
QuestInfo::mutable_clan() {
  return &clan_;
}

// optional int32 doclantime = 4;
inline bool QuestInfo::has_doclantime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QuestInfo::set_has_doclantime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QuestInfo::clear_has_doclantime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QuestInfo::clear_doclantime() {
  doclantime_ = 0;
  clear_has_doclantime();
}
inline ::google::protobuf::int32 QuestInfo::doclantime() const {
  return doclantime_;
}
inline void QuestInfo::set_doclantime(::google::protobuf::int32 value) {
  set_has_doclantime();
  doclantime_ = value;
}

// optional int32 dailytime = 5;
inline bool QuestInfo::has_dailytime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void QuestInfo::set_has_dailytime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void QuestInfo::clear_has_dailytime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void QuestInfo::clear_dailytime() {
  dailytime_ = 0;
  clear_has_dailytime();
}
inline ::google::protobuf::int32 QuestInfo::dailytime() const {
  return dailytime_;
}
inline void QuestInfo::set_dailytime(::google::protobuf::int32 value) {
  set_has_dailytime();
  dailytime_ = value;
}

// repeated .PlayerInfo.DailyQuest yesterdaydaily = 6;
inline int QuestInfo::yesterdaydaily_size() const {
  return yesterdaydaily_.size();
}
inline void QuestInfo::clear_yesterdaydaily() {
  yesterdaydaily_.Clear();
}
inline const ::PlayerInfo::DailyQuest& QuestInfo::yesterdaydaily(int index) const {
  return yesterdaydaily_.Get(index);
}
inline ::PlayerInfo::DailyQuest* QuestInfo::mutable_yesterdaydaily(int index) {
  return yesterdaydaily_.Mutable(index);
}
inline ::PlayerInfo::DailyQuest* QuestInfo::add_yesterdaydaily() {
  return yesterdaydaily_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DailyQuest >&
QuestInfo::yesterdaydaily() const {
  return yesterdaydaily_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DailyQuest >*
QuestInfo::mutable_yesterdaydaily() {
  return &yesterdaydaily_;
}

// repeated .PlayerInfo.ClanQuest yesterdayclan = 7;
inline int QuestInfo::yesterdayclan_size() const {
  return yesterdayclan_.size();
}
inline void QuestInfo::clear_yesterdayclan() {
  yesterdayclan_.Clear();
}
inline const ::PlayerInfo::ClanQuest& QuestInfo::yesterdayclan(int index) const {
  return yesterdayclan_.Get(index);
}
inline ::PlayerInfo::ClanQuest* QuestInfo::mutable_yesterdayclan(int index) {
  return yesterdayclan_.Mutable(index);
}
inline ::PlayerInfo::ClanQuest* QuestInfo::add_yesterdayclan() {
  return yesterdayclan_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ClanQuest >&
QuestInfo::yesterdayclan() const {
  return yesterdayclan_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ClanQuest >*
QuestInfo::mutable_yesterdayclan() {
  return &yesterdayclan_;
}

// optional bool allMainTaskHadCompFlag = 8;
inline bool QuestInfo::has_allmaintaskhadcompflag() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void QuestInfo::set_has_allmaintaskhadcompflag() {
  _has_bits_[0] |= 0x00000080u;
}
inline void QuestInfo::clear_has_allmaintaskhadcompflag() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void QuestInfo::clear_allmaintaskhadcompflag() {
  allmaintaskhadcompflag_ = false;
  clear_has_allmaintaskhadcompflag();
}
inline bool QuestInfo::allmaintaskhadcompflag() const {
  return allmaintaskhadcompflag_;
}
inline void QuestInfo::set_allmaintaskhadcompflag(bool value) {
  set_has_allmaintaskhadcompflag();
  allmaintaskhadcompflag_ = value;
}

// repeated .PlayerInfo.CampQuest ccampQuest = 9;
inline int QuestInfo::ccampquest_size() const {
  return ccampquest_.size();
}
inline void QuestInfo::clear_ccampquest() {
  ccampquest_.Clear();
}
inline const ::PlayerInfo::CampQuest& QuestInfo::ccampquest(int index) const {
  return ccampquest_.Get(index);
}
inline ::PlayerInfo::CampQuest* QuestInfo::mutable_ccampquest(int index) {
  return ccampquest_.Mutable(index);
}
inline ::PlayerInfo::CampQuest* QuestInfo::add_ccampquest() {
  return ccampquest_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::CampQuest >&
QuestInfo::ccampquest() const {
  return ccampquest_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::CampQuest >*
QuestInfo::mutable_ccampquest() {
  return &ccampquest_;
}

// optional int32 doCamptime = 10;
inline bool QuestInfo::has_docamptime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void QuestInfo::set_has_docamptime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void QuestInfo::clear_has_docamptime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void QuestInfo::clear_docamptime() {
  docamptime_ = 0;
  clear_has_docamptime();
}
inline ::google::protobuf::int32 QuestInfo::docamptime() const {
  return docamptime_;
}
inline void QuestInfo::set_docamptime(::google::protobuf::int32 value) {
  set_has_docamptime();
  docamptime_ = value;
}

// optional uint32 questGuideID = 11;
inline bool QuestInfo::has_questguideid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void QuestInfo::set_has_questguideid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void QuestInfo::clear_has_questguideid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void QuestInfo::clear_questguideid() {
  questguideid_ = 0u;
  clear_has_questguideid();
}
inline ::google::protobuf::uint32 QuestInfo::questguideid() const {
  return questguideid_;
}
inline void QuestInfo::set_questguideid(::google::protobuf::uint32 value) {
  set_has_questguideid();
  questguideid_ = value;
}

// optional .PlayerInfo.WeekQuest weekquest = 12;
inline bool QuestInfo::has_weekquest() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void QuestInfo::set_has_weekquest() {
  _has_bits_[0] |= 0x00000800u;
}
inline void QuestInfo::clear_has_weekquest() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void QuestInfo::clear_weekquest() {
  if (weekquest_ != NULL) weekquest_->::PlayerInfo::WeekQuest::Clear();
  clear_has_weekquest();
}
inline const ::PlayerInfo::WeekQuest& QuestInfo::weekquest() const {
  return weekquest_ != NULL ? *weekquest_ : *default_instance_->weekquest_;
}
inline ::PlayerInfo::WeekQuest* QuestInfo::mutable_weekquest() {
  set_has_weekquest();
  if (weekquest_ == NULL) weekquest_ = new ::PlayerInfo::WeekQuest;
  return weekquest_;
}
inline ::PlayerInfo::WeekQuest* QuestInfo::release_weekquest() {
  clear_has_weekquest();
  ::PlayerInfo::WeekQuest* temp = weekquest_;
  weekquest_ = NULL;
  return temp;
}
inline void QuestInfo::set_allocated_weekquest(::PlayerInfo::WeekQuest* weekquest) {
  delete weekquest_;
  weekquest_ = weekquest;
  if (weekquest) {
    set_has_weekquest();
  } else {
    clear_has_weekquest();
  }
}

// repeated .PlayerInfo.CampQuest yesterdaycamp = 13;
inline int QuestInfo::yesterdaycamp_size() const {
  return yesterdaycamp_.size();
}
inline void QuestInfo::clear_yesterdaycamp() {
  yesterdaycamp_.Clear();
}
inline const ::PlayerInfo::CampQuest& QuestInfo::yesterdaycamp(int index) const {
  return yesterdaycamp_.Get(index);
}
inline ::PlayerInfo::CampQuest* QuestInfo::mutable_yesterdaycamp(int index) {
  return yesterdaycamp_.Mutable(index);
}
inline ::PlayerInfo::CampQuest* QuestInfo::add_yesterdaycamp() {
  return yesterdaycamp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::CampQuest >&
QuestInfo::yesterdaycamp() const {
  return yesterdaycamp_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::CampQuest >*
QuestInfo::mutable_yesterdaycamp() {
  return &yesterdaycamp_;
}

// optional int32 yesterdayWeekTimes = 14;
inline bool QuestInfo::has_yesterdayweektimes() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void QuestInfo::set_has_yesterdayweektimes() {
  _has_bits_[0] |= 0x00002000u;
}
inline void QuestInfo::clear_has_yesterdayweektimes() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void QuestInfo::clear_yesterdayweektimes() {
  yesterdayweektimes_ = 0;
  clear_has_yesterdayweektimes();
}
inline ::google::protobuf::int32 QuestInfo::yesterdayweektimes() const {
  return yesterdayweektimes_;
}
inline void QuestInfo::set_yesterdayweektimes(::google::protobuf::int32 value) {
  set_has_yesterdayweektimes();
  yesterdayweektimes_ = value;
}

// -------------------------------------------------------------------

// WeekQuestItem

// optional int32 itemID = 1;
inline bool WeekQuestItem::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeekQuestItem::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeekQuestItem::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeekQuestItem::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 WeekQuestItem::itemid() const {
  return itemid_;
}
inline void WeekQuestItem::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 counts = 2;
inline bool WeekQuestItem::has_counts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeekQuestItem::set_has_counts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeekQuestItem::clear_has_counts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeekQuestItem::clear_counts() {
  counts_ = 0;
  clear_has_counts();
}
inline ::google::protobuf::int32 WeekQuestItem::counts() const {
  return counts_;
}
inline void WeekQuestItem::set_counts(::google::protobuf::int32 value) {
  set_has_counts();
  counts_ = value;
}

// optional int32 bindType = 3;
inline bool WeekQuestItem::has_bindtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeekQuestItem::set_has_bindtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeekQuestItem::clear_has_bindtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeekQuestItem::clear_bindtype() {
  bindtype_ = 0;
  clear_has_bindtype();
}
inline ::google::protobuf::int32 WeekQuestItem::bindtype() const {
  return bindtype_;
}
inline void WeekQuestItem::set_bindtype(::google::protobuf::int32 value) {
  set_has_bindtype();
  bindtype_ = value;
}

// -------------------------------------------------------------------

// WeekQuest

// optional int64 time = 1;
inline bool WeekQuest::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeekQuest::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeekQuest::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeekQuest::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 WeekQuest::time() const {
  return time_;
}
inline void WeekQuest::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional int32 times = 2;
inline bool WeekQuest::has_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeekQuest::set_has_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeekQuest::clear_has_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeekQuest::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 WeekQuest::times() const {
  return times_;
}
inline void WeekQuest::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// repeated .PlayerInfo.WeekQuestItem rewardIDs = 3;
inline int WeekQuest::rewardids_size() const {
  return rewardids_.size();
}
inline void WeekQuest::clear_rewardids() {
  rewardids_.Clear();
}
inline const ::PlayerInfo::WeekQuestItem& WeekQuest::rewardids(int index) const {
  return rewardids_.Get(index);
}
inline ::PlayerInfo::WeekQuestItem* WeekQuest::mutable_rewardids(int index) {
  return rewardids_.Mutable(index);
}
inline ::PlayerInfo::WeekQuestItem* WeekQuest::add_rewardids() {
  return rewardids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::WeekQuestItem >&
WeekQuest::rewardids() const {
  return rewardids_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::WeekQuestItem >*
WeekQuest::mutable_rewardids() {
  return &rewardids_;
}

// repeated .PlayerInfo.WeekQuestItem endrewardIDs = 4;
inline int WeekQuest::endrewardids_size() const {
  return endrewardids_.size();
}
inline void WeekQuest::clear_endrewardids() {
  endrewardids_.Clear();
}
inline const ::PlayerInfo::WeekQuestItem& WeekQuest::endrewardids(int index) const {
  return endrewardids_.Get(index);
}
inline ::PlayerInfo::WeekQuestItem* WeekQuest::mutable_endrewardids(int index) {
  return endrewardids_.Mutable(index);
}
inline ::PlayerInfo::WeekQuestItem* WeekQuest::add_endrewardids() {
  return endrewardids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::WeekQuestItem >&
WeekQuest::endrewardids() const {
  return endrewardids_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::WeekQuestItem >*
WeekQuest::mutable_endrewardids() {
  return &endrewardids_;
}

// -------------------------------------------------------------------

// NewQuestInfo

// optional .PlayerInfo.ActiveQuest qActive = 1;
inline bool NewQuestInfo::has_qactive() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewQuestInfo::set_has_qactive() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewQuestInfo::clear_has_qactive() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewQuestInfo::clear_qactive() {
  if (qactive_ != NULL) qactive_->::PlayerInfo::ActiveQuest::Clear();
  clear_has_qactive();
}
inline const ::PlayerInfo::ActiveQuest& NewQuestInfo::qactive() const {
  return qactive_ != NULL ? *qactive_ : *default_instance_->qactive_;
}
inline ::PlayerInfo::ActiveQuest* NewQuestInfo::mutable_qactive() {
  set_has_qactive();
  if (qactive_ == NULL) qactive_ = new ::PlayerInfo::ActiveQuest;
  return qactive_;
}
inline ::PlayerInfo::ActiveQuest* NewQuestInfo::release_qactive() {
  clear_has_qactive();
  ::PlayerInfo::ActiveQuest* temp = qactive_;
  qactive_ = NULL;
  return temp;
}
inline void NewQuestInfo::set_allocated_qactive(::PlayerInfo::ActiveQuest* qactive) {
  delete qactive_;
  qactive_ = qactive;
  if (qactive) {
    set_has_qactive();
  } else {
    clear_has_qactive();
  }
}

// optional .PlayerInfo.DailyQuest qDaily = 2;
inline bool NewQuestInfo::has_qdaily() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewQuestInfo::set_has_qdaily() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewQuestInfo::clear_has_qdaily() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewQuestInfo::clear_qdaily() {
  if (qdaily_ != NULL) qdaily_->::PlayerInfo::DailyQuest::Clear();
  clear_has_qdaily();
}
inline const ::PlayerInfo::DailyQuest& NewQuestInfo::qdaily() const {
  return qdaily_ != NULL ? *qdaily_ : *default_instance_->qdaily_;
}
inline ::PlayerInfo::DailyQuest* NewQuestInfo::mutable_qdaily() {
  set_has_qdaily();
  if (qdaily_ == NULL) qdaily_ = new ::PlayerInfo::DailyQuest;
  return qdaily_;
}
inline ::PlayerInfo::DailyQuest* NewQuestInfo::release_qdaily() {
  clear_has_qdaily();
  ::PlayerInfo::DailyQuest* temp = qdaily_;
  qdaily_ = NULL;
  return temp;
}
inline void NewQuestInfo::set_allocated_qdaily(::PlayerInfo::DailyQuest* qdaily) {
  delete qdaily_;
  qdaily_ = qdaily;
  if (qdaily) {
    set_has_qdaily();
  } else {
    clear_has_qdaily();
  }
}

// optional .PlayerInfo.ClanQuest qClan = 3;
inline bool NewQuestInfo::has_qclan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewQuestInfo::set_has_qclan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewQuestInfo::clear_has_qclan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewQuestInfo::clear_qclan() {
  if (qclan_ != NULL) qclan_->::PlayerInfo::ClanQuest::Clear();
  clear_has_qclan();
}
inline const ::PlayerInfo::ClanQuest& NewQuestInfo::qclan() const {
  return qclan_ != NULL ? *qclan_ : *default_instance_->qclan_;
}
inline ::PlayerInfo::ClanQuest* NewQuestInfo::mutable_qclan() {
  set_has_qclan();
  if (qclan_ == NULL) qclan_ = new ::PlayerInfo::ClanQuest;
  return qclan_;
}
inline ::PlayerInfo::ClanQuest* NewQuestInfo::release_qclan() {
  clear_has_qclan();
  ::PlayerInfo::ClanQuest* temp = qclan_;
  qclan_ = NULL;
  return temp;
}
inline void NewQuestInfo::set_allocated_qclan(::PlayerInfo::ClanQuest* qclan) {
  delete qclan_;
  qclan_ = qclan;
  if (qclan) {
    set_has_qclan();
  } else {
    clear_has_qclan();
  }
}

// optional .PlayerInfo.DailyQuest yesterdaydaily = 4;
inline bool NewQuestInfo::has_yesterdaydaily() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewQuestInfo::set_has_yesterdaydaily() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewQuestInfo::clear_has_yesterdaydaily() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewQuestInfo::clear_yesterdaydaily() {
  if (yesterdaydaily_ != NULL) yesterdaydaily_->::PlayerInfo::DailyQuest::Clear();
  clear_has_yesterdaydaily();
}
inline const ::PlayerInfo::DailyQuest& NewQuestInfo::yesterdaydaily() const {
  return yesterdaydaily_ != NULL ? *yesterdaydaily_ : *default_instance_->yesterdaydaily_;
}
inline ::PlayerInfo::DailyQuest* NewQuestInfo::mutable_yesterdaydaily() {
  set_has_yesterdaydaily();
  if (yesterdaydaily_ == NULL) yesterdaydaily_ = new ::PlayerInfo::DailyQuest;
  return yesterdaydaily_;
}
inline ::PlayerInfo::DailyQuest* NewQuestInfo::release_yesterdaydaily() {
  clear_has_yesterdaydaily();
  ::PlayerInfo::DailyQuest* temp = yesterdaydaily_;
  yesterdaydaily_ = NULL;
  return temp;
}
inline void NewQuestInfo::set_allocated_yesterdaydaily(::PlayerInfo::DailyQuest* yesterdaydaily) {
  delete yesterdaydaily_;
  yesterdaydaily_ = yesterdaydaily;
  if (yesterdaydaily) {
    set_has_yesterdaydaily();
  } else {
    clear_has_yesterdaydaily();
  }
}

// optional .PlayerInfo.ClanQuest yesterdayclan = 5;
inline bool NewQuestInfo::has_yesterdayclan() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NewQuestInfo::set_has_yesterdayclan() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NewQuestInfo::clear_has_yesterdayclan() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NewQuestInfo::clear_yesterdayclan() {
  if (yesterdayclan_ != NULL) yesterdayclan_->::PlayerInfo::ClanQuest::Clear();
  clear_has_yesterdayclan();
}
inline const ::PlayerInfo::ClanQuest& NewQuestInfo::yesterdayclan() const {
  return yesterdayclan_ != NULL ? *yesterdayclan_ : *default_instance_->yesterdayclan_;
}
inline ::PlayerInfo::ClanQuest* NewQuestInfo::mutable_yesterdayclan() {
  set_has_yesterdayclan();
  if (yesterdayclan_ == NULL) yesterdayclan_ = new ::PlayerInfo::ClanQuest;
  return yesterdayclan_;
}
inline ::PlayerInfo::ClanQuest* NewQuestInfo::release_yesterdayclan() {
  clear_has_yesterdayclan();
  ::PlayerInfo::ClanQuest* temp = yesterdayclan_;
  yesterdayclan_ = NULL;
  return temp;
}
inline void NewQuestInfo::set_allocated_yesterdayclan(::PlayerInfo::ClanQuest* yesterdayclan) {
  delete yesterdayclan_;
  yesterdayclan_ = yesterdayclan;
  if (yesterdayclan) {
    set_has_yesterdayclan();
  } else {
    clear_has_yesterdayclan();
  }
}

// -------------------------------------------------------------------

// ActiveQuest

// required int32 id = 1;
inline bool ActiveQuest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActiveQuest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActiveQuest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActiveQuest::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ActiveQuest::id() const {
  return id_;
}
inline void ActiveQuest::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 state = 2;
inline bool ActiveQuest::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActiveQuest::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActiveQuest::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActiveQuest::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 ActiveQuest::state() const {
  return state_;
}
inline void ActiveQuest::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// required int32 ftarget = 3;
inline bool ActiveQuest::has_ftarget() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActiveQuest::set_has_ftarget() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActiveQuest::clear_has_ftarget() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActiveQuest::clear_ftarget() {
  ftarget_ = 0;
  clear_has_ftarget();
}
inline ::google::protobuf::int32 ActiveQuest::ftarget() const {
  return ftarget_;
}
inline void ActiveQuest::set_ftarget(::google::protobuf::int32 value) {
  set_has_ftarget();
  ftarget_ = value;
}

// optional int32 starget = 4;
inline bool ActiveQuest::has_starget() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActiveQuest::set_has_starget() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActiveQuest::clear_has_starget() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActiveQuest::clear_starget() {
  starget_ = 0;
  clear_has_starget();
}
inline ::google::protobuf::int32 ActiveQuest::starget() const {
  return starget_;
}
inline void ActiveQuest::set_starget(::google::protobuf::int32 value) {
  set_has_starget();
  starget_ = value;
}

// optional int32 numlevel = 5;
inline bool ActiveQuest::has_numlevel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActiveQuest::set_has_numlevel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActiveQuest::clear_has_numlevel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActiveQuest::clear_numlevel() {
  numlevel_ = 0;
  clear_has_numlevel();
}
inline ::google::protobuf::int32 ActiveQuest::numlevel() const {
  return numlevel_;
}
inline void ActiveQuest::set_numlevel(::google::protobuf::int32 value) {
  set_has_numlevel();
  numlevel_ = value;
}

// optional int32 rewardlevel = 6;
inline bool ActiveQuest::has_rewardlevel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ActiveQuest::set_has_rewardlevel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ActiveQuest::clear_has_rewardlevel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ActiveQuest::clear_rewardlevel() {
  rewardlevel_ = 0;
  clear_has_rewardlevel();
}
inline ::google::protobuf::int32 ActiveQuest::rewardlevel() const {
  return rewardlevel_;
}
inline void ActiveQuest::set_rewardlevel(::google::protobuf::int32 value) {
  set_has_rewardlevel();
  rewardlevel_ = value;
}

// optional int32 times = 7;
inline bool ActiveQuest::has_times() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ActiveQuest::set_has_times() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ActiveQuest::clear_has_times() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ActiveQuest::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 ActiveQuest::times() const {
  return times_;
}
inline void ActiveQuest::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// -------------------------------------------------------------------

// DailyQuest

// required int32 questid = 1;
inline bool DailyQuest::has_questid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DailyQuest::set_has_questid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DailyQuest::clear_has_questid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DailyQuest::clear_questid() {
  questid_ = 0;
  clear_has_questid();
}
inline ::google::protobuf::int32 DailyQuest::questid() const {
  return questid_;
}
inline void DailyQuest::set_questid(::google::protobuf::int32 value) {
  set_has_questid();
  questid_ = value;
}

// required int32 numlevel = 2;
inline bool DailyQuest::has_numlevel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DailyQuest::set_has_numlevel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DailyQuest::clear_has_numlevel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DailyQuest::clear_numlevel() {
  numlevel_ = 0;
  clear_has_numlevel();
}
inline ::google::protobuf::int32 DailyQuest::numlevel() const {
  return numlevel_;
}
inline void DailyQuest::set_numlevel(::google::protobuf::int32 value) {
  set_has_numlevel();
  numlevel_ = value;
}

// required int32 rewardlevel = 3;
inline bool DailyQuest::has_rewardlevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DailyQuest::set_has_rewardlevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DailyQuest::clear_has_rewardlevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DailyQuest::clear_rewardlevel() {
  rewardlevel_ = 0;
  clear_has_rewardlevel();
}
inline ::google::protobuf::int32 DailyQuest::rewardlevel() const {
  return rewardlevel_;
}
inline void DailyQuest::set_rewardlevel(::google::protobuf::int32 value) {
  set_has_rewardlevel();
  rewardlevel_ = value;
}

// required int32 times = 4;
inline bool DailyQuest::has_times() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DailyQuest::set_has_times() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DailyQuest::clear_has_times() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DailyQuest::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 DailyQuest::times() const {
  return times_;
}
inline void DailyQuest::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// optional float numCoefficient = 5;
inline bool DailyQuest::has_numcoefficient() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DailyQuest::set_has_numcoefficient() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DailyQuest::clear_has_numcoefficient() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DailyQuest::clear_numcoefficient() {
  numcoefficient_ = 0;
  clear_has_numcoefficient();
}
inline float DailyQuest::numcoefficient() const {
  return numcoefficient_;
}
inline void DailyQuest::set_numcoefficient(float value) {
  set_has_numcoefficient();
  numcoefficient_ = value;
}

// -------------------------------------------------------------------

// ClanQuest

// required int32 questid = 1;
inline bool ClanQuest::has_questid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanQuest::set_has_questid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanQuest::clear_has_questid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanQuest::clear_questid() {
  questid_ = 0;
  clear_has_questid();
}
inline ::google::protobuf::int32 ClanQuest::questid() const {
  return questid_;
}
inline void ClanQuest::set_questid(::google::protobuf::int32 value) {
  set_has_questid();
  questid_ = value;
}

// required int32 numlevel = 2;
inline bool ClanQuest::has_numlevel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanQuest::set_has_numlevel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanQuest::clear_has_numlevel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanQuest::clear_numlevel() {
  numlevel_ = 0;
  clear_has_numlevel();
}
inline ::google::protobuf::int32 ClanQuest::numlevel() const {
  return numlevel_;
}
inline void ClanQuest::set_numlevel(::google::protobuf::int32 value) {
  set_has_numlevel();
  numlevel_ = value;
}

// required int32 rewardlevel = 3;
inline bool ClanQuest::has_rewardlevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanQuest::set_has_rewardlevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanQuest::clear_has_rewardlevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanQuest::clear_rewardlevel() {
  rewardlevel_ = 0;
  clear_has_rewardlevel();
}
inline ::google::protobuf::int32 ClanQuest::rewardlevel() const {
  return rewardlevel_;
}
inline void ClanQuest::set_rewardlevel(::google::protobuf::int32 value) {
  set_has_rewardlevel();
  rewardlevel_ = value;
}

// required int32 times = 4;
inline bool ClanQuest::has_times() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanQuest::set_has_times() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanQuest::clear_has_times() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanQuest::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 ClanQuest::times() const {
  return times_;
}
inline void ClanQuest::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// optional float numCoefficient = 5;
inline bool ClanQuest::has_numcoefficient() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClanQuest::set_has_numcoefficient() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClanQuest::clear_has_numcoefficient() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClanQuest::clear_numcoefficient() {
  numcoefficient_ = 0;
  clear_has_numcoefficient();
}
inline float ClanQuest::numcoefficient() const {
  return numcoefficient_;
}
inline void ClanQuest::set_numcoefficient(float value) {
  set_has_numcoefficient();
  numcoefficient_ = value;
}

// -------------------------------------------------------------------

// CampQuest

// required int32 questid = 1;
inline bool CampQuest::has_questid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CampQuest::set_has_questid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CampQuest::clear_has_questid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CampQuest::clear_questid() {
  questid_ = 0;
  clear_has_questid();
}
inline ::google::protobuf::int32 CampQuest::questid() const {
  return questid_;
}
inline void CampQuest::set_questid(::google::protobuf::int32 value) {
  set_has_questid();
  questid_ = value;
}

// required int32 numlevel = 2;
inline bool CampQuest::has_numlevel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CampQuest::set_has_numlevel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CampQuest::clear_has_numlevel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CampQuest::clear_numlevel() {
  numlevel_ = 0;
  clear_has_numlevel();
}
inline ::google::protobuf::int32 CampQuest::numlevel() const {
  return numlevel_;
}
inline void CampQuest::set_numlevel(::google::protobuf::int32 value) {
  set_has_numlevel();
  numlevel_ = value;
}

// required int32 rewardlevel = 3;
inline bool CampQuest::has_rewardlevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CampQuest::set_has_rewardlevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CampQuest::clear_has_rewardlevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CampQuest::clear_rewardlevel() {
  rewardlevel_ = 0;
  clear_has_rewardlevel();
}
inline ::google::protobuf::int32 CampQuest::rewardlevel() const {
  return rewardlevel_;
}
inline void CampQuest::set_rewardlevel(::google::protobuf::int32 value) {
  set_has_rewardlevel();
  rewardlevel_ = value;
}

// required int32 times = 4;
inline bool CampQuest::has_times() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CampQuest::set_has_times() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CampQuest::clear_has_times() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CampQuest::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 CampQuest::times() const {
  return times_;
}
inline void CampQuest::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// optional float numCoefficient = 5;
inline bool CampQuest::has_numcoefficient() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CampQuest::set_has_numcoefficient() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CampQuest::clear_has_numcoefficient() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CampQuest::clear_numcoefficient() {
  numcoefficient_ = 0;
  clear_has_numcoefficient();
}
inline float CampQuest::numcoefficient() const {
  return numcoefficient_;
}
inline void CampQuest::set_numcoefficient(float value) {
  set_has_numcoefficient();
  numcoefficient_ = value;
}

// -------------------------------------------------------------------

// POneTalentSkill

// optional int32 talentID = 1;
inline bool POneTalentSkill::has_talentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void POneTalentSkill::set_has_talentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void POneTalentSkill::clear_has_talentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void POneTalentSkill::clear_talentid() {
  talentid_ = 0;
  clear_has_talentid();
}
inline ::google::protobuf::int32 POneTalentSkill::talentid() const {
  return talentid_;
}
inline void POneTalentSkill::set_talentid(::google::protobuf::int32 value) {
  set_has_talentid();
  talentid_ = value;
}

// repeated int32 skillList = 2;
inline int POneTalentSkill::skilllist_size() const {
  return skilllist_.size();
}
inline void POneTalentSkill::clear_skilllist() {
  skilllist_.Clear();
}
inline ::google::protobuf::int32 POneTalentSkill::skilllist(int index) const {
  return skilllist_.Get(index);
}
inline void POneTalentSkill::set_skilllist(int index, ::google::protobuf::int32 value) {
  skilllist_.Set(index, value);
}
inline void POneTalentSkill::add_skilllist(::google::protobuf::int32 value) {
  skilllist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
POneTalentSkill::skilllist() const {
  return skilllist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
POneTalentSkill::mutable_skilllist() {
  return &skilllist_;
}

// -------------------------------------------------------------------

// SkillInfo

// repeated int32 skillid = 1;
inline int SkillInfo::skillid_size() const {
  return skillid_.size();
}
inline void SkillInfo::clear_skillid() {
  skillid_.Clear();
}
inline ::google::protobuf::int32 SkillInfo::skillid(int index) const {
  return skillid_.Get(index);
}
inline void SkillInfo::set_skillid(int index, ::google::protobuf::int32 value) {
  skillid_.Set(index, value);
}
inline void SkillInfo::add_skillid(::google::protobuf::int32 value) {
  skillid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SkillInfo::skillid() const {
  return skillid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SkillInfo::mutable_skillid() {
  return &skillid_;
}

// repeated .PlayerInfo.BuffInfo buf = 2;
inline int SkillInfo::buf_size() const {
  return buf_.size();
}
inline void SkillInfo::clear_buf() {
  buf_.Clear();
}
inline const ::PlayerInfo::BuffInfo& SkillInfo::buf(int index) const {
  return buf_.Get(index);
}
inline ::PlayerInfo::BuffInfo* SkillInfo::mutable_buf(int index) {
  return buf_.Mutable(index);
}
inline ::PlayerInfo::BuffInfo* SkillInfo::add_buf() {
  return buf_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BuffInfo >&
SkillInfo::buf() const {
  return buf_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BuffInfo >*
SkillInfo::mutable_buf() {
  return &buf_;
}

// repeated .PlayerInfo.POneTalentSkill skillData = 3;
inline int SkillInfo::skilldata_size() const {
  return skilldata_.size();
}
inline void SkillInfo::clear_skilldata() {
  skilldata_.Clear();
}
inline const ::PlayerInfo::POneTalentSkill& SkillInfo::skilldata(int index) const {
  return skilldata_.Get(index);
}
inline ::PlayerInfo::POneTalentSkill* SkillInfo::mutable_skilldata(int index) {
  return skilldata_.Mutable(index);
}
inline ::PlayerInfo::POneTalentSkill* SkillInfo::add_skilldata() {
  return skilldata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::POneTalentSkill >&
SkillInfo::skilldata() const {
  return skilldata_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::POneTalentSkill >*
SkillInfo::mutable_skilldata() {
  return &skilldata_;
}

// optional int32 curTalent = 4;
inline bool SkillInfo::has_curtalent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SkillInfo::set_has_curtalent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SkillInfo::clear_has_curtalent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SkillInfo::clear_curtalent() {
  curtalent_ = 0;
  clear_has_curtalent();
}
inline ::google::protobuf::int32 SkillInfo::curtalent() const {
  return curtalent_;
}
inline void SkillInfo::set_curtalent(::google::protobuf::int32 value) {
  set_has_curtalent();
  curtalent_ = value;
}

// repeated int32 clanskills = 5;
inline int SkillInfo::clanskills_size() const {
  return clanskills_.size();
}
inline void SkillInfo::clear_clanskills() {
  clanskills_.Clear();
}
inline ::google::protobuf::int32 SkillInfo::clanskills(int index) const {
  return clanskills_.Get(index);
}
inline void SkillInfo::set_clanskills(int index, ::google::protobuf::int32 value) {
  clanskills_.Set(index, value);
}
inline void SkillInfo::add_clanskills(::google::protobuf::int32 value) {
  clanskills_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SkillInfo::clanskills() const {
  return clanskills_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SkillInfo::mutable_clanskills() {
  return &clanskills_;
}

// -------------------------------------------------------------------

// BuffInfo

// required int32 type = 1;
inline bool BuffInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuffInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuffInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuffInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 BuffInfo::type() const {
  return type_;
}
inline void BuffInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 id = 2;
inline bool BuffInfo::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuffInfo::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuffInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuffInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 BuffInfo::id() const {
  return id_;
}
inline void BuffInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int64 endtime = 3;
inline bool BuffInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuffInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuffInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuffInfo::clear_endtime() {
  endtime_ = GOOGLE_LONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::int64 BuffInfo::endtime() const {
  return endtime_;
}
inline void BuffInfo::set_endtime(::google::protobuf::int64 value) {
  set_has_endtime();
  endtime_ = value;
}

// optional int64 offtime = 4;
inline bool BuffInfo::has_offtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuffInfo::set_has_offtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuffInfo::clear_has_offtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuffInfo::clear_offtime() {
  offtime_ = GOOGLE_LONGLONG(0);
  clear_has_offtime();
}
inline ::google::protobuf::int64 BuffInfo::offtime() const {
  return offtime_;
}
inline void BuffInfo::set_offtime(::google::protobuf::int64 value) {
  set_has_offtime();
  offtime_ = value;
}

// optional bool isdel = 5;
inline bool BuffInfo::has_isdel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuffInfo::set_has_isdel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuffInfo::clear_has_isdel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuffInfo::clear_isdel() {
  isdel_ = false;
  clear_has_isdel();
}
inline bool BuffInfo::isdel() const {
  return isdel_;
}
inline void BuffInfo::set_isdel(bool value) {
  set_has_isdel();
  isdel_ = value;
}

// -------------------------------------------------------------------

// CDInfo

// repeated .PlayerInfo.ChannelCD cd = 1;
inline int CDInfo::cd_size() const {
  return cd_.size();
}
inline void CDInfo::clear_cd() {
  cd_.Clear();
}
inline const ::PlayerInfo::ChannelCD& CDInfo::cd(int index) const {
  return cd_.Get(index);
}
inline ::PlayerInfo::ChannelCD* CDInfo::mutable_cd(int index) {
  return cd_.Mutable(index);
}
inline ::PlayerInfo::ChannelCD* CDInfo::add_cd() {
  return cd_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ChannelCD >&
CDInfo::cd() const {
  return cd_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ChannelCD >*
CDInfo::mutable_cd() {
  return &cd_;
}

// -------------------------------------------------------------------

// ChannelCD

// required int32 type = 1;
inline bool ChannelCD::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChannelCD::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChannelCD::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChannelCD::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ChannelCD::type() const {
  return type_;
}
inline void ChannelCD::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int64 endtime = 2;
inline bool ChannelCD::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChannelCD::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChannelCD::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChannelCD::clear_endtime() {
  endtime_ = GOOGLE_LONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::int64 ChannelCD::endtime() const {
  return endtime_;
}
inline void ChannelCD::set_endtime(::google::protobuf::int64 value) {
  set_has_endtime();
  endtime_ = value;
}

// -------------------------------------------------------------------

// ContainerInfo

// optional .PlayerInfo.PackageInfo package = 1;
inline bool ContainerInfo::has_package() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContainerInfo::set_has_package() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContainerInfo::clear_has_package() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContainerInfo::clear_package() {
  if (package_ != NULL) package_->::PlayerInfo::PackageInfo::Clear();
  clear_has_package();
}
inline const ::PlayerInfo::PackageInfo& ContainerInfo::package() const {
  return package_ != NULL ? *package_ : *default_instance_->package_;
}
inline ::PlayerInfo::PackageInfo* ContainerInfo::mutable_package() {
  set_has_package();
  if (package_ == NULL) package_ = new ::PlayerInfo::PackageInfo;
  return package_;
}
inline ::PlayerInfo::PackageInfo* ContainerInfo::release_package() {
  clear_has_package();
  ::PlayerInfo::PackageInfo* temp = package_;
  package_ = NULL;
  return temp;
}
inline void ContainerInfo::set_allocated_package(::PlayerInfo::PackageInfo* package) {
  delete package_;
  package_ = package;
  if (package) {
    set_has_package();
  } else {
    clear_has_package();
  }
}

// optional .PlayerInfo.StoreHouseInfo storehouse = 2;
inline bool ContainerInfo::has_storehouse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContainerInfo::set_has_storehouse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContainerInfo::clear_has_storehouse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContainerInfo::clear_storehouse() {
  if (storehouse_ != NULL) storehouse_->::PlayerInfo::StoreHouseInfo::Clear();
  clear_has_storehouse();
}
inline const ::PlayerInfo::StoreHouseInfo& ContainerInfo::storehouse() const {
  return storehouse_ != NULL ? *storehouse_ : *default_instance_->storehouse_;
}
inline ::PlayerInfo::StoreHouseInfo* ContainerInfo::mutable_storehouse() {
  set_has_storehouse();
  if (storehouse_ == NULL) storehouse_ = new ::PlayerInfo::StoreHouseInfo;
  return storehouse_;
}
inline ::PlayerInfo::StoreHouseInfo* ContainerInfo::release_storehouse() {
  clear_has_storehouse();
  ::PlayerInfo::StoreHouseInfo* temp = storehouse_;
  storehouse_ = NULL;
  return temp;
}
inline void ContainerInfo::set_allocated_storehouse(::PlayerInfo::StoreHouseInfo* storehouse) {
  delete storehouse_;
  storehouse_ = storehouse;
  if (storehouse) {
    set_has_storehouse();
  } else {
    clear_has_storehouse();
  }
}

// -------------------------------------------------------------------

// PlayerTypeInfo

// repeated int32 type = 1;
inline int PlayerTypeInfo::type_size() const {
  return type_.size();
}
inline void PlayerTypeInfo::clear_type() {
  type_.Clear();
}
inline ::google::protobuf::int32 PlayerTypeInfo::type(int index) const {
  return type_.Get(index);
}
inline void PlayerTypeInfo::set_type(int index, ::google::protobuf::int32 value) {
  type_.Set(index, value);
}
inline void PlayerTypeInfo::add_type(::google::protobuf::int32 value) {
  type_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PlayerTypeInfo::type() const {
  return type_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PlayerTypeInfo::mutable_type() {
  return &type_;
}

// optional .PlayerInfo.HorseInfo horse = 2;
inline bool PlayerTypeInfo::has_horse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerTypeInfo::set_has_horse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerTypeInfo::clear_has_horse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerTypeInfo::clear_horse() {
  if (horse_ != NULL) horse_->::PlayerInfo::HorseInfo::Clear();
  clear_has_horse();
}
inline const ::PlayerInfo::HorseInfo& PlayerTypeInfo::horse() const {
  return horse_ != NULL ? *horse_ : *default_instance_->horse_;
}
inline ::PlayerInfo::HorseInfo* PlayerTypeInfo::mutable_horse() {
  set_has_horse();
  if (horse_ == NULL) horse_ = new ::PlayerInfo::HorseInfo;
  return horse_;
}
inline ::PlayerInfo::HorseInfo* PlayerTypeInfo::release_horse() {
  clear_has_horse();
  ::PlayerInfo::HorseInfo* temp = horse_;
  horse_ = NULL;
  return temp;
}
inline void PlayerTypeInfo::set_allocated_horse(::PlayerInfo::HorseInfo* horse) {
  delete horse_;
  horse_ = horse;
  if (horse) {
    set_has_horse();
  } else {
    clear_has_horse();
  }
}

// optional .PlayerInfo.DanLuInfo danlu = 3;
inline bool PlayerTypeInfo::has_danlu() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerTypeInfo::set_has_danlu() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerTypeInfo::clear_has_danlu() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerTypeInfo::clear_danlu() {
  if (danlu_ != NULL) danlu_->::PlayerInfo::DanLuInfo::Clear();
  clear_has_danlu();
}
inline const ::PlayerInfo::DanLuInfo& PlayerTypeInfo::danlu() const {
  return danlu_ != NULL ? *danlu_ : *default_instance_->danlu_;
}
inline ::PlayerInfo::DanLuInfo* PlayerTypeInfo::mutable_danlu() {
  set_has_danlu();
  if (danlu_ == NULL) danlu_ = new ::PlayerInfo::DanLuInfo;
  return danlu_;
}
inline ::PlayerInfo::DanLuInfo* PlayerTypeInfo::release_danlu() {
  clear_has_danlu();
  ::PlayerInfo::DanLuInfo* temp = danlu_;
  danlu_ = NULL;
  return temp;
}
inline void PlayerTypeInfo::set_allocated_danlu(::PlayerInfo::DanLuInfo* danlu) {
  delete danlu_;
  danlu_ = danlu;
  if (danlu) {
    set_has_danlu();
  } else {
    clear_has_danlu();
  }
}

// optional .PlayerInfo.MagicWeapon magicw = 4;
inline bool PlayerTypeInfo::has_magicw() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerTypeInfo::set_has_magicw() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerTypeInfo::clear_has_magicw() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerTypeInfo::clear_magicw() {
  if (magicw_ != NULL) magicw_->::PlayerInfo::MagicWeapon::Clear();
  clear_has_magicw();
}
inline const ::PlayerInfo::MagicWeapon& PlayerTypeInfo::magicw() const {
  return magicw_ != NULL ? *magicw_ : *default_instance_->magicw_;
}
inline ::PlayerInfo::MagicWeapon* PlayerTypeInfo::mutable_magicw() {
  set_has_magicw();
  if (magicw_ == NULL) magicw_ = new ::PlayerInfo::MagicWeapon;
  return magicw_;
}
inline ::PlayerInfo::MagicWeapon* PlayerTypeInfo::release_magicw() {
  clear_has_magicw();
  ::PlayerInfo::MagicWeapon* temp = magicw_;
  magicw_ = NULL;
  return temp;
}
inline void PlayerTypeInfo::set_allocated_magicw(::PlayerInfo::MagicWeapon* magicw) {
  delete magicw_;
  magicw_ = magicw;
  if (magicw) {
    set_has_magicw();
  } else {
    clear_has_magicw();
  }
}

// optional .PlayerInfo.RandCJobLucky cjob = 5;
inline bool PlayerTypeInfo::has_cjob() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerTypeInfo::set_has_cjob() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerTypeInfo::clear_has_cjob() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerTypeInfo::clear_cjob() {
  if (cjob_ != NULL) cjob_->::PlayerInfo::RandCJobLucky::Clear();
  clear_has_cjob();
}
inline const ::PlayerInfo::RandCJobLucky& PlayerTypeInfo::cjob() const {
  return cjob_ != NULL ? *cjob_ : *default_instance_->cjob_;
}
inline ::PlayerInfo::RandCJobLucky* PlayerTypeInfo::mutable_cjob() {
  set_has_cjob();
  if (cjob_ == NULL) cjob_ = new ::PlayerInfo::RandCJobLucky;
  return cjob_;
}
inline ::PlayerInfo::RandCJobLucky* PlayerTypeInfo::release_cjob() {
  clear_has_cjob();
  ::PlayerInfo::RandCJobLucky* temp = cjob_;
  cjob_ = NULL;
  return temp;
}
inline void PlayerTypeInfo::set_allocated_cjob(::PlayerInfo::RandCJobLucky* cjob) {
  delete cjob_;
  cjob_ = cjob;
  if (cjob) {
    set_has_cjob();
  } else {
    clear_has_cjob();
  }
}

// optional .PlayerInfo.LucklyTurntable lucktable = 6;
inline bool PlayerTypeInfo::has_lucktable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerTypeInfo::set_has_lucktable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerTypeInfo::clear_has_lucktable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerTypeInfo::clear_lucktable() {
  if (lucktable_ != NULL) lucktable_->::PlayerInfo::LucklyTurntable::Clear();
  clear_has_lucktable();
}
inline const ::PlayerInfo::LucklyTurntable& PlayerTypeInfo::lucktable() const {
  return lucktable_ != NULL ? *lucktable_ : *default_instance_->lucktable_;
}
inline ::PlayerInfo::LucklyTurntable* PlayerTypeInfo::mutable_lucktable() {
  set_has_lucktable();
  if (lucktable_ == NULL) lucktable_ = new ::PlayerInfo::LucklyTurntable;
  return lucktable_;
}
inline ::PlayerInfo::LucklyTurntable* PlayerTypeInfo::release_lucktable() {
  clear_has_lucktable();
  ::PlayerInfo::LucklyTurntable* temp = lucktable_;
  lucktable_ = NULL;
  return temp;
}
inline void PlayerTypeInfo::set_allocated_lucktable(::PlayerInfo::LucklyTurntable* lucktable) {
  delete lucktable_;
  lucktable_ = lucktable;
  if (lucktable) {
    set_has_lucktable();
  } else {
    clear_has_lucktable();
  }
}

// optional .PlayerInfo.Activity activity = 7;
inline bool PlayerTypeInfo::has_activity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerTypeInfo::set_has_activity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerTypeInfo::clear_has_activity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerTypeInfo::clear_activity() {
  if (activity_ != NULL) activity_->::PlayerInfo::Activity::Clear();
  clear_has_activity();
}
inline const ::PlayerInfo::Activity& PlayerTypeInfo::activity() const {
  return activity_ != NULL ? *activity_ : *default_instance_->activity_;
}
inline ::PlayerInfo::Activity* PlayerTypeInfo::mutable_activity() {
  set_has_activity();
  if (activity_ == NULL) activity_ = new ::PlayerInfo::Activity;
  return activity_;
}
inline ::PlayerInfo::Activity* PlayerTypeInfo::release_activity() {
  clear_has_activity();
  ::PlayerInfo::Activity* temp = activity_;
  activity_ = NULL;
  return temp;
}
inline void PlayerTypeInfo::set_allocated_activity(::PlayerInfo::Activity* activity) {
  delete activity_;
  activity_ = activity;
  if (activity) {
    set_has_activity();
  } else {
    clear_has_activity();
  }
}

// optional .PlayerInfo.DestinationInfoList destination = 8;
inline bool PlayerTypeInfo::has_destination() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayerTypeInfo::set_has_destination() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayerTypeInfo::clear_has_destination() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayerTypeInfo::clear_destination() {
  if (destination_ != NULL) destination_->::PlayerInfo::DestinationInfoList::Clear();
  clear_has_destination();
}
inline const ::PlayerInfo::DestinationInfoList& PlayerTypeInfo::destination() const {
  return destination_ != NULL ? *destination_ : *default_instance_->destination_;
}
inline ::PlayerInfo::DestinationInfoList* PlayerTypeInfo::mutable_destination() {
  set_has_destination();
  if (destination_ == NULL) destination_ = new ::PlayerInfo::DestinationInfoList;
  return destination_;
}
inline ::PlayerInfo::DestinationInfoList* PlayerTypeInfo::release_destination() {
  clear_has_destination();
  ::PlayerInfo::DestinationInfoList* temp = destination_;
  destination_ = NULL;
  return temp;
}
inline void PlayerTypeInfo::set_allocated_destination(::PlayerInfo::DestinationInfoList* destination) {
  delete destination_;
  destination_ = destination;
  if (destination) {
    set_has_destination();
  } else {
    clear_has_destination();
  }
}

// -------------------------------------------------------------------

// EquipQuickInfo

// repeated .PlayerInfo.ItemInfo equip = 1;
inline int EquipQuickInfo::equip_size() const {
  return equip_.size();
}
inline void EquipQuickInfo::clear_equip() {
  equip_.Clear();
}
inline const ::PlayerInfo::ItemInfo& EquipQuickInfo::equip(int index) const {
  return equip_.Get(index);
}
inline ::PlayerInfo::ItemInfo* EquipQuickInfo::mutable_equip(int index) {
  return equip_.Mutable(index);
}
inline ::PlayerInfo::ItemInfo* EquipQuickInfo::add_equip() {
  return equip_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ItemInfo >&
EquipQuickInfo::equip() const {
  return equip_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ItemInfo >*
EquipQuickInfo::mutable_equip() {
  return &equip_;
}

// repeated .PlayerInfo.QuickContainer quick = 2;
inline int EquipQuickInfo::quick_size() const {
  return quick_.size();
}
inline void EquipQuickInfo::clear_quick() {
  quick_.Clear();
}
inline const ::PlayerInfo::QuickContainer& EquipQuickInfo::quick(int index) const {
  return quick_.Get(index);
}
inline ::PlayerInfo::QuickContainer* EquipQuickInfo::mutable_quick(int index) {
  return quick_.Mutable(index);
}
inline ::PlayerInfo::QuickContainer* EquipQuickInfo::add_quick() {
  return quick_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::QuickContainer >&
EquipQuickInfo::quick() const {
  return quick_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::QuickContainer >*
EquipQuickInfo::mutable_quick() {
  return &quick_;
}

// -------------------------------------------------------------------

// PackageInfo

// repeated .PlayerInfo.ItemInfo package = 1;
inline int PackageInfo::package_size() const {
  return package_.size();
}
inline void PackageInfo::clear_package() {
  package_.Clear();
}
inline const ::PlayerInfo::ItemInfo& PackageInfo::package(int index) const {
  return package_.Get(index);
}
inline ::PlayerInfo::ItemInfo* PackageInfo::mutable_package(int index) {
  return package_.Mutable(index);
}
inline ::PlayerInfo::ItemInfo* PackageInfo::add_package() {
  return package_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ItemInfo >&
PackageInfo::package() const {
  return package_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ItemInfo >*
PackageInfo::mutable_package() {
  return &package_;
}

// optional int32 size = 2;
inline bool PackageInfo::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PackageInfo::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PackageInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PackageInfo::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 PackageInfo::size() const {
  return size_;
}
inline void PackageInfo::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional int64 time = 3;
inline bool PackageInfo::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PackageInfo::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PackageInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PackageInfo::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 PackageInfo::time() const {
  return time_;
}
inline void PackageInfo::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// StoreHouseInfo

// repeated .PlayerInfo.ItemInfo storehouse = 1;
inline int StoreHouseInfo::storehouse_size() const {
  return storehouse_.size();
}
inline void StoreHouseInfo::clear_storehouse() {
  storehouse_.Clear();
}
inline const ::PlayerInfo::ItemInfo& StoreHouseInfo::storehouse(int index) const {
  return storehouse_.Get(index);
}
inline ::PlayerInfo::ItemInfo* StoreHouseInfo::mutable_storehouse(int index) {
  return storehouse_.Mutable(index);
}
inline ::PlayerInfo::ItemInfo* StoreHouseInfo::add_storehouse() {
  return storehouse_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ItemInfo >&
StoreHouseInfo::storehouse() const {
  return storehouse_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ItemInfo >*
StoreHouseInfo::mutable_storehouse() {
  return &storehouse_;
}

// optional int32 size = 3;
inline bool StoreHouseInfo::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreHouseInfo::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreHouseInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreHouseInfo::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 StoreHouseInfo::size() const {
  return size_;
}
inline void StoreHouseInfo::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// optional int64 time = 4;
inline bool StoreHouseInfo::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StoreHouseInfo::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StoreHouseInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StoreHouseInfo::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 StoreHouseInfo::time() const {
  return time_;
}
inline void StoreHouseInfo::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// MonitorInfo

// repeated bool attackskill = 1;
inline int MonitorInfo::attackskill_size() const {
  return attackskill_.size();
}
inline void MonitorInfo::clear_attackskill() {
  attackskill_.Clear();
}
inline bool MonitorInfo::attackskill(int index) const {
  return attackskill_.Get(index);
}
inline void MonitorInfo::set_attackskill(int index, bool value) {
  attackskill_.Set(index, value);
}
inline void MonitorInfo::add_attackskill(bool value) {
  attackskill_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
MonitorInfo::attackskill() const {
  return attackskill_;
}
inline ::google::protobuf::RepeatedField< bool >*
MonitorInfo::mutable_attackskill() {
  return &attackskill_;
}

// repeated int64 skillid = 2;
inline int MonitorInfo::skillid_size() const {
  return skillid_.size();
}
inline void MonitorInfo::clear_skillid() {
  skillid_.Clear();
}
inline ::google::protobuf::int64 MonitorInfo::skillid(int index) const {
  return skillid_.Get(index);
}
inline void MonitorInfo::set_skillid(int index, ::google::protobuf::int64 value) {
  skillid_.Set(index, value);
}
inline void MonitorInfo::add_skillid(::google::protobuf::int64 value) {
  skillid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
MonitorInfo::skillid() const {
  return skillid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
MonitorInfo::mutable_skillid() {
  return &skillid_;
}

// optional bool ispickequip = 3;
inline bool MonitorInfo::has_ispickequip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MonitorInfo::set_has_ispickequip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MonitorInfo::clear_has_ispickequip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MonitorInfo::clear_ispickequip() {
  ispickequip_ = false;
  clear_has_ispickequip();
}
inline bool MonitorInfo::ispickequip() const {
  return ispickequip_;
}
inline void MonitorInfo::set_ispickequip(bool value) {
  set_has_ispickequip();
  ispickequip_ = value;
}

// optional int32 quality = 4;
inline bool MonitorInfo::has_quality() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MonitorInfo::set_has_quality() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MonitorInfo::clear_has_quality() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MonitorInfo::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::google::protobuf::int32 MonitorInfo::quality() const {
  return quality_;
}
inline void MonitorInfo::set_quality(::google::protobuf::int32 value) {
  set_has_quality();
  quality_ = value;
}

// optional int32 profession = 5;
inline bool MonitorInfo::has_profession() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MonitorInfo::set_has_profession() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MonitorInfo::clear_has_profession() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MonitorInfo::clear_profession() {
  profession_ = 0;
  clear_has_profession();
}
inline ::google::protobuf::int32 MonitorInfo::profession() const {
  return profession_;
}
inline void MonitorInfo::set_profession(::google::protobuf::int32 value) {
  set_has_profession();
  profession_ = value;
}

// optional bool ispickstone = 6;
inline bool MonitorInfo::has_ispickstone() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MonitorInfo::set_has_ispickstone() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MonitorInfo::clear_has_ispickstone() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MonitorInfo::clear_ispickstone() {
  ispickstone_ = false;
  clear_has_ispickstone();
}
inline bool MonitorInfo::ispickstone() const {
  return ispickstone_;
}
inline void MonitorInfo::set_ispickstone(bool value) {
  set_has_ispickstone();
  ispickstone_ = value;
}

// optional bool ispickconsume = 7;
inline bool MonitorInfo::has_ispickconsume() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MonitorInfo::set_has_ispickconsume() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MonitorInfo::clear_has_ispickconsume() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MonitorInfo::clear_ispickconsume() {
  ispickconsume_ = false;
  clear_has_ispickconsume();
}
inline bool MonitorInfo::ispickconsume() const {
  return ispickconsume_;
}
inline void MonitorInfo::set_ispickconsume(bool value) {
  set_has_ispickconsume();
  ispickconsume_ = value;
}

// optional bool ispickmoney = 8;
inline bool MonitorInfo::has_ispickmoney() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MonitorInfo::set_has_ispickmoney() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MonitorInfo::clear_has_ispickmoney() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MonitorInfo::clear_ispickmoney() {
  ispickmoney_ = false;
  clear_has_ispickmoney();
}
inline bool MonitorInfo::ispickmoney() const {
  return ispickmoney_;
}
inline void MonitorInfo::set_ispickmoney(bool value) {
  set_has_ispickmoney();
  ispickmoney_ = value;
}

// optional bool ispickother = 9;
inline bool MonitorInfo::has_ispickother() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MonitorInfo::set_has_ispickother() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MonitorInfo::clear_has_ispickother() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MonitorInfo::clear_ispickother() {
  ispickother_ = false;
  clear_has_ispickother();
}
inline bool MonitorInfo::ispickother() const {
  return ispickother_;
}
inline void MonitorInfo::set_ispickother(bool value) {
  set_has_ispickother();
  ispickother_ = value;
}

// optional bool isgroup = 10;
inline bool MonitorInfo::has_isgroup() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MonitorInfo::set_has_isgroup() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MonitorInfo::clear_has_isgroup() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MonitorInfo::clear_isgroup() {
  isgroup_ = false;
  clear_has_isgroup();
}
inline bool MonitorInfo::isgroup() const {
  return isgroup_;
}
inline void MonitorInfo::set_isgroup(bool value) {
  set_has_isgroup();
  isgroup_ = value;
}

// optional bool assistskill = 11;
inline bool MonitorInfo::has_assistskill() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MonitorInfo::set_has_assistskill() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MonitorInfo::clear_has_assistskill() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MonitorInfo::clear_assistskill() {
  assistskill_ = false;
  clear_has_assistskill();
}
inline bool MonitorInfo::assistskill() const {
  return assistskill_;
}
inline void MonitorInfo::set_assistskill(bool value) {
  set_has_assistskill();
  assistskill_ = value;
}

// optional bool isbuyhp = 12;
inline bool MonitorInfo::has_isbuyhp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MonitorInfo::set_has_isbuyhp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MonitorInfo::clear_has_isbuyhp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MonitorInfo::clear_isbuyhp() {
  isbuyhp_ = false;
  clear_has_isbuyhp();
}
inline bool MonitorInfo::isbuyhp() const {
  return isbuyhp_;
}
inline void MonitorInfo::set_isbuyhp(bool value) {
  set_has_isbuyhp();
  isbuyhp_ = value;
}

// optional int32 hpbuytype = 13;
inline bool MonitorInfo::has_hpbuytype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MonitorInfo::set_has_hpbuytype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MonitorInfo::clear_has_hpbuytype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MonitorInfo::clear_hpbuytype() {
  hpbuytype_ = 0;
  clear_has_hpbuytype();
}
inline ::google::protobuf::int32 MonitorInfo::hpbuytype() const {
  return hpbuytype_;
}
inline void MonitorInfo::set_hpbuytype(::google::protobuf::int32 value) {
  set_has_hpbuytype();
  hpbuytype_ = value;
}

// optional bool isbuymp = 14;
inline bool MonitorInfo::has_isbuymp() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MonitorInfo::set_has_isbuymp() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MonitorInfo::clear_has_isbuymp() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MonitorInfo::clear_isbuymp() {
  isbuymp_ = false;
  clear_has_isbuymp();
}
inline bool MonitorInfo::isbuymp() const {
  return isbuymp_;
}
inline void MonitorInfo::set_isbuymp(bool value) {
  set_has_isbuymp();
  isbuymp_ = value;
}

// optional int32 mpbuytype = 15;
inline bool MonitorInfo::has_mpbuytype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MonitorInfo::set_has_mpbuytype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MonitorInfo::clear_has_mpbuytype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MonitorInfo::clear_mpbuytype() {
  mpbuytype_ = 0;
  clear_has_mpbuytype();
}
inline ::google::protobuf::int32 MonitorInfo::mpbuytype() const {
  return mpbuytype_;
}
inline void MonitorInfo::set_mpbuytype(::google::protobuf::int32 value) {
  set_has_mpbuytype();
  mpbuytype_ = value;
}

// optional bool isrevalsit = 16;
inline bool MonitorInfo::has_isrevalsit() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MonitorInfo::set_has_isrevalsit() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MonitorInfo::clear_has_isrevalsit() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MonitorInfo::clear_isrevalsit() {
  isrevalsit_ = false;
  clear_has_isrevalsit();
}
inline bool MonitorInfo::isrevalsit() const {
  return isrevalsit_;
}
inline void MonitorInfo::set_isrevalsit(bool value) {
  set_has_isrevalsit();
  isrevalsit_ = value;
}

// optional bool isuseexp = 17;
inline bool MonitorInfo::has_isuseexp() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MonitorInfo::set_has_isuseexp() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MonitorInfo::clear_has_isuseexp() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MonitorInfo::clear_isuseexp() {
  isuseexp_ = false;
  clear_has_isuseexp();
}
inline bool MonitorInfo::isuseexp() const {
  return isuseexp_;
}
inline void MonitorInfo::set_isuseexp(bool value) {
  set_has_isuseexp();
  isuseexp_ = value;
}

// optional int32 hp = 18;
inline bool MonitorInfo::has_hp() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MonitorInfo::set_has_hp() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MonitorInfo::clear_has_hp() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MonitorInfo::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 MonitorInfo::hp() const {
  return hp_;
}
inline void MonitorInfo::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// optional bool hpuse = 19;
inline bool MonitorInfo::has_hpuse() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MonitorInfo::set_has_hpuse() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MonitorInfo::clear_has_hpuse() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MonitorInfo::clear_hpuse() {
  hpuse_ = false;
  clear_has_hpuse();
}
inline bool MonitorInfo::hpuse() const {
  return hpuse_;
}
inline void MonitorInfo::set_hpuse(bool value) {
  set_has_hpuse();
  hpuse_ = value;
}

// optional int32 mp = 20;
inline bool MonitorInfo::has_mp() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MonitorInfo::set_has_mp() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MonitorInfo::clear_has_mp() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MonitorInfo::clear_mp() {
  mp_ = 0;
  clear_has_mp();
}
inline ::google::protobuf::int32 MonitorInfo::mp() const {
  return mp_;
}
inline void MonitorInfo::set_mp(::google::protobuf::int32 value) {
  set_has_mp();
  mp_ = value;
}

// optional bool mpuse = 21;
inline bool MonitorInfo::has_mpuse() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MonitorInfo::set_has_mpuse() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MonitorInfo::clear_has_mpuse() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MonitorInfo::clear_mpuse() {
  mpuse_ = false;
  clear_has_mpuse();
}
inline bool MonitorInfo::mpuse() const {
  return mpuse_;
}
inline void MonitorInfo::set_mpuse(bool value) {
  set_has_mpuse();
  mpuse_ = value;
}

// -------------------------------------------------------------------

// SettingInfo

// repeated int32 type = 1;
inline int SettingInfo::type_size() const {
  return type_.size();
}
inline void SettingInfo::clear_type() {
  type_.Clear();
}
inline ::google::protobuf::int32 SettingInfo::type(int index) const {
  return type_.Get(index);
}
inline void SettingInfo::set_type(int index, ::google::protobuf::int32 value) {
  type_.Set(index, value);
}
inline void SettingInfo::add_type(::google::protobuf::int32 value) {
  type_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SettingInfo::type() const {
  return type_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SettingInfo::mutable_type() {
  return &type_;
}

// repeated int32 value = 2;
inline int SettingInfo::value_size() const {
  return value_.size();
}
inline void SettingInfo::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::int32 SettingInfo::value(int index) const {
  return value_.Get(index);
}
inline void SettingInfo::set_value(int index, ::google::protobuf::int32 value) {
  value_.Set(index, value);
}
inline void SettingInfo::add_value(::google::protobuf::int32 value) {
  value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SettingInfo::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SettingInfo::mutable_value() {
  return &value_;
}

// -------------------------------------------------------------------

// HorseInfo

// required int32 id = 1;
inline bool HorseInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HorseInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HorseInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HorseInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 HorseInfo::id() const {
  return id_;
}
inline void HorseInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 mid = 2;
inline bool HorseInfo::has_mid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HorseInfo::set_has_mid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HorseInfo::clear_has_mid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HorseInfo::clear_mid() {
  mid_ = 0;
  clear_has_mid();
}
inline ::google::protobuf::int32 HorseInfo::mid() const {
  return mid_;
}
inline void HorseInfo::set_mid(::google::protobuf::int32 value) {
  set_has_mid();
  mid_ = value;
}

// optional int32 exp = 3;
inline bool HorseInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HorseInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HorseInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HorseInfo::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 HorseInfo::exp() const {
  return exp_;
}
inline void HorseInfo::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// repeated .PlayerInfo.SkinInfo skinIDList = 4;
inline int HorseInfo::skinidlist_size() const {
  return skinidlist_.size();
}
inline void HorseInfo::clear_skinidlist() {
  skinidlist_.Clear();
}
inline const ::PlayerInfo::SkinInfo& HorseInfo::skinidlist(int index) const {
  return skinidlist_.Get(index);
}
inline ::PlayerInfo::SkinInfo* HorseInfo::mutable_skinidlist(int index) {
  return skinidlist_.Mutable(index);
}
inline ::PlayerInfo::SkinInfo* HorseInfo::add_skinidlist() {
  return skinidlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::SkinInfo >&
HorseInfo::skinidlist() const {
  return skinidlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::SkinInfo >*
HorseInfo::mutable_skinidlist() {
  return &skinidlist_;
}

// -------------------------------------------------------------------

// SkinInfo

// required int32 skinID = 1;
inline bool SkinInfo::has_skinid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkinInfo::set_has_skinid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkinInfo::clear_has_skinid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkinInfo::clear_skinid() {
  skinid_ = 0;
  clear_has_skinid();
}
inline ::google::protobuf::int32 SkinInfo::skinid() const {
  return skinid_;
}
inline void SkinInfo::set_skinid(::google::protobuf::int32 value) {
  set_has_skinid();
  skinid_ = value;
}

// optional int64 endTime = 2;
inline bool SkinInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkinInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SkinInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SkinInfo::clear_endtime() {
  endtime_ = GOOGLE_LONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::int64 SkinInfo::endtime() const {
  return endtime_;
}
inline void SkinInfo::set_endtime(::google::protobuf::int64 value) {
  set_has_endtime();
  endtime_ = value;
}

// -------------------------------------------------------------------

// ItemInfo

// required int32 id = 1;
inline bool ItemInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ItemInfo::id() const {
  return id_;
}
inline void ItemInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 flag = 2;
inline bool ItemInfo::has_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemInfo::set_has_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemInfo::clear_has_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemInfo::clear_flag() {
  flag_ = 0u;
  clear_has_flag();
}
inline ::google::protobuf::uint32 ItemInfo::flag() const {
  return flag_;
}
inline void ItemInfo::set_flag(::google::protobuf::uint32 value) {
  set_has_flag();
  flag_ = value;
}

// repeated uint32 newattr = 3;
inline int ItemInfo::newattr_size() const {
  return newattr_.size();
}
inline void ItemInfo::clear_newattr() {
  newattr_.Clear();
}
inline ::google::protobuf::uint32 ItemInfo::newattr(int index) const {
  return newattr_.Get(index);
}
inline void ItemInfo::set_newattr(int index, ::google::protobuf::uint32 value) {
  newattr_.Set(index, value);
}
inline void ItemInfo::add_newattr(::google::protobuf::uint32 value) {
  newattr_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ItemInfo::newattr() const {
  return newattr_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ItemInfo::mutable_newattr() {
  return &newattr_;
}

// repeated int32 stoneid = 4;
inline int ItemInfo::stoneid_size() const {
  return stoneid_.size();
}
inline void ItemInfo::clear_stoneid() {
  stoneid_.Clear();
}
inline ::google::protobuf::int32 ItemInfo::stoneid(int index) const {
  return stoneid_.Get(index);
}
inline void ItemInfo::set_stoneid(int index, ::google::protobuf::int32 value) {
  stoneid_.Set(index, value);
}
inline void ItemInfo::add_stoneid(::google::protobuf::int32 value) {
  stoneid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ItemInfo::stoneid() const {
  return stoneid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ItemInfo::mutable_stoneid() {
  return &stoneid_;
}

// optional int64 endtime = 5;
inline bool ItemInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ItemInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ItemInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ItemInfo::clear_endtime() {
  endtime_ = GOOGLE_LONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::int64 ItemInfo::endtime() const {
  return endtime_;
}
inline void ItemInfo::set_endtime(::google::protobuf::int64 value) {
  set_has_endtime();
  endtime_ = value;
}

// optional int32 num = 6;
inline bool ItemInfo::has_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ItemInfo::set_has_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ItemInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ItemInfo::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 ItemInfo::num() const {
  return num_;
}
inline void ItemInfo::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// repeated int32 inlayPos = 7;
inline int ItemInfo::inlaypos_size() const {
  return inlaypos_.size();
}
inline void ItemInfo::clear_inlaypos() {
  inlaypos_.Clear();
}
inline ::google::protobuf::int32 ItemInfo::inlaypos(int index) const {
  return inlaypos_.Get(index);
}
inline void ItemInfo::set_inlaypos(int index, ::google::protobuf::int32 value) {
  inlaypos_.Set(index, value);
}
inline void ItemInfo::add_inlaypos(::google::protobuf::int32 value) {
  inlaypos_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ItemInfo::inlaypos() const {
  return inlaypos_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ItemInfo::mutable_inlaypos() {
  return &inlaypos_;
}

// repeated uint32 refineAttrLv = 8;
inline int ItemInfo::refineattrlv_size() const {
  return refineattrlv_.size();
}
inline void ItemInfo::clear_refineattrlv() {
  refineattrlv_.Clear();
}
inline ::google::protobuf::uint32 ItemInfo::refineattrlv(int index) const {
  return refineattrlv_.Get(index);
}
inline void ItemInfo::set_refineattrlv(int index, ::google::protobuf::uint32 value) {
  refineattrlv_.Set(index, value);
}
inline void ItemInfo::add_refineattrlv(::google::protobuf::uint32 value) {
  refineattrlv_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ItemInfo::refineattrlv() const {
  return refineattrlv_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ItemInfo::mutable_refineattrlv() {
  return &refineattrlv_;
}

// -------------------------------------------------------------------

// AttrValue

// required int32 id = 1;
inline bool AttrValue::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttrValue::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttrValue::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttrValue::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 AttrValue::id() const {
  return id_;
}
inline void AttrValue::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 value = 2;
inline bool AttrValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AttrValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AttrValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AttrValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 AttrValue::value() const {
  return value_;
}
inline void AttrValue::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// QuickContainer

// required int32 type = 1;
inline bool QuickContainer::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuickContainer::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuickContainer::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuickContainer::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 QuickContainer::type() const {
  return type_;
}
inline void QuickContainer::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 value = 2;
inline bool QuickContainer::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QuickContainer::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QuickContainer::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QuickContainer::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 QuickContainer::value() const {
  return value_;
}
inline void QuickContainer::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// WPlayerInfo

// optional .PlayerInfo.FriendInfoList friendlist = 1;
inline bool WPlayerInfo::has_friendlist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WPlayerInfo::set_has_friendlist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WPlayerInfo::clear_has_friendlist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WPlayerInfo::clear_friendlist() {
  if (friendlist_ != NULL) friendlist_->::PlayerInfo::FriendInfoList::Clear();
  clear_has_friendlist();
}
inline const ::PlayerInfo::FriendInfoList& WPlayerInfo::friendlist() const {
  return friendlist_ != NULL ? *friendlist_ : *default_instance_->friendlist_;
}
inline ::PlayerInfo::FriendInfoList* WPlayerInfo::mutable_friendlist() {
  set_has_friendlist();
  if (friendlist_ == NULL) friendlist_ = new ::PlayerInfo::FriendInfoList;
  return friendlist_;
}
inline ::PlayerInfo::FriendInfoList* WPlayerInfo::release_friendlist() {
  clear_has_friendlist();
  ::PlayerInfo::FriendInfoList* temp = friendlist_;
  friendlist_ = NULL;
  return temp;
}
inline void WPlayerInfo::set_allocated_friendlist(::PlayerInfo::FriendInfoList* friendlist) {
  delete friendlist_;
  friendlist_ = friendlist;
  if (friendlist) {
    set_has_friendlist();
  } else {
    clear_has_friendlist();
  }
}

// -------------------------------------------------------------------

// FriendInfoList

// repeated .PlayerInfo.FriendInfo friends = 1;
inline int FriendInfoList::friends_size() const {
  return friends_.size();
}
inline void FriendInfoList::clear_friends() {
  friends_.Clear();
}
inline const ::PlayerInfo::FriendInfo& FriendInfoList::friends(int index) const {
  return friends_.Get(index);
}
inline ::PlayerInfo::FriendInfo* FriendInfoList::mutable_friends(int index) {
  return friends_.Mutable(index);
}
inline ::PlayerInfo::FriendInfo* FriendInfoList::add_friends() {
  return friends_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::FriendInfo >&
FriendInfoList::friends() const {
  return friends_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::FriendInfo >*
FriendInfoList::mutable_friends() {
  return &friends_;
}

// repeated int64 inwho = 2;
inline int FriendInfoList::inwho_size() const {
  return inwho_.size();
}
inline void FriendInfoList::clear_inwho() {
  inwho_.Clear();
}
inline ::google::protobuf::int64 FriendInfoList::inwho(int index) const {
  return inwho_.Get(index);
}
inline void FriendInfoList::set_inwho(int index, ::google::protobuf::int64 value) {
  inwho_.Set(index, value);
}
inline void FriendInfoList::add_inwho(::google::protobuf::int64 value) {
  inwho_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
FriendInfoList::inwho() const {
  return inwho_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
FriendInfoList::mutable_inwho() {
  return &inwho_;
}

// optional int32 m_ReceiveCounts = 3;
inline bool FriendInfoList::has_m_receivecounts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FriendInfoList::set_has_m_receivecounts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FriendInfoList::clear_has_m_receivecounts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FriendInfoList::clear_m_receivecounts() {
  m_receivecounts_ = 0;
  clear_has_m_receivecounts();
}
inline ::google::protobuf::int32 FriendInfoList::m_receivecounts() const {
  return m_receivecounts_;
}
inline void FriendInfoList::set_m_receivecounts(::google::protobuf::int32 value) {
  set_has_m_receivecounts();
  m_receivecounts_ = value;
}

// optional int32 m_SendCounts = 4;
inline bool FriendInfoList::has_m_sendcounts() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FriendInfoList::set_has_m_sendcounts() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FriendInfoList::clear_has_m_sendcounts() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FriendInfoList::clear_m_sendcounts() {
  m_sendcounts_ = 0;
  clear_has_m_sendcounts();
}
inline ::google::protobuf::int32 FriendInfoList::m_sendcounts() const {
  return m_sendcounts_;
}
inline void FriendInfoList::set_m_sendcounts(::google::protobuf::int32 value) {
  set_has_m_sendcounts();
  m_sendcounts_ = value;
}

// optional int64 m_ResetTime = 5;
inline bool FriendInfoList::has_m_resettime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FriendInfoList::set_has_m_resettime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FriendInfoList::clear_has_m_resettime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FriendInfoList::clear_m_resettime() {
  m_resettime_ = GOOGLE_LONGLONG(0);
  clear_has_m_resettime();
}
inline ::google::protobuf::int64 FriendInfoList::m_resettime() const {
  return m_resettime_;
}
inline void FriendInfoList::set_m_resettime(::google::protobuf::int64 value) {
  set_has_m_resettime();
  m_resettime_ = value;
}

// optional int64 m_marryId = 6;
inline bool FriendInfoList::has_m_marryid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FriendInfoList::set_has_m_marryid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FriendInfoList::clear_has_m_marryid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FriendInfoList::clear_m_marryid() {
  m_marryid_ = GOOGLE_LONGLONG(0);
  clear_has_m_marryid();
}
inline ::google::protobuf::int64 FriendInfoList::m_marryid() const {
  return m_marryid_;
}
inline void FriendInfoList::set_m_marryid(::google::protobuf::int64 value) {
  set_has_m_marryid();
  m_marryid_ = value;
}

// repeated int64 m_Invited = 7;
inline int FriendInfoList::m_invited_size() const {
  return m_invited_.size();
}
inline void FriendInfoList::clear_m_invited() {
  m_invited_.Clear();
}
inline ::google::protobuf::int64 FriendInfoList::m_invited(int index) const {
  return m_invited_.Get(index);
}
inline void FriendInfoList::set_m_invited(int index, ::google::protobuf::int64 value) {
  m_invited_.Set(index, value);
}
inline void FriendInfoList::add_m_invited(::google::protobuf::int64 value) {
  m_invited_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
FriendInfoList::m_invited() const {
  return m_invited_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
FriendInfoList::mutable_m_invited() {
  return &m_invited_;
}

// -------------------------------------------------------------------

// FriendInfo

// required int32 type = 1;
inline bool FriendInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FriendInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FriendInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FriendInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 FriendInfo::type() const {
  return type_;
}
inline void FriendInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int64 charid = 2;
inline bool FriendInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FriendInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FriendInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FriendInfo::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 FriendInfo::charid() const {
  return charid_;
}
inline void FriendInfo::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// required string friendname = 3;
inline bool FriendInfo::has_friendname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FriendInfo::set_has_friendname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FriendInfo::clear_has_friendname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FriendInfo::clear_friendname() {
  if (friendname_ != &::google::protobuf::internal::kEmptyString) {
    friendname_->clear();
  }
  clear_has_friendname();
}
inline const ::std::string& FriendInfo::friendname() const {
  return *friendname_;
}
inline void FriendInfo::set_friendname(const ::std::string& value) {
  set_has_friendname();
  if (friendname_ == &::google::protobuf::internal::kEmptyString) {
    friendname_ = new ::std::string;
  }
  friendname_->assign(value);
}
inline void FriendInfo::set_friendname(const char* value) {
  set_has_friendname();
  if (friendname_ == &::google::protobuf::internal::kEmptyString) {
    friendname_ = new ::std::string;
  }
  friendname_->assign(value);
}
inline void FriendInfo::set_friendname(const char* value, size_t size) {
  set_has_friendname();
  if (friendname_ == &::google::protobuf::internal::kEmptyString) {
    friendname_ = new ::std::string;
  }
  friendname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FriendInfo::mutable_friendname() {
  set_has_friendname();
  if (friendname_ == &::google::protobuf::internal::kEmptyString) {
    friendname_ = new ::std::string;
  }
  return friendname_;
}
inline ::std::string* FriendInfo::release_friendname() {
  clear_has_friendname();
  if (friendname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = friendname_;
    friendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FriendInfo::set_allocated_friendname(::std::string* friendname) {
  if (friendname_ != &::google::protobuf::internal::kEmptyString) {
    delete friendname_;
  }
  if (friendname) {
    set_has_friendname();
    friendname_ = friendname;
  } else {
    clear_has_friendname();
    friendname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 lv = 4;
inline bool FriendInfo::has_lv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FriendInfo::set_has_lv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FriendInfo::clear_has_lv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FriendInfo::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 FriendInfo::lv() const {
  return lv_;
}
inline void FriendInfo::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// optional int32 profession = 5;
inline bool FriendInfo::has_profession() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FriendInfo::set_has_profession() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FriendInfo::clear_has_profession() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FriendInfo::clear_profession() {
  profession_ = 0;
  clear_has_profession();
}
inline ::google::protobuf::int32 FriendInfo::profession() const {
  return profession_;
}
inline void FriendInfo::set_profession(::google::protobuf::int32 value) {
  set_has_profession();
  profession_ = value;
}

// optional int32 hatred = 6;
inline bool FriendInfo::has_hatred() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FriendInfo::set_has_hatred() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FriendInfo::clear_has_hatred() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FriendInfo::clear_hatred() {
  hatred_ = 0;
  clear_has_hatred();
}
inline ::google::protobuf::int32 FriendInfo::hatred() const {
  return hatred_;
}
inline void FriendInfo::set_hatred(::google::protobuf::int32 value) {
  set_has_hatred();
  hatred_ = value;
}

// optional int32 cohesion = 7;
inline bool FriendInfo::has_cohesion() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FriendInfo::set_has_cohesion() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FriendInfo::clear_has_cohesion() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FriendInfo::clear_cohesion() {
  cohesion_ = 0;
  clear_has_cohesion();
}
inline ::google::protobuf::int32 FriendInfo::cohesion() const {
  return cohesion_;
}
inline void FriendInfo::set_cohesion(::google::protobuf::int32 value) {
  set_has_cohesion();
  cohesion_ = value;
}

// optional int32 vipLevel = 8;
inline bool FriendInfo::has_viplevel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FriendInfo::set_has_viplevel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FriendInfo::clear_has_viplevel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FriendInfo::clear_viplevel() {
  viplevel_ = 0;
  clear_has_viplevel();
}
inline ::google::protobuf::int32 FriendInfo::viplevel() const {
  return viplevel_;
}
inline void FriendInfo::set_viplevel(::google::protobuf::int32 value) {
  set_has_viplevel();
  viplevel_ = value;
}

// optional int32 fighting = 9;
inline bool FriendInfo::has_fighting() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FriendInfo::set_has_fighting() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FriendInfo::clear_has_fighting() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FriendInfo::clear_fighting() {
  fighting_ = 0;
  clear_has_fighting();
}
inline ::google::protobuf::int32 FriendInfo::fighting() const {
  return fighting_;
}
inline void FriendInfo::set_fighting(::google::protobuf::int32 value) {
  set_has_fighting();
  fighting_ = value;
}

// optional int32 sex = 10;
inline bool FriendInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FriendInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FriendInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FriendInfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 FriendInfo::sex() const {
  return sex_;
}
inline void FriendInfo::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// -------------------------------------------------------------------

// InstanceInfoList

// repeated .PlayerInfo.InstanceDiffculty diffcultyInfo = 1;
inline int InstanceInfoList::diffcultyinfo_size() const {
  return diffcultyinfo_.size();
}
inline void InstanceInfoList::clear_diffcultyinfo() {
  diffcultyinfo_.Clear();
}
inline const ::PlayerInfo::InstanceDiffculty& InstanceInfoList::diffcultyinfo(int index) const {
  return diffcultyinfo_.Get(index);
}
inline ::PlayerInfo::InstanceDiffculty* InstanceInfoList::mutable_diffcultyinfo(int index) {
  return diffcultyinfo_.Mutable(index);
}
inline ::PlayerInfo::InstanceDiffculty* InstanceInfoList::add_diffcultyinfo() {
  return diffcultyinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceDiffculty >&
InstanceInfoList::diffcultyinfo() const {
  return diffcultyinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceDiffculty >*
InstanceInfoList::mutable_diffcultyinfo() {
  return &diffcultyinfo_;
}

// repeated .PlayerInfo.InstanceVip vipInfo = 2;
inline int InstanceInfoList::vipinfo_size() const {
  return vipinfo_.size();
}
inline void InstanceInfoList::clear_vipinfo() {
  vipinfo_.Clear();
}
inline const ::PlayerInfo::InstanceVip& InstanceInfoList::vipinfo(int index) const {
  return vipinfo_.Get(index);
}
inline ::PlayerInfo::InstanceVip* InstanceInfoList::mutable_vipinfo(int index) {
  return vipinfo_.Mutable(index);
}
inline ::PlayerInfo::InstanceVip* InstanceInfoList::add_vipinfo() {
  return vipinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceVip >&
InstanceInfoList::vipinfo() const {
  return vipinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceVip >*
InstanceInfoList::mutable_vipinfo() {
  return &vipinfo_;
}

// repeated .PlayerInfo.InstanceDiffculty expInfo = 3;
inline int InstanceInfoList::expinfo_size() const {
  return expinfo_.size();
}
inline void InstanceInfoList::clear_expinfo() {
  expinfo_.Clear();
}
inline const ::PlayerInfo::InstanceDiffculty& InstanceInfoList::expinfo(int index) const {
  return expinfo_.Get(index);
}
inline ::PlayerInfo::InstanceDiffculty* InstanceInfoList::mutable_expinfo(int index) {
  return expinfo_.Mutable(index);
}
inline ::PlayerInfo::InstanceDiffculty* InstanceInfoList::add_expinfo() {
  return expinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceDiffculty >&
InstanceInfoList::expinfo() const {
  return expinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceDiffculty >*
InstanceInfoList::mutable_expinfo() {
  return &expinfo_;
}

// repeated .PlayerInfo.InstanceDiffculty moneyInfo = 4;
inline int InstanceInfoList::moneyinfo_size() const {
  return moneyinfo_.size();
}
inline void InstanceInfoList::clear_moneyinfo() {
  moneyinfo_.Clear();
}
inline const ::PlayerInfo::InstanceDiffculty& InstanceInfoList::moneyinfo(int index) const {
  return moneyinfo_.Get(index);
}
inline ::PlayerInfo::InstanceDiffculty* InstanceInfoList::mutable_moneyinfo(int index) {
  return moneyinfo_.Mutable(index);
}
inline ::PlayerInfo::InstanceDiffculty* InstanceInfoList::add_moneyinfo() {
  return moneyinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceDiffculty >&
InstanceInfoList::moneyinfo() const {
  return moneyinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceDiffculty >*
InstanceInfoList::mutable_moneyinfo() {
  return &moneyinfo_;
}

// -------------------------------------------------------------------

// InstanceDiffculty

// required int32 mapId = 1;
inline bool InstanceDiffculty::has_mapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceDiffculty::set_has_mapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceDiffculty::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceDiffculty::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 InstanceDiffculty::mapid() const {
  return mapid_;
}
inline void InstanceDiffculty::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
}

// optional int32 pass = 2;
inline bool InstanceDiffculty::has_pass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceDiffculty::set_has_pass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceDiffculty::clear_has_pass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceDiffculty::clear_pass() {
  pass_ = 0;
  clear_has_pass();
}
inline ::google::protobuf::int32 InstanceDiffculty::pass() const {
  return pass_;
}
inline void InstanceDiffculty::set_pass(::google::protobuf::int32 value) {
  set_has_pass();
  pass_ = value;
}

// optional int32 num = 3;
inline bool InstanceDiffculty::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstanceDiffculty::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstanceDiffculty::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstanceDiffculty::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 InstanceDiffculty::num() const {
  return num_;
}
inline void InstanceDiffculty::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 time = 4;
inline bool InstanceDiffculty::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstanceDiffculty::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstanceDiffculty::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstanceDiffculty::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 InstanceDiffculty::time() const {
  return time_;
}
inline void InstanceDiffculty::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// optional int32 reset = 5;
inline bool InstanceDiffculty::has_reset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstanceDiffculty::set_has_reset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstanceDiffculty::clear_has_reset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstanceDiffculty::clear_reset() {
  reset_ = 0;
  clear_has_reset();
}
inline ::google::protobuf::int32 InstanceDiffculty::reset() const {
  return reset_;
}
inline void InstanceDiffculty::set_reset(::google::protobuf::int32 value) {
  set_has_reset();
  reset_ = value;
}

// -------------------------------------------------------------------

// InstanceVip

// required int32 mapId = 1;
inline bool InstanceVip::has_mapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceVip::set_has_mapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceVip::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceVip::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 InstanceVip::mapid() const {
  return mapid_;
}
inline void InstanceVip::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
}

// optional int32 pass = 2;
inline bool InstanceVip::has_pass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceVip::set_has_pass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceVip::clear_has_pass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceVip::clear_pass() {
  pass_ = 0;
  clear_has_pass();
}
inline ::google::protobuf::int32 InstanceVip::pass() const {
  return pass_;
}
inline void InstanceVip::set_pass(::google::protobuf::int32 value) {
  set_has_pass();
  pass_ = value;
}

// optional int32 num = 3;
inline bool InstanceVip::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstanceVip::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstanceVip::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstanceVip::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 InstanceVip::num() const {
  return num_;
}
inline void InstanceVip::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int64 time = 4;
inline bool InstanceVip::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstanceVip::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstanceVip::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstanceVip::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 InstanceVip::time() const {
  return time_;
}
inline void InstanceVip::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// InstanceInfoTwoDays

// optional .PlayerInfo.InstanceInfoList todayinfo = 1;
inline bool InstanceInfoTwoDays::has_todayinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceInfoTwoDays::set_has_todayinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceInfoTwoDays::clear_has_todayinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceInfoTwoDays::clear_todayinfo() {
  if (todayinfo_ != NULL) todayinfo_->::PlayerInfo::InstanceInfoList::Clear();
  clear_has_todayinfo();
}
inline const ::PlayerInfo::InstanceInfoList& InstanceInfoTwoDays::todayinfo() const {
  return todayinfo_ != NULL ? *todayinfo_ : *default_instance_->todayinfo_;
}
inline ::PlayerInfo::InstanceInfoList* InstanceInfoTwoDays::mutable_todayinfo() {
  set_has_todayinfo();
  if (todayinfo_ == NULL) todayinfo_ = new ::PlayerInfo::InstanceInfoList;
  return todayinfo_;
}
inline ::PlayerInfo::InstanceInfoList* InstanceInfoTwoDays::release_todayinfo() {
  clear_has_todayinfo();
  ::PlayerInfo::InstanceInfoList* temp = todayinfo_;
  todayinfo_ = NULL;
  return temp;
}
inline void InstanceInfoTwoDays::set_allocated_todayinfo(::PlayerInfo::InstanceInfoList* todayinfo) {
  delete todayinfo_;
  todayinfo_ = todayinfo;
  if (todayinfo) {
    set_has_todayinfo();
  } else {
    clear_has_todayinfo();
  }
}

// optional .PlayerInfo.InstanceInfoList yesterdayinfo = 2;
inline bool InstanceInfoTwoDays::has_yesterdayinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceInfoTwoDays::set_has_yesterdayinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceInfoTwoDays::clear_has_yesterdayinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceInfoTwoDays::clear_yesterdayinfo() {
  if (yesterdayinfo_ != NULL) yesterdayinfo_->::PlayerInfo::InstanceInfoList::Clear();
  clear_has_yesterdayinfo();
}
inline const ::PlayerInfo::InstanceInfoList& InstanceInfoTwoDays::yesterdayinfo() const {
  return yesterdayinfo_ != NULL ? *yesterdayinfo_ : *default_instance_->yesterdayinfo_;
}
inline ::PlayerInfo::InstanceInfoList* InstanceInfoTwoDays::mutable_yesterdayinfo() {
  set_has_yesterdayinfo();
  if (yesterdayinfo_ == NULL) yesterdayinfo_ = new ::PlayerInfo::InstanceInfoList;
  return yesterdayinfo_;
}
inline ::PlayerInfo::InstanceInfoList* InstanceInfoTwoDays::release_yesterdayinfo() {
  clear_has_yesterdayinfo();
  ::PlayerInfo::InstanceInfoList* temp = yesterdayinfo_;
  yesterdayinfo_ = NULL;
  return temp;
}
inline void InstanceInfoTwoDays::set_allocated_yesterdayinfo(::PlayerInfo::InstanceInfoList* yesterdayinfo) {
  delete yesterdayinfo_;
  yesterdayinfo_ = yesterdayinfo;
  if (yesterdayinfo) {
    set_has_yesterdayinfo();
  } else {
    clear_has_yesterdayinfo();
  }
}

// -------------------------------------------------------------------

// PrestigeInfoList

// optional .PlayerInfo.PrestigeInfo info = 1;
inline bool PrestigeInfoList::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrestigeInfoList::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrestigeInfoList::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrestigeInfoList::clear_info() {
  if (info_ != NULL) info_->::PlayerInfo::PrestigeInfo::Clear();
  clear_has_info();
}
inline const ::PlayerInfo::PrestigeInfo& PrestigeInfoList::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::PlayerInfo::PrestigeInfo* PrestigeInfoList::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::PlayerInfo::PrestigeInfo;
  return info_;
}
inline ::PlayerInfo::PrestigeInfo* PrestigeInfoList::release_info() {
  clear_has_info();
  ::PlayerInfo::PrestigeInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void PrestigeInfoList::set_allocated_info(::PlayerInfo::PrestigeInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional .PlayerInfo.DBAchShopInfo shop = 2;
inline bool PrestigeInfoList::has_shop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrestigeInfoList::set_has_shop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrestigeInfoList::clear_has_shop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrestigeInfoList::clear_shop() {
  if (shop_ != NULL) shop_->::PlayerInfo::DBAchShopInfo::Clear();
  clear_has_shop();
}
inline const ::PlayerInfo::DBAchShopInfo& PrestigeInfoList::shop() const {
  return shop_ != NULL ? *shop_ : *default_instance_->shop_;
}
inline ::PlayerInfo::DBAchShopInfo* PrestigeInfoList::mutable_shop() {
  set_has_shop();
  if (shop_ == NULL) shop_ = new ::PlayerInfo::DBAchShopInfo;
  return shop_;
}
inline ::PlayerInfo::DBAchShopInfo* PrestigeInfoList::release_shop() {
  clear_has_shop();
  ::PlayerInfo::DBAchShopInfo* temp = shop_;
  shop_ = NULL;
  return temp;
}
inline void PrestigeInfoList::set_allocated_shop(::PlayerInfo::DBAchShopInfo* shop) {
  delete shop_;
  shop_ = shop;
  if (shop) {
    set_has_shop();
  } else {
    clear_has_shop();
  }
}

// -------------------------------------------------------------------

// PrestigeInfo

// repeated .PlayerInfo.PrestigeContent prestigeinfos = 1;
inline int PrestigeInfo::prestigeinfos_size() const {
  return prestigeinfos_.size();
}
inline void PrestigeInfo::clear_prestigeinfos() {
  prestigeinfos_.Clear();
}
inline const ::PlayerInfo::PrestigeContent& PrestigeInfo::prestigeinfos(int index) const {
  return prestigeinfos_.Get(index);
}
inline ::PlayerInfo::PrestigeContent* PrestigeInfo::mutable_prestigeinfos(int index) {
  return prestigeinfos_.Mutable(index);
}
inline ::PlayerInfo::PrestigeContent* PrestigeInfo::add_prestigeinfos() {
  return prestigeinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::PrestigeContent >&
PrestigeInfo::prestigeinfos() const {
  return prestigeinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::PrestigeContent >*
PrestigeInfo::mutable_prestigeinfos() {
  return &prestigeinfos_;
}

// -------------------------------------------------------------------

// PrestigeContent

// required int32 prestigeType = 1;
inline bool PrestigeContent::has_prestigetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrestigeContent::set_has_prestigetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrestigeContent::clear_has_prestigetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrestigeContent::clear_prestigetype() {
  prestigetype_ = 0;
  clear_has_prestigetype();
}
inline ::google::protobuf::int32 PrestigeContent::prestigetype() const {
  return prestigetype_;
}
inline void PrestigeContent::set_prestigetype(::google::protobuf::int32 value) {
  set_has_prestigetype();
  prestigetype_ = value;
}

// required int32 prestigeID = 2;
inline bool PrestigeContent::has_prestigeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrestigeContent::set_has_prestigeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrestigeContent::clear_has_prestigeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrestigeContent::clear_prestigeid() {
  prestigeid_ = 0;
  clear_has_prestigeid();
}
inline ::google::protobuf::int32 PrestigeContent::prestigeid() const {
  return prestigeid_;
}
inline void PrestigeContent::set_prestigeid(::google::protobuf::int32 value) {
  set_has_prestigeid();
  prestigeid_ = value;
}

// required int32 num = 3;
inline bool PrestigeContent::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrestigeContent::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrestigeContent::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrestigeContent::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 PrestigeContent::num() const {
  return num_;
}
inline void PrestigeContent::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// required int32 isComplete = 4;
inline bool PrestigeContent::has_iscomplete() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PrestigeContent::set_has_iscomplete() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PrestigeContent::clear_has_iscomplete() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PrestigeContent::clear_iscomplete() {
  iscomplete_ = 0;
  clear_has_iscomplete();
}
inline ::google::protobuf::int32 PrestigeContent::iscomplete() const {
  return iscomplete_;
}
inline void PrestigeContent::set_iscomplete(::google::protobuf::int32 value) {
  set_has_iscomplete();
  iscomplete_ = value;
}

// required int32 hadGet = 5;
inline bool PrestigeContent::has_hadget() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PrestigeContent::set_has_hadget() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PrestigeContent::clear_has_hadget() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PrestigeContent::clear_hadget() {
  hadget_ = 0;
  clear_has_hadget();
}
inline ::google::protobuf::int32 PrestigeContent::hadget() const {
  return hadget_;
}
inline void PrestigeContent::set_hadget(::google::protobuf::int32 value) {
  set_has_hadget();
  hadget_ = value;
}

// -------------------------------------------------------------------

// TitleInfoList

// optional .PlayerInfo.TitleInfo info = 1;
inline bool TitleInfoList::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TitleInfoList::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TitleInfoList::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TitleInfoList::clear_info() {
  if (info_ != NULL) info_->::PlayerInfo::TitleInfo::Clear();
  clear_has_info();
}
inline const ::PlayerInfo::TitleInfo& TitleInfoList::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::PlayerInfo::TitleInfo* TitleInfoList::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::PlayerInfo::TitleInfo;
  return info_;
}
inline ::PlayerInfo::TitleInfo* TitleInfoList::release_info() {
  clear_has_info();
  ::PlayerInfo::TitleInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void TitleInfoList::set_allocated_info(::PlayerInfo::TitleInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// TitleInfo

// repeated .PlayerInfo.TitleStatus titleinfo = 1;
inline int TitleInfo::titleinfo_size() const {
  return titleinfo_.size();
}
inline void TitleInfo::clear_titleinfo() {
  titleinfo_.Clear();
}
inline const ::PlayerInfo::TitleStatus& TitleInfo::titleinfo(int index) const {
  return titleinfo_.Get(index);
}
inline ::PlayerInfo::TitleStatus* TitleInfo::mutable_titleinfo(int index) {
  return titleinfo_.Mutable(index);
}
inline ::PlayerInfo::TitleStatus* TitleInfo::add_titleinfo() {
  return titleinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::TitleStatus >&
TitleInfo::titleinfo() const {
  return titleinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::TitleStatus >*
TitleInfo::mutable_titleinfo() {
  return &titleinfo_;
}

// -------------------------------------------------------------------

// TitleStatus

// required int32 titleId = 1;
inline bool TitleStatus::has_titleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TitleStatus::set_has_titleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TitleStatus::clear_has_titleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TitleStatus::clear_titleid() {
  titleid_ = 0;
  clear_has_titleid();
}
inline ::google::protobuf::int32 TitleStatus::titleid() const {
  return titleid_;
}
inline void TitleStatus::set_titleid(::google::protobuf::int32 value) {
  set_has_titleid();
  titleid_ = value;
}

// required int32 titleStatus = 2;
inline bool TitleStatus::has_titlestatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TitleStatus::set_has_titlestatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TitleStatus::clear_has_titlestatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TitleStatus::clear_titlestatus() {
  titlestatus_ = 0;
  clear_has_titlestatus();
}
inline ::google::protobuf::int32 TitleStatus::titlestatus() const {
  return titlestatus_;
}
inline void TitleStatus::set_titlestatus(::google::protobuf::int32 value) {
  set_has_titlestatus();
  titlestatus_ = value;
}

// required int32 titleActive = 3;
inline bool TitleStatus::has_titleactive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TitleStatus::set_has_titleactive() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TitleStatus::clear_has_titleactive() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TitleStatus::clear_titleactive() {
  titleactive_ = 0;
  clear_has_titleactive();
}
inline ::google::protobuf::int32 TitleStatus::titleactive() const {
  return titleactive_;
}
inline void TitleStatus::set_titleactive(::google::protobuf::int32 value) {
  set_has_titleactive();
  titleactive_ = value;
}

// -------------------------------------------------------------------

// DestinationInfoList

// optional .PlayerInfo.DestinationInfo info = 1;
inline bool DestinationInfoList::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DestinationInfoList::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DestinationInfoList::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DestinationInfoList::clear_info() {
  if (info_ != NULL) info_->::PlayerInfo::DestinationInfo::Clear();
  clear_has_info();
}
inline const ::PlayerInfo::DestinationInfo& DestinationInfoList::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::PlayerInfo::DestinationInfo* DestinationInfoList::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::PlayerInfo::DestinationInfo;
  return info_;
}
inline ::PlayerInfo::DestinationInfo* DestinationInfoList::release_info() {
  clear_has_info();
  ::PlayerInfo::DestinationInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void DestinationInfoList::set_allocated_info(::PlayerInfo::DestinationInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// DestinationInfo

// repeated .PlayerInfo.DestinationContent destinationinfos = 1;
inline int DestinationInfo::destinationinfos_size() const {
  return destinationinfos_.size();
}
inline void DestinationInfo::clear_destinationinfos() {
  destinationinfos_.Clear();
}
inline const ::PlayerInfo::DestinationContent& DestinationInfo::destinationinfos(int index) const {
  return destinationinfos_.Get(index);
}
inline ::PlayerInfo::DestinationContent* DestinationInfo::mutable_destinationinfos(int index) {
  return destinationinfos_.Mutable(index);
}
inline ::PlayerInfo::DestinationContent* DestinationInfo::add_destinationinfos() {
  return destinationinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DestinationContent >&
DestinationInfo::destinationinfos() const {
  return destinationinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DestinationContent >*
DestinationInfo::mutable_destinationinfos() {
  return &destinationinfos_;
}

// -------------------------------------------------------------------

// DestinationContent

// required int32 destinationID = 1;
inline bool DestinationContent::has_destinationid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DestinationContent::set_has_destinationid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DestinationContent::clear_has_destinationid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DestinationContent::clear_destinationid() {
  destinationid_ = 0;
  clear_has_destinationid();
}
inline ::google::protobuf::int32 DestinationContent::destinationid() const {
  return destinationid_;
}
inline void DestinationContent::set_destinationid(::google::protobuf::int32 value) {
  set_has_destinationid();
  destinationid_ = value;
}

// optional int32 destinationType = 2;
inline bool DestinationContent::has_destinationtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DestinationContent::set_has_destinationtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DestinationContent::clear_has_destinationtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DestinationContent::clear_destinationtype() {
  destinationtype_ = 0;
  clear_has_destinationtype();
}
inline ::google::protobuf::int32 DestinationContent::destinationtype() const {
  return destinationtype_;
}
inline void DestinationContent::set_destinationtype(::google::protobuf::int32 value) {
  set_has_destinationtype();
  destinationtype_ = value;
}

// optional int32 num = 3;
inline bool DestinationContent::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DestinationContent::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DestinationContent::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DestinationContent::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 DestinationContent::num() const {
  return num_;
}
inline void DestinationContent::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 isComplete = 4;
inline bool DestinationContent::has_iscomplete() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DestinationContent::set_has_iscomplete() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DestinationContent::clear_has_iscomplete() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DestinationContent::clear_iscomplete() {
  iscomplete_ = 0;
  clear_has_iscomplete();
}
inline ::google::protobuf::int32 DestinationContent::iscomplete() const {
  return iscomplete_;
}
inline void DestinationContent::set_iscomplete(::google::protobuf::int32 value) {
  set_has_iscomplete();
  iscomplete_ = value;
}

// optional int32 hadGet = 5;
inline bool DestinationContent::has_hadget() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DestinationContent::set_has_hadget() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DestinationContent::clear_has_hadget() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DestinationContent::clear_hadget() {
  hadget_ = 0;
  clear_has_hadget();
}
inline ::google::protobuf::int32 DestinationContent::hadget() const {
  return hadget_;
}
inline void DestinationContent::set_hadget(::google::protobuf::int32 value) {
  set_has_hadget();
  hadget_ = value;
}

// -------------------------------------------------------------------

// SignInInfo

// optional int32 SignIn = 1;
inline bool SignInInfo::has_signin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignInInfo::set_has_signin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignInInfo::clear_has_signin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignInInfo::clear_signin() {
  signin_ = 0;
  clear_has_signin();
}
inline ::google::protobuf::int32 SignInInfo::signin() const {
  return signin_;
}
inline void SignInInfo::set_signin(::google::protobuf::int32 value) {
  set_has_signin();
  signin_ = value;
}

// optional int32 Reward = 2;
inline bool SignInInfo::has_reward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignInInfo::set_has_reward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignInInfo::clear_has_reward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignInInfo::clear_reward() {
  reward_ = 0;
  clear_has_reward();
}
inline ::google::protobuf::int32 SignInInfo::reward() const {
  return reward_;
}
inline void SignInInfo::set_reward(::google::protobuf::int32 value) {
  set_has_reward();
  reward_ = value;
}

// optional int32 totalLogin = 3;
inline bool SignInInfo::has_totallogin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignInInfo::set_has_totallogin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignInInfo::clear_has_totallogin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignInInfo::clear_totallogin() {
  totallogin_ = 0;
  clear_has_totallogin();
}
inline ::google::protobuf::int32 SignInInfo::totallogin() const {
  return totallogin_;
}
inline void SignInInfo::set_totallogin(::google::protobuf::int32 value) {
  set_has_totallogin();
  totallogin_ = value;
}

// optional int32 totalLoginReward = 4;
inline bool SignInInfo::has_totalloginreward() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignInInfo::set_has_totalloginreward() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignInInfo::clear_has_totalloginreward() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignInInfo::clear_totalloginreward() {
  totalloginreward_ = 0;
  clear_has_totalloginreward();
}
inline ::google::protobuf::int32 SignInInfo::totalloginreward() const {
  return totalloginreward_;
}
inline void SignInInfo::set_totalloginreward(::google::protobuf::int32 value) {
  set_has_totalloginreward();
  totalloginreward_ = value;
}

// optional bool firstChargeOverFlag = 5;
inline bool SignInInfo::has_firstchargeoverflag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignInInfo::set_has_firstchargeoverflag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignInInfo::clear_has_firstchargeoverflag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignInInfo::clear_firstchargeoverflag() {
  firstchargeoverflag_ = false;
  clear_has_firstchargeoverflag();
}
inline bool SignInInfo::firstchargeoverflag() const {
  return firstchargeoverflag_;
}
inline void SignInInfo::set_firstchargeoverflag(bool value) {
  set_has_firstchargeoverflag();
  firstchargeoverflag_ = value;
}

// -------------------------------------------------------------------

// CounterService

// repeated int32 id = 1;
inline int CounterService::id_size() const {
  return id_.size();
}
inline void CounterService::clear_id() {
  id_.Clear();
}
inline ::google::protobuf::int32 CounterService::id(int index) const {
  return id_.Get(index);
}
inline void CounterService::set_id(int index, ::google::protobuf::int32 value) {
  id_.Set(index, value);
}
inline void CounterService::add_id(::google::protobuf::int32 value) {
  id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CounterService::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CounterService::mutable_id() {
  return &id_;
}

// repeated int32 num = 2;
inline int CounterService::num_size() const {
  return num_.size();
}
inline void CounterService::clear_num() {
  num_.Clear();
}
inline ::google::protobuf::int32 CounterService::num(int index) const {
  return num_.Get(index);
}
inline void CounterService::set_num(int index, ::google::protobuf::int32 value) {
  num_.Set(index, value);
}
inline void CounterService::add_num(::google::protobuf::int32 value) {
  num_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
CounterService::num() const {
  return num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
CounterService::mutable_num() {
  return &num_;
}

// -------------------------------------------------------------------

// CounterServiceList

// optional .PlayerInfo.CounterService counter = 1;
inline bool CounterServiceList::has_counter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CounterServiceList::set_has_counter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CounterServiceList::clear_has_counter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CounterServiceList::clear_counter() {
  if (counter_ != NULL) counter_->::PlayerInfo::CounterService::Clear();
  clear_has_counter();
}
inline const ::PlayerInfo::CounterService& CounterServiceList::counter() const {
  return counter_ != NULL ? *counter_ : *default_instance_->counter_;
}
inline ::PlayerInfo::CounterService* CounterServiceList::mutable_counter() {
  set_has_counter();
  if (counter_ == NULL) counter_ = new ::PlayerInfo::CounterService;
  return counter_;
}
inline ::PlayerInfo::CounterService* CounterServiceList::release_counter() {
  clear_has_counter();
  ::PlayerInfo::CounterService* temp = counter_;
  counter_ = NULL;
  return temp;
}
inline void CounterServiceList::set_allocated_counter(::PlayerInfo::CounterService* counter) {
  delete counter_;
  counter_ = counter;
  if (counter) {
    set_has_counter();
  } else {
    clear_has_counter();
  }
}

// optional .PlayerInfo.CounterService yesterdaycounter = 2;
inline bool CounterServiceList::has_yesterdaycounter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CounterServiceList::set_has_yesterdaycounter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CounterServiceList::clear_has_yesterdaycounter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CounterServiceList::clear_yesterdaycounter() {
  if (yesterdaycounter_ != NULL) yesterdaycounter_->::PlayerInfo::CounterService::Clear();
  clear_has_yesterdaycounter();
}
inline const ::PlayerInfo::CounterService& CounterServiceList::yesterdaycounter() const {
  return yesterdaycounter_ != NULL ? *yesterdaycounter_ : *default_instance_->yesterdaycounter_;
}
inline ::PlayerInfo::CounterService* CounterServiceList::mutable_yesterdaycounter() {
  set_has_yesterdaycounter();
  if (yesterdaycounter_ == NULL) yesterdaycounter_ = new ::PlayerInfo::CounterService;
  return yesterdaycounter_;
}
inline ::PlayerInfo::CounterService* CounterServiceList::release_yesterdaycounter() {
  clear_has_yesterdaycounter();
  ::PlayerInfo::CounterService* temp = yesterdaycounter_;
  yesterdaycounter_ = NULL;
  return temp;
}
inline void CounterServiceList::set_allocated_yesterdaycounter(::PlayerInfo::CounterService* yesterdaycounter) {
  delete yesterdaycounter_;
  yesterdaycounter_ = yesterdaycounter;
  if (yesterdaycounter) {
    set_has_yesterdaycounter();
  } else {
    clear_has_yesterdaycounter();
  }
}

// optional int64 lastResetTime = 3;
inline bool CounterServiceList::has_lastresettime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CounterServiceList::set_has_lastresettime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CounterServiceList::clear_has_lastresettime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CounterServiceList::clear_lastresettime() {
  lastresettime_ = GOOGLE_LONGLONG(0);
  clear_has_lastresettime();
}
inline ::google::protobuf::int64 CounterServiceList::lastresettime() const {
  return lastresettime_;
}
inline void CounterServiceList::set_lastresettime(::google::protobuf::int64 value) {
  set_has_lastresettime();
  lastresettime_ = value;
}

// -------------------------------------------------------------------

// EscortInfo

// optional int32 line = 1;
inline bool EscortInfo::has_line() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EscortInfo::set_has_line() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EscortInfo::clear_has_line() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EscortInfo::clear_line() {
  line_ = 0;
  clear_has_line();
}
inline ::google::protobuf::int32 EscortInfo::line() const {
  return line_;
}
inline void EscortInfo::set_line(::google::protobuf::int32 value) {
  set_has_line();
  line_ = value;
}

// optional int32 quality = 2;
inline bool EscortInfo::has_quality() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EscortInfo::set_has_quality() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EscortInfo::clear_has_quality() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EscortInfo::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::google::protobuf::int32 EscortInfo::quality() const {
  return quality_;
}
inline void EscortInfo::set_quality(::google::protobuf::int32 value) {
  set_has_quality();
  quality_ = value;
}

// optional int32 robTimes = 3;
inline bool EscortInfo::has_robtimes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EscortInfo::set_has_robtimes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EscortInfo::clear_has_robtimes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EscortInfo::clear_robtimes() {
  robtimes_ = 0;
  clear_has_robtimes();
}
inline ::google::protobuf::int32 EscortInfo::robtimes() const {
  return robtimes_;
}
inline void EscortInfo::set_robtimes(::google::protobuf::int32 value) {
  set_has_robtimes();
  robtimes_ = value;
}

// optional int64 leftTimes = 4;
inline bool EscortInfo::has_lefttimes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EscortInfo::set_has_lefttimes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EscortInfo::clear_has_lefttimes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EscortInfo::clear_lefttimes() {
  lefttimes_ = GOOGLE_LONGLONG(0);
  clear_has_lefttimes();
}
inline ::google::protobuf::int64 EscortInfo::lefttimes() const {
  return lefttimes_;
}
inline void EscortInfo::set_lefttimes(::google::protobuf::int64 value) {
  set_has_lefttimes();
  lefttimes_ = value;
}

// optional int64 speedlefttime = 5;
inline bool EscortInfo::has_speedlefttime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EscortInfo::set_has_speedlefttime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EscortInfo::clear_has_speedlefttime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EscortInfo::clear_speedlefttime() {
  speedlefttime_ = GOOGLE_LONGLONG(0);
  clear_has_speedlefttime();
}
inline ::google::protobuf::int64 EscortInfo::speedlefttime() const {
  return speedlefttime_;
}
inline void EscortInfo::set_speedlefttime(::google::protobuf::int64 value) {
  set_has_speedlefttime();
  speedlefttime_ = value;
}

// optional int64 mapid = 6;
inline bool EscortInfo::has_mapid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EscortInfo::set_has_mapid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EscortInfo::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EscortInfo::clear_mapid() {
  mapid_ = GOOGLE_LONGLONG(0);
  clear_has_mapid();
}
inline ::google::protobuf::int64 EscortInfo::mapid() const {
  return mapid_;
}
inline void EscortInfo::set_mapid(::google::protobuf::int64 value) {
  set_has_mapid();
  mapid_ = value;
}

// optional int32 xpos = 7;
inline bool EscortInfo::has_xpos() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EscortInfo::set_has_xpos() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EscortInfo::clear_has_xpos() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EscortInfo::clear_xpos() {
  xpos_ = 0;
  clear_has_xpos();
}
inline ::google::protobuf::int32 EscortInfo::xpos() const {
  return xpos_;
}
inline void EscortInfo::set_xpos(::google::protobuf::int32 value) {
  set_has_xpos();
  xpos_ = value;
}

// optional int32 ypos = 8;
inline bool EscortInfo::has_ypos() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EscortInfo::set_has_ypos() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EscortInfo::clear_has_ypos() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EscortInfo::clear_ypos() {
  ypos_ = 0;
  clear_has_ypos();
}
inline ::google::protobuf::int32 EscortInfo::ypos() const {
  return ypos_;
}
inline void EscortInfo::set_ypos(::google::protobuf::int32 value) {
  set_has_ypos();
  ypos_ = value;
}

// optional int32 hp = 9;
inline bool EscortInfo::has_hp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EscortInfo::set_has_hp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EscortInfo::clear_has_hp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EscortInfo::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 EscortInfo::hp() const {
  return hp_;
}
inline void EscortInfo::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// optional int32 num = 10;
inline bool EscortInfo::has_num() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EscortInfo::set_has_num() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EscortInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EscortInfo::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 EscortInfo::num() const {
  return num_;
}
inline void EscortInfo::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 rewardExp = 11;
inline bool EscortInfo::has_rewardexp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EscortInfo::set_has_rewardexp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EscortInfo::clear_has_rewardexp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EscortInfo::clear_rewardexp() {
  rewardexp_ = 0;
  clear_has_rewardexp();
}
inline ::google::protobuf::int32 EscortInfo::rewardexp() const {
  return rewardexp_;
}
inline void EscortInfo::set_rewardexp(::google::protobuf::int32 value) {
  set_has_rewardexp();
  rewardexp_ = value;
}

// optional int32 rewardMoney = 12;
inline bool EscortInfo::has_rewardmoney() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EscortInfo::set_has_rewardmoney() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EscortInfo::clear_has_rewardmoney() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EscortInfo::clear_rewardmoney() {
  rewardmoney_ = 0;
  clear_has_rewardmoney();
}
inline ::google::protobuf::int32 EscortInfo::rewardmoney() const {
  return rewardmoney_;
}
inline void EscortInfo::set_rewardmoney(::google::protobuf::int32 value) {
  set_has_rewardmoney();
  rewardmoney_ = value;
}

// -------------------------------------------------------------------

// DanLuInfo

// optional int32 danluId = 1;
inline bool DanLuInfo::has_danluid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DanLuInfo::set_has_danluid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DanLuInfo::clear_has_danluid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DanLuInfo::clear_danluid() {
  danluid_ = 0;
  clear_has_danluid();
}
inline ::google::protobuf::int32 DanLuInfo::danluid() const {
  return danluid_;
}
inline void DanLuInfo::set_danluid(::google::protobuf::int32 value) {
  set_has_danluid();
  danluid_ = value;
}

// optional int32 exp = 2;
inline bool DanLuInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DanLuInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DanLuInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DanLuInfo::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 DanLuInfo::exp() const {
  return exp_;
}
inline void DanLuInfo::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 point = 3;
inline bool DanLuInfo::has_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DanLuInfo::set_has_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DanLuInfo::clear_has_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DanLuInfo::clear_point() {
  point_ = 0;
  clear_has_point();
}
inline ::google::protobuf::int32 DanLuInfo::point() const {
  return point_;
}
inline void DanLuInfo::set_point(::google::protobuf::int32 value) {
  set_has_point();
  point_ = value;
}

// repeated int32 itemID = 4;
inline int DanLuInfo::itemid_size() const {
  return itemid_.size();
}
inline void DanLuInfo::clear_itemid() {
  itemid_.Clear();
}
inline ::google::protobuf::int32 DanLuInfo::itemid(int index) const {
  return itemid_.Get(index);
}
inline void DanLuInfo::set_itemid(int index, ::google::protobuf::int32 value) {
  itemid_.Set(index, value);
}
inline void DanLuInfo::add_itemid(::google::protobuf::int32 value) {
  itemid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DanLuInfo::itemid() const {
  return itemid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DanLuInfo::mutable_itemid() {
  return &itemid_;
}

// optional int32 produceNum = 5;
inline bool DanLuInfo::has_producenum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DanLuInfo::set_has_producenum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DanLuInfo::clear_has_producenum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DanLuInfo::clear_producenum() {
  producenum_ = 0;
  clear_has_producenum();
}
inline ::google::protobuf::int32 DanLuInfo::producenum() const {
  return producenum_;
}
inline void DanLuInfo::set_producenum(::google::protobuf::int32 value) {
  set_has_producenum();
  producenum_ = value;
}

// repeated int32 itemPos = 6;
inline int DanLuInfo::itempos_size() const {
  return itempos_.size();
}
inline void DanLuInfo::clear_itempos() {
  itempos_.Clear();
}
inline ::google::protobuf::int32 DanLuInfo::itempos(int index) const {
  return itempos_.Get(index);
}
inline void DanLuInfo::set_itempos(int index, ::google::protobuf::int32 value) {
  itempos_.Set(index, value);
}
inline void DanLuInfo::add_itempos(::google::protobuf::int32 value) {
  itempos_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DanLuInfo::itempos() const {
  return itempos_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DanLuInfo::mutable_itempos() {
  return &itempos_;
}

// repeated int32 itemNum = 7;
inline int DanLuInfo::itemnum_size() const {
  return itemnum_.size();
}
inline void DanLuInfo::clear_itemnum() {
  itemnum_.Clear();
}
inline ::google::protobuf::int32 DanLuInfo::itemnum(int index) const {
  return itemnum_.Get(index);
}
inline void DanLuInfo::set_itemnum(int index, ::google::protobuf::int32 value) {
  itemnum_.Set(index, value);
}
inline void DanLuInfo::add_itemnum(::google::protobuf::int32 value) {
  itemnum_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DanLuInfo::itemnum() const {
  return itemnum_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DanLuInfo::mutable_itemnum() {
  return &itemnum_;
}

// -------------------------------------------------------------------

// PlayerVipInfo

// optional int32 giftInfo = 1;
inline bool PlayerVipInfo::has_giftinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerVipInfo::set_has_giftinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerVipInfo::clear_has_giftinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerVipInfo::clear_giftinfo() {
  giftinfo_ = 0;
  clear_has_giftinfo();
}
inline ::google::protobuf::int32 PlayerVipInfo::giftinfo() const {
  return giftinfo_;
}
inline void PlayerVipInfo::set_giftinfo(::google::protobuf::int32 value) {
  set_has_giftinfo();
  giftinfo_ = value;
}

// optional int32 vipAddUpGold = 2;
inline bool PlayerVipInfo::has_vipaddupgold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerVipInfo::set_has_vipaddupgold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerVipInfo::clear_has_vipaddupgold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerVipInfo::clear_vipaddupgold() {
  vipaddupgold_ = 0;
  clear_has_vipaddupgold();
}
inline ::google::protobuf::int32 PlayerVipInfo::vipaddupgold() const {
  return vipaddupgold_;
}
inline void PlayerVipInfo::set_vipaddupgold(::google::protobuf::int32 value) {
  set_has_vipaddupgold();
  vipaddupgold_ = value;
}

// optional int64 endTime = 3;
inline bool PlayerVipInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerVipInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerVipInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerVipInfo::clear_endtime() {
  endtime_ = GOOGLE_LONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::int64 PlayerVipInfo::endtime() const {
  return endtime_;
}
inline void PlayerVipInfo::set_endtime(::google::protobuf::int64 value) {
  set_has_endtime();
  endtime_ = value;
}

// optional int32 day = 4;
inline bool PlayerVipInfo::has_day() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerVipInfo::set_has_day() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerVipInfo::clear_has_day() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerVipInfo::clear_day() {
  day_ = 0;
  clear_has_day();
}
inline ::google::protobuf::int32 PlayerVipInfo::day() const {
  return day_;
}
inline void PlayerVipInfo::set_day(::google::protobuf::int32 value) {
  set_has_day();
  day_ = value;
}

// optional int32 maxDay = 5;
inline bool PlayerVipInfo::has_maxday() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerVipInfo::set_has_maxday() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerVipInfo::clear_has_maxday() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerVipInfo::clear_maxday() {
  maxday_ = 0;
  clear_has_maxday();
}
inline ::google::protobuf::int32 PlayerVipInfo::maxday() const {
  return maxday_;
}
inline void PlayerVipInfo::set_maxday(::google::protobuf::int32 value) {
  set_has_maxday();
  maxday_ = value;
}

// optional int64 lastTime = 6;
inline bool PlayerVipInfo::has_lasttime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerVipInfo::set_has_lasttime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerVipInfo::clear_has_lasttime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerVipInfo::clear_lasttime() {
  lasttime_ = GOOGLE_LONGLONG(0);
  clear_has_lasttime();
}
inline ::google::protobuf::int64 PlayerVipInfo::lasttime() const {
  return lasttime_;
}
inline void PlayerVipInfo::set_lasttime(::google::protobuf::int64 value) {
  set_has_lasttime();
  lasttime_ = value;
}

// repeated int64 item = 7;
inline int PlayerVipInfo::item_size() const {
  return item_.size();
}
inline void PlayerVipInfo::clear_item() {
  item_.Clear();
}
inline ::google::protobuf::int64 PlayerVipInfo::item(int index) const {
  return item_.Get(index);
}
inline void PlayerVipInfo::set_item(int index, ::google::protobuf::int64 value) {
  item_.Set(index, value);
}
inline void PlayerVipInfo::add_item(::google::protobuf::int64 value) {
  item_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
PlayerVipInfo::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
PlayerVipInfo::mutable_item() {
  return &item_;
}

// optional int32 vipCardLv = 8;
inline bool PlayerVipInfo::has_vipcardlv() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayerVipInfo::set_has_vipcardlv() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayerVipInfo::clear_has_vipcardlv() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayerVipInfo::clear_vipcardlv() {
  vipcardlv_ = 0;
  clear_has_vipcardlv();
}
inline ::google::protobuf::int32 PlayerVipInfo::vipcardlv() const {
  return vipcardlv_;
}
inline void PlayerVipInfo::set_vipcardlv(::google::protobuf::int32 value) {
  set_has_vipcardlv();
  vipcardlv_ = value;
}

// optional int64 vipCardBeginTime = 9;
inline bool PlayerVipInfo::has_vipcardbegintime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlayerVipInfo::set_has_vipcardbegintime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlayerVipInfo::clear_has_vipcardbegintime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlayerVipInfo::clear_vipcardbegintime() {
  vipcardbegintime_ = GOOGLE_LONGLONG(0);
  clear_has_vipcardbegintime();
}
inline ::google::protobuf::int64 PlayerVipInfo::vipcardbegintime() const {
  return vipcardbegintime_;
}
inline void PlayerVipInfo::set_vipcardbegintime(::google::protobuf::int64 value) {
  set_has_vipcardbegintime();
  vipcardbegintime_ = value;
}

// optional int64 valideSecs = 10;
inline bool PlayerVipInfo::has_validesecs() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PlayerVipInfo::set_has_validesecs() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PlayerVipInfo::clear_has_validesecs() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PlayerVipInfo::clear_validesecs() {
  validesecs_ = GOOGLE_LONGLONG(0);
  clear_has_validesecs();
}
inline ::google::protobuf::int64 PlayerVipInfo::validesecs() const {
  return validesecs_;
}
inline void PlayerVipInfo::set_validesecs(::google::protobuf::int64 value) {
  set_has_validesecs();
  validesecs_ = value;
}

// -------------------------------------------------------------------

// PassivePlayerSkill

// optional int32 index = 1;
inline bool PassivePlayerSkill::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PassivePlayerSkill::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PassivePlayerSkill::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PassivePlayerSkill::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 PassivePlayerSkill::index() const {
  return index_;
}
inline void PassivePlayerSkill::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// optional int32 skillid = 2;
inline bool PassivePlayerSkill::has_skillid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PassivePlayerSkill::set_has_skillid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PassivePlayerSkill::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PassivePlayerSkill::clear_skillid() {
  skillid_ = 0;
  clear_has_skillid();
}
inline ::google::protobuf::int32 PassivePlayerSkill::skillid() const {
  return skillid_;
}
inline void PassivePlayerSkill::set_skillid(::google::protobuf::int32 value) {
  set_has_skillid();
  skillid_ = value;
}

// -------------------------------------------------------------------

// MagicWeapon

// optional int32 id = 1 [default = 0];
inline bool MagicWeapon::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MagicWeapon::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MagicWeapon::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MagicWeapon::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MagicWeapon::id() const {
  return id_;
}
inline void MagicWeapon::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 exp = 2;
inline bool MagicWeapon::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MagicWeapon::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MagicWeapon::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MagicWeapon::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 MagicWeapon::exp() const {
  return exp_;
}
inline void MagicWeapon::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// repeated int32 skillid = 3;
inline int MagicWeapon::skillid_size() const {
  return skillid_.size();
}
inline void MagicWeapon::clear_skillid() {
  skillid_.Clear();
}
inline ::google::protobuf::int32 MagicWeapon::skillid(int index) const {
  return skillid_.Get(index);
}
inline void MagicWeapon::set_skillid(int index, ::google::protobuf::int32 value) {
  skillid_.Set(index, value);
}
inline void MagicWeapon::add_skillid(::google::protobuf::int32 value) {
  skillid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MagicWeapon::skillid() const {
  return skillid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MagicWeapon::mutable_skillid() {
  return &skillid_;
}

// optional int64 advancetime = 4;
inline bool MagicWeapon::has_advancetime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MagicWeapon::set_has_advancetime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MagicWeapon::clear_has_advancetime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MagicWeapon::clear_advancetime() {
  advancetime_ = GOOGLE_LONGLONG(0);
  clear_has_advancetime();
}
inline ::google::protobuf::int64 MagicWeapon::advancetime() const {
  return advancetime_;
}
inline void MagicWeapon::set_advancetime(::google::protobuf::int64 value) {
  set_has_advancetime();
  advancetime_ = value;
}

// optional int32 tempID = 5;
inline bool MagicWeapon::has_tempid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MagicWeapon::set_has_tempid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MagicWeapon::clear_has_tempid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MagicWeapon::clear_tempid() {
  tempid_ = 0;
  clear_has_tempid();
}
inline ::google::protobuf::int32 MagicWeapon::tempid() const {
  return tempid_;
}
inline void MagicWeapon::set_tempid(::google::protobuf::int32 value) {
  set_has_tempid();
  tempid_ = value;
}

// optional int32 needtime = 6;
inline bool MagicWeapon::has_needtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MagicWeapon::set_has_needtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MagicWeapon::clear_has_needtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MagicWeapon::clear_needtime() {
  needtime_ = 0;
  clear_has_needtime();
}
inline ::google::protobuf::int32 MagicWeapon::needtime() const {
  return needtime_;
}
inline void MagicWeapon::set_needtime(::google::protobuf::int32 value) {
  set_has_needtime();
  needtime_ = value;
}

// repeated .PlayerInfo.PassivePlayerSkill passiveSkillList = 7;
inline int MagicWeapon::passiveskilllist_size() const {
  return passiveskilllist_.size();
}
inline void MagicWeapon::clear_passiveskilllist() {
  passiveskilllist_.Clear();
}
inline const ::PlayerInfo::PassivePlayerSkill& MagicWeapon::passiveskilllist(int index) const {
  return passiveskilllist_.Get(index);
}
inline ::PlayerInfo::PassivePlayerSkill* MagicWeapon::mutable_passiveskilllist(int index) {
  return passiveskilllist_.Mutable(index);
}
inline ::PlayerInfo::PassivePlayerSkill* MagicWeapon::add_passiveskilllist() {
  return passiveskilllist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::PassivePlayerSkill >&
MagicWeapon::passiveskilllist() const {
  return passiveskilllist_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::PassivePlayerSkill >*
MagicWeapon::mutable_passiveskilllist() {
  return &passiveskilllist_;
}

// optional bool firstReflush = 8;
inline bool MagicWeapon::has_firstreflush() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MagicWeapon::set_has_firstreflush() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MagicWeapon::clear_has_firstreflush() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MagicWeapon::clear_firstreflush() {
  firstreflush_ = false;
  clear_has_firstreflush();
}
inline bool MagicWeapon::firstreflush() const {
  return firstreflush_;
}
inline void MagicWeapon::set_firstreflush(bool value) {
  set_has_firstreflush();
  firstreflush_ = value;
}

// -------------------------------------------------------------------

// RandCJobLucky_CJobItem

// required int32 id = 1;
inline bool RandCJobLucky_CJobItem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandCJobLucky_CJobItem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandCJobLucky_CJobItem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandCJobLucky_CJobItem::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RandCJobLucky_CJobItem::id() const {
  return id_;
}
inline void RandCJobLucky_CJobItem::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 exp = 2;
inline bool RandCJobLucky_CJobItem::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RandCJobLucky_CJobItem::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RandCJobLucky_CJobItem::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RandCJobLucky_CJobItem::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 RandCJobLucky_CJobItem::exp() const {
  return exp_;
}
inline void RandCJobLucky_CJobItem::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// -------------------------------------------------------------------

// RandCJobLucky_CreatureCJob

// required int64 id = 1;
inline bool RandCJobLucky_CreatureCJob::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandCJobLucky_CreatureCJob::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RandCJobLucky_CreatureCJob::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RandCJobLucky_CreatureCJob::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 RandCJobLucky_CreatureCJob::id() const {
  return id_;
}
inline void RandCJobLucky_CreatureCJob::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// repeated .PlayerInfo.RandCJobLucky.CJobItem item = 2;
inline int RandCJobLucky_CreatureCJob::item_size() const {
  return item_.size();
}
inline void RandCJobLucky_CreatureCJob::clear_item() {
  item_.Clear();
}
inline const ::PlayerInfo::RandCJobLucky_CJobItem& RandCJobLucky_CreatureCJob::item(int index) const {
  return item_.Get(index);
}
inline ::PlayerInfo::RandCJobLucky_CJobItem* RandCJobLucky_CreatureCJob::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::PlayerInfo::RandCJobLucky_CJobItem* RandCJobLucky_CreatureCJob::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::RandCJobLucky_CJobItem >&
RandCJobLucky_CreatureCJob::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::RandCJobLucky_CJobItem >*
RandCJobLucky_CreatureCJob::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// RandCJobLucky

// repeated .PlayerInfo.RandCJobLucky.CJobItem package = 1;
inline int RandCJobLucky::package_size() const {
  return package_.size();
}
inline void RandCJobLucky::clear_package() {
  package_.Clear();
}
inline const ::PlayerInfo::RandCJobLucky_CJobItem& RandCJobLucky::package(int index) const {
  return package_.Get(index);
}
inline ::PlayerInfo::RandCJobLucky_CJobItem* RandCJobLucky::mutable_package(int index) {
  return package_.Mutable(index);
}
inline ::PlayerInfo::RandCJobLucky_CJobItem* RandCJobLucky::add_package() {
  return package_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::RandCJobLucky_CJobItem >&
RandCJobLucky::package() const {
  return package_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::RandCJobLucky_CJobItem >*
RandCJobLucky::mutable_package() {
  return &package_;
}

// repeated int32 exampackage = 2;
inline int RandCJobLucky::exampackage_size() const {
  return exampackage_.size();
}
inline void RandCJobLucky::clear_exampackage() {
  exampackage_.Clear();
}
inline ::google::protobuf::int32 RandCJobLucky::exampackage(int index) const {
  return exampackage_.Get(index);
}
inline void RandCJobLucky::set_exampackage(int index, ::google::protobuf::int32 value) {
  exampackage_.Set(index, value);
}
inline void RandCJobLucky::add_exampackage(::google::protobuf::int32 value) {
  exampackage_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RandCJobLucky::exampackage() const {
  return exampackage_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RandCJobLucky::mutable_exampackage() {
  return &exampackage_;
}

// repeated .PlayerInfo.RandCJobLucky.CreatureCJob rolepackage = 3;
inline int RandCJobLucky::rolepackage_size() const {
  return rolepackage_.size();
}
inline void RandCJobLucky::clear_rolepackage() {
  rolepackage_.Clear();
}
inline const ::PlayerInfo::RandCJobLucky_CreatureCJob& RandCJobLucky::rolepackage(int index) const {
  return rolepackage_.Get(index);
}
inline ::PlayerInfo::RandCJobLucky_CreatureCJob* RandCJobLucky::mutable_rolepackage(int index) {
  return rolepackage_.Mutable(index);
}
inline ::PlayerInfo::RandCJobLucky_CreatureCJob* RandCJobLucky::add_rolepackage() {
  return rolepackage_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::RandCJobLucky_CreatureCJob >&
RandCJobLucky::rolepackage() const {
  return rolepackage_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::RandCJobLucky_CreatureCJob >*
RandCJobLucky::mutable_rolepackage() {
  return &rolepackage_;
}

// optional int32 jobexp = 4;
inline bool RandCJobLucky::has_jobexp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RandCJobLucky::set_has_jobexp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RandCJobLucky::clear_has_jobexp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RandCJobLucky::clear_jobexp() {
  jobexp_ = 0;
  clear_has_jobexp();
}
inline ::google::protobuf::int32 RandCJobLucky::jobexp() const {
  return jobexp_;
}
inline void RandCJobLucky::set_jobexp(::google::protobuf::int32 value) {
  set_has_jobexp();
  jobexp_ = value;
}

// optional int32 randNum = 5;
inline bool RandCJobLucky::has_randnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RandCJobLucky::set_has_randnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RandCJobLucky::clear_has_randnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RandCJobLucky::clear_randnum() {
  randnum_ = 0;
  clear_has_randnum();
}
inline ::google::protobuf::int32 RandCJobLucky::randnum() const {
  return randnum_;
}
inline void RandCJobLucky::set_randnum(::google::protobuf::int32 value) {
  set_has_randnum();
  randnum_ = value;
}

// -------------------------------------------------------------------

// LucklyTurntable

// optional int64 tm = 1;
inline bool LucklyTurntable::has_tm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LucklyTurntable::set_has_tm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LucklyTurntable::clear_has_tm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LucklyTurntable::clear_tm() {
  tm_ = GOOGLE_LONGLONG(0);
  clear_has_tm();
}
inline ::google::protobuf::int64 LucklyTurntable::tm() const {
  return tm_;
}
inline void LucklyTurntable::set_tm(::google::protobuf::int64 value) {
  set_has_tm();
  tm_ = value;
}

// repeated int32 reawidList = 2;
inline int LucklyTurntable::reawidlist_size() const {
  return reawidlist_.size();
}
inline void LucklyTurntable::clear_reawidlist() {
  reawidlist_.Clear();
}
inline ::google::protobuf::int32 LucklyTurntable::reawidlist(int index) const {
  return reawidlist_.Get(index);
}
inline void LucklyTurntable::set_reawidlist(int index, ::google::protobuf::int32 value) {
  reawidlist_.Set(index, value);
}
inline void LucklyTurntable::add_reawidlist(::google::protobuf::int32 value) {
  reawidlist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LucklyTurntable::reawidlist() const {
  return reawidlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LucklyTurntable::mutable_reawidlist() {
  return &reawidlist_;
}

// repeated int32 itemid = 3;
inline int LucklyTurntable::itemid_size() const {
  return itemid_.size();
}
inline void LucklyTurntable::clear_itemid() {
  itemid_.Clear();
}
inline ::google::protobuf::int32 LucklyTurntable::itemid(int index) const {
  return itemid_.Get(index);
}
inline void LucklyTurntable::set_itemid(int index, ::google::protobuf::int32 value) {
  itemid_.Set(index, value);
}
inline void LucklyTurntable::add_itemid(::google::protobuf::int32 value) {
  itemid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LucklyTurntable::itemid() const {
  return itemid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LucklyTurntable::mutable_itemid() {
  return &itemid_;
}

// repeated int32 num = 4;
inline int LucklyTurntable::num_size() const {
  return num_.size();
}
inline void LucklyTurntable::clear_num() {
  num_.Clear();
}
inline ::google::protobuf::int32 LucklyTurntable::num(int index) const {
  return num_.Get(index);
}
inline void LucklyTurntable::set_num(int index, ::google::protobuf::int32 value) {
  num_.Set(index, value);
}
inline void LucklyTurntable::add_num(::google::protobuf::int32 value) {
  num_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LucklyTurntable::num() const {
  return num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LucklyTurntable::mutable_num() {
  return &num_;
}

// repeated int32 id = 5;
inline int LucklyTurntable::id_size() const {
  return id_.size();
}
inline void LucklyTurntable::clear_id() {
  id_.Clear();
}
inline ::google::protobuf::int32 LucklyTurntable::id(int index) const {
  return id_.Get(index);
}
inline void LucklyTurntable::set_id(int index, ::google::protobuf::int32 value) {
  id_.Set(index, value);
}
inline void LucklyTurntable::add_id(::google::protobuf::int32 value) {
  id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LucklyTurntable::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LucklyTurntable::mutable_id() {
  return &id_;
}

// repeated int32 bindType = 6;
inline int LucklyTurntable::bindtype_size() const {
  return bindtype_.size();
}
inline void LucklyTurntable::clear_bindtype() {
  bindtype_.Clear();
}
inline ::google::protobuf::int32 LucklyTurntable::bindtype(int index) const {
  return bindtype_.Get(index);
}
inline void LucklyTurntable::set_bindtype(int index, ::google::protobuf::int32 value) {
  bindtype_.Set(index, value);
}
inline void LucklyTurntable::add_bindtype(::google::protobuf::int32 value) {
  bindtype_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LucklyTurntable::bindtype() const {
  return bindtype_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LucklyTurntable::mutable_bindtype() {
  return &bindtype_;
}

// -------------------------------------------------------------------

// Activity

// optional int32 curnode = 1;
inline bool Activity::has_curnode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Activity::set_has_curnode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Activity::clear_has_curnode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Activity::clear_curnode() {
  curnode_ = 0;
  clear_has_curnode();
}
inline ::google::protobuf::int32 Activity::curnode() const {
  return curnode_;
}
inline void Activity::set_curnode(::google::protobuf::int32 value) {
  set_has_curnode();
  curnode_ = value;
}

// optional int32 preward = 2;
inline bool Activity::has_preward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Activity::set_has_preward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Activity::clear_has_preward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Activity::clear_preward() {
  preward_ = 0;
  clear_has_preward();
}
inline ::google::protobuf::int32 Activity::preward() const {
  return preward_;
}
inline void Activity::set_preward(::google::protobuf::int32 value) {
  set_has_preward();
  preward_ = value;
}

// optional int32 pastnode = 3;
inline bool Activity::has_pastnode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Activity::set_has_pastnode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Activity::clear_has_pastnode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Activity::clear_pastnode() {
  pastnode_ = 0;
  clear_has_pastnode();
}
inline ::google::protobuf::int32 Activity::pastnode() const {
  return pastnode_;
}
inline void Activity::set_pastnode(::google::protobuf::int32 value) {
  set_has_pastnode();
  pastnode_ = value;
}

// optional int64 swapstime = 4;
inline bool Activity::has_swapstime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Activity::set_has_swapstime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Activity::clear_has_swapstime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Activity::clear_swapstime() {
  swapstime_ = GOOGLE_LONGLONG(0);
  clear_has_swapstime();
}
inline ::google::protobuf::int64 Activity::swapstime() const {
  return swapstime_;
}
inline void Activity::set_swapstime(::google::protobuf::int64 value) {
  set_has_swapstime();
  swapstime_ = value;
}

// repeated .PlayerInfo.ActivityYellowVipReward vipreward = 5;
inline int Activity::vipreward_size() const {
  return vipreward_.size();
}
inline void Activity::clear_vipreward() {
  vipreward_.Clear();
}
inline const ::PlayerInfo::ActivityYellowVipReward& Activity::vipreward(int index) const {
  return vipreward_.Get(index);
}
inline ::PlayerInfo::ActivityYellowVipReward* Activity::mutable_vipreward(int index) {
  return vipreward_.Mutable(index);
}
inline ::PlayerInfo::ActivityYellowVipReward* Activity::add_vipreward() {
  return vipreward_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ActivityYellowVipReward >&
Activity::vipreward() const {
  return vipreward_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ActivityYellowVipReward >*
Activity::mutable_vipreward() {
  return &vipreward_;
}

// repeated int32 TreasonKingBestTime = 6;
inline int Activity::treasonkingbesttime_size() const {
  return treasonkingbesttime_.size();
}
inline void Activity::clear_treasonkingbesttime() {
  treasonkingbesttime_.Clear();
}
inline ::google::protobuf::int32 Activity::treasonkingbesttime(int index) const {
  return treasonkingbesttime_.Get(index);
}
inline void Activity::set_treasonkingbesttime(int index, ::google::protobuf::int32 value) {
  treasonkingbesttime_.Set(index, value);
}
inline void Activity::add_treasonkingbesttime(::google::protobuf::int32 value) {
  treasonkingbesttime_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Activity::treasonkingbesttime() const {
  return treasonkingbesttime_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Activity::mutable_treasonkingbesttime() {
  return &treasonkingbesttime_;
}

// -------------------------------------------------------------------

// ActivityYellowVipReward

// required int32 activityId = 1;
inline bool ActivityYellowVipReward::has_activityid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityYellowVipReward::set_has_activityid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityYellowVipReward::clear_has_activityid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityYellowVipReward::clear_activityid() {
  activityid_ = 0;
  clear_has_activityid();
}
inline ::google::protobuf::int32 ActivityYellowVipReward::activityid() const {
  return activityid_;
}
inline void ActivityYellowVipReward::set_activityid(::google::protobuf::int32 value) {
  set_has_activityid();
  activityid_ = value;
}

// repeated .PlayerInfo.ActivityYellowVipRewardList rewardList = 2;
inline int ActivityYellowVipReward::rewardlist_size() const {
  return rewardlist_.size();
}
inline void ActivityYellowVipReward::clear_rewardlist() {
  rewardlist_.Clear();
}
inline const ::PlayerInfo::ActivityYellowVipRewardList& ActivityYellowVipReward::rewardlist(int index) const {
  return rewardlist_.Get(index);
}
inline ::PlayerInfo::ActivityYellowVipRewardList* ActivityYellowVipReward::mutable_rewardlist(int index) {
  return rewardlist_.Mutable(index);
}
inline ::PlayerInfo::ActivityYellowVipRewardList* ActivityYellowVipReward::add_rewardlist() {
  return rewardlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ActivityYellowVipRewardList >&
ActivityYellowVipReward::rewardlist() const {
  return rewardlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::ActivityYellowVipRewardList >*
ActivityYellowVipReward::mutable_rewardlist() {
  return &rewardlist_;
}

// -------------------------------------------------------------------

// ActivityYellowVipRewardList

// optional int32 state = 1;
inline bool ActivityYellowVipRewardList::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityYellowVipRewardList::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityYellowVipRewardList::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityYellowVipRewardList::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 ActivityYellowVipRewardList::state() const {
  return state_;
}
inline void ActivityYellowVipRewardList::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// optional int32 value = 2;
inline bool ActivityYellowVipRewardList::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityYellowVipRewardList::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityYellowVipRewardList::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityYellowVipRewardList::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 ActivityYellowVipRewardList::value() const {
  return value_;
}
inline void ActivityYellowVipRewardList::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// LineMapInfoList

// repeated .PlayerInfo.LineMapInfo lineinfo = 1;
inline int LineMapInfoList::lineinfo_size() const {
  return lineinfo_.size();
}
inline void LineMapInfoList::clear_lineinfo() {
  lineinfo_.Clear();
}
inline const ::PlayerInfo::LineMapInfo& LineMapInfoList::lineinfo(int index) const {
  return lineinfo_.Get(index);
}
inline ::PlayerInfo::LineMapInfo* LineMapInfoList::mutable_lineinfo(int index) {
  return lineinfo_.Mutable(index);
}
inline ::PlayerInfo::LineMapInfo* LineMapInfoList::add_lineinfo() {
  return lineinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::LineMapInfo >&
LineMapInfoList::lineinfo() const {
  return lineinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::LineMapInfo >*
LineMapInfoList::mutable_lineinfo() {
  return &lineinfo_;
}

// required int64 mysecenceid = 2;
inline bool LineMapInfoList::has_mysecenceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineMapInfoList::set_has_mysecenceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineMapInfoList::clear_has_mysecenceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineMapInfoList::clear_mysecenceid() {
  mysecenceid_ = GOOGLE_LONGLONG(0);
  clear_has_mysecenceid();
}
inline ::google::protobuf::int64 LineMapInfoList::mysecenceid() const {
  return mysecenceid_;
}
inline void LineMapInfoList::set_mysecenceid(::google::protobuf::int64 value) {
  set_has_mysecenceid();
  mysecenceid_ = value;
}

// -------------------------------------------------------------------

// LineMapInfo

// required int64 scenceid = 1;
inline bool LineMapInfo::has_scenceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LineMapInfo::set_has_scenceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LineMapInfo::clear_has_scenceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LineMapInfo::clear_scenceid() {
  scenceid_ = GOOGLE_LONGLONG(0);
  clear_has_scenceid();
}
inline ::google::protobuf::int64 LineMapInfo::scenceid() const {
  return scenceid_;
}
inline void LineMapInfo::set_scenceid(::google::protobuf::int64 value) {
  set_has_scenceid();
  scenceid_ = value;
}

// required int32 playernum = 2;
inline bool LineMapInfo::has_playernum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineMapInfo::set_has_playernum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineMapInfo::clear_has_playernum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineMapInfo::clear_playernum() {
  playernum_ = 0;
  clear_has_playernum();
}
inline ::google::protobuf::int32 LineMapInfo::playernum() const {
  return playernum_;
}
inline void LineMapInfo::set_playernum(::google::protobuf::int32 value) {
  set_has_playernum();
  playernum_ = value;
}

// -------------------------------------------------------------------

// GirlWarInfo

// repeated .PlayerInfo.GirlWar girlwar = 1;
inline int GirlWarInfo::girlwar_size() const {
  return girlwar_.size();
}
inline void GirlWarInfo::clear_girlwar() {
  girlwar_.Clear();
}
inline const ::PlayerInfo::GirlWar& GirlWarInfo::girlwar(int index) const {
  return girlwar_.Get(index);
}
inline ::PlayerInfo::GirlWar* GirlWarInfo::mutable_girlwar(int index) {
  return girlwar_.Mutable(index);
}
inline ::PlayerInfo::GirlWar* GirlWarInfo::add_girlwar() {
  return girlwar_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::GirlWar >&
GirlWarInfo::girlwar() const {
  return girlwar_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::GirlWar >*
GirlWarInfo::mutable_girlwar() {
  return &girlwar_;
}

// -------------------------------------------------------------------

// GirlWar

// required int32 id = 1;
inline bool GirlWar::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GirlWar::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GirlWar::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GirlWar::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GirlWar::id() const {
  return id_;
}
inline void GirlWar::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional bytes name = 2;
inline bool GirlWar::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GirlWar::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GirlWar::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GirlWar::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GirlWar::name() const {
  return *name_;
}
inline void GirlWar::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GirlWar::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GirlWar::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GirlWar::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GirlWar::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GirlWar::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 fightpower = 3;
inline bool GirlWar::has_fightpower() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GirlWar::set_has_fightpower() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GirlWar::clear_has_fightpower() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GirlWar::clear_fightpower() {
  fightpower_ = 0;
  clear_has_fightpower();
}
inline ::google::protobuf::int32 GirlWar::fightpower() const {
  return fightpower_;
}
inline void GirlWar::set_fightpower(::google::protobuf::int32 value) {
  set_has_fightpower();
  fightpower_ = value;
}

// optional int64 exp = 4;
inline bool GirlWar::has_exp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GirlWar::set_has_exp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GirlWar::clear_has_exp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GirlWar::clear_exp() {
  exp_ = GOOGLE_LONGLONG(0);
  clear_has_exp();
}
inline ::google::protobuf::int64 GirlWar::exp() const {
  return exp_;
}
inline void GirlWar::set_exp(::google::protobuf::int64 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 level = 5;
inline bool GirlWar::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GirlWar::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GirlWar::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GirlWar::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 GirlWar::level() const {
  return level_;
}
inline void GirlWar::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 hp = 6;
inline bool GirlWar::has_hp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GirlWar::set_has_hp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GirlWar::clear_has_hp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GirlWar::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 GirlWar::hp() const {
  return hp_;
}
inline void GirlWar::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// optional int32 phyattack = 7;
inline bool GirlWar::has_phyattack() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GirlWar::set_has_phyattack() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GirlWar::clear_has_phyattack() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GirlWar::clear_phyattack() {
  phyattack_ = 0;
  clear_has_phyattack();
}
inline ::google::protobuf::int32 GirlWar::phyattack() const {
  return phyattack_;
}
inline void GirlWar::set_phyattack(::google::protobuf::int32 value) {
  set_has_phyattack();
  phyattack_ = value;
}

// optional int32 phyattackmax = 8;
inline bool GirlWar::has_phyattackmax() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GirlWar::set_has_phyattackmax() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GirlWar::clear_has_phyattackmax() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GirlWar::clear_phyattackmax() {
  phyattackmax_ = 0;
  clear_has_phyattackmax();
}
inline ::google::protobuf::int32 GirlWar::phyattackmax() const {
  return phyattackmax_;
}
inline void GirlWar::set_phyattackmax(::google::protobuf::int32 value) {
  set_has_phyattackmax();
  phyattackmax_ = value;
}

// optional int32 magicattack = 9;
inline bool GirlWar::has_magicattack() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GirlWar::set_has_magicattack() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GirlWar::clear_has_magicattack() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GirlWar::clear_magicattack() {
  magicattack_ = 0;
  clear_has_magicattack();
}
inline ::google::protobuf::int32 GirlWar::magicattack() const {
  return magicattack_;
}
inline void GirlWar::set_magicattack(::google::protobuf::int32 value) {
  set_has_magicattack();
  magicattack_ = value;
}

// optional int32 magicattackmax = 10;
inline bool GirlWar::has_magicattackmax() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GirlWar::set_has_magicattackmax() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GirlWar::clear_has_magicattackmax() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GirlWar::clear_magicattackmax() {
  magicattackmax_ = 0;
  clear_has_magicattackmax();
}
inline ::google::protobuf::int32 GirlWar::magicattackmax() const {
  return magicattackmax_;
}
inline void GirlWar::set_magicattackmax(::google::protobuf::int32 value) {
  set_has_magicattackmax();
  magicattackmax_ = value;
}

// optional int32 phydefence = 11;
inline bool GirlWar::has_phydefence() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GirlWar::set_has_phydefence() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GirlWar::clear_has_phydefence() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GirlWar::clear_phydefence() {
  phydefence_ = 0;
  clear_has_phydefence();
}
inline ::google::protobuf::int32 GirlWar::phydefence() const {
  return phydefence_;
}
inline void GirlWar::set_phydefence(::google::protobuf::int32 value) {
  set_has_phydefence();
  phydefence_ = value;
}

// optional int32 hitrate = 12;
inline bool GirlWar::has_hitrate() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GirlWar::set_has_hitrate() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GirlWar::clear_has_hitrate() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GirlWar::clear_hitrate() {
  hitrate_ = 0;
  clear_has_hitrate();
}
inline ::google::protobuf::int32 GirlWar::hitrate() const {
  return hitrate_;
}
inline void GirlWar::set_hitrate(::google::protobuf::int32 value) {
  set_has_hitrate();
  hitrate_ = value;
}

// optional int32 avoidrate = 13;
inline bool GirlWar::has_avoidrate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GirlWar::set_has_avoidrate() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GirlWar::clear_has_avoidrate() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GirlWar::clear_avoidrate() {
  avoidrate_ = 0;
  clear_has_avoidrate();
}
inline ::google::protobuf::int32 GirlWar::avoidrate() const {
  return avoidrate_;
}
inline void GirlWar::set_avoidrate(::google::protobuf::int32 value) {
  set_has_avoidrate();
  avoidrate_ = value;
}

// optional int32 crit = 14;
inline bool GirlWar::has_crit() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GirlWar::set_has_crit() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GirlWar::clear_has_crit() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GirlWar::clear_crit() {
  crit_ = 0;
  clear_has_crit();
}
inline ::google::protobuf::int32 GirlWar::crit() const {
  return crit_;
}
inline void GirlWar::set_crit(::google::protobuf::int32 value) {
  set_has_crit();
  crit_ = value;
}

// optional int32 ung = 15;
inline bool GirlWar::has_ung() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GirlWar::set_has_ung() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GirlWar::clear_has_ung() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GirlWar::clear_ung() {
  ung_ = 0;
  clear_has_ung();
}
inline ::google::protobuf::int32 GirlWar::ung() const {
  return ung_;
}
inline void GirlWar::set_ung(::google::protobuf::int32 value) {
  set_has_ung();
  ung_ = value;
}

// optional int32 movespeed = 16;
inline bool GirlWar::has_movespeed() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GirlWar::set_has_movespeed() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GirlWar::clear_has_movespeed() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GirlWar::clear_movespeed() {
  movespeed_ = 0;
  clear_has_movespeed();
}
inline ::google::protobuf::int32 GirlWar::movespeed() const {
  return movespeed_;
}
inline void GirlWar::set_movespeed(::google::protobuf::int32 value) {
  set_has_movespeed();
  movespeed_ = value;
}

// optional int64 deadTime = 17;
inline bool GirlWar::has_deadtime() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GirlWar::set_has_deadtime() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GirlWar::clear_has_deadtime() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GirlWar::clear_deadtime() {
  deadtime_ = GOOGLE_LONGLONG(0);
  clear_has_deadtime();
}
inline ::google::protobuf::int64 GirlWar::deadtime() const {
  return deadtime_;
}
inline void GirlWar::set_deadtime(::google::protobuf::int64 value) {
  set_has_deadtime();
  deadtime_ = value;
}

// optional int32 starrank = 18;
inline bool GirlWar::has_starrank() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GirlWar::set_has_starrank() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GirlWar::clear_has_starrank() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GirlWar::clear_starrank() {
  starrank_ = 0;
  clear_has_starrank();
}
inline ::google::protobuf::int32 GirlWar::starrank() const {
  return starrank_;
}
inline void GirlWar::set_starrank(::google::protobuf::int32 value) {
  set_has_starrank();
  starrank_ = value;
}

// optional int32 quality = 19;
inline bool GirlWar::has_quality() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GirlWar::set_has_quality() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GirlWar::clear_has_quality() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GirlWar::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::google::protobuf::int32 GirlWar::quality() const {
  return quality_;
}
inline void GirlWar::set_quality(::google::protobuf::int32 value) {
  set_has_quality();
  quality_ = value;
}

// optional int32 hpmax = 20;
inline bool GirlWar::has_hpmax() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GirlWar::set_has_hpmax() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GirlWar::clear_has_hpmax() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GirlWar::clear_hpmax() {
  hpmax_ = 0;
  clear_has_hpmax();
}
inline ::google::protobuf::int32 GirlWar::hpmax() const {
  return hpmax_;
}
inline void GirlWar::set_hpmax(::google::protobuf::int32 value) {
  set_has_hpmax();
  hpmax_ = value;
}

// optional int32 skill1 = 21;
inline bool GirlWar::has_skill1() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GirlWar::set_has_skill1() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GirlWar::clear_has_skill1() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GirlWar::clear_skill1() {
  skill1_ = 0;
  clear_has_skill1();
}
inline ::google::protobuf::int32 GirlWar::skill1() const {
  return skill1_;
}
inline void GirlWar::set_skill1(::google::protobuf::int32 value) {
  set_has_skill1();
  skill1_ = value;
}

// optional int32 skill2 = 22;
inline bool GirlWar::has_skill2() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GirlWar::set_has_skill2() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GirlWar::clear_has_skill2() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GirlWar::clear_skill2() {
  skill2_ = 0;
  clear_has_skill2();
}
inline ::google::protobuf::int32 GirlWar::skill2() const {
  return skill2_;
}
inline void GirlWar::set_skill2(::google::protobuf::int32 value) {
  set_has_skill2();
  skill2_ = value;
}

// optional int32 skill3 = 23;
inline bool GirlWar::has_skill3() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void GirlWar::set_has_skill3() {
  _has_bits_[0] |= 0x00400000u;
}
inline void GirlWar::clear_has_skill3() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void GirlWar::clear_skill3() {
  skill3_ = 0;
  clear_has_skill3();
}
inline ::google::protobuf::int32 GirlWar::skill3() const {
  return skill3_;
}
inline void GirlWar::set_skill3(::google::protobuf::int32 value) {
  set_has_skill3();
  skill3_ = value;
}

// repeated int32 index = 24;
inline int GirlWar::index_size() const {
  return index_.size();
}
inline void GirlWar::clear_index() {
  index_.Clear();
}
inline ::google::protobuf::int32 GirlWar::index(int index) const {
  return index_.Get(index);
}
inline void GirlWar::set_index(int index, ::google::protobuf::int32 value) {
  index_.Set(index, value);
}
inline void GirlWar::add_index(::google::protobuf::int32 value) {
  index_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GirlWar::index() const {
  return index_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GirlWar::mutable_index() {
  return &index_;
}

// repeated int32 equip = 25;
inline int GirlWar::equip_size() const {
  return equip_.size();
}
inline void GirlWar::clear_equip() {
  equip_.Clear();
}
inline ::google::protobuf::int32 GirlWar::equip(int index) const {
  return equip_.Get(index);
}
inline void GirlWar::set_equip(int index, ::google::protobuf::int32 value) {
  equip_.Set(index, value);
}
inline void GirlWar::add_equip(::google::protobuf::int32 value) {
  equip_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GirlWar::equip() const {
  return equip_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GirlWar::mutable_equip() {
  return &equip_;
}

// optional bool iswar = 26;
inline bool GirlWar::has_iswar() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void GirlWar::set_has_iswar() {
  _has_bits_[0] |= 0x02000000u;
}
inline void GirlWar::clear_has_iswar() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void GirlWar::clear_iswar() {
  iswar_ = false;
  clear_has_iswar();
}
inline bool GirlWar::iswar() const {
  return iswar_;
}
inline void GirlWar::set_iswar(bool value) {
  set_has_iswar();
  iswar_ = value;
}

// -------------------------------------------------------------------

// LessInfo

// repeated int32 type = 1;
inline int LessInfo::type_size() const {
  return type_.size();
}
inline void LessInfo::clear_type() {
  type_.Clear();
}
inline ::google::protobuf::int32 LessInfo::type(int index) const {
  return type_.Get(index);
}
inline void LessInfo::set_type(int index, ::google::protobuf::int32 value) {
  type_.Set(index, value);
}
inline void LessInfo::add_type(::google::protobuf::int32 value) {
  type_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LessInfo::type() const {
  return type_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LessInfo::mutable_type() {
  return &type_;
}

// optional .PlayerInfo.InstanceInfoTwoDays instanceList = 2;
inline bool LessInfo::has_instancelist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LessInfo::set_has_instancelist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LessInfo::clear_has_instancelist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LessInfo::clear_instancelist() {
  if (instancelist_ != NULL) instancelist_->::PlayerInfo::InstanceInfoTwoDays::Clear();
  clear_has_instancelist();
}
inline const ::PlayerInfo::InstanceInfoTwoDays& LessInfo::instancelist() const {
  return instancelist_ != NULL ? *instancelist_ : *default_instance_->instancelist_;
}
inline ::PlayerInfo::InstanceInfoTwoDays* LessInfo::mutable_instancelist() {
  set_has_instancelist();
  if (instancelist_ == NULL) instancelist_ = new ::PlayerInfo::InstanceInfoTwoDays;
  return instancelist_;
}
inline ::PlayerInfo::InstanceInfoTwoDays* LessInfo::release_instancelist() {
  clear_has_instancelist();
  ::PlayerInfo::InstanceInfoTwoDays* temp = instancelist_;
  instancelist_ = NULL;
  return temp;
}
inline void LessInfo::set_allocated_instancelist(::PlayerInfo::InstanceInfoTwoDays* instancelist) {
  delete instancelist_;
  instancelist_ = instancelist;
  if (instancelist) {
    set_has_instancelist();
  } else {
    clear_has_instancelist();
  }
}

// optional .PlayerInfo.SignInInfo signin = 3;
inline bool LessInfo::has_signin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LessInfo::set_has_signin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LessInfo::clear_has_signin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LessInfo::clear_signin() {
  if (signin_ != NULL) signin_->::PlayerInfo::SignInInfo::Clear();
  clear_has_signin();
}
inline const ::PlayerInfo::SignInInfo& LessInfo::signin() const {
  return signin_ != NULL ? *signin_ : *default_instance_->signin_;
}
inline ::PlayerInfo::SignInInfo* LessInfo::mutable_signin() {
  set_has_signin();
  if (signin_ == NULL) signin_ = new ::PlayerInfo::SignInInfo;
  return signin_;
}
inline ::PlayerInfo::SignInInfo* LessInfo::release_signin() {
  clear_has_signin();
  ::PlayerInfo::SignInInfo* temp = signin_;
  signin_ = NULL;
  return temp;
}
inline void LessInfo::set_allocated_signin(::PlayerInfo::SignInInfo* signin) {
  delete signin_;
  signin_ = signin;
  if (signin) {
    set_has_signin();
  } else {
    clear_has_signin();
  }
}

// optional .PlayerInfo.CounterServiceList counter = 4;
inline bool LessInfo::has_counter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LessInfo::set_has_counter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LessInfo::clear_has_counter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LessInfo::clear_counter() {
  if (counter_ != NULL) counter_->::PlayerInfo::CounterServiceList::Clear();
  clear_has_counter();
}
inline const ::PlayerInfo::CounterServiceList& LessInfo::counter() const {
  return counter_ != NULL ? *counter_ : *default_instance_->counter_;
}
inline ::PlayerInfo::CounterServiceList* LessInfo::mutable_counter() {
  set_has_counter();
  if (counter_ == NULL) counter_ = new ::PlayerInfo::CounterServiceList;
  return counter_;
}
inline ::PlayerInfo::CounterServiceList* LessInfo::release_counter() {
  clear_has_counter();
  ::PlayerInfo::CounterServiceList* temp = counter_;
  counter_ = NULL;
  return temp;
}
inline void LessInfo::set_allocated_counter(::PlayerInfo::CounterServiceList* counter) {
  delete counter_;
  counter_ = counter;
  if (counter) {
    set_has_counter();
  } else {
    clear_has_counter();
  }
}

// optional .PlayerInfo.EscortInfo escort = 5;
inline bool LessInfo::has_escort() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LessInfo::set_has_escort() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LessInfo::clear_has_escort() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LessInfo::clear_escort() {
  if (escort_ != NULL) escort_->::PlayerInfo::EscortInfo::Clear();
  clear_has_escort();
}
inline const ::PlayerInfo::EscortInfo& LessInfo::escort() const {
  return escort_ != NULL ? *escort_ : *default_instance_->escort_;
}
inline ::PlayerInfo::EscortInfo* LessInfo::mutable_escort() {
  set_has_escort();
  if (escort_ == NULL) escort_ = new ::PlayerInfo::EscortInfo;
  return escort_;
}
inline ::PlayerInfo::EscortInfo* LessInfo::release_escort() {
  clear_has_escort();
  ::PlayerInfo::EscortInfo* temp = escort_;
  escort_ = NULL;
  return temp;
}
inline void LessInfo::set_allocated_escort(::PlayerInfo::EscortInfo* escort) {
  delete escort_;
  escort_ = escort;
  if (escort) {
    set_has_escort();
  } else {
    clear_has_escort();
  }
}

// optional .PlayerInfo.PlayerVipInfo playerVip = 6;
inline bool LessInfo::has_playervip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LessInfo::set_has_playervip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LessInfo::clear_has_playervip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LessInfo::clear_playervip() {
  if (playervip_ != NULL) playervip_->::PlayerInfo::PlayerVipInfo::Clear();
  clear_has_playervip();
}
inline const ::PlayerInfo::PlayerVipInfo& LessInfo::playervip() const {
  return playervip_ != NULL ? *playervip_ : *default_instance_->playervip_;
}
inline ::PlayerInfo::PlayerVipInfo* LessInfo::mutable_playervip() {
  set_has_playervip();
  if (playervip_ == NULL) playervip_ = new ::PlayerInfo::PlayerVipInfo;
  return playervip_;
}
inline ::PlayerInfo::PlayerVipInfo* LessInfo::release_playervip() {
  clear_has_playervip();
  ::PlayerInfo::PlayerVipInfo* temp = playervip_;
  playervip_ = NULL;
  return temp;
}
inline void LessInfo::set_allocated_playervip(::PlayerInfo::PlayerVipInfo* playervip) {
  delete playervip_;
  playervip_ = playervip;
  if (playervip) {
    set_has_playervip();
  } else {
    clear_has_playervip();
  }
}

// optional .PlayerInfo.PrestigeInfoList prestige = 7;
inline bool LessInfo::has_prestige() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LessInfo::set_has_prestige() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LessInfo::clear_has_prestige() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LessInfo::clear_prestige() {
  if (prestige_ != NULL) prestige_->::PlayerInfo::PrestigeInfoList::Clear();
  clear_has_prestige();
}
inline const ::PlayerInfo::PrestigeInfoList& LessInfo::prestige() const {
  return prestige_ != NULL ? *prestige_ : *default_instance_->prestige_;
}
inline ::PlayerInfo::PrestigeInfoList* LessInfo::mutable_prestige() {
  set_has_prestige();
  if (prestige_ == NULL) prestige_ = new ::PlayerInfo::PrestigeInfoList;
  return prestige_;
}
inline ::PlayerInfo::PrestigeInfoList* LessInfo::release_prestige() {
  clear_has_prestige();
  ::PlayerInfo::PrestigeInfoList* temp = prestige_;
  prestige_ = NULL;
  return temp;
}
inline void LessInfo::set_allocated_prestige(::PlayerInfo::PrestigeInfoList* prestige) {
  delete prestige_;
  prestige_ = prestige;
  if (prestige) {
    set_has_prestige();
  } else {
    clear_has_prestige();
  }
}

// optional .PlayerInfo.TitleInfoList title = 8;
inline bool LessInfo::has_title() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LessInfo::set_has_title() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LessInfo::clear_has_title() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LessInfo::clear_title() {
  if (title_ != NULL) title_->::PlayerInfo::TitleInfoList::Clear();
  clear_has_title();
}
inline const ::PlayerInfo::TitleInfoList& LessInfo::title() const {
  return title_ != NULL ? *title_ : *default_instance_->title_;
}
inline ::PlayerInfo::TitleInfoList* LessInfo::mutable_title() {
  set_has_title();
  if (title_ == NULL) title_ = new ::PlayerInfo::TitleInfoList;
  return title_;
}
inline ::PlayerInfo::TitleInfoList* LessInfo::release_title() {
  clear_has_title();
  ::PlayerInfo::TitleInfoList* temp = title_;
  title_ = NULL;
  return temp;
}
inline void LessInfo::set_allocated_title(::PlayerInfo::TitleInfoList* title) {
  delete title_;
  title_ = title;
  if (title) {
    set_has_title();
  } else {
    clear_has_title();
  }
}

// optional .FashionMsgProto.FashionShow fashion = 9;
inline bool LessInfo::has_fashion() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LessInfo::set_has_fashion() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LessInfo::clear_has_fashion() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LessInfo::clear_fashion() {
  if (fashion_ != NULL) fashion_->::FashionMsgProto::FashionShow::Clear();
  clear_has_fashion();
}
inline const ::FashionMsgProto::FashionShow& LessInfo::fashion() const {
  return fashion_ != NULL ? *fashion_ : *default_instance_->fashion_;
}
inline ::FashionMsgProto::FashionShow* LessInfo::mutable_fashion() {
  set_has_fashion();
  if (fashion_ == NULL) fashion_ = new ::FashionMsgProto::FashionShow;
  return fashion_;
}
inline ::FashionMsgProto::FashionShow* LessInfo::release_fashion() {
  clear_has_fashion();
  ::FashionMsgProto::FashionShow* temp = fashion_;
  fashion_ = NULL;
  return temp;
}
inline void LessInfo::set_allocated_fashion(::FashionMsgProto::FashionShow* fashion) {
  delete fashion_;
  fashion_ = fashion;
  if (fashion) {
    set_has_fashion();
  } else {
    clear_has_fashion();
  }
}

// optional .VitalityProto.ProtoVitalityInfo vitality = 10;
inline bool LessInfo::has_vitality() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LessInfo::set_has_vitality() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LessInfo::clear_has_vitality() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LessInfo::clear_vitality() {
  if (vitality_ != NULL) vitality_->::VitalityProto::ProtoVitalityInfo::Clear();
  clear_has_vitality();
}
inline const ::VitalityProto::ProtoVitalityInfo& LessInfo::vitality() const {
  return vitality_ != NULL ? *vitality_ : *default_instance_->vitality_;
}
inline ::VitalityProto::ProtoVitalityInfo* LessInfo::mutable_vitality() {
  set_has_vitality();
  if (vitality_ == NULL) vitality_ = new ::VitalityProto::ProtoVitalityInfo;
  return vitality_;
}
inline ::VitalityProto::ProtoVitalityInfo* LessInfo::release_vitality() {
  clear_has_vitality();
  ::VitalityProto::ProtoVitalityInfo* temp = vitality_;
  vitality_ = NULL;
  return temp;
}
inline void LessInfo::set_allocated_vitality(::VitalityProto::ProtoVitalityInfo* vitality) {
  delete vitality_;
  vitality_ = vitality;
  if (vitality) {
    set_has_vitality();
  } else {
    clear_has_vitality();
  }
}

// optional .PlayerInfo.CampShopInfo campShopData = 11;
inline bool LessInfo::has_campshopdata() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LessInfo::set_has_campshopdata() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LessInfo::clear_has_campshopdata() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LessInfo::clear_campshopdata() {
  if (campshopdata_ != NULL) campshopdata_->::PlayerInfo::CampShopInfo::Clear();
  clear_has_campshopdata();
}
inline const ::PlayerInfo::CampShopInfo& LessInfo::campshopdata() const {
  return campshopdata_ != NULL ? *campshopdata_ : *default_instance_->campshopdata_;
}
inline ::PlayerInfo::CampShopInfo* LessInfo::mutable_campshopdata() {
  set_has_campshopdata();
  if (campshopdata_ == NULL) campshopdata_ = new ::PlayerInfo::CampShopInfo;
  return campshopdata_;
}
inline ::PlayerInfo::CampShopInfo* LessInfo::release_campshopdata() {
  clear_has_campshopdata();
  ::PlayerInfo::CampShopInfo* temp = campshopdata_;
  campshopdata_ = NULL;
  return temp;
}
inline void LessInfo::set_allocated_campshopdata(::PlayerInfo::CampShopInfo* campshopdata) {
  delete campshopdata_;
  campshopdata_ = campshopdata;
  if (campshopdata) {
    set_has_campshopdata();
  } else {
    clear_has_campshopdata();
  }
}

// optional .PlayerInfo.FestivalInfo festivalData = 12;
inline bool LessInfo::has_festivaldata() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LessInfo::set_has_festivaldata() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LessInfo::clear_has_festivaldata() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LessInfo::clear_festivaldata() {
  if (festivaldata_ != NULL) festivaldata_->::PlayerInfo::FestivalInfo::Clear();
  clear_has_festivaldata();
}
inline const ::PlayerInfo::FestivalInfo& LessInfo::festivaldata() const {
  return festivaldata_ != NULL ? *festivaldata_ : *default_instance_->festivaldata_;
}
inline ::PlayerInfo::FestivalInfo* LessInfo::mutable_festivaldata() {
  set_has_festivaldata();
  if (festivaldata_ == NULL) festivaldata_ = new ::PlayerInfo::FestivalInfo;
  return festivaldata_;
}
inline ::PlayerInfo::FestivalInfo* LessInfo::release_festivaldata() {
  clear_has_festivaldata();
  ::PlayerInfo::FestivalInfo* temp = festivaldata_;
  festivaldata_ = NULL;
  return temp;
}
inline void LessInfo::set_allocated_festivaldata(::PlayerInfo::FestivalInfo* festivaldata) {
  delete festivaldata_;
  festivaldata_ = festivaldata;
  if (festivaldata) {
    set_has_festivaldata();
  } else {
    clear_has_festivaldata();
  }
}

// optional .PlayerInfo.MoneyInstance info = 13;
inline bool LessInfo::has_info() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LessInfo::set_has_info() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LessInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LessInfo::clear_info() {
  if (info_ != NULL) info_->::PlayerInfo::MoneyInstance::Clear();
  clear_has_info();
}
inline const ::PlayerInfo::MoneyInstance& LessInfo::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::PlayerInfo::MoneyInstance* LessInfo::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::PlayerInfo::MoneyInstance;
  return info_;
}
inline ::PlayerInfo::MoneyInstance* LessInfo::release_info() {
  clear_has_info();
  ::PlayerInfo::MoneyInstance* temp = info_;
  info_ = NULL;
  return temp;
}
inline void LessInfo::set_allocated_info(::PlayerInfo::MoneyInstance* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// StoneInfo

// repeated .PlayerInfo.StoneItem item = 1;
inline int StoneInfo::item_size() const {
  return item_.size();
}
inline void StoneInfo::clear_item() {
  item_.Clear();
}
inline const ::PlayerInfo::StoneItem& StoneInfo::item(int index) const {
  return item_.Get(index);
}
inline ::PlayerInfo::StoneItem* StoneInfo::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::PlayerInfo::StoneItem* StoneInfo::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::StoneItem >&
StoneInfo::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::StoneItem >*
StoneInfo::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// StoneItem

// required int32 pos = 1;
inline bool StoneItem::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoneItem::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoneItem::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoneItem::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 StoneItem::pos() const {
  return pos_;
}
inline void StoneItem::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// repeated int32 stoneid = 2;
inline int StoneItem::stoneid_size() const {
  return stoneid_.size();
}
inline void StoneItem::clear_stoneid() {
  stoneid_.Clear();
}
inline ::google::protobuf::int32 StoneItem::stoneid(int index) const {
  return stoneid_.Get(index);
}
inline void StoneItem::set_stoneid(int index, ::google::protobuf::int32 value) {
  stoneid_.Set(index, value);
}
inline void StoneItem::add_stoneid(::google::protobuf::int32 value) {
  stoneid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
StoneItem::stoneid() const {
  return stoneid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
StoneItem::mutable_stoneid() {
  return &stoneid_;
}

// -------------------------------------------------------------------

// DBAchShopInfo

// optional int64 time = 1;
inline bool DBAchShopInfo::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBAchShopInfo::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBAchShopInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBAchShopInfo::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 DBAchShopInfo::time() const {
  return time_;
}
inline void DBAchShopInfo::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// repeated .PlayerInfo.DBAchShopItem item = 2;
inline int DBAchShopInfo::item_size() const {
  return item_.size();
}
inline void DBAchShopInfo::clear_item() {
  item_.Clear();
}
inline const ::PlayerInfo::DBAchShopItem& DBAchShopInfo::item(int index) const {
  return item_.Get(index);
}
inline ::PlayerInfo::DBAchShopItem* DBAchShopInfo::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::PlayerInfo::DBAchShopItem* DBAchShopInfo::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DBAchShopItem >&
DBAchShopInfo::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::DBAchShopItem >*
DBAchShopInfo::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// DBAchShopItem

// required int32 id = 1;
inline bool DBAchShopItem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBAchShopItem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBAchShopItem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBAchShopItem::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 DBAchShopItem::id() const {
  return id_;
}
inline void DBAchShopItem::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 count = 2;
inline bool DBAchShopItem::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBAchShopItem::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBAchShopItem::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBAchShopItem::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 DBAchShopItem::count() const {
  return count_;
}
inline void DBAchShopItem::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// repeated int32 goodsid = 3;
inline int DBAchShopItem::goodsid_size() const {
  return goodsid_.size();
}
inline void DBAchShopItem::clear_goodsid() {
  goodsid_.Clear();
}
inline ::google::protobuf::int32 DBAchShopItem::goodsid(int index) const {
  return goodsid_.Get(index);
}
inline void DBAchShopItem::set_goodsid(int index, ::google::protobuf::int32 value) {
  goodsid_.Set(index, value);
}
inline void DBAchShopItem::add_goodsid(::google::protobuf::int32 value) {
  goodsid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DBAchShopItem::goodsid() const {
  return goodsid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DBAchShopItem::mutable_goodsid() {
  return &goodsid_;
}

// -------------------------------------------------------------------

// CampShopInfo

// optional int64 time = 1;
inline bool CampShopInfo::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CampShopInfo::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CampShopInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CampShopInfo::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 CampShopInfo::time() const {
  return time_;
}
inline void CampShopInfo::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// repeated .PlayerInfo.CampShopItem item = 2;
inline int CampShopInfo::item_size() const {
  return item_.size();
}
inline void CampShopInfo::clear_item() {
  item_.Clear();
}
inline const ::PlayerInfo::CampShopItem& CampShopInfo::item(int index) const {
  return item_.Get(index);
}
inline ::PlayerInfo::CampShopItem* CampShopInfo::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::PlayerInfo::CampShopItem* CampShopInfo::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::CampShopItem >&
CampShopInfo::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::CampShopItem >*
CampShopInfo::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// CampShopItem

// optional int32 id = 1;
inline bool CampShopItem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CampShopItem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CampShopItem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CampShopItem::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 CampShopItem::id() const {
  return id_;
}
inline void CampShopItem::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 nums = 2;
inline bool CampShopItem::has_nums() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CampShopItem::set_has_nums() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CampShopItem::clear_has_nums() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CampShopItem::clear_nums() {
  nums_ = 0;
  clear_has_nums();
}
inline ::google::protobuf::int32 CampShopItem::nums() const {
  return nums_;
}
inline void CampShopItem::set_nums(::google::protobuf::int32 value) {
  set_has_nums();
  nums_ = value;
}

// -------------------------------------------------------------------

// FestivalInfo

// optional int64 time = 1;
inline bool FestivalInfo::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FestivalInfo::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FestivalInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FestivalInfo::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 FestivalInfo::time() const {
  return time_;
}
inline void FestivalInfo::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// repeated .PlayerInfo.festivalItem item = 2;
inline int FestivalInfo::item_size() const {
  return item_.size();
}
inline void FestivalInfo::clear_item() {
  item_.Clear();
}
inline const ::PlayerInfo::festivalItem& FestivalInfo::item(int index) const {
  return item_.Get(index);
}
inline ::PlayerInfo::festivalItem* FestivalInfo::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::PlayerInfo::festivalItem* FestivalInfo::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::festivalItem >&
FestivalInfo::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::festivalItem >*
FestivalInfo::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// festivalItem

// optional int32 id = 1;
inline bool festivalItem::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void festivalItem::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void festivalItem::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void festivalItem::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 festivalItem::id() const {
  return id_;
}
inline void festivalItem::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 nums = 2;
inline bool festivalItem::has_nums() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void festivalItem::set_has_nums() {
  _has_bits_[0] |= 0x00000002u;
}
inline void festivalItem::clear_has_nums() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void festivalItem::clear_nums() {
  nums_ = 0;
  clear_has_nums();
}
inline ::google::protobuf::int32 festivalItem::nums() const {
  return nums_;
}
inline void festivalItem::set_nums(::google::protobuf::int32 value) {
  set_has_nums();
  nums_ = value;
}

// -------------------------------------------------------------------

// MoneyInstance

// optional int32 mapId = 1;
inline bool MoneyInstance::has_mapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoneyInstance::set_has_mapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoneyInstance::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoneyInstance::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 MoneyInstance::mapid() const {
  return mapid_;
}
inline void MoneyInstance::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
}

// optional int32 pass = 2;
inline bool MoneyInstance::has_pass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoneyInstance::set_has_pass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoneyInstance::clear_has_pass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoneyInstance::clear_pass() {
  pass_ = 0;
  clear_has_pass();
}
inline ::google::protobuf::int32 MoneyInstance::pass() const {
  return pass_;
}
inline void MoneyInstance::set_pass(::google::protobuf::int32 value) {
  set_has_pass();
  pass_ = value;
}

// optional int32 num = 3;
inline bool MoneyInstance::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoneyInstance::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoneyInstance::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoneyInstance::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 MoneyInstance::num() const {
  return num_;
}
inline void MoneyInstance::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 buytimes = 4;
inline bool MoneyInstance::has_buytimes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoneyInstance::set_has_buytimes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoneyInstance::clear_has_buytimes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoneyInstance::clear_buytimes() {
  buytimes_ = 0;
  clear_has_buytimes();
}
inline ::google::protobuf::int32 MoneyInstance::buytimes() const {
  return buytimes_;
}
inline void MoneyInstance::set_buytimes(::google::protobuf::int32 value) {
  set_has_buytimes();
  buytimes_ = value;
}

// optional int32 reset = 5;
inline bool MoneyInstance::has_reset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoneyInstance::set_has_reset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoneyInstance::clear_has_reset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoneyInstance::clear_reset() {
  reset_ = 0;
  clear_has_reset();
}
inline ::google::protobuf::int32 MoneyInstance::reset() const {
  return reset_;
}
inline void MoneyInstance::set_reset(::google::protobuf::int32 value) {
  set_has_reset();
  reset_ = value;
}

// optional int64 updatetime = 6;
inline bool MoneyInstance::has_updatetime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoneyInstance::set_has_updatetime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoneyInstance::clear_has_updatetime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoneyInstance::clear_updatetime() {
  updatetime_ = GOOGLE_LONGLONG(0);
  clear_has_updatetime();
}
inline ::google::protobuf::int64 MoneyInstance::updatetime() const {
  return updatetime_;
}
inline void MoneyInstance::set_updatetime(::google::protobuf::int64 value) {
  set_has_updatetime();
  updatetime_ = value;
}

// -------------------------------------------------------------------

// ChallengeInstance

// optional int32 layer = 1;
inline bool ChallengeInstance::has_layer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChallengeInstance::set_has_layer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChallengeInstance::clear_has_layer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChallengeInstance::clear_layer() {
  layer_ = 0;
  clear_has_layer();
}
inline ::google::protobuf::int32 ChallengeInstance::layer() const {
  return layer_;
}
inline void ChallengeInstance::set_layer(::google::protobuf::int32 value) {
  set_has_layer();
  layer_ = value;
}

// optional int32 maxlayer = 2;
inline bool ChallengeInstance::has_maxlayer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChallengeInstance::set_has_maxlayer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChallengeInstance::clear_has_maxlayer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChallengeInstance::clear_maxlayer() {
  maxlayer_ = 0;
  clear_has_maxlayer();
}
inline ::google::protobuf::int32 ChallengeInstance::maxlayer() const {
  return maxlayer_;
}
inline void ChallengeInstance::set_maxlayer(::google::protobuf::int32 value) {
  set_has_maxlayer();
  maxlayer_ = value;
}

// -------------------------------------------------------------------

// HeroInstanceData

// optional int32 layer = 1;
inline bool HeroInstanceData::has_layer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeroInstanceData::set_has_layer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeroInstanceData::clear_has_layer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeroInstanceData::clear_layer() {
  layer_ = 0;
  clear_has_layer();
}
inline ::google::protobuf::int32 HeroInstanceData::layer() const {
  return layer_;
}
inline void HeroInstanceData::set_layer(::google::protobuf::int32 value) {
  set_has_layer();
  layer_ = value;
}

// repeated int32 fetchs = 2;
inline int HeroInstanceData::fetchs_size() const {
  return fetchs_.size();
}
inline void HeroInstanceData::clear_fetchs() {
  fetchs_.Clear();
}
inline ::google::protobuf::int32 HeroInstanceData::fetchs(int index) const {
  return fetchs_.Get(index);
}
inline void HeroInstanceData::set_fetchs(int index, ::google::protobuf::int32 value) {
  fetchs_.Set(index, value);
}
inline void HeroInstanceData::add_fetchs(::google::protobuf::int32 value) {
  fetchs_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
HeroInstanceData::fetchs() const {
  return fetchs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
HeroInstanceData::mutable_fetchs() {
  return &fetchs_;
}

// -------------------------------------------------------------------

// BranchLineInfo

// repeated .PlayerInfo.LineMapInfo info = 1;
inline int BranchLineInfo::info_size() const {
  return info_.size();
}
inline void BranchLineInfo::clear_info() {
  info_.Clear();
}
inline const ::PlayerInfo::LineMapInfo& BranchLineInfo::info(int index) const {
  return info_.Get(index);
}
inline ::PlayerInfo::LineMapInfo* BranchLineInfo::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::PlayerInfo::LineMapInfo* BranchLineInfo::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::LineMapInfo >&
BranchLineInfo::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::LineMapInfo >*
BranchLineInfo::mutable_info() {
  return &info_;
}

// -------------------------------------------------------------------

// TotalBranchLineInfo

// repeated .PlayerInfo.BranchLineInfo list = 1;
inline int TotalBranchLineInfo::list_size() const {
  return list_.size();
}
inline void TotalBranchLineInfo::clear_list() {
  list_.Clear();
}
inline const ::PlayerInfo::BranchLineInfo& TotalBranchLineInfo::list(int index) const {
  return list_.Get(index);
}
inline ::PlayerInfo::BranchLineInfo* TotalBranchLineInfo::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::PlayerInfo::BranchLineInfo* TotalBranchLineInfo::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BranchLineInfo >&
TotalBranchLineInfo::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BranchLineInfo >*
TotalBranchLineInfo::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// ClientIEInfo

// required string info = 1;
inline bool ClientIEInfo::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientIEInfo::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientIEInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientIEInfo::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& ClientIEInfo::info() const {
  return *info_;
}
inline void ClientIEInfo::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void ClientIEInfo::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void ClientIEInfo::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientIEInfo::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* ClientIEInfo::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientIEInfo::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OnceRewardInfo

// optional bool microRewardFlag = 1;
inline bool OnceRewardInfo::has_microrewardflag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnceRewardInfo::set_has_microrewardflag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnceRewardInfo::clear_has_microrewardflag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnceRewardInfo::clear_microrewardflag() {
  microrewardflag_ = false;
  clear_has_microrewardflag();
}
inline bool OnceRewardInfo::microrewardflag() const {
  return microrewardflag_;
}
inline void OnceRewardInfo::set_microrewardflag(bool value) {
  set_has_microrewardflag();
  microrewardflag_ = value;
}

// optional bool firstChargeOverFlag = 2;
inline bool OnceRewardInfo::has_firstchargeoverflag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnceRewardInfo::set_has_firstchargeoverflag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnceRewardInfo::clear_has_firstchargeoverflag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnceRewardInfo::clear_firstchargeoverflag() {
  firstchargeoverflag_ = false;
  clear_has_firstchargeoverflag();
}
inline bool OnceRewardInfo::firstchargeoverflag() const {
  return firstchargeoverflag_;
}
inline void OnceRewardInfo::set_firstchargeoverflag(bool value) {
  set_has_firstchargeoverflag();
  firstchargeoverflag_ = value;
}

// -------------------------------------------------------------------

// GroupInstance

// optional int64 timeReset = 1;
inline bool GroupInstance::has_timereset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupInstance::set_has_timereset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupInstance::clear_has_timereset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupInstance::clear_timereset() {
  timereset_ = GOOGLE_LONGLONG(0);
  clear_has_timereset();
}
inline ::google::protobuf::int64 GroupInstance::timereset() const {
  return timereset_;
}
inline void GroupInstance::set_timereset(::google::protobuf::int64 value) {
  set_has_timereset();
  timereset_ = value;
}

// repeated .PlayerInfo.InstanceGroupList groupList = 2;
inline int GroupInstance::grouplist_size() const {
  return grouplist_.size();
}
inline void GroupInstance::clear_grouplist() {
  grouplist_.Clear();
}
inline const ::PlayerInfo::InstanceGroupList& GroupInstance::grouplist(int index) const {
  return grouplist_.Get(index);
}
inline ::PlayerInfo::InstanceGroupList* GroupInstance::mutable_grouplist(int index) {
  return grouplist_.Mutable(index);
}
inline ::PlayerInfo::InstanceGroupList* GroupInstance::add_grouplist() {
  return grouplist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceGroupList >&
GroupInstance::grouplist() const {
  return grouplist_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceGroupList >*
GroupInstance::mutable_grouplist() {
  return &grouplist_;
}

// -------------------------------------------------------------------

// InstanceGroupList

// required int32 mapId = 1;
inline bool InstanceGroupList::has_mapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceGroupList::set_has_mapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceGroupList::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceGroupList::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 InstanceGroupList::mapid() const {
  return mapid_;
}
inline void InstanceGroupList::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
}

// optional int32 num = 2;
inline bool InstanceGroupList::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceGroupList::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceGroupList::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceGroupList::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 InstanceGroupList::num() const {
  return num_;
}
inline void InstanceGroupList::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 vipnum = 3;
inline bool InstanceGroupList::has_vipnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstanceGroupList::set_has_vipnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstanceGroupList::clear_has_vipnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstanceGroupList::clear_vipnum() {
  vipnum_ = 0;
  clear_has_vipnum();
}
inline ::google::protobuf::int32 InstanceGroupList::vipnum() const {
  return vipnum_;
}
inline void InstanceGroupList::set_vipnum(::google::protobuf::int32 value) {
  set_has_vipnum();
  vipnum_ = value;
}

// optional int32 buynum = 4;
inline bool InstanceGroupList::has_buynum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstanceGroupList::set_has_buynum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstanceGroupList::clear_has_buynum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstanceGroupList::clear_buynum() {
  buynum_ = 0;
  clear_has_buynum();
}
inline ::google::protobuf::int32 InstanceGroupList::buynum() const {
  return buynum_;
}
inline void InstanceGroupList::set_buynum(::google::protobuf::int32 value) {
  set_has_buynum();
  buynum_ = value;
}

// optional int32 pass = 5;
inline bool InstanceGroupList::has_pass() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstanceGroupList::set_has_pass() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstanceGroupList::clear_has_pass() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstanceGroupList::clear_pass() {
  pass_ = 0;
  clear_has_pass();
}
inline ::google::protobuf::int32 InstanceGroupList::pass() const {
  return pass_;
}
inline void InstanceGroupList::set_pass(::google::protobuf::int32 value) {
  set_has_pass();
  pass_ = value;
}

// -------------------------------------------------------------------

// EliteInstance

// repeated .PlayerInfo.InstanceEliteList list = 1;
inline int EliteInstance::list_size() const {
  return list_.size();
}
inline void EliteInstance::clear_list() {
  list_.Clear();
}
inline const ::PlayerInfo::InstanceEliteList& EliteInstance::list(int index) const {
  return list_.Get(index);
}
inline ::PlayerInfo::InstanceEliteList* EliteInstance::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::PlayerInfo::InstanceEliteList* EliteInstance::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceEliteList >&
EliteInstance::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceEliteList >*
EliteInstance::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// InstanceEliteList

// required int32 mapId = 1;
inline bool InstanceEliteList::has_mapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceEliteList::set_has_mapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceEliteList::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceEliteList::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 InstanceEliteList::mapid() const {
  return mapid_;
}
inline void InstanceEliteList::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
}

// optional int32 pass = 2;
inline bool InstanceEliteList::has_pass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceEliteList::set_has_pass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceEliteList::clear_has_pass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceEliteList::clear_pass() {
  pass_ = 0;
  clear_has_pass();
}
inline ::google::protobuf::int32 InstanceEliteList::pass() const {
  return pass_;
}
inline void InstanceEliteList::set_pass(::google::protobuf::int32 value) {
  set_has_pass();
  pass_ = value;
}

// optional int32 num = 3;
inline bool InstanceEliteList::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstanceEliteList::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstanceEliteList::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstanceEliteList::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 InstanceEliteList::num() const {
  return num_;
}
inline void InstanceEliteList::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 time = 4;
inline bool InstanceEliteList::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstanceEliteList::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstanceEliteList::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstanceEliteList::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 InstanceEliteList::time() const {
  return time_;
}
inline void InstanceEliteList::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// optional int32 reset = 5;
inline bool InstanceEliteList::has_reset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstanceEliteList::set_has_reset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstanceEliteList::clear_has_reset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstanceEliteList::clear_reset() {
  reset_ = 0;
  clear_has_reset();
}
inline ::google::protobuf::int32 InstanceEliteList::reset() const {
  return reset_;
}
inline void InstanceEliteList::set_reset(::google::protobuf::int32 value) {
  set_has_reset();
  reset_ = value;
}

// -------------------------------------------------------------------

// CauchemarInstance

// repeated .PlayerInfo.InstanceCauchemarList list = 1;
inline int CauchemarInstance::list_size() const {
  return list_.size();
}
inline void CauchemarInstance::clear_list() {
  list_.Clear();
}
inline const ::PlayerInfo::InstanceCauchemarList& CauchemarInstance::list(int index) const {
  return list_.Get(index);
}
inline ::PlayerInfo::InstanceCauchemarList* CauchemarInstance::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::PlayerInfo::InstanceCauchemarList* CauchemarInstance::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceCauchemarList >&
CauchemarInstance::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceCauchemarList >*
CauchemarInstance::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// InstanceCauchemarList

// required int32 mapId = 1;
inline bool InstanceCauchemarList::has_mapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceCauchemarList::set_has_mapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceCauchemarList::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceCauchemarList::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 InstanceCauchemarList::mapid() const {
  return mapid_;
}
inline void InstanceCauchemarList::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
}

// optional int32 pass = 2;
inline bool InstanceCauchemarList::has_pass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceCauchemarList::set_has_pass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceCauchemarList::clear_has_pass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceCauchemarList::clear_pass() {
  pass_ = 0;
  clear_has_pass();
}
inline ::google::protobuf::int32 InstanceCauchemarList::pass() const {
  return pass_;
}
inline void InstanceCauchemarList::set_pass(::google::protobuf::int32 value) {
  set_has_pass();
  pass_ = value;
}

// optional int32 num = 3;
inline bool InstanceCauchemarList::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstanceCauchemarList::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstanceCauchemarList::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstanceCauchemarList::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 InstanceCauchemarList::num() const {
  return num_;
}
inline void InstanceCauchemarList::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 time = 4;
inline bool InstanceCauchemarList::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstanceCauchemarList::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstanceCauchemarList::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstanceCauchemarList::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 InstanceCauchemarList::time() const {
  return time_;
}
inline void InstanceCauchemarList::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// optional int32 reset = 5;
inline bool InstanceCauchemarList::has_reset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstanceCauchemarList::set_has_reset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstanceCauchemarList::clear_has_reset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstanceCauchemarList::clear_reset() {
  reset_ = 0;
  clear_has_reset();
}
inline ::google::protobuf::int32 InstanceCauchemarList::reset() const {
  return reset_;
}
inline void InstanceCauchemarList::set_reset(::google::protobuf::int32 value) {
  set_has_reset();
  reset_ = value;
}

// -------------------------------------------------------------------

// AdvancedInstance

// repeated .PlayerInfo.InstanceAdvancedList list = 1;
inline int AdvancedInstance::list_size() const {
  return list_.size();
}
inline void AdvancedInstance::clear_list() {
  list_.Clear();
}
inline const ::PlayerInfo::InstanceAdvancedList& AdvancedInstance::list(int index) const {
  return list_.Get(index);
}
inline ::PlayerInfo::InstanceAdvancedList* AdvancedInstance::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::PlayerInfo::InstanceAdvancedList* AdvancedInstance::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceAdvancedList >&
AdvancedInstance::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::InstanceAdvancedList >*
AdvancedInstance::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// InstanceAdvancedList

// required int32 mapId = 1;
inline bool InstanceAdvancedList::has_mapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstanceAdvancedList::set_has_mapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstanceAdvancedList::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstanceAdvancedList::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 InstanceAdvancedList::mapid() const {
  return mapid_;
}
inline void InstanceAdvancedList::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
}

// optional int32 pass = 2;
inline bool InstanceAdvancedList::has_pass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstanceAdvancedList::set_has_pass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstanceAdvancedList::clear_has_pass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstanceAdvancedList::clear_pass() {
  pass_ = 0;
  clear_has_pass();
}
inline ::google::protobuf::int32 InstanceAdvancedList::pass() const {
  return pass_;
}
inline void InstanceAdvancedList::set_pass(::google::protobuf::int32 value) {
  set_has_pass();
  pass_ = value;
}

// optional int32 num = 3;
inline bool InstanceAdvancedList::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstanceAdvancedList::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstanceAdvancedList::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstanceAdvancedList::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 InstanceAdvancedList::num() const {
  return num_;
}
inline void InstanceAdvancedList::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 time = 4;
inline bool InstanceAdvancedList::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstanceAdvancedList::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstanceAdvancedList::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstanceAdvancedList::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 InstanceAdvancedList::time() const {
  return time_;
}
inline void InstanceAdvancedList::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// optional int32 reset = 5;
inline bool InstanceAdvancedList::has_reset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstanceAdvancedList::set_has_reset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstanceAdvancedList::clear_has_reset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstanceAdvancedList::clear_reset() {
  reset_ = 0;
  clear_has_reset();
}
inline ::google::protobuf::int32 InstanceAdvancedList::reset() const {
  return reset_;
}
inline void InstanceAdvancedList::set_reset(::google::protobuf::int32 value) {
  set_has_reset();
  reset_ = value;
}

// -------------------------------------------------------------------

// BaseShopInfo

// optional int64 flushTime = 1;
inline bool BaseShopInfo::has_flushtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseShopInfo::set_has_flushtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseShopInfo::clear_has_flushtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseShopInfo::clear_flushtime() {
  flushtime_ = GOOGLE_LONGLONG(0);
  clear_has_flushtime();
}
inline ::google::protobuf::int64 BaseShopInfo::flushtime() const {
  return flushtime_;
}
inline void BaseShopInfo::set_flushtime(::google::protobuf::int64 value) {
  set_has_flushtime();
  flushtime_ = value;
}

// repeated .PlayerInfo.BaseShopInfoList list = 2;
inline int BaseShopInfo::list_size() const {
  return list_.size();
}
inline void BaseShopInfo::clear_list() {
  list_.Clear();
}
inline const ::PlayerInfo::BaseShopInfoList& BaseShopInfo::list(int index) const {
  return list_.Get(index);
}
inline ::PlayerInfo::BaseShopInfoList* BaseShopInfo::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::PlayerInfo::BaseShopInfoList* BaseShopInfo::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BaseShopInfoList >&
BaseShopInfo::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BaseShopInfoList >*
BaseShopInfo::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// BaseShopInfoList

// required int32 type = 1;
inline bool BaseShopInfoList::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseShopInfoList::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseShopInfoList::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseShopInfoList::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 BaseShopInfoList::type() const {
  return type_;
}
inline void BaseShopInfoList::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated .PlayerInfo.BaseShopInfoData data = 2;
inline int BaseShopInfoList::data_size() const {
  return data_.size();
}
inline void BaseShopInfoList::clear_data() {
  data_.Clear();
}
inline const ::PlayerInfo::BaseShopInfoData& BaseShopInfoList::data(int index) const {
  return data_.Get(index);
}
inline ::PlayerInfo::BaseShopInfoData* BaseShopInfoList::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::PlayerInfo::BaseShopInfoData* BaseShopInfoList::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BaseShopInfoData >&
BaseShopInfoList::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::PlayerInfo::BaseShopInfoData >*
BaseShopInfoList::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// BaseShopInfoData

// optional int32 id = 1;
inline bool BaseShopInfoData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseShopInfoData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseShopInfoData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseShopInfoData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 BaseShopInfoData::id() const {
  return id_;
}
inline void BaseShopInfoData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 nums = 2;
inline bool BaseShopInfoData::has_nums() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BaseShopInfoData::set_has_nums() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BaseShopInfoData::clear_has_nums() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BaseShopInfoData::clear_nums() {
  nums_ = 0;
  clear_has_nums();
}
inline ::google::protobuf::int32 BaseShopInfoData::nums() const {
  return nums_;
}
inline void BaseShopInfoData::set_nums(::google::protobuf::int32 value) {
  set_has_nums();
  nums_ = value;
}

// -------------------------------------------------------------------

// AnswerInfo

// optional int32 currentIndex = 1;
inline bool AnswerInfo::has_currentindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnswerInfo::set_has_currentindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnswerInfo::clear_has_currentindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnswerInfo::clear_currentindex() {
  currentindex_ = 0;
  clear_has_currentindex();
}
inline ::google::protobuf::int32 AnswerInfo::currentindex() const {
  return currentindex_;
}
inline void AnswerInfo::set_currentindex(::google::protobuf::int32 value) {
  set_has_currentindex();
  currentindex_ = value;
}

// optional int32 currentTitleID = 2;
inline bool AnswerInfo::has_currenttitleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnswerInfo::set_has_currenttitleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnswerInfo::clear_has_currenttitleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnswerInfo::clear_currenttitleid() {
  currenttitleid_ = 0;
  clear_has_currenttitleid();
}
inline ::google::protobuf::int32 AnswerInfo::currenttitleid() const {
  return currenttitleid_;
}
inline void AnswerInfo::set_currenttitleid(::google::protobuf::int32 value) {
  set_has_currenttitleid();
  currenttitleid_ = value;
}

// optional int32 rightCounts = 3;
inline bool AnswerInfo::has_rightcounts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnswerInfo::set_has_rightcounts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnswerInfo::clear_has_rightcounts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnswerInfo::clear_rightcounts() {
  rightcounts_ = 0;
  clear_has_rightcounts();
}
inline ::google::protobuf::int32 AnswerInfo::rightcounts() const {
  return rightcounts_;
}
inline void AnswerInfo::set_rightcounts(::google::protobuf::int32 value) {
  set_has_rightcounts();
  rightcounts_ = value;
}

// optional int32 wrongCounts = 4;
inline bool AnswerInfo::has_wrongcounts() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnswerInfo::set_has_wrongcounts() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnswerInfo::clear_has_wrongcounts() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnswerInfo::clear_wrongcounts() {
  wrongcounts_ = 0;
  clear_has_wrongcounts();
}
inline ::google::protobuf::int32 AnswerInfo::wrongcounts() const {
  return wrongcounts_;
}
inline void AnswerInfo::set_wrongcounts(::google::protobuf::int32 value) {
  set_has_wrongcounts();
  wrongcounts_ = value;
}

// repeated int32 titleAnswerIds = 5;
inline int AnswerInfo::titleanswerids_size() const {
  return titleanswerids_.size();
}
inline void AnswerInfo::clear_titleanswerids() {
  titleanswerids_.Clear();
}
inline ::google::protobuf::int32 AnswerInfo::titleanswerids(int index) const {
  return titleanswerids_.Get(index);
}
inline void AnswerInfo::set_titleanswerids(int index, ::google::protobuf::int32 value) {
  titleanswerids_.Set(index, value);
}
inline void AnswerInfo::add_titleanswerids(::google::protobuf::int32 value) {
  titleanswerids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AnswerInfo::titleanswerids() const {
  return titleanswerids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AnswerInfo::mutable_titleanswerids() {
  return &titleanswerids_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace PlayerInfo

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CharLogin_2fPlayerInfo_2eproto__INCLUDED

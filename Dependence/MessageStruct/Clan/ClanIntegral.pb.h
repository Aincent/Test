// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Clan/ClanIntegral.proto

#ifndef PROTOBUF_Clan_2fClanIntegral_2eproto__INCLUDED
#define PROTOBUF_Clan_2fClanIntegral_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ClanPackage {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

class RetIntegralInfo;
class RntegralRanking;
class RetSingUpIntegral;
class RetReSingUpIntegral;
class RetAttClanInfo;
class RetNoticeWar;
class RetKillRankingInfo;
class KillRanking;
class SingleKillRanking;
class SingleKill;
class IntegralReward;
class IntegralWinReward;
class RewardInfo;
class SysReSingUp;
class SysIntegralOnlyId;
class SysIntegralToWorld;
class SysIntegral;

// ===================================================================

class RetIntegralInfo : public ::google::protobuf::Message {
 public:
  RetIntegralInfo();
  virtual ~RetIntegralInfo();

  RetIntegralInfo(const RetIntegralInfo& from);

  inline RetIntegralInfo& operator=(const RetIntegralInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RetIntegralInfo& default_instance();

  void Swap(RetIntegralInfo* other);

  // implements Message ----------------------------------------------

  RetIntegralInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetIntegralInfo& from);
  void MergeFrom(const RetIntegralInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional int32 integral = 2;
  inline bool has_integral() const;
  inline void clear_integral();
  static const int kIntegralFieldNumber = 2;
  inline ::google::protobuf::int32 integral() const;
  inline void set_integral(::google::protobuf::int32 value);

  // optional int32 power = 3;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 3;
  inline ::google::protobuf::int32 power() const;
  inline void set_power(::google::protobuf::int32 value);

  // optional int32 win = 4;
  inline bool has_win() const;
  inline void clear_win();
  static const int kWinFieldNumber = 4;
  inline ::google::protobuf::int32 win() const;
  inline void set_win(::google::protobuf::int32 value);

  // optional int32 lose = 5;
  inline bool has_lose() const;
  inline void clear_lose();
  static const int kLoseFieldNumber = 5;
  inline ::google::protobuf::int32 lose() const;
  inline void set_lose(::google::protobuf::int32 value);

  // optional bytes clanname = 6;
  inline bool has_clanname() const;
  inline void clear_clanname();
  static const int kClannameFieldNumber = 6;
  inline const ::std::string& clanname() const;
  inline void set_clanname(const ::std::string& value);
  inline void set_clanname(const char* value);
  inline void set_clanname(const void* value, size_t size);
  inline ::std::string* mutable_clanname();
  inline ::std::string* release_clanname();
  inline void set_allocated_clanname(::std::string* clanname);

  // optional int64 onlyid = 7;
  inline bool has_onlyid() const;
  inline void clear_onlyid();
  static const int kOnlyidFieldNumber = 7;
  inline ::google::protobuf::int64 onlyid() const;
  inline void set_onlyid(::google::protobuf::int64 value);

  // optional bool besingup = 8;
  inline bool has_besingup() const;
  inline void clear_besingup();
  static const int kBesingupFieldNumber = 8;
  inline bool besingup() const;
  inline void set_besingup(bool value);

  // repeated .ClanPackage.RntegralRanking info = 9;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 9;
  inline const ::ClanPackage::RntegralRanking& info(int index) const;
  inline ::ClanPackage::RntegralRanking* mutable_info(int index);
  inline ::ClanPackage::RntegralRanking* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::RntegralRanking >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::RntegralRanking >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:ClanPackage.RetIntegralInfo)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_integral();
  inline void clear_has_integral();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_win();
  inline void clear_has_win();
  inline void set_has_lose();
  inline void clear_has_lose();
  inline void set_has_clanname();
  inline void clear_has_clanname();
  inline void set_has_onlyid();
  inline void clear_has_onlyid();
  inline void set_has_besingup();
  inline void clear_has_besingup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 integral_;
  ::google::protobuf::int32 power_;
  ::google::protobuf::int32 win_;
  ::std::string* clanname_;
  ::google::protobuf::int32 lose_;
  bool besingup_;
  ::google::protobuf::int64 onlyid_;
  ::google::protobuf::RepeatedPtrField< ::ClanPackage::RntegralRanking > info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static RetIntegralInfo* default_instance_;
};
// -------------------------------------------------------------------

class RntegralRanking : public ::google::protobuf::Message {
 public:
  RntegralRanking();
  virtual ~RntegralRanking();

  RntegralRanking(const RntegralRanking& from);

  inline RntegralRanking& operator=(const RntegralRanking& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RntegralRanking& default_instance();

  void Swap(RntegralRanking* other);

  // implements Message ----------------------------------------------

  RntegralRanking* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RntegralRanking& from);
  void MergeFrom(const RntegralRanking& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes clanname = 1;
  inline bool has_clanname() const;
  inline void clear_clanname();
  static const int kClannameFieldNumber = 1;
  inline const ::std::string& clanname() const;
  inline void set_clanname(const ::std::string& value);
  inline void set_clanname(const char* value);
  inline void set_clanname(const void* value, size_t size);
  inline ::std::string* mutable_clanname();
  inline ::std::string* release_clanname();
  inline void set_allocated_clanname(::std::string* clanname);

  // optional int32 integral = 2;
  inline bool has_integral() const;
  inline void clear_integral();
  static const int kIntegralFieldNumber = 2;
  inline ::google::protobuf::int32 integral() const;
  inline void set_integral(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.RntegralRanking)
 private:
  inline void set_has_clanname();
  inline void clear_has_clanname();
  inline void set_has_integral();
  inline void clear_has_integral();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* clanname_;
  ::google::protobuf::int32 integral_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static RntegralRanking* default_instance_;
};
// -------------------------------------------------------------------

class RetSingUpIntegral : public ::google::protobuf::Message {
 public:
  RetSingUpIntegral();
  virtual ~RetSingUpIntegral();

  RetSingUpIntegral(const RetSingUpIntegral& from);

  inline RetSingUpIntegral& operator=(const RetSingUpIntegral& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RetSingUpIntegral& default_instance();

  void Swap(RetSingUpIntegral* other);

  // implements Message ----------------------------------------------

  RetSingUpIntegral* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetSingUpIntegral& from);
  void MergeFrom(const RetSingUpIntegral& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional .ClanPackage.RetIntegralInfo info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ClanPackage::RetIntegralInfo& info() const;
  inline ::ClanPackage::RetIntegralInfo* mutable_info();
  inline ::ClanPackage::RetIntegralInfo* release_info();
  inline void set_allocated_info(::ClanPackage::RetIntegralInfo* info);

  // @@protoc_insertion_point(class_scope:ClanPackage.RetSingUpIntegral)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ClanPackage::RetIntegralInfo* info_;
  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static RetSingUpIntegral* default_instance_;
};
// -------------------------------------------------------------------

class RetReSingUpIntegral : public ::google::protobuf::Message {
 public:
  RetReSingUpIntegral();
  virtual ~RetReSingUpIntegral();

  RetReSingUpIntegral(const RetReSingUpIntegral& from);

  inline RetReSingUpIntegral& operator=(const RetReSingUpIntegral& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RetReSingUpIntegral& default_instance();

  void Swap(RetReSingUpIntegral* other);

  // implements Message ----------------------------------------------

  RetReSingUpIntegral* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetReSingUpIntegral& from);
  void MergeFrom(const RetReSingUpIntegral& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional .ClanPackage.RetIntegralInfo info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ClanPackage::RetIntegralInfo& info() const;
  inline ::ClanPackage::RetIntegralInfo* mutable_info();
  inline ::ClanPackage::RetIntegralInfo* release_info();
  inline void set_allocated_info(::ClanPackage::RetIntegralInfo* info);

  // @@protoc_insertion_point(class_scope:ClanPackage.RetReSingUpIntegral)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ClanPackage::RetIntegralInfo* info_;
  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static RetReSingUpIntegral* default_instance_;
};
// -------------------------------------------------------------------

class RetAttClanInfo : public ::google::protobuf::Message {
 public:
  RetAttClanInfo();
  virtual ~RetAttClanInfo();

  RetAttClanInfo(const RetAttClanInfo& from);

  inline RetAttClanInfo& operator=(const RetAttClanInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RetAttClanInfo& default_instance();

  void Swap(RetAttClanInfo* other);

  // implements Message ----------------------------------------------

  RetAttClanInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetAttClanInfo& from);
  void MergeFrom(const RetAttClanInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional bytes clanname = 2;
  inline bool has_clanname() const;
  inline void clear_clanname();
  static const int kClannameFieldNumber = 2;
  inline const ::std::string& clanname() const;
  inline void set_clanname(const ::std::string& value);
  inline void set_clanname(const char* value);
  inline void set_clanname(const void* value, size_t size);
  inline ::std::string* mutable_clanname();
  inline ::std::string* release_clanname();
  inline void set_allocated_clanname(::std::string* clanname);

  // optional int32 clanlv = 3;
  inline bool has_clanlv() const;
  inline void clear_clanlv();
  static const int kClanlvFieldNumber = 3;
  inline ::google::protobuf::int32 clanlv() const;
  inline void set_clanlv(::google::protobuf::int32 value);

  // optional int32 pepolenum = 4;
  inline bool has_pepolenum() const;
  inline void clear_pepolenum();
  static const int kPepolenumFieldNumber = 4;
  inline ::google::protobuf::int32 pepolenum() const;
  inline void set_pepolenum(::google::protobuf::int32 value);

  // optional int32 integral = 5;
  inline bool has_integral() const;
  inline void clear_integral();
  static const int kIntegralFieldNumber = 5;
  inline ::google::protobuf::int32 integral() const;
  inline void set_integral(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.RetAttClanInfo)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_clanname();
  inline void clear_has_clanname();
  inline void set_has_clanlv();
  inline void clear_has_clanlv();
  inline void set_has_pepolenum();
  inline void clear_has_pepolenum();
  inline void set_has_integral();
  inline void clear_has_integral();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* clanname_;
  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 clanlv_;
  ::google::protobuf::int32 pepolenum_;
  ::google::protobuf::int32 integral_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static RetAttClanInfo* default_instance_;
};
// -------------------------------------------------------------------

class RetNoticeWar : public ::google::protobuf::Message {
 public:
  RetNoticeWar();
  virtual ~RetNoticeWar();

  RetNoticeWar(const RetNoticeWar& from);

  inline RetNoticeWar& operator=(const RetNoticeWar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RetNoticeWar& default_instance();

  void Swap(RetNoticeWar* other);

  // implements Message ----------------------------------------------

  RetNoticeWar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetNoticeWar& from);
  void MergeFrom(const RetNoticeWar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.RetNoticeWar)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static RetNoticeWar* default_instance_;
};
// -------------------------------------------------------------------

class RetKillRankingInfo : public ::google::protobuf::Message {
 public:
  RetKillRankingInfo();
  virtual ~RetKillRankingInfo();

  RetKillRankingInfo(const RetKillRankingInfo& from);

  inline RetKillRankingInfo& operator=(const RetKillRankingInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RetKillRankingInfo& default_instance();

  void Swap(RetKillRankingInfo* other);

  // implements Message ----------------------------------------------

  RetKillRankingInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetKillRankingInfo& from);
  void MergeFrom(const RetKillRankingInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional .ClanPackage.KillRanking myself = 2;
  inline bool has_myself() const;
  inline void clear_myself();
  static const int kMyselfFieldNumber = 2;
  inline const ::ClanPackage::KillRanking& myself() const;
  inline ::ClanPackage::KillRanking* mutable_myself();
  inline ::ClanPackage::KillRanking* release_myself();
  inline void set_allocated_myself(::ClanPackage::KillRanking* myself);

  // optional .ClanPackage.KillRanking other = 3;
  inline bool has_other() const;
  inline void clear_other();
  static const int kOtherFieldNumber = 3;
  inline const ::ClanPackage::KillRanking& other() const;
  inline ::ClanPackage::KillRanking* mutable_other();
  inline ::ClanPackage::KillRanking* release_other();
  inline void set_allocated_other(::ClanPackage::KillRanking* other);

  // @@protoc_insertion_point(class_scope:ClanPackage.RetKillRankingInfo)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_myself();
  inline void clear_has_myself();
  inline void set_has_other();
  inline void clear_has_other();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ClanPackage::KillRanking* myself_;
  ::ClanPackage::KillRanking* other_;
  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static RetKillRankingInfo* default_instance_;
};
// -------------------------------------------------------------------

class KillRanking : public ::google::protobuf::Message {
 public:
  KillRanking();
  virtual ~KillRanking();

  KillRanking(const KillRanking& from);

  inline KillRanking& operator=(const KillRanking& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KillRanking& default_instance();

  void Swap(KillRanking* other);

  // implements Message ----------------------------------------------

  KillRanking* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KillRanking& from);
  void MergeFrom(const KillRanking& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 boss = 1;
  inline bool has_boss() const;
  inline void clear_boss();
  static const int kBossFieldNumber = 1;
  inline ::google::protobuf::int32 boss() const;
  inline void set_boss(::google::protobuf::int32 value);

  // optional int32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::int32 total() const;
  inline void set_total(::google::protobuf::int32 value);

  // repeated .ClanPackage.SingleKillRanking info = 3;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 3;
  inline const ::ClanPackage::SingleKillRanking& info(int index) const;
  inline ::ClanPackage::SingleKillRanking* mutable_info(int index);
  inline ::ClanPackage::SingleKillRanking* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::SingleKillRanking >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::SingleKillRanking >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:ClanPackage.KillRanking)
 private:
  inline void set_has_boss();
  inline void clear_has_boss();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 boss_;
  ::google::protobuf::int32 total_;
  ::google::protobuf::RepeatedPtrField< ::ClanPackage::SingleKillRanking > info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static KillRanking* default_instance_;
};
// -------------------------------------------------------------------

class SingleKillRanking : public ::google::protobuf::Message {
 public:
  SingleKillRanking();
  virtual ~SingleKillRanking();

  SingleKillRanking(const SingleKillRanking& from);

  inline SingleKillRanking& operator=(const SingleKillRanking& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleKillRanking& default_instance();

  void Swap(SingleKillRanking* other);

  // implements Message ----------------------------------------------

  SingleKillRanking* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SingleKillRanking& from);
  void MergeFrom(const SingleKillRanking& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 kill = 2;
  inline bool has_kill() const;
  inline void clear_kill();
  static const int kKillFieldNumber = 2;
  inline ::google::protobuf::int32 kill() const;
  inline void set_kill(::google::protobuf::int32 value);

  // optional int32 die = 3;
  inline bool has_die() const;
  inline void clear_die();
  static const int kDieFieldNumber = 3;
  inline ::google::protobuf::int32 die() const;
  inline void set_die(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.SingleKillRanking)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_kill();
  inline void clear_has_kill();
  inline void set_has_die();
  inline void clear_has_die();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 kill_;
  ::google::protobuf::int32 die_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static SingleKillRanking* default_instance_;
};
// -------------------------------------------------------------------

class SingleKill : public ::google::protobuf::Message {
 public:
  SingleKill();
  virtual ~SingleKill();

  SingleKill(const SingleKill& from);

  inline SingleKill& operator=(const SingleKill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleKill& default_instance();

  void Swap(SingleKill* other);

  // implements Message ----------------------------------------------

  SingleKill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SingleKill& from);
  void MergeFrom(const SingleKill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 totalboss = 1;
  inline bool has_totalboss() const;
  inline void clear_totalboss();
  static const int kTotalbossFieldNumber = 1;
  inline ::google::protobuf::int32 totalboss() const;
  inline void set_totalboss(::google::protobuf::int32 value);

  // optional int32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::int32 total() const;
  inline void set_total(::google::protobuf::int32 value);

  // optional int32 othertotalboss = 3;
  inline bool has_othertotalboss() const;
  inline void clear_othertotalboss();
  static const int kOthertotalbossFieldNumber = 3;
  inline ::google::protobuf::int32 othertotalboss() const;
  inline void set_othertotalboss(::google::protobuf::int32 value);

  // optional int32 othertotal = 4;
  inline bool has_othertotal() const;
  inline void clear_othertotal();
  static const int kOthertotalFieldNumber = 4;
  inline ::google::protobuf::int32 othertotal() const;
  inline void set_othertotal(::google::protobuf::int32 value);

  // optional int32 kill = 5;
  inline bool has_kill() const;
  inline void clear_kill();
  static const int kKillFieldNumber = 5;
  inline ::google::protobuf::int32 kill() const;
  inline void set_kill(::google::protobuf::int32 value);

  // optional int32 die = 6;
  inline bool has_die() const;
  inline void clear_die();
  static const int kDieFieldNumber = 6;
  inline ::google::protobuf::int32 die() const;
  inline void set_die(::google::protobuf::int32 value);

  // optional int32 boss = 7;
  inline bool has_boss() const;
  inline void clear_boss();
  static const int kBossFieldNumber = 7;
  inline ::google::protobuf::int32 boss() const;
  inline void set_boss(::google::protobuf::int32 value);

  // optional int32 ranking = 8;
  inline bool has_ranking() const;
  inline void clear_ranking();
  static const int kRankingFieldNumber = 8;
  inline ::google::protobuf::int32 ranking() const;
  inline void set_ranking(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.SingleKill)
 private:
  inline void set_has_totalboss();
  inline void clear_has_totalboss();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_othertotalboss();
  inline void clear_has_othertotalboss();
  inline void set_has_othertotal();
  inline void clear_has_othertotal();
  inline void set_has_kill();
  inline void clear_has_kill();
  inline void set_has_die();
  inline void clear_has_die();
  inline void set_has_boss();
  inline void clear_has_boss();
  inline void set_has_ranking();
  inline void clear_has_ranking();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 totalboss_;
  ::google::protobuf::int32 total_;
  ::google::protobuf::int32 othertotalboss_;
  ::google::protobuf::int32 othertotal_;
  ::google::protobuf::int32 kill_;
  ::google::protobuf::int32 die_;
  ::google::protobuf::int32 boss_;
  ::google::protobuf::int32 ranking_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static SingleKill* default_instance_;
};
// -------------------------------------------------------------------

class IntegralReward : public ::google::protobuf::Message {
 public:
  IntegralReward();
  virtual ~IntegralReward();

  IntegralReward(const IntegralReward& from);

  inline IntegralReward& operator=(const IntegralReward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntegralReward& default_instance();

  void Swap(IntegralReward* other);

  // implements Message ----------------------------------------------

  IntegralReward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntegralReward& from);
  void MergeFrom(const IntegralReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 IsSuccess = 1;
  inline bool has_issuccess() const;
  inline void clear_issuccess();
  static const int kIsSuccessFieldNumber = 1;
  inline ::google::protobuf::int32 issuccess() const;
  inline void set_issuccess(::google::protobuf::int32 value);

  // optional int32 clanIntegral = 2;
  inline bool has_clanintegral() const;
  inline void clear_clanintegral();
  static const int kClanIntegralFieldNumber = 2;
  inline ::google::protobuf::int32 clanintegral() const;
  inline void set_clanintegral(::google::protobuf::int32 value);

  // optional int32 clanmoney = 3;
  inline bool has_clanmoney() const;
  inline void clear_clanmoney();
  static const int kClanmoneyFieldNumber = 3;
  inline ::google::protobuf::int32 clanmoney() const;
  inline void set_clanmoney(::google::protobuf::int32 value);

  // optional int32 kill = 4;
  inline bool has_kill() const;
  inline void clear_kill();
  static const int kKillFieldNumber = 4;
  inline ::google::protobuf::int32 kill() const;
  inline void set_kill(::google::protobuf::int32 value);

  // repeated .ClanPackage.RewardInfo items = 5;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 5;
  inline const ::ClanPackage::RewardInfo& items(int index) const;
  inline ::ClanPackage::RewardInfo* mutable_items(int index);
  inline ::ClanPackage::RewardInfo* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >*
      mutable_items();

  // repeated .ClanPackage.RewardInfo singkillitems = 6;
  inline int singkillitems_size() const;
  inline void clear_singkillitems();
  static const int kSingkillitemsFieldNumber = 6;
  inline const ::ClanPackage::RewardInfo& singkillitems(int index) const;
  inline ::ClanPackage::RewardInfo* mutable_singkillitems(int index);
  inline ::ClanPackage::RewardInfo* add_singkillitems();
  inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >&
      singkillitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >*
      mutable_singkillitems();

  // repeated .ClanPackage.RewardInfo mvpitems = 7;
  inline int mvpitems_size() const;
  inline void clear_mvpitems();
  static const int kMvpitemsFieldNumber = 7;
  inline const ::ClanPackage::RewardInfo& mvpitems(int index) const;
  inline ::ClanPackage::RewardInfo* mutable_mvpitems(int index);
  inline ::ClanPackage::RewardInfo* add_mvpitems();
  inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >&
      mvpitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >*
      mutable_mvpitems();

  // repeated .ClanPackage.RewardInfo killitems = 8;
  inline int killitems_size() const;
  inline void clear_killitems();
  static const int kKillitemsFieldNumber = 8;
  inline const ::ClanPackage::RewardInfo& killitems(int index) const;
  inline ::ClanPackage::RewardInfo* mutable_killitems(int index);
  inline ::ClanPackage::RewardInfo* add_killitems();
  inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >&
      killitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >*
      mutable_killitems();

  // @@protoc_insertion_point(class_scope:ClanPackage.IntegralReward)
 private:
  inline void set_has_issuccess();
  inline void clear_has_issuccess();
  inline void set_has_clanintegral();
  inline void clear_has_clanintegral();
  inline void set_has_clanmoney();
  inline void clear_has_clanmoney();
  inline void set_has_kill();
  inline void clear_has_kill();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 issuccess_;
  ::google::protobuf::int32 clanintegral_;
  ::google::protobuf::int32 clanmoney_;
  ::google::protobuf::int32 kill_;
  ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo > items_;
  ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo > singkillitems_;
  ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo > mvpitems_;
  ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo > killitems_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static IntegralReward* default_instance_;
};
// -------------------------------------------------------------------

class IntegralWinReward : public ::google::protobuf::Message {
 public:
  IntegralWinReward();
  virtual ~IntegralWinReward();

  IntegralWinReward(const IntegralWinReward& from);

  inline IntegralWinReward& operator=(const IntegralWinReward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IntegralWinReward& default_instance();

  void Swap(IntegralWinReward* other);

  // implements Message ----------------------------------------------

  IntegralWinReward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IntegralWinReward& from);
  void MergeFrom(const IntegralWinReward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ClanPackage.RewardInfo items = 5;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 5;
  inline const ::ClanPackage::RewardInfo& items(int index) const;
  inline ::ClanPackage::RewardInfo* mutable_items(int index);
  inline ::ClanPackage::RewardInfo* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:ClanPackage.IntegralWinReward)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static IntegralWinReward* default_instance_;
};
// -------------------------------------------------------------------

class RewardInfo : public ::google::protobuf::Message {
 public:
  RewardInfo();
  virtual ~RewardInfo();

  RewardInfo(const RewardInfo& from);

  inline RewardInfo& operator=(const RewardInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardInfo& default_instance();

  void Swap(RewardInfo* other);

  // implements Message ----------------------------------------------

  RewardInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RewardInfo& from);
  void MergeFrom(const RewardInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 itemid = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 itemnum = 2;
  inline bool has_itemnum() const;
  inline void clear_itemnum();
  static const int kItemnumFieldNumber = 2;
  inline ::google::protobuf::int32 itemnum() const;
  inline void set_itemnum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.RewardInfo)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_itemnum();
  inline void clear_has_itemnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 itemnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static RewardInfo* default_instance_;
};
// -------------------------------------------------------------------

class SysReSingUp : public ::google::protobuf::Message {
 public:
  SysReSingUp();
  virtual ~SysReSingUp();

  SysReSingUp(const SysReSingUp& from);

  inline SysReSingUp& operator=(const SysReSingUp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysReSingUp& default_instance();

  void Swap(SysReSingUp* other);

  // implements Message ----------------------------------------------

  SysReSingUp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysReSingUp& from);
  void MergeFrom(const SysReSingUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // optional int32 golden = 2;
  inline bool has_golden() const;
  inline void clear_golden();
  static const int kGoldenFieldNumber = 2;
  inline ::google::protobuf::int32 golden() const;
  inline void set_golden(::google::protobuf::int32 value);

  // optional int32 ret = 3;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 3;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.SysReSingUp)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_golden();
  inline void clear_has_golden();
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::google::protobuf::int32 golden_;
  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static SysReSingUp* default_instance_;
};
// -------------------------------------------------------------------

class SysIntegralOnlyId : public ::google::protobuf::Message {
 public:
  SysIntegralOnlyId();
  virtual ~SysIntegralOnlyId();

  SysIntegralOnlyId(const SysIntegralOnlyId& from);

  inline SysIntegralOnlyId& operator=(const SysIntegralOnlyId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysIntegralOnlyId& default_instance();

  void Swap(SysIntegralOnlyId* other);

  // implements Message ----------------------------------------------

  SysIntegralOnlyId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysIntegralOnlyId& from);
  void MergeFrom(const SysIntegralOnlyId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 onlyid = 1;
  inline bool has_onlyid() const;
  inline void clear_onlyid();
  static const int kOnlyidFieldNumber = 1;
  inline ::google::protobuf::int64 onlyid() const;
  inline void set_onlyid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.SysIntegralOnlyId)
 private:
  inline void set_has_onlyid();
  inline void clear_has_onlyid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 onlyid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static SysIntegralOnlyId* default_instance_;
};
// -------------------------------------------------------------------

class SysIntegralToWorld : public ::google::protobuf::Message {
 public:
  SysIntegralToWorld();
  virtual ~SysIntegralToWorld();

  SysIntegralToWorld(const SysIntegralToWorld& from);

  inline SysIntegralToWorld& operator=(const SysIntegralToWorld& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysIntegralToWorld& default_instance();

  void Swap(SysIntegralToWorld* other);

  // implements Message ----------------------------------------------

  SysIntegralToWorld* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysIntegralToWorld& from);
  void MergeFrom(const SysIntegralToWorld& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ClanPackage.SysIntegral integralf = 1;
  inline bool has_integralf() const;
  inline void clear_integralf();
  static const int kIntegralfFieldNumber = 1;
  inline const ::ClanPackage::SysIntegral& integralf() const;
  inline ::ClanPackage::SysIntegral* mutable_integralf();
  inline ::ClanPackage::SysIntegral* release_integralf();
  inline void set_allocated_integralf(::ClanPackage::SysIntegral* integralf);

  // optional .ClanPackage.SysIntegral integrals = 2;
  inline bool has_integrals() const;
  inline void clear_integrals();
  static const int kIntegralsFieldNumber = 2;
  inline const ::ClanPackage::SysIntegral& integrals() const;
  inline ::ClanPackage::SysIntegral* mutable_integrals();
  inline ::ClanPackage::SysIntegral* release_integrals();
  inline void set_allocated_integrals(::ClanPackage::SysIntegral* integrals);

  // @@protoc_insertion_point(class_scope:ClanPackage.SysIntegralToWorld)
 private:
  inline void set_has_integralf();
  inline void clear_has_integralf();
  inline void set_has_integrals();
  inline void clear_has_integrals();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ClanPackage::SysIntegral* integralf_;
  ::ClanPackage::SysIntegral* integrals_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static SysIntegralToWorld* default_instance_;
};
// -------------------------------------------------------------------

class SysIntegral : public ::google::protobuf::Message {
 public:
  SysIntegral();
  virtual ~SysIntegral();

  SysIntegral(const SysIntegral& from);

  inline SysIntegral& operator=(const SysIntegral& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysIntegral& default_instance();

  void Swap(SysIntegral* other);

  // implements Message ----------------------------------------------

  SysIntegral* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SysIntegral& from);
  void MergeFrom(const SysIntegral& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 clanId = 1;
  inline bool has_clanid() const;
  inline void clear_clanid();
  static const int kClanIdFieldNumber = 1;
  inline ::google::protobuf::int32 clanid() const;
  inline void set_clanid(::google::protobuf::int32 value);

  // optional int32 clanIntegral = 2;
  inline bool has_clanintegral() const;
  inline void clear_clanintegral();
  static const int kClanIntegralFieldNumber = 2;
  inline ::google::protobuf::int32 clanintegral() const;
  inline void set_clanintegral(::google::protobuf::int32 value);

  // optional int32 clanmoney = 3;
  inline bool has_clanmoney() const;
  inline void clear_clanmoney();
  static const int kClanmoneyFieldNumber = 3;
  inline ::google::protobuf::int32 clanmoney() const;
  inline void set_clanmoney(::google::protobuf::int32 value);

  // optional int32 IsSuccess = 4;
  inline bool has_issuccess() const;
  inline void clear_issuccess();
  static const int kIsSuccessFieldNumber = 4;
  inline ::google::protobuf::int32 issuccess() const;
  inline void set_issuccess(::google::protobuf::int32 value);

  // repeated int64 charidList = 5;
  inline int charidlist_size() const;
  inline void clear_charidlist();
  static const int kCharidListFieldNumber = 5;
  inline ::google::protobuf::int64 charidlist(int index) const;
  inline void set_charidlist(int index, ::google::protobuf::int64 value);
  inline void add_charidlist(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      charidlist() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_charidlist();

  // @@protoc_insertion_point(class_scope:ClanPackage.SysIntegral)
 private:
  inline void set_has_clanid();
  inline void clear_has_clanid();
  inline void set_has_clanintegral();
  inline void clear_has_clanintegral();
  inline void set_has_clanmoney();
  inline void clear_has_clanmoney();
  inline void set_has_issuccess();
  inline void clear_has_issuccess();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 clanid_;
  ::google::protobuf::int32 clanintegral_;
  ::google::protobuf::int32 clanmoney_;
  ::google::protobuf::int32 issuccess_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > charidlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClanIntegral_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClanIntegral_2eproto();

  void InitAsDefaultInstance();
  static SysIntegral* default_instance_;
};
// ===================================================================


// ===================================================================

// RetIntegralInfo

// required int32 status = 1;
inline bool RetIntegralInfo::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetIntegralInfo::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetIntegralInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetIntegralInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 RetIntegralInfo::status() const {
  return status_;
}
inline void RetIntegralInfo::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional int32 integral = 2;
inline bool RetIntegralInfo::has_integral() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetIntegralInfo::set_has_integral() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetIntegralInfo::clear_has_integral() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetIntegralInfo::clear_integral() {
  integral_ = 0;
  clear_has_integral();
}
inline ::google::protobuf::int32 RetIntegralInfo::integral() const {
  return integral_;
}
inline void RetIntegralInfo::set_integral(::google::protobuf::int32 value) {
  set_has_integral();
  integral_ = value;
}

// optional int32 power = 3;
inline bool RetIntegralInfo::has_power() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RetIntegralInfo::set_has_power() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RetIntegralInfo::clear_has_power() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RetIntegralInfo::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline ::google::protobuf::int32 RetIntegralInfo::power() const {
  return power_;
}
inline void RetIntegralInfo::set_power(::google::protobuf::int32 value) {
  set_has_power();
  power_ = value;
}

// optional int32 win = 4;
inline bool RetIntegralInfo::has_win() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RetIntegralInfo::set_has_win() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RetIntegralInfo::clear_has_win() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RetIntegralInfo::clear_win() {
  win_ = 0;
  clear_has_win();
}
inline ::google::protobuf::int32 RetIntegralInfo::win() const {
  return win_;
}
inline void RetIntegralInfo::set_win(::google::protobuf::int32 value) {
  set_has_win();
  win_ = value;
}

// optional int32 lose = 5;
inline bool RetIntegralInfo::has_lose() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RetIntegralInfo::set_has_lose() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RetIntegralInfo::clear_has_lose() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RetIntegralInfo::clear_lose() {
  lose_ = 0;
  clear_has_lose();
}
inline ::google::protobuf::int32 RetIntegralInfo::lose() const {
  return lose_;
}
inline void RetIntegralInfo::set_lose(::google::protobuf::int32 value) {
  set_has_lose();
  lose_ = value;
}

// optional bytes clanname = 6;
inline bool RetIntegralInfo::has_clanname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RetIntegralInfo::set_has_clanname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RetIntegralInfo::clear_has_clanname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RetIntegralInfo::clear_clanname() {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    clanname_->clear();
  }
  clear_has_clanname();
}
inline const ::std::string& RetIntegralInfo::clanname() const {
  return *clanname_;
}
inline void RetIntegralInfo::set_clanname(const ::std::string& value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void RetIntegralInfo::set_clanname(const char* value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void RetIntegralInfo::set_clanname(const void* value, size_t size) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RetIntegralInfo::mutable_clanname() {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  return clanname_;
}
inline ::std::string* RetIntegralInfo::release_clanname() {
  clear_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clanname_;
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RetIntegralInfo::set_allocated_clanname(::std::string* clanname) {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    delete clanname_;
  }
  if (clanname) {
    set_has_clanname();
    clanname_ = clanname;
  } else {
    clear_has_clanname();
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 onlyid = 7;
inline bool RetIntegralInfo::has_onlyid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RetIntegralInfo::set_has_onlyid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RetIntegralInfo::clear_has_onlyid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RetIntegralInfo::clear_onlyid() {
  onlyid_ = GOOGLE_LONGLONG(0);
  clear_has_onlyid();
}
inline ::google::protobuf::int64 RetIntegralInfo::onlyid() const {
  return onlyid_;
}
inline void RetIntegralInfo::set_onlyid(::google::protobuf::int64 value) {
  set_has_onlyid();
  onlyid_ = value;
}

// optional bool besingup = 8;
inline bool RetIntegralInfo::has_besingup() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RetIntegralInfo::set_has_besingup() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RetIntegralInfo::clear_has_besingup() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RetIntegralInfo::clear_besingup() {
  besingup_ = false;
  clear_has_besingup();
}
inline bool RetIntegralInfo::besingup() const {
  return besingup_;
}
inline void RetIntegralInfo::set_besingup(bool value) {
  set_has_besingup();
  besingup_ = value;
}

// repeated .ClanPackage.RntegralRanking info = 9;
inline int RetIntegralInfo::info_size() const {
  return info_.size();
}
inline void RetIntegralInfo::clear_info() {
  info_.Clear();
}
inline const ::ClanPackage::RntegralRanking& RetIntegralInfo::info(int index) const {
  return info_.Get(index);
}
inline ::ClanPackage::RntegralRanking* RetIntegralInfo::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::ClanPackage::RntegralRanking* RetIntegralInfo::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::RntegralRanking >&
RetIntegralInfo::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::RntegralRanking >*
RetIntegralInfo::mutable_info() {
  return &info_;
}

// -------------------------------------------------------------------

// RntegralRanking

// optional bytes clanname = 1;
inline bool RntegralRanking::has_clanname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RntegralRanking::set_has_clanname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RntegralRanking::clear_has_clanname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RntegralRanking::clear_clanname() {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    clanname_->clear();
  }
  clear_has_clanname();
}
inline const ::std::string& RntegralRanking::clanname() const {
  return *clanname_;
}
inline void RntegralRanking::set_clanname(const ::std::string& value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void RntegralRanking::set_clanname(const char* value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void RntegralRanking::set_clanname(const void* value, size_t size) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RntegralRanking::mutable_clanname() {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  return clanname_;
}
inline ::std::string* RntegralRanking::release_clanname() {
  clear_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clanname_;
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RntegralRanking::set_allocated_clanname(::std::string* clanname) {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    delete clanname_;
  }
  if (clanname) {
    set_has_clanname();
    clanname_ = clanname;
  } else {
    clear_has_clanname();
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 integral = 2;
inline bool RntegralRanking::has_integral() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RntegralRanking::set_has_integral() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RntegralRanking::clear_has_integral() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RntegralRanking::clear_integral() {
  integral_ = 0;
  clear_has_integral();
}
inline ::google::protobuf::int32 RntegralRanking::integral() const {
  return integral_;
}
inline void RntegralRanking::set_integral(::google::protobuf::int32 value) {
  set_has_integral();
  integral_ = value;
}

// -------------------------------------------------------------------

// RetSingUpIntegral

// required int32 ret = 1;
inline bool RetSingUpIntegral::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetSingUpIntegral::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetSingUpIntegral::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetSingUpIntegral::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 RetSingUpIntegral::ret() const {
  return ret_;
}
inline void RetSingUpIntegral::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional .ClanPackage.RetIntegralInfo info = 2;
inline bool RetSingUpIntegral::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetSingUpIntegral::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetSingUpIntegral::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetSingUpIntegral::clear_info() {
  if (info_ != NULL) info_->::ClanPackage::RetIntegralInfo::Clear();
  clear_has_info();
}
inline const ::ClanPackage::RetIntegralInfo& RetSingUpIntegral::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::ClanPackage::RetIntegralInfo* RetSingUpIntegral::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::ClanPackage::RetIntegralInfo;
  return info_;
}
inline ::ClanPackage::RetIntegralInfo* RetSingUpIntegral::release_info() {
  clear_has_info();
  ::ClanPackage::RetIntegralInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void RetSingUpIntegral::set_allocated_info(::ClanPackage::RetIntegralInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// RetReSingUpIntegral

// required int32 ret = 1;
inline bool RetReSingUpIntegral::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetReSingUpIntegral::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetReSingUpIntegral::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetReSingUpIntegral::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 RetReSingUpIntegral::ret() const {
  return ret_;
}
inline void RetReSingUpIntegral::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional .ClanPackage.RetIntegralInfo info = 2;
inline bool RetReSingUpIntegral::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetReSingUpIntegral::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetReSingUpIntegral::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetReSingUpIntegral::clear_info() {
  if (info_ != NULL) info_->::ClanPackage::RetIntegralInfo::Clear();
  clear_has_info();
}
inline const ::ClanPackage::RetIntegralInfo& RetReSingUpIntegral::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::ClanPackage::RetIntegralInfo* RetReSingUpIntegral::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::ClanPackage::RetIntegralInfo;
  return info_;
}
inline ::ClanPackage::RetIntegralInfo* RetReSingUpIntegral::release_info() {
  clear_has_info();
  ::ClanPackage::RetIntegralInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void RetReSingUpIntegral::set_allocated_info(::ClanPackage::RetIntegralInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// RetAttClanInfo

// required int32 ret = 1;
inline bool RetAttClanInfo::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetAttClanInfo::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetAttClanInfo::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetAttClanInfo::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 RetAttClanInfo::ret() const {
  return ret_;
}
inline void RetAttClanInfo::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional bytes clanname = 2;
inline bool RetAttClanInfo::has_clanname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetAttClanInfo::set_has_clanname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetAttClanInfo::clear_has_clanname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetAttClanInfo::clear_clanname() {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    clanname_->clear();
  }
  clear_has_clanname();
}
inline const ::std::string& RetAttClanInfo::clanname() const {
  return *clanname_;
}
inline void RetAttClanInfo::set_clanname(const ::std::string& value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void RetAttClanInfo::set_clanname(const char* value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void RetAttClanInfo::set_clanname(const void* value, size_t size) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RetAttClanInfo::mutable_clanname() {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  return clanname_;
}
inline ::std::string* RetAttClanInfo::release_clanname() {
  clear_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clanname_;
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RetAttClanInfo::set_allocated_clanname(::std::string* clanname) {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    delete clanname_;
  }
  if (clanname) {
    set_has_clanname();
    clanname_ = clanname;
  } else {
    clear_has_clanname();
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 clanlv = 3;
inline bool RetAttClanInfo::has_clanlv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RetAttClanInfo::set_has_clanlv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RetAttClanInfo::clear_has_clanlv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RetAttClanInfo::clear_clanlv() {
  clanlv_ = 0;
  clear_has_clanlv();
}
inline ::google::protobuf::int32 RetAttClanInfo::clanlv() const {
  return clanlv_;
}
inline void RetAttClanInfo::set_clanlv(::google::protobuf::int32 value) {
  set_has_clanlv();
  clanlv_ = value;
}

// optional int32 pepolenum = 4;
inline bool RetAttClanInfo::has_pepolenum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RetAttClanInfo::set_has_pepolenum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RetAttClanInfo::clear_has_pepolenum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RetAttClanInfo::clear_pepolenum() {
  pepolenum_ = 0;
  clear_has_pepolenum();
}
inline ::google::protobuf::int32 RetAttClanInfo::pepolenum() const {
  return pepolenum_;
}
inline void RetAttClanInfo::set_pepolenum(::google::protobuf::int32 value) {
  set_has_pepolenum();
  pepolenum_ = value;
}

// optional int32 integral = 5;
inline bool RetAttClanInfo::has_integral() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RetAttClanInfo::set_has_integral() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RetAttClanInfo::clear_has_integral() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RetAttClanInfo::clear_integral() {
  integral_ = 0;
  clear_has_integral();
}
inline ::google::protobuf::int32 RetAttClanInfo::integral() const {
  return integral_;
}
inline void RetAttClanInfo::set_integral(::google::protobuf::int32 value) {
  set_has_integral();
  integral_ = value;
}

// -------------------------------------------------------------------

// RetNoticeWar

// required int32 ret = 1;
inline bool RetNoticeWar::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetNoticeWar::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetNoticeWar::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetNoticeWar::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 RetNoticeWar::ret() const {
  return ret_;
}
inline void RetNoticeWar::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// RetKillRankingInfo

// required int32 ret = 1;
inline bool RetKillRankingInfo::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetKillRankingInfo::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetKillRankingInfo::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetKillRankingInfo::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 RetKillRankingInfo::ret() const {
  return ret_;
}
inline void RetKillRankingInfo::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional .ClanPackage.KillRanking myself = 2;
inline bool RetKillRankingInfo::has_myself() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetKillRankingInfo::set_has_myself() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetKillRankingInfo::clear_has_myself() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetKillRankingInfo::clear_myself() {
  if (myself_ != NULL) myself_->::ClanPackage::KillRanking::Clear();
  clear_has_myself();
}
inline const ::ClanPackage::KillRanking& RetKillRankingInfo::myself() const {
  return myself_ != NULL ? *myself_ : *default_instance_->myself_;
}
inline ::ClanPackage::KillRanking* RetKillRankingInfo::mutable_myself() {
  set_has_myself();
  if (myself_ == NULL) myself_ = new ::ClanPackage::KillRanking;
  return myself_;
}
inline ::ClanPackage::KillRanking* RetKillRankingInfo::release_myself() {
  clear_has_myself();
  ::ClanPackage::KillRanking* temp = myself_;
  myself_ = NULL;
  return temp;
}
inline void RetKillRankingInfo::set_allocated_myself(::ClanPackage::KillRanking* myself) {
  delete myself_;
  myself_ = myself;
  if (myself) {
    set_has_myself();
  } else {
    clear_has_myself();
  }
}

// optional .ClanPackage.KillRanking other = 3;
inline bool RetKillRankingInfo::has_other() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RetKillRankingInfo::set_has_other() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RetKillRankingInfo::clear_has_other() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RetKillRankingInfo::clear_other() {
  if (other_ != NULL) other_->::ClanPackage::KillRanking::Clear();
  clear_has_other();
}
inline const ::ClanPackage::KillRanking& RetKillRankingInfo::other() const {
  return other_ != NULL ? *other_ : *default_instance_->other_;
}
inline ::ClanPackage::KillRanking* RetKillRankingInfo::mutable_other() {
  set_has_other();
  if (other_ == NULL) other_ = new ::ClanPackage::KillRanking;
  return other_;
}
inline ::ClanPackage::KillRanking* RetKillRankingInfo::release_other() {
  clear_has_other();
  ::ClanPackage::KillRanking* temp = other_;
  other_ = NULL;
  return temp;
}
inline void RetKillRankingInfo::set_allocated_other(::ClanPackage::KillRanking* other) {
  delete other_;
  other_ = other;
  if (other) {
    set_has_other();
  } else {
    clear_has_other();
  }
}

// -------------------------------------------------------------------

// KillRanking

// optional int32 boss = 1;
inline bool KillRanking::has_boss() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KillRanking::set_has_boss() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KillRanking::clear_has_boss() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KillRanking::clear_boss() {
  boss_ = 0;
  clear_has_boss();
}
inline ::google::protobuf::int32 KillRanking::boss() const {
  return boss_;
}
inline void KillRanking::set_boss(::google::protobuf::int32 value) {
  set_has_boss();
  boss_ = value;
}

// optional int32 total = 2;
inline bool KillRanking::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KillRanking::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KillRanking::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KillRanking::clear_total() {
  total_ = 0;
  clear_has_total();
}
inline ::google::protobuf::int32 KillRanking::total() const {
  return total_;
}
inline void KillRanking::set_total(::google::protobuf::int32 value) {
  set_has_total();
  total_ = value;
}

// repeated .ClanPackage.SingleKillRanking info = 3;
inline int KillRanking::info_size() const {
  return info_.size();
}
inline void KillRanking::clear_info() {
  info_.Clear();
}
inline const ::ClanPackage::SingleKillRanking& KillRanking::info(int index) const {
  return info_.Get(index);
}
inline ::ClanPackage::SingleKillRanking* KillRanking::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::ClanPackage::SingleKillRanking* KillRanking::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::SingleKillRanking >&
KillRanking::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::SingleKillRanking >*
KillRanking::mutable_info() {
  return &info_;
}

// -------------------------------------------------------------------

// SingleKillRanking

// optional bytes name = 1;
inline bool SingleKillRanking::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleKillRanking::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SingleKillRanking::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SingleKillRanking::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SingleKillRanking::name() const {
  return *name_;
}
inline void SingleKillRanking::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SingleKillRanking::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SingleKillRanking::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SingleKillRanking::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SingleKillRanking::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SingleKillRanking::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 kill = 2;
inline bool SingleKillRanking::has_kill() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SingleKillRanking::set_has_kill() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SingleKillRanking::clear_has_kill() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SingleKillRanking::clear_kill() {
  kill_ = 0;
  clear_has_kill();
}
inline ::google::protobuf::int32 SingleKillRanking::kill() const {
  return kill_;
}
inline void SingleKillRanking::set_kill(::google::protobuf::int32 value) {
  set_has_kill();
  kill_ = value;
}

// optional int32 die = 3;
inline bool SingleKillRanking::has_die() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SingleKillRanking::set_has_die() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SingleKillRanking::clear_has_die() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SingleKillRanking::clear_die() {
  die_ = 0;
  clear_has_die();
}
inline ::google::protobuf::int32 SingleKillRanking::die() const {
  return die_;
}
inline void SingleKillRanking::set_die(::google::protobuf::int32 value) {
  set_has_die();
  die_ = value;
}

// -------------------------------------------------------------------

// SingleKill

// optional int32 totalboss = 1;
inline bool SingleKill::has_totalboss() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleKill::set_has_totalboss() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SingleKill::clear_has_totalboss() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SingleKill::clear_totalboss() {
  totalboss_ = 0;
  clear_has_totalboss();
}
inline ::google::protobuf::int32 SingleKill::totalboss() const {
  return totalboss_;
}
inline void SingleKill::set_totalboss(::google::protobuf::int32 value) {
  set_has_totalboss();
  totalboss_ = value;
}

// optional int32 total = 2;
inline bool SingleKill::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SingleKill::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SingleKill::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SingleKill::clear_total() {
  total_ = 0;
  clear_has_total();
}
inline ::google::protobuf::int32 SingleKill::total() const {
  return total_;
}
inline void SingleKill::set_total(::google::protobuf::int32 value) {
  set_has_total();
  total_ = value;
}

// optional int32 othertotalboss = 3;
inline bool SingleKill::has_othertotalboss() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SingleKill::set_has_othertotalboss() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SingleKill::clear_has_othertotalboss() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SingleKill::clear_othertotalboss() {
  othertotalboss_ = 0;
  clear_has_othertotalboss();
}
inline ::google::protobuf::int32 SingleKill::othertotalboss() const {
  return othertotalboss_;
}
inline void SingleKill::set_othertotalboss(::google::protobuf::int32 value) {
  set_has_othertotalboss();
  othertotalboss_ = value;
}

// optional int32 othertotal = 4;
inline bool SingleKill::has_othertotal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SingleKill::set_has_othertotal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SingleKill::clear_has_othertotal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SingleKill::clear_othertotal() {
  othertotal_ = 0;
  clear_has_othertotal();
}
inline ::google::protobuf::int32 SingleKill::othertotal() const {
  return othertotal_;
}
inline void SingleKill::set_othertotal(::google::protobuf::int32 value) {
  set_has_othertotal();
  othertotal_ = value;
}

// optional int32 kill = 5;
inline bool SingleKill::has_kill() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SingleKill::set_has_kill() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SingleKill::clear_has_kill() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SingleKill::clear_kill() {
  kill_ = 0;
  clear_has_kill();
}
inline ::google::protobuf::int32 SingleKill::kill() const {
  return kill_;
}
inline void SingleKill::set_kill(::google::protobuf::int32 value) {
  set_has_kill();
  kill_ = value;
}

// optional int32 die = 6;
inline bool SingleKill::has_die() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SingleKill::set_has_die() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SingleKill::clear_has_die() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SingleKill::clear_die() {
  die_ = 0;
  clear_has_die();
}
inline ::google::protobuf::int32 SingleKill::die() const {
  return die_;
}
inline void SingleKill::set_die(::google::protobuf::int32 value) {
  set_has_die();
  die_ = value;
}

// optional int32 boss = 7;
inline bool SingleKill::has_boss() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SingleKill::set_has_boss() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SingleKill::clear_has_boss() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SingleKill::clear_boss() {
  boss_ = 0;
  clear_has_boss();
}
inline ::google::protobuf::int32 SingleKill::boss() const {
  return boss_;
}
inline void SingleKill::set_boss(::google::protobuf::int32 value) {
  set_has_boss();
  boss_ = value;
}

// optional int32 ranking = 8;
inline bool SingleKill::has_ranking() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SingleKill::set_has_ranking() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SingleKill::clear_has_ranking() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SingleKill::clear_ranking() {
  ranking_ = 0;
  clear_has_ranking();
}
inline ::google::protobuf::int32 SingleKill::ranking() const {
  return ranking_;
}
inline void SingleKill::set_ranking(::google::protobuf::int32 value) {
  set_has_ranking();
  ranking_ = value;
}

// -------------------------------------------------------------------

// IntegralReward

// required int32 IsSuccess = 1;
inline bool IntegralReward::has_issuccess() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntegralReward::set_has_issuccess() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IntegralReward::clear_has_issuccess() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IntegralReward::clear_issuccess() {
  issuccess_ = 0;
  clear_has_issuccess();
}
inline ::google::protobuf::int32 IntegralReward::issuccess() const {
  return issuccess_;
}
inline void IntegralReward::set_issuccess(::google::protobuf::int32 value) {
  set_has_issuccess();
  issuccess_ = value;
}

// optional int32 clanIntegral = 2;
inline bool IntegralReward::has_clanintegral() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IntegralReward::set_has_clanintegral() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IntegralReward::clear_has_clanintegral() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IntegralReward::clear_clanintegral() {
  clanintegral_ = 0;
  clear_has_clanintegral();
}
inline ::google::protobuf::int32 IntegralReward::clanintegral() const {
  return clanintegral_;
}
inline void IntegralReward::set_clanintegral(::google::protobuf::int32 value) {
  set_has_clanintegral();
  clanintegral_ = value;
}

// optional int32 clanmoney = 3;
inline bool IntegralReward::has_clanmoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IntegralReward::set_has_clanmoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IntegralReward::clear_has_clanmoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IntegralReward::clear_clanmoney() {
  clanmoney_ = 0;
  clear_has_clanmoney();
}
inline ::google::protobuf::int32 IntegralReward::clanmoney() const {
  return clanmoney_;
}
inline void IntegralReward::set_clanmoney(::google::protobuf::int32 value) {
  set_has_clanmoney();
  clanmoney_ = value;
}

// optional int32 kill = 4;
inline bool IntegralReward::has_kill() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IntegralReward::set_has_kill() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IntegralReward::clear_has_kill() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IntegralReward::clear_kill() {
  kill_ = 0;
  clear_has_kill();
}
inline ::google::protobuf::int32 IntegralReward::kill() const {
  return kill_;
}
inline void IntegralReward::set_kill(::google::protobuf::int32 value) {
  set_has_kill();
  kill_ = value;
}

// repeated .ClanPackage.RewardInfo items = 5;
inline int IntegralReward::items_size() const {
  return items_.size();
}
inline void IntegralReward::clear_items() {
  items_.Clear();
}
inline const ::ClanPackage::RewardInfo& IntegralReward::items(int index) const {
  return items_.Get(index);
}
inline ::ClanPackage::RewardInfo* IntegralReward::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::ClanPackage::RewardInfo* IntegralReward::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >&
IntegralReward::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >*
IntegralReward::mutable_items() {
  return &items_;
}

// repeated .ClanPackage.RewardInfo singkillitems = 6;
inline int IntegralReward::singkillitems_size() const {
  return singkillitems_.size();
}
inline void IntegralReward::clear_singkillitems() {
  singkillitems_.Clear();
}
inline const ::ClanPackage::RewardInfo& IntegralReward::singkillitems(int index) const {
  return singkillitems_.Get(index);
}
inline ::ClanPackage::RewardInfo* IntegralReward::mutable_singkillitems(int index) {
  return singkillitems_.Mutable(index);
}
inline ::ClanPackage::RewardInfo* IntegralReward::add_singkillitems() {
  return singkillitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >&
IntegralReward::singkillitems() const {
  return singkillitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >*
IntegralReward::mutable_singkillitems() {
  return &singkillitems_;
}

// repeated .ClanPackage.RewardInfo mvpitems = 7;
inline int IntegralReward::mvpitems_size() const {
  return mvpitems_.size();
}
inline void IntegralReward::clear_mvpitems() {
  mvpitems_.Clear();
}
inline const ::ClanPackage::RewardInfo& IntegralReward::mvpitems(int index) const {
  return mvpitems_.Get(index);
}
inline ::ClanPackage::RewardInfo* IntegralReward::mutable_mvpitems(int index) {
  return mvpitems_.Mutable(index);
}
inline ::ClanPackage::RewardInfo* IntegralReward::add_mvpitems() {
  return mvpitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >&
IntegralReward::mvpitems() const {
  return mvpitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >*
IntegralReward::mutable_mvpitems() {
  return &mvpitems_;
}

// repeated .ClanPackage.RewardInfo killitems = 8;
inline int IntegralReward::killitems_size() const {
  return killitems_.size();
}
inline void IntegralReward::clear_killitems() {
  killitems_.Clear();
}
inline const ::ClanPackage::RewardInfo& IntegralReward::killitems(int index) const {
  return killitems_.Get(index);
}
inline ::ClanPackage::RewardInfo* IntegralReward::mutable_killitems(int index) {
  return killitems_.Mutable(index);
}
inline ::ClanPackage::RewardInfo* IntegralReward::add_killitems() {
  return killitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >&
IntegralReward::killitems() const {
  return killitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >*
IntegralReward::mutable_killitems() {
  return &killitems_;
}

// -------------------------------------------------------------------

// IntegralWinReward

// repeated .ClanPackage.RewardInfo items = 5;
inline int IntegralWinReward::items_size() const {
  return items_.size();
}
inline void IntegralWinReward::clear_items() {
  items_.Clear();
}
inline const ::ClanPackage::RewardInfo& IntegralWinReward::items(int index) const {
  return items_.Get(index);
}
inline ::ClanPackage::RewardInfo* IntegralWinReward::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::ClanPackage::RewardInfo* IntegralWinReward::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >&
IntegralWinReward::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::RewardInfo >*
IntegralWinReward::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// RewardInfo

// required int32 itemid = 1;
inline bool RewardInfo::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardInfo::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardInfo::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardInfo::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 RewardInfo::itemid() const {
  return itemid_;
}
inline void RewardInfo::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 itemnum = 2;
inline bool RewardInfo::has_itemnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardInfo::set_has_itemnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardInfo::clear_has_itemnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardInfo::clear_itemnum() {
  itemnum_ = 0;
  clear_has_itemnum();
}
inline ::google::protobuf::int32 RewardInfo::itemnum() const {
  return itemnum_;
}
inline void RewardInfo::set_itemnum(::google::protobuf::int32 value) {
  set_has_itemnum();
  itemnum_ = value;
}

// -------------------------------------------------------------------

// SysReSingUp

// required int64 charid = 1;
inline bool SysReSingUp::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysReSingUp::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysReSingUp::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysReSingUp::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 SysReSingUp::charid() const {
  return charid_;
}
inline void SysReSingUp::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// optional int32 golden = 2;
inline bool SysReSingUp::has_golden() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SysReSingUp::set_has_golden() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SysReSingUp::clear_has_golden() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SysReSingUp::clear_golden() {
  golden_ = 0;
  clear_has_golden();
}
inline ::google::protobuf::int32 SysReSingUp::golden() const {
  return golden_;
}
inline void SysReSingUp::set_golden(::google::protobuf::int32 value) {
  set_has_golden();
  golden_ = value;
}

// optional int32 ret = 3;
inline bool SysReSingUp::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SysReSingUp::set_has_ret() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SysReSingUp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SysReSingUp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 SysReSingUp::ret() const {
  return ret_;
}
inline void SysReSingUp::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// SysIntegralOnlyId

// required int64 onlyid = 1;
inline bool SysIntegralOnlyId::has_onlyid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysIntegralOnlyId::set_has_onlyid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysIntegralOnlyId::clear_has_onlyid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysIntegralOnlyId::clear_onlyid() {
  onlyid_ = GOOGLE_LONGLONG(0);
  clear_has_onlyid();
}
inline ::google::protobuf::int64 SysIntegralOnlyId::onlyid() const {
  return onlyid_;
}
inline void SysIntegralOnlyId::set_onlyid(::google::protobuf::int64 value) {
  set_has_onlyid();
  onlyid_ = value;
}

// -------------------------------------------------------------------

// SysIntegralToWorld

// optional .ClanPackage.SysIntegral integralf = 1;
inline bool SysIntegralToWorld::has_integralf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysIntegralToWorld::set_has_integralf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysIntegralToWorld::clear_has_integralf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysIntegralToWorld::clear_integralf() {
  if (integralf_ != NULL) integralf_->::ClanPackage::SysIntegral::Clear();
  clear_has_integralf();
}
inline const ::ClanPackage::SysIntegral& SysIntegralToWorld::integralf() const {
  return integralf_ != NULL ? *integralf_ : *default_instance_->integralf_;
}
inline ::ClanPackage::SysIntegral* SysIntegralToWorld::mutable_integralf() {
  set_has_integralf();
  if (integralf_ == NULL) integralf_ = new ::ClanPackage::SysIntegral;
  return integralf_;
}
inline ::ClanPackage::SysIntegral* SysIntegralToWorld::release_integralf() {
  clear_has_integralf();
  ::ClanPackage::SysIntegral* temp = integralf_;
  integralf_ = NULL;
  return temp;
}
inline void SysIntegralToWorld::set_allocated_integralf(::ClanPackage::SysIntegral* integralf) {
  delete integralf_;
  integralf_ = integralf;
  if (integralf) {
    set_has_integralf();
  } else {
    clear_has_integralf();
  }
}

// optional .ClanPackage.SysIntegral integrals = 2;
inline bool SysIntegralToWorld::has_integrals() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SysIntegralToWorld::set_has_integrals() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SysIntegralToWorld::clear_has_integrals() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SysIntegralToWorld::clear_integrals() {
  if (integrals_ != NULL) integrals_->::ClanPackage::SysIntegral::Clear();
  clear_has_integrals();
}
inline const ::ClanPackage::SysIntegral& SysIntegralToWorld::integrals() const {
  return integrals_ != NULL ? *integrals_ : *default_instance_->integrals_;
}
inline ::ClanPackage::SysIntegral* SysIntegralToWorld::mutable_integrals() {
  set_has_integrals();
  if (integrals_ == NULL) integrals_ = new ::ClanPackage::SysIntegral;
  return integrals_;
}
inline ::ClanPackage::SysIntegral* SysIntegralToWorld::release_integrals() {
  clear_has_integrals();
  ::ClanPackage::SysIntegral* temp = integrals_;
  integrals_ = NULL;
  return temp;
}
inline void SysIntegralToWorld::set_allocated_integrals(::ClanPackage::SysIntegral* integrals) {
  delete integrals_;
  integrals_ = integrals;
  if (integrals) {
    set_has_integrals();
  } else {
    clear_has_integrals();
  }
}

// -------------------------------------------------------------------

// SysIntegral

// required int32 clanId = 1;
inline bool SysIntegral::has_clanid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysIntegral::set_has_clanid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysIntegral::clear_has_clanid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysIntegral::clear_clanid() {
  clanid_ = 0;
  clear_has_clanid();
}
inline ::google::protobuf::int32 SysIntegral::clanid() const {
  return clanid_;
}
inline void SysIntegral::set_clanid(::google::protobuf::int32 value) {
  set_has_clanid();
  clanid_ = value;
}

// optional int32 clanIntegral = 2;
inline bool SysIntegral::has_clanintegral() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SysIntegral::set_has_clanintegral() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SysIntegral::clear_has_clanintegral() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SysIntegral::clear_clanintegral() {
  clanintegral_ = 0;
  clear_has_clanintegral();
}
inline ::google::protobuf::int32 SysIntegral::clanintegral() const {
  return clanintegral_;
}
inline void SysIntegral::set_clanintegral(::google::protobuf::int32 value) {
  set_has_clanintegral();
  clanintegral_ = value;
}

// optional int32 clanmoney = 3;
inline bool SysIntegral::has_clanmoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SysIntegral::set_has_clanmoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SysIntegral::clear_has_clanmoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SysIntegral::clear_clanmoney() {
  clanmoney_ = 0;
  clear_has_clanmoney();
}
inline ::google::protobuf::int32 SysIntegral::clanmoney() const {
  return clanmoney_;
}
inline void SysIntegral::set_clanmoney(::google::protobuf::int32 value) {
  set_has_clanmoney();
  clanmoney_ = value;
}

// optional int32 IsSuccess = 4;
inline bool SysIntegral::has_issuccess() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SysIntegral::set_has_issuccess() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SysIntegral::clear_has_issuccess() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SysIntegral::clear_issuccess() {
  issuccess_ = 0;
  clear_has_issuccess();
}
inline ::google::protobuf::int32 SysIntegral::issuccess() const {
  return issuccess_;
}
inline void SysIntegral::set_issuccess(::google::protobuf::int32 value) {
  set_has_issuccess();
  issuccess_ = value;
}

// repeated int64 charidList = 5;
inline int SysIntegral::charidlist_size() const {
  return charidlist_.size();
}
inline void SysIntegral::clear_charidlist() {
  charidlist_.Clear();
}
inline ::google::protobuf::int64 SysIntegral::charidlist(int index) const {
  return charidlist_.Get(index);
}
inline void SysIntegral::set_charidlist(int index, ::google::protobuf::int64 value) {
  charidlist_.Set(index, value);
}
inline void SysIntegral::add_charidlist(::google::protobuf::int64 value) {
  charidlist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
SysIntegral::charidlist() const {
  return charidlist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
SysIntegral::mutable_charidlist() {
  return &charidlist_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ClanPackage

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Clan_2fClanIntegral_2eproto__INCLUDED

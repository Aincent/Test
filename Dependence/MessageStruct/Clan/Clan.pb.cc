// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Clan/Clan.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Clan/Clan.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ClanPackage {

namespace {

const ::google::protobuf::Descriptor* ClientReqCreateClan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqCreateClan_reflection_ = NULL;
const ::google::protobuf::Descriptor* WorldReqTakeOff_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WorldReqTakeOff_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckCreateClan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckCreateClan_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckClanBase_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckClanBase_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqClanList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqClanList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckClanList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckClanList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClanList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClanList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqMemberList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqMemberList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckMemberList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckMemberList_reflection_ = NULL;
const ::google::protobuf::Descriptor* MemberInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MemberInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReqSeeMemberList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReqSeeMemberList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckSeeMemberList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckSeeMemberList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqClanEvent_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqClanEvent_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckClanEvent_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckClanEvent_reflection_ = NULL;
const ::google::protobuf::Descriptor* JoinClan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  JoinClan_reflection_ = NULL;
const ::google::protobuf::Descriptor* LeaveClan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LeaveClan_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClanMemberKilled_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClanMemberKilled_reflection_ = NULL;
const ::google::protobuf::Descriptor* SynchClanEventToWS_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SynchClanEventToWS_reflection_ = NULL;
const ::google::protobuf::Descriptor* MemberContri_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MemberContri_reflection_ = NULL;
const ::google::protobuf::Descriptor* JobChange_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  JobChange_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClanUpdate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClanUpdate_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClanCitryHold_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClanCitryHold_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClanPaidEvent_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClanPaidEvent_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqClanRequestList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqClanRequestList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckClanRequestList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckClanRequestList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClanRequestList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClanRequestList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqClanContriList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqClanContriList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckClanContriList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckClanContriList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClanContriList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClanContriList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqJoinClan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqJoinClan_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckJoinClan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckJoinClan_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientAlterTitle_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientAlterTitle_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqContri_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqContri_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckContri_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckContri_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckUpdateLv_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckUpdateLv_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientChangeIcon_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientChangeIcon_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckClientChangeIcon_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckClientChangeIcon_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqGiveJob_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqGiveJob_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckGiveJob_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckGiveJob_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqOutJob_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqOutJob_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckOutJob_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckOutJob_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqKickMember_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqKickMember_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckKickMember_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckKickMember_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientChangeJoinFlag_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientChangeJoinFlag_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqJoinControl_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqJoinControl_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckJoinControl_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckJoinControl_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqAskJoin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqAskJoin_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckAskJoin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckAskJoin_reflection_ = NULL;
const ::google::protobuf::Descriptor* AskClientJoin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AskClientJoin_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqRefuseOrJoin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqRefuseOrJoin_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckRefuseOrJoin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckRefuseOrJoin_reflection_ = NULL;
const ::google::protobuf::Descriptor* SynchAttrToGM_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SynchAttrToGM_reflection_ = NULL;
const ::google::protobuf::Descriptor* WorldReqGiveCost_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WorldReqGiveCost_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckGiveCost_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckGiveCost_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClanNameChange_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClanNameChange_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClanLimit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClanLimit_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClanGoods_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClanGoods_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClanShop_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClanShop_reflection_ = NULL;
const ::google::protobuf::Descriptor* SaveClanLimit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SaveClanLimit_reflection_ = NULL;
const ::google::protobuf::Descriptor* SaveClanSkill_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SaveClanSkill_reflection_ = NULL;
const ::google::protobuf::Descriptor* SClanSkill_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SClanSkill_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClanSkill_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClanSkill_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqSkillUpdate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqSkillUpdate_reflection_ = NULL;
const ::google::protobuf::Descriptor* WSToClentSkillUpdate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WSToClentSkillUpdate_reflection_ = NULL;
const ::google::protobuf::Descriptor* WSToClientSimSkillUpdate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WSToClientSimSkillUpdate_reflection_ = NULL;
const ::google::protobuf::Descriptor* WSToGameADBuff_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WSToGameADBuff_reflection_ = NULL;
const ::google::protobuf::Descriptor* WSToGameClanLevel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WSToGameClanLevel_reflection_ = NULL;
const ::google::protobuf::Descriptor* SynchWillJoinToGM_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SynchWillJoinToGM_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShowClanWelfare_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShowClanWelfare_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClanWelfare_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClanWelfare_reflection_ = NULL;
const ::google::protobuf::Descriptor* SendClanWelfare_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SendClanWelfare_reflection_ = NULL;
const ::google::protobuf::Descriptor* TakeClanWelfare_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TakeClanWelfare_reflection_ = NULL;
const ::google::protobuf::Descriptor* RetTakeClanWelfare_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RetTakeClanWelfare_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqBackClanMap_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqBackClanMap_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckReqBackClanMap_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckReqBackClanMap_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckClanSkills_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckClanSkills_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReqUpGrageClanSkill_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReqUpGrageClanSkill_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckUpGradeClanSkill_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckUpGradeClanSkill_reflection_ = NULL;
const ::google::protobuf::Descriptor* Ws2GsRobberActive_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Ws2GsRobberActive_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClanMapInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClanMapInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Ws2GsDestroyClanMap_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Ws2GsDestroyClanMap_reflection_ = NULL;
const ::google::protobuf::Descriptor* RobberResult_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobberResult_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientReqChanceJoinClan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientReqChanceJoinClan_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckChanceJoinClan_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckChanceJoinClan_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_Clan_2fClan_2eproto() {
  protobuf_AddDesc_Clan_2fClan_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "Clan/Clan.proto");
  GOOGLE_CHECK(file != NULL);
  ClientReqCreateClan_descriptor_ = file->message_type(0);
  static const int ClientReqCreateClan_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqCreateClan, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqCreateClan, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqCreateClan, type_),
  };
  ClientReqCreateClan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqCreateClan_descriptor_,
      ClientReqCreateClan::default_instance_,
      ClientReqCreateClan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqCreateClan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqCreateClan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqCreateClan));
  WorldReqTakeOff_descriptor_ = file->message_type(1);
  static const int WorldReqTakeOff_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldReqTakeOff, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldReqTakeOff, type_),
  };
  WorldReqTakeOff_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WorldReqTakeOff_descriptor_,
      WorldReqTakeOff::default_instance_,
      WorldReqTakeOff_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldReqTakeOff, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldReqTakeOff, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WorldReqTakeOff));
  AckCreateClan_descriptor_ = file->message_type(2);
  static const int AckCreateClan_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckCreateClan, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckCreateClan, info_),
  };
  AckCreateClan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckCreateClan_descriptor_,
      AckCreateClan::default_instance_,
      AckCreateClan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckCreateClan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckCreateClan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckCreateClan));
  AckClanBase_descriptor_ = file->message_type(3);
  static const int AckClanBase_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanBase, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanBase, lv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanBase, title_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanBase, money_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanBase, golden_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanBase, titletime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanBase, createtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanBase, factioncon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanBase, clanname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanBase, bossname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanBase, icon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanBase, members_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanBase, autoflag_),
  };
  AckClanBase_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckClanBase_descriptor_,
      AckClanBase::default_instance_,
      AckClanBase_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanBase, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanBase, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckClanBase));
  ClientReqClanList_descriptor_ = file->message_type(4);
  static const int ClientReqClanList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqClanList, page_),
  };
  ClientReqClanList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqClanList_descriptor_,
      ClientReqClanList::default_instance_,
      ClientReqClanList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqClanList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqClanList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqClanList));
  AckClanList_descriptor_ = file->message_type(5);
  static const int AckClanList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanList, size_),
  };
  AckClanList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckClanList_descriptor_,
      AckClanList::default_instance_,
      AckClanList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckClanList));
  ClanList_descriptor_ = file->message_type(6);
  static const int ClanList_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanList, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanList, rank_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanList, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanList, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanList, lv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanList, fight_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanList, country_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanList, apply_),
  };
  ClanList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClanList_descriptor_,
      ClanList::default_instance_,
      ClanList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClanList));
  ClientReqMemberList_descriptor_ = file->message_type(7);
  static const int ClientReqMemberList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqMemberList, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqMemberList, page_),
  };
  ClientReqMemberList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqMemberList_descriptor_,
      ClientReqMemberList::default_instance_,
      ClientReqMemberList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqMemberList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqMemberList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqMemberList));
  AckMemberList_descriptor_ = file->message_type(8);
  static const int AckMemberList_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckMemberList, info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckMemberList, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckMemberList, fight_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckMemberList, isend_),
  };
  AckMemberList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckMemberList_descriptor_,
      AckMemberList::default_instance_,
      AckMemberList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckMemberList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckMemberList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckMemberList));
  MemberInfo_descriptor_ = file->message_type(9);
  static const int MemberInfo_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, profession_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, contri_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, fight_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, job_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, lv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, vip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, isonline_),
  };
  MemberInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MemberInfo_descriptor_,
      MemberInfo::default_instance_,
      MemberInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MemberInfo));
  ReqSeeMemberList_descriptor_ = file->message_type(10);
  static const int ReqSeeMemberList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqSeeMemberList, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqSeeMemberList, page_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqSeeMemberList, clanid_),
  };
  ReqSeeMemberList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReqSeeMemberList_descriptor_,
      ReqSeeMemberList::default_instance_,
      ReqSeeMemberList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqSeeMemberList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqSeeMemberList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReqSeeMemberList));
  AckSeeMemberList_descriptor_ = file->message_type(11);
  static const int AckSeeMemberList_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckSeeMemberList, info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckSeeMemberList, clanname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckSeeMemberList, clanlevel_),
  };
  AckSeeMemberList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckSeeMemberList_descriptor_,
      AckSeeMemberList::default_instance_,
      AckSeeMemberList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckSeeMemberList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckSeeMemberList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckSeeMemberList));
  ClientReqClanEvent_descriptor_ = file->message_type(12);
  static const int ClientReqClanEvent_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqClanEvent, page_),
  };
  ClientReqClanEvent_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqClanEvent_descriptor_,
      ClientReqClanEvent::default_instance_,
      ClientReqClanEvent_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqClanEvent, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqClanEvent, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqClanEvent));
  AckClanEvent_descriptor_ = file->message_type(13);
  static const int AckClanEvent_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanEvent, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanEvent, content_),
  };
  AckClanEvent_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckClanEvent_descriptor_,
      AckClanEvent::default_instance_,
      AckClanEvent_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanEvent, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanEvent, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckClanEvent));
  JoinClan_descriptor_ = file->message_type(14);
  static const int JoinClan_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoinClan, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoinClan, name_),
  };
  JoinClan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      JoinClan_descriptor_,
      JoinClan::default_instance_,
      JoinClan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoinClan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JoinClan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(JoinClan));
  LeaveClan_descriptor_ = file->message_type(15);
  static const int LeaveClan_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaveClan, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaveClan, name_),
  };
  LeaveClan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LeaveClan_descriptor_,
      LeaveClan::default_instance_,
      LeaveClan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaveClan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LeaveClan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LeaveClan));
  ClanMemberKilled_descriptor_ = file->message_type(16);
  static const int ClanMemberKilled_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanMemberKilled, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanMemberKilled, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanMemberKilled, mapid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanMemberKilled, killer_),
  };
  ClanMemberKilled_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClanMemberKilled_descriptor_,
      ClanMemberKilled::default_instance_,
      ClanMemberKilled_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanMemberKilled, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanMemberKilled, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClanMemberKilled));
  SynchClanEventToWS_descriptor_ = file->message_type(17);
  static const int SynchClanEventToWS_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchClanEventToWS, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchClanEventToWS, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchClanEventToWS, killer_),
  };
  SynchClanEventToWS_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SynchClanEventToWS_descriptor_,
      SynchClanEventToWS::default_instance_,
      SynchClanEventToWS_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchClanEventToWS, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchClanEventToWS, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SynchClanEventToWS));
  MemberContri_descriptor_ = file->message_type(18);
  static const int MemberContri_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberContri, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberContri, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberContri, golden_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberContri, money_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberContri, contri_),
  };
  MemberContri_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MemberContri_descriptor_,
      MemberContri::default_instance_,
      MemberContri_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberContri, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MemberContri, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MemberContri));
  JobChange_descriptor_ = file->message_type(19);
  static const int JobChange_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JobChange, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JobChange, bname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JobChange, ename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JobChange, job_),
  };
  JobChange_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      JobChange_descriptor_,
      JobChange::default_instance_,
      JobChange_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JobChange, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(JobChange, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(JobChange));
  ClanUpdate_descriptor_ = file->message_type(20);
  static const int ClanUpdate_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanUpdate, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanUpdate, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanUpdate, lv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanUpdate, count_),
  };
  ClanUpdate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClanUpdate_descriptor_,
      ClanUpdate::default_instance_,
      ClanUpdate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanUpdate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanUpdate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClanUpdate));
  ClanCitryHold_descriptor_ = file->message_type(21);
  static const int ClanCitryHold_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanCitryHold, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanCitryHold, cityid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanCitryHold, clan_),
  };
  ClanCitryHold_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClanCitryHold_descriptor_,
      ClanCitryHold::default_instance_,
      ClanCitryHold_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanCitryHold, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanCitryHold, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClanCitryHold));
  ClanPaidEvent_descriptor_ = file->message_type(22);
  static const int ClanPaidEvent_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanPaidEvent, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanPaidEvent, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanPaidEvent, money_),
  };
  ClanPaidEvent_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClanPaidEvent_descriptor_,
      ClanPaidEvent::default_instance_,
      ClanPaidEvent_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanPaidEvent, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanPaidEvent, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClanPaidEvent));
  ClientReqClanRequestList_descriptor_ = file->message_type(23);
  static const int ClientReqClanRequestList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqClanRequestList, page_),
  };
  ClientReqClanRequestList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqClanRequestList_descriptor_,
      ClientReqClanRequestList::default_instance_,
      ClientReqClanRequestList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqClanRequestList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqClanRequestList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqClanRequestList));
  AckClanRequestList_descriptor_ = file->message_type(24);
  static const int AckClanRequestList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanRequestList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanRequestList, isend_),
  };
  AckClanRequestList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckClanRequestList_descriptor_,
      AckClanRequestList::default_instance_,
      AckClanRequestList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanRequestList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanRequestList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckClanRequestList));
  ClanRequestList_descriptor_ = file->message_type(25);
  static const int ClanRequestList_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanRequestList, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanRequestList, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanRequestList, lv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanRequestList, profession_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanRequestList, fight_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanRequestList, vip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanRequestList, sex_),
  };
  ClanRequestList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClanRequestList_descriptor_,
      ClanRequestList::default_instance_,
      ClanRequestList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanRequestList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanRequestList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClanRequestList));
  ClientReqClanContriList_descriptor_ = file->message_type(26);
  static const int ClientReqClanContriList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqClanContriList, page_),
  };
  ClientReqClanContriList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqClanContriList_descriptor_,
      ClientReqClanContriList::default_instance_,
      ClientReqClanContriList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqClanContriList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqClanContriList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqClanContriList));
  AckClanContriList_descriptor_ = file->message_type(27);
  static const int AckClanContriList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanContriList, list_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanContriList, isend_),
  };
  AckClanContriList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckClanContriList_descriptor_,
      AckClanContriList::default_instance_,
      AckClanContriList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanContriList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanContriList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckClanContriList));
  ClanContriList_descriptor_ = file->message_type(28);
  static const int ClanContriList_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanContriList, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanContriList, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanContriList, lv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanContriList, money_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanContriList, golden_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanContriList, contri_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanContriList, contrimax_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanContriList, viplv_),
  };
  ClanContriList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClanContriList_descriptor_,
      ClanContriList::default_instance_,
      ClanContriList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanContriList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanContriList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClanContriList));
  ClientReqJoinClan_descriptor_ = file->message_type(29);
  static const int ClientReqJoinClan_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqJoinClan, id_),
  };
  ClientReqJoinClan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqJoinClan_descriptor_,
      ClientReqJoinClan::default_instance_,
      ClientReqJoinClan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqJoinClan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqJoinClan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqJoinClan));
  AckJoinClan_descriptor_ = file->message_type(30);
  static const int AckJoinClan_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckJoinClan, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckJoinClan, clanid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckJoinClan, info_),
  };
  AckJoinClan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckJoinClan_descriptor_,
      AckJoinClan::default_instance_,
      AckJoinClan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckJoinClan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckJoinClan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckJoinClan));
  ClientAlterTitle_descriptor_ = file->message_type(31);
  static const int ClientAlterTitle_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientAlterTitle, title_),
  };
  ClientAlterTitle_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientAlterTitle_descriptor_,
      ClientAlterTitle::default_instance_,
      ClientAlterTitle_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientAlterTitle, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientAlterTitle, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientAlterTitle));
  ClientReqContri_descriptor_ = file->message_type(32);
  static const int ClientReqContri_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqContri, money_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqContri, golden_),
  };
  ClientReqContri_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqContri_descriptor_,
      ClientReqContri::default_instance_,
      ClientReqContri_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqContri, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqContri, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqContri));
  AckContri_descriptor_ = file->message_type(33);
  static const int AckContri_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckContri, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckContri, contri_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckContri, money_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckContri, golden_),
  };
  AckContri_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckContri_descriptor_,
      AckContri::default_instance_,
      AckContri_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckContri, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckContri, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckContri));
  AckUpdateLv_descriptor_ = file->message_type(34);
  static const int AckUpdateLv_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpdateLv, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpdateLv, lv_),
  };
  AckUpdateLv_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckUpdateLv_descriptor_,
      AckUpdateLv::default_instance_,
      AckUpdateLv_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpdateLv, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpdateLv, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckUpdateLv));
  ClientChangeIcon_descriptor_ = file->message_type(35);
  static const int ClientChangeIcon_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientChangeIcon, icon_),
  };
  ClientChangeIcon_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientChangeIcon_descriptor_,
      ClientChangeIcon::default_instance_,
      ClientChangeIcon_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientChangeIcon, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientChangeIcon, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientChangeIcon));
  AckClientChangeIcon_descriptor_ = file->message_type(36);
  static const int AckClientChangeIcon_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClientChangeIcon, success_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClientChangeIcon, icon_),
  };
  AckClientChangeIcon_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckClientChangeIcon_descriptor_,
      AckClientChangeIcon::default_instance_,
      AckClientChangeIcon_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClientChangeIcon, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClientChangeIcon, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckClientChangeIcon));
  ClientReqGiveJob_descriptor_ = file->message_type(37);
  static const int ClientReqGiveJob_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqGiveJob, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqGiveJob, job_),
  };
  ClientReqGiveJob_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqGiveJob_descriptor_,
      ClientReqGiveJob::default_instance_,
      ClientReqGiveJob_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqGiveJob, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqGiveJob, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqGiveJob));
  AckGiveJob_descriptor_ = file->message_type(38);
  static const int AckGiveJob_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckGiveJob, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckGiveJob, job_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckGiveJob, charid_),
  };
  AckGiveJob_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckGiveJob_descriptor_,
      AckGiveJob::default_instance_,
      AckGiveJob_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckGiveJob, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckGiveJob, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckGiveJob));
  ClientReqOutJob_descriptor_ = file->message_type(39);
  static const int ClientReqOutJob_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqOutJob, charid_),
  };
  ClientReqOutJob_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqOutJob_descriptor_,
      ClientReqOutJob::default_instance_,
      ClientReqOutJob_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqOutJob, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqOutJob, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqOutJob));
  AckOutJob_descriptor_ = file->message_type(40);
  static const int AckOutJob_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckOutJob, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckOutJob, charid_),
  };
  AckOutJob_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckOutJob_descriptor_,
      AckOutJob::default_instance_,
      AckOutJob_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckOutJob, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckOutJob, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckOutJob));
  ClientReqKickMember_descriptor_ = file->message_type(41);
  static const int ClientReqKickMember_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqKickMember, charid_),
  };
  ClientReqKickMember_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqKickMember_descriptor_,
      ClientReqKickMember::default_instance_,
      ClientReqKickMember_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqKickMember, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqKickMember, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqKickMember));
  AckKickMember_descriptor_ = file->message_type(42);
  static const int AckKickMember_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckKickMember, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckKickMember, charid_),
  };
  AckKickMember_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckKickMember_descriptor_,
      AckKickMember::default_instance_,
      AckKickMember_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckKickMember, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckKickMember, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckKickMember));
  ClientChangeJoinFlag_descriptor_ = file->message_type(43);
  static const int ClientChangeJoinFlag_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientChangeJoinFlag, flag_),
  };
  ClientChangeJoinFlag_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientChangeJoinFlag_descriptor_,
      ClientChangeJoinFlag::default_instance_,
      ClientChangeJoinFlag_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientChangeJoinFlag, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientChangeJoinFlag, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientChangeJoinFlag));
  ClientReqJoinControl_descriptor_ = file->message_type(44);
  static const int ClientReqJoinControl_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqJoinControl, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqJoinControl, charid_),
  };
  ClientReqJoinControl_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqJoinControl_descriptor_,
      ClientReqJoinControl::default_instance_,
      ClientReqJoinControl_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqJoinControl, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqJoinControl, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqJoinControl));
  AckJoinControl_descriptor_ = file->message_type(45);
  static const int AckJoinControl_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckJoinControl, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckJoinControl, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckJoinControl, type_),
  };
  AckJoinControl_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckJoinControl_descriptor_,
      AckJoinControl::default_instance_,
      AckJoinControl_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckJoinControl, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckJoinControl, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckJoinControl));
  ClientReqAskJoin_descriptor_ = file->message_type(46);
  static const int ClientReqAskJoin_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqAskJoin, charid_),
  };
  ClientReqAskJoin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqAskJoin_descriptor_,
      ClientReqAskJoin::default_instance_,
      ClientReqAskJoin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqAskJoin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqAskJoin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqAskJoin));
  AckAskJoin_descriptor_ = file->message_type(47);
  static const int AckAskJoin_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckAskJoin, ret_),
  };
  AckAskJoin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckAskJoin_descriptor_,
      AckAskJoin::default_instance_,
      AckAskJoin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckAskJoin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckAskJoin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckAskJoin));
  AskClientJoin_descriptor_ = file->message_type(48);
  static const int AskClientJoin_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AskClientJoin, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AskClientJoin, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AskClientJoin, clanname_),
  };
  AskClientJoin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AskClientJoin_descriptor_,
      AskClientJoin::default_instance_,
      AskClientJoin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AskClientJoin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AskClientJoin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AskClientJoin));
  ClientReqRefuseOrJoin_descriptor_ = file->message_type(49);
  static const int ClientReqRefuseOrJoin_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqRefuseOrJoin, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqRefuseOrJoin, id_),
  };
  ClientReqRefuseOrJoin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqRefuseOrJoin_descriptor_,
      ClientReqRefuseOrJoin::default_instance_,
      ClientReqRefuseOrJoin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqRefuseOrJoin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqRefuseOrJoin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqRefuseOrJoin));
  AckRefuseOrJoin_descriptor_ = file->message_type(50);
  static const int AckRefuseOrJoin_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckRefuseOrJoin, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckRefuseOrJoin, info_),
  };
  AckRefuseOrJoin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckRefuseOrJoin_descriptor_,
      AckRefuseOrJoin::default_instance_,
      AckRefuseOrJoin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckRefuseOrJoin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckRefuseOrJoin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckRefuseOrJoin));
  SynchAttrToGM_descriptor_ = file->message_type(51);
  static const int SynchAttrToGM_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchAttrToGM, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchAttrToGM, blv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchAttrToGM, elv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchAttrToGM, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchAttrToGM, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchAttrToGM, job_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchAttrToGM, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchAttrToGM, clanicon_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchAttrToGM, clancontribution_),
  };
  SynchAttrToGM_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SynchAttrToGM_descriptor_,
      SynchAttrToGM::default_instance_,
      SynchAttrToGM_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchAttrToGM, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchAttrToGM, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SynchAttrToGM));
  WorldReqGiveCost_descriptor_ = file->message_type(52);
  static const int WorldReqGiveCost_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldReqGiveCost, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldReqGiveCost, money_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldReqGiveCost, golden_),
  };
  WorldReqGiveCost_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WorldReqGiveCost_descriptor_,
      WorldReqGiveCost::default_instance_,
      WorldReqGiveCost_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldReqGiveCost, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WorldReqGiveCost, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WorldReqGiveCost));
  AckGiveCost_descriptor_ = file->message_type(53);
  static const int AckGiveCost_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckGiveCost, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckGiveCost, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckGiveCost, money_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckGiveCost, golden_),
  };
  AckGiveCost_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckGiveCost_descriptor_,
      AckGiveCost::default_instance_,
      AckGiveCost_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckGiveCost, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckGiveCost, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckGiveCost));
  ClanNameChange_descriptor_ = file->message_type(54);
  static const int ClanNameChange_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanNameChange, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanNameChange, key_),
  };
  ClanNameChange_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClanNameChange_descriptor_,
      ClanNameChange::default_instance_,
      ClanNameChange_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanNameChange, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanNameChange, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClanNameChange));
  ClanLimit_descriptor_ = file->message_type(55);
  static const int ClanLimit_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanLimit, clangoods_),
  };
  ClanLimit_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClanLimit_descriptor_,
      ClanLimit::default_instance_,
      ClanLimit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanLimit, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanLimit, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClanLimit));
  ClanGoods_descriptor_ = file->message_type(56);
  static const int ClanGoods_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanGoods, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanGoods, limit_),
  };
  ClanGoods_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClanGoods_descriptor_,
      ClanGoods::default_instance_,
      ClanGoods_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanGoods, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanGoods, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClanGoods));
  ClanShop_descriptor_ = file->message_type(57);
  static const int ClanShop_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanShop, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanShop, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanShop, surpluscounts_),
  };
  ClanShop_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClanShop_descriptor_,
      ClanShop::default_instance_,
      ClanShop_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanShop, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanShop, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClanShop));
  SaveClanLimit_descriptor_ = file->message_type(58);
  static const int SaveClanLimit_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SaveClanLimit, clangoods_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SaveClanLimit, time_),
  };
  SaveClanLimit_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SaveClanLimit_descriptor_,
      SaveClanLimit::default_instance_,
      SaveClanLimit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SaveClanLimit, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SaveClanLimit, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SaveClanLimit));
  SaveClanSkill_descriptor_ = file->message_type(59);
  static const int SaveClanSkill_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SaveClanSkill, sclanskill_),
  };
  SaveClanSkill_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SaveClanSkill_descriptor_,
      SaveClanSkill::default_instance_,
      SaveClanSkill_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SaveClanSkill, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SaveClanSkill, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SaveClanSkill));
  SClanSkill_descriptor_ = file->message_type(60);
  static const int SClanSkill_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SClanSkill, skillid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SClanSkill, curexp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SClanSkill, type_),
  };
  SClanSkill_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SClanSkill_descriptor_,
      SClanSkill::default_instance_,
      SClanSkill_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SClanSkill, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SClanSkill, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SClanSkill));
  ClanSkill_descriptor_ = file->message_type(61);
  static const int ClanSkill_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanSkill, skillid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanSkill, curexp_),
  };
  ClanSkill_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClanSkill_descriptor_,
      ClanSkill::default_instance_,
      ClanSkill_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanSkill, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanSkill, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClanSkill));
  ClientReqSkillUpdate_descriptor_ = file->message_type(62);
  static const int ClientReqSkillUpdate_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqSkillUpdate, type_),
  };
  ClientReqSkillUpdate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqSkillUpdate_descriptor_,
      ClientReqSkillUpdate::default_instance_,
      ClientReqSkillUpdate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqSkillUpdate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqSkillUpdate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqSkillUpdate));
  WSToClentSkillUpdate_descriptor_ = file->message_type(63);
  static const int WSToClentSkillUpdate_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClentSkillUpdate, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClentSkillUpdate, skillid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClentSkillUpdate, curexp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClentSkillUpdate, contri_),
  };
  WSToClentSkillUpdate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WSToClentSkillUpdate_descriptor_,
      WSToClentSkillUpdate::default_instance_,
      WSToClentSkillUpdate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClentSkillUpdate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClentSkillUpdate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WSToClentSkillUpdate));
  WSToClientSimSkillUpdate_descriptor_ = file->message_type(64);
  static const int WSToClientSimSkillUpdate_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientSimSkillUpdate, skillid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientSimSkillUpdate, curexp_),
  };
  WSToClientSimSkillUpdate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WSToClientSimSkillUpdate_descriptor_,
      WSToClientSimSkillUpdate::default_instance_,
      WSToClientSimSkillUpdate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientSimSkillUpdate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToClientSimSkillUpdate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WSToClientSimSkillUpdate));
  WSToGameADBuff_descriptor_ = file->message_type(65);
  static const int WSToGameADBuff_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToGameADBuff, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToGameADBuff, flag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToGameADBuff, skillid_),
  };
  WSToGameADBuff_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WSToGameADBuff_descriptor_,
      WSToGameADBuff::default_instance_,
      WSToGameADBuff_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToGameADBuff, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToGameADBuff, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WSToGameADBuff));
  WSToGameClanLevel_descriptor_ = file->message_type(66);
  static const int WSToGameClanLevel_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToGameClanLevel, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToGameClanLevel, clanlevel_),
  };
  WSToGameClanLevel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WSToGameClanLevel_descriptor_,
      WSToGameClanLevel::default_instance_,
      WSToGameClanLevel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToGameClanLevel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WSToGameClanLevel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WSToGameClanLevel));
  SynchWillJoinToGM_descriptor_ = file->message_type(67);
  static const int SynchWillJoinToGM_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchWillJoinToGM, charid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchWillJoinToGM, flag_),
  };
  SynchWillJoinToGM_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SynchWillJoinToGM_descriptor_,
      SynchWillJoinToGM::default_instance_,
      SynchWillJoinToGM_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchWillJoinToGM, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SynchWillJoinToGM, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SynchWillJoinToGM));
  ShowClanWelfare_descriptor_ = file->message_type(68);
  static const int ShowClanWelfare_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShowClanWelfare, welfares_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShowClanWelfare, historycontri_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShowClanWelfare, jointime_),
  };
  ShowClanWelfare_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShowClanWelfare_descriptor_,
      ShowClanWelfare::default_instance_,
      ShowClanWelfare_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShowClanWelfare, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShowClanWelfare, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShowClanWelfare));
  ClanWelfare_descriptor_ = file->message_type(69);
  static const int ClanWelfare_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanWelfare, welfareid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanWelfare, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanWelfare, welfareinfoid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanWelfare, limitlv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanWelfare, limitday_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanWelfare, limitcontri_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanWelfare, num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanWelfare, istake_),
  };
  ClanWelfare_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClanWelfare_descriptor_,
      ClanWelfare::default_instance_,
      ClanWelfare_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanWelfare, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanWelfare, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClanWelfare));
  SendClanWelfare_descriptor_ = file->message_type(70);
  static const int SendClanWelfare_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendClanWelfare, welfareinfoid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendClanWelfare, lv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendClanWelfare, day_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendClanWelfare, contri_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendClanWelfare, num_),
  };
  SendClanWelfare_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SendClanWelfare_descriptor_,
      SendClanWelfare::default_instance_,
      SendClanWelfare_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendClanWelfare, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendClanWelfare, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SendClanWelfare));
  TakeClanWelfare_descriptor_ = file->message_type(71);
  static const int TakeClanWelfare_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TakeClanWelfare, welfareid_),
  };
  TakeClanWelfare_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TakeClanWelfare_descriptor_,
      TakeClanWelfare::default_instance_,
      TakeClanWelfare_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TakeClanWelfare, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TakeClanWelfare, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TakeClanWelfare));
  RetTakeClanWelfare_descriptor_ = file->message_type(72);
  static const int RetTakeClanWelfare_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetTakeClanWelfare, err_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetTakeClanWelfare, welfare_),
  };
  RetTakeClanWelfare_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RetTakeClanWelfare_descriptor_,
      RetTakeClanWelfare::default_instance_,
      RetTakeClanWelfare_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetTakeClanWelfare, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetTakeClanWelfare, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RetTakeClanWelfare));
  ClientReqBackClanMap_descriptor_ = file->message_type(73);
  static const int ClientReqBackClanMap_offsets_[1] = {
  };
  ClientReqBackClanMap_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqBackClanMap_descriptor_,
      ClientReqBackClanMap::default_instance_,
      ClientReqBackClanMap_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqBackClanMap, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqBackClanMap, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqBackClanMap));
  AckReqBackClanMap_descriptor_ = file->message_type(74);
  static const int AckReqBackClanMap_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckReqBackClanMap, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckReqBackClanMap, mapid_),
  };
  AckReqBackClanMap_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckReqBackClanMap_descriptor_,
      AckReqBackClanMap::default_instance_,
      AckReqBackClanMap_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckReqBackClanMap, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckReqBackClanMap, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckReqBackClanMap));
  AckClanSkills_descriptor_ = file->message_type(75);
  static const int AckClanSkills_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanSkills, id_),
  };
  AckClanSkills_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckClanSkills_descriptor_,
      AckClanSkills::default_instance_,
      AckClanSkills_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanSkills, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckClanSkills, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckClanSkills));
  ReqUpGrageClanSkill_descriptor_ = file->message_type(76);
  static const int ReqUpGrageClanSkill_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqUpGrageClanSkill, id_),
  };
  ReqUpGrageClanSkill_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReqUpGrageClanSkill_descriptor_,
      ReqUpGrageClanSkill::default_instance_,
      ReqUpGrageClanSkill_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqUpGrageClanSkill, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqUpGrageClanSkill, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReqUpGrageClanSkill));
  AckUpGradeClanSkill_descriptor_ = file->message_type(77);
  static const int AckUpGradeClanSkill_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpGradeClanSkill, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpGradeClanSkill, oldskill_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpGradeClanSkill, newskill_),
  };
  AckUpGradeClanSkill_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckUpGradeClanSkill_descriptor_,
      AckUpGradeClanSkill::default_instance_,
      AckUpGradeClanSkill_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpGradeClanSkill, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpGradeClanSkill, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckUpGradeClanSkill));
  Ws2GsRobberActive_descriptor_ = file->message_type(78);
  static const int Ws2GsRobberActive_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ws2GsRobberActive, flag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ws2GsRobberActive, info_),
  };
  Ws2GsRobberActive_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Ws2GsRobberActive_descriptor_,
      Ws2GsRobberActive::default_instance_,
      Ws2GsRobberActive_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ws2GsRobberActive, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ws2GsRobberActive, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Ws2GsRobberActive));
  ClanMapInfo_descriptor_ = file->message_type(79);
  static const int ClanMapInfo_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanMapInfo, clanid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanMapInfo, mapid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanMapInfo, win_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanMapInfo, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanMapInfo, conwin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanMapInfo, confail_),
  };
  ClanMapInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClanMapInfo_descriptor_,
      ClanMapInfo::default_instance_,
      ClanMapInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanMapInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClanMapInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClanMapInfo));
  Ws2GsDestroyClanMap_descriptor_ = file->message_type(80);
  static const int Ws2GsDestroyClanMap_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ws2GsDestroyClanMap, clanid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ws2GsDestroyClanMap, mapid_),
  };
  Ws2GsDestroyClanMap_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Ws2GsDestroyClanMap_descriptor_,
      Ws2GsDestroyClanMap::default_instance_,
      Ws2GsDestroyClanMap_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ws2GsDestroyClanMap, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ws2GsDestroyClanMap, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Ws2GsDestroyClanMap));
  RobberResult_descriptor_ = file->message_type(81);
  static const int RobberResult_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobberResult, clanid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobberResult, win_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobberResult, param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobberResult, conwin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobberResult, confail_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobberResult, money_),
  };
  RobberResult_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RobberResult_descriptor_,
      RobberResult::default_instance_,
      RobberResult_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobberResult, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobberResult, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RobberResult));
  ClientReqChanceJoinClan_descriptor_ = file->message_type(82);
  static const int ClientReqChanceJoinClan_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqChanceJoinClan, id_),
  };
  ClientReqChanceJoinClan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientReqChanceJoinClan_descriptor_,
      ClientReqChanceJoinClan::default_instance_,
      ClientReqChanceJoinClan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqChanceJoinClan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientReqChanceJoinClan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientReqChanceJoinClan));
  AckChanceJoinClan_descriptor_ = file->message_type(83);
  static const int AckChanceJoinClan_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckChanceJoinClan, ret_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckChanceJoinClan, clanid_),
  };
  AckChanceJoinClan_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckChanceJoinClan_descriptor_,
      AckChanceJoinClan::default_instance_,
      AckChanceJoinClan_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckChanceJoinClan, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckChanceJoinClan, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckChanceJoinClan));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_Clan_2fClan_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqCreateClan_descriptor_, &ClientReqCreateClan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WorldReqTakeOff_descriptor_, &WorldReqTakeOff::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckCreateClan_descriptor_, &AckCreateClan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckClanBase_descriptor_, &AckClanBase::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqClanList_descriptor_, &ClientReqClanList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckClanList_descriptor_, &AckClanList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClanList_descriptor_, &ClanList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqMemberList_descriptor_, &ClientReqMemberList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckMemberList_descriptor_, &AckMemberList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MemberInfo_descriptor_, &MemberInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReqSeeMemberList_descriptor_, &ReqSeeMemberList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckSeeMemberList_descriptor_, &AckSeeMemberList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqClanEvent_descriptor_, &ClientReqClanEvent::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckClanEvent_descriptor_, &AckClanEvent::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    JoinClan_descriptor_, &JoinClan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LeaveClan_descriptor_, &LeaveClan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClanMemberKilled_descriptor_, &ClanMemberKilled::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SynchClanEventToWS_descriptor_, &SynchClanEventToWS::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MemberContri_descriptor_, &MemberContri::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    JobChange_descriptor_, &JobChange::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClanUpdate_descriptor_, &ClanUpdate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClanCitryHold_descriptor_, &ClanCitryHold::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClanPaidEvent_descriptor_, &ClanPaidEvent::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqClanRequestList_descriptor_, &ClientReqClanRequestList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckClanRequestList_descriptor_, &AckClanRequestList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClanRequestList_descriptor_, &ClanRequestList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqClanContriList_descriptor_, &ClientReqClanContriList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckClanContriList_descriptor_, &AckClanContriList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClanContriList_descriptor_, &ClanContriList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqJoinClan_descriptor_, &ClientReqJoinClan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckJoinClan_descriptor_, &AckJoinClan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientAlterTitle_descriptor_, &ClientAlterTitle::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqContri_descriptor_, &ClientReqContri::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckContri_descriptor_, &AckContri::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckUpdateLv_descriptor_, &AckUpdateLv::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientChangeIcon_descriptor_, &ClientChangeIcon::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckClientChangeIcon_descriptor_, &AckClientChangeIcon::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqGiveJob_descriptor_, &ClientReqGiveJob::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckGiveJob_descriptor_, &AckGiveJob::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqOutJob_descriptor_, &ClientReqOutJob::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckOutJob_descriptor_, &AckOutJob::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqKickMember_descriptor_, &ClientReqKickMember::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckKickMember_descriptor_, &AckKickMember::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientChangeJoinFlag_descriptor_, &ClientChangeJoinFlag::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqJoinControl_descriptor_, &ClientReqJoinControl::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckJoinControl_descriptor_, &AckJoinControl::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqAskJoin_descriptor_, &ClientReqAskJoin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckAskJoin_descriptor_, &AckAskJoin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AskClientJoin_descriptor_, &AskClientJoin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqRefuseOrJoin_descriptor_, &ClientReqRefuseOrJoin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckRefuseOrJoin_descriptor_, &AckRefuseOrJoin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SynchAttrToGM_descriptor_, &SynchAttrToGM::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WorldReqGiveCost_descriptor_, &WorldReqGiveCost::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckGiveCost_descriptor_, &AckGiveCost::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClanNameChange_descriptor_, &ClanNameChange::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClanLimit_descriptor_, &ClanLimit::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClanGoods_descriptor_, &ClanGoods::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClanShop_descriptor_, &ClanShop::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SaveClanLimit_descriptor_, &SaveClanLimit::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SaveClanSkill_descriptor_, &SaveClanSkill::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SClanSkill_descriptor_, &SClanSkill::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClanSkill_descriptor_, &ClanSkill::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqSkillUpdate_descriptor_, &ClientReqSkillUpdate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WSToClentSkillUpdate_descriptor_, &WSToClentSkillUpdate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WSToClientSimSkillUpdate_descriptor_, &WSToClientSimSkillUpdate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WSToGameADBuff_descriptor_, &WSToGameADBuff::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WSToGameClanLevel_descriptor_, &WSToGameClanLevel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SynchWillJoinToGM_descriptor_, &SynchWillJoinToGM::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShowClanWelfare_descriptor_, &ShowClanWelfare::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClanWelfare_descriptor_, &ClanWelfare::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SendClanWelfare_descriptor_, &SendClanWelfare::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TakeClanWelfare_descriptor_, &TakeClanWelfare::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RetTakeClanWelfare_descriptor_, &RetTakeClanWelfare::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqBackClanMap_descriptor_, &ClientReqBackClanMap::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckReqBackClanMap_descriptor_, &AckReqBackClanMap::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckClanSkills_descriptor_, &AckClanSkills::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReqUpGrageClanSkill_descriptor_, &ReqUpGrageClanSkill::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckUpGradeClanSkill_descriptor_, &AckUpGradeClanSkill::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Ws2GsRobberActive_descriptor_, &Ws2GsRobberActive::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClanMapInfo_descriptor_, &ClanMapInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Ws2GsDestroyClanMap_descriptor_, &Ws2GsDestroyClanMap::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RobberResult_descriptor_, &RobberResult::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientReqChanceJoinClan_descriptor_, &ClientReqChanceJoinClan::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckChanceJoinClan_descriptor_, &AckChanceJoinClan::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_Clan_2fClan_2eproto() {
  delete ClientReqCreateClan::default_instance_;
  delete ClientReqCreateClan_reflection_;
  delete WorldReqTakeOff::default_instance_;
  delete WorldReqTakeOff_reflection_;
  delete AckCreateClan::default_instance_;
  delete AckCreateClan_reflection_;
  delete AckClanBase::default_instance_;
  delete AckClanBase_reflection_;
  delete ClientReqClanList::default_instance_;
  delete ClientReqClanList_reflection_;
  delete AckClanList::default_instance_;
  delete AckClanList_reflection_;
  delete ClanList::default_instance_;
  delete ClanList_reflection_;
  delete ClientReqMemberList::default_instance_;
  delete ClientReqMemberList_reflection_;
  delete AckMemberList::default_instance_;
  delete AckMemberList_reflection_;
  delete MemberInfo::default_instance_;
  delete MemberInfo_reflection_;
  delete ReqSeeMemberList::default_instance_;
  delete ReqSeeMemberList_reflection_;
  delete AckSeeMemberList::default_instance_;
  delete AckSeeMemberList_reflection_;
  delete ClientReqClanEvent::default_instance_;
  delete ClientReqClanEvent_reflection_;
  delete AckClanEvent::default_instance_;
  delete AckClanEvent_reflection_;
  delete JoinClan::default_instance_;
  delete JoinClan_reflection_;
  delete LeaveClan::default_instance_;
  delete LeaveClan_reflection_;
  delete ClanMemberKilled::default_instance_;
  delete ClanMemberKilled_reflection_;
  delete SynchClanEventToWS::default_instance_;
  delete SynchClanEventToWS_reflection_;
  delete MemberContri::default_instance_;
  delete MemberContri_reflection_;
  delete JobChange::default_instance_;
  delete JobChange_reflection_;
  delete ClanUpdate::default_instance_;
  delete ClanUpdate_reflection_;
  delete ClanCitryHold::default_instance_;
  delete ClanCitryHold_reflection_;
  delete ClanPaidEvent::default_instance_;
  delete ClanPaidEvent_reflection_;
  delete ClientReqClanRequestList::default_instance_;
  delete ClientReqClanRequestList_reflection_;
  delete AckClanRequestList::default_instance_;
  delete AckClanRequestList_reflection_;
  delete ClanRequestList::default_instance_;
  delete ClanRequestList_reflection_;
  delete ClientReqClanContriList::default_instance_;
  delete ClientReqClanContriList_reflection_;
  delete AckClanContriList::default_instance_;
  delete AckClanContriList_reflection_;
  delete ClanContriList::default_instance_;
  delete ClanContriList_reflection_;
  delete ClientReqJoinClan::default_instance_;
  delete ClientReqJoinClan_reflection_;
  delete AckJoinClan::default_instance_;
  delete AckJoinClan_reflection_;
  delete ClientAlterTitle::default_instance_;
  delete ClientAlterTitle_reflection_;
  delete ClientReqContri::default_instance_;
  delete ClientReqContri_reflection_;
  delete AckContri::default_instance_;
  delete AckContri_reflection_;
  delete AckUpdateLv::default_instance_;
  delete AckUpdateLv_reflection_;
  delete ClientChangeIcon::default_instance_;
  delete ClientChangeIcon_reflection_;
  delete AckClientChangeIcon::default_instance_;
  delete AckClientChangeIcon_reflection_;
  delete ClientReqGiveJob::default_instance_;
  delete ClientReqGiveJob_reflection_;
  delete AckGiveJob::default_instance_;
  delete AckGiveJob_reflection_;
  delete ClientReqOutJob::default_instance_;
  delete ClientReqOutJob_reflection_;
  delete AckOutJob::default_instance_;
  delete AckOutJob_reflection_;
  delete ClientReqKickMember::default_instance_;
  delete ClientReqKickMember_reflection_;
  delete AckKickMember::default_instance_;
  delete AckKickMember_reflection_;
  delete ClientChangeJoinFlag::default_instance_;
  delete ClientChangeJoinFlag_reflection_;
  delete ClientReqJoinControl::default_instance_;
  delete ClientReqJoinControl_reflection_;
  delete AckJoinControl::default_instance_;
  delete AckJoinControl_reflection_;
  delete ClientReqAskJoin::default_instance_;
  delete ClientReqAskJoin_reflection_;
  delete AckAskJoin::default_instance_;
  delete AckAskJoin_reflection_;
  delete AskClientJoin::default_instance_;
  delete AskClientJoin_reflection_;
  delete ClientReqRefuseOrJoin::default_instance_;
  delete ClientReqRefuseOrJoin_reflection_;
  delete AckRefuseOrJoin::default_instance_;
  delete AckRefuseOrJoin_reflection_;
  delete SynchAttrToGM::default_instance_;
  delete SynchAttrToGM_reflection_;
  delete WorldReqGiveCost::default_instance_;
  delete WorldReqGiveCost_reflection_;
  delete AckGiveCost::default_instance_;
  delete AckGiveCost_reflection_;
  delete ClanNameChange::default_instance_;
  delete ClanNameChange_reflection_;
  delete ClanLimit::default_instance_;
  delete ClanLimit_reflection_;
  delete ClanGoods::default_instance_;
  delete ClanGoods_reflection_;
  delete ClanShop::default_instance_;
  delete ClanShop_reflection_;
  delete SaveClanLimit::default_instance_;
  delete SaveClanLimit_reflection_;
  delete SaveClanSkill::default_instance_;
  delete SaveClanSkill_reflection_;
  delete SClanSkill::default_instance_;
  delete SClanSkill_reflection_;
  delete ClanSkill::default_instance_;
  delete ClanSkill_reflection_;
  delete ClientReqSkillUpdate::default_instance_;
  delete ClientReqSkillUpdate_reflection_;
  delete WSToClentSkillUpdate::default_instance_;
  delete WSToClentSkillUpdate_reflection_;
  delete WSToClientSimSkillUpdate::default_instance_;
  delete WSToClientSimSkillUpdate_reflection_;
  delete WSToGameADBuff::default_instance_;
  delete WSToGameADBuff_reflection_;
  delete WSToGameClanLevel::default_instance_;
  delete WSToGameClanLevel_reflection_;
  delete SynchWillJoinToGM::default_instance_;
  delete SynchWillJoinToGM_reflection_;
  delete ShowClanWelfare::default_instance_;
  delete ShowClanWelfare_reflection_;
  delete ClanWelfare::default_instance_;
  delete ClanWelfare_reflection_;
  delete SendClanWelfare::default_instance_;
  delete SendClanWelfare_reflection_;
  delete TakeClanWelfare::default_instance_;
  delete TakeClanWelfare_reflection_;
  delete RetTakeClanWelfare::default_instance_;
  delete RetTakeClanWelfare_reflection_;
  delete ClientReqBackClanMap::default_instance_;
  delete ClientReqBackClanMap_reflection_;
  delete AckReqBackClanMap::default_instance_;
  delete AckReqBackClanMap_reflection_;
  delete AckClanSkills::default_instance_;
  delete AckClanSkills_reflection_;
  delete ReqUpGrageClanSkill::default_instance_;
  delete ReqUpGrageClanSkill_reflection_;
  delete AckUpGradeClanSkill::default_instance_;
  delete AckUpGradeClanSkill_reflection_;
  delete Ws2GsRobberActive::default_instance_;
  delete Ws2GsRobberActive_reflection_;
  delete ClanMapInfo::default_instance_;
  delete ClanMapInfo_reflection_;
  delete Ws2GsDestroyClanMap::default_instance_;
  delete Ws2GsDestroyClanMap_reflection_;
  delete RobberResult::default_instance_;
  delete RobberResult_reflection_;
  delete ClientReqChanceJoinClan::default_instance_;
  delete ClientReqChanceJoinClan_reflection_;
  delete AckChanceJoinClan::default_instance_;
  delete AckChanceJoinClan_reflection_;
}

void protobuf_AddDesc_Clan_2fClan_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\017Clan/Clan.proto\022\013ClanPackage\"=\n\023Client"
    "ReqCreateClan\022\n\n\002id\030\001 \002(\005\022\014\n\004name\030\002 \001(\t\022"
    "\014\n\004type\030\003 \001(\010\"+\n\017WorldReqTakeOff\022\n\n\002id\030\001"
    " \002(\003\022\014\n\004type\030\002 \001(\010\"D\n\rAckCreateClan\022\013\n\003r"
    "et\030\001 \002(\005\022&\n\004info\030\002 \001(\0132\030.ClanPackage.Ack"
    "ClanBase\"\343\001\n\013AckClanBase\022\n\n\002id\030\001 \002(\r\022\n\n\002"
    "lv\030\002 \001(\005\022\r\n\005title\030\003 \001(\t\022\r\n\005money\030\004 \001(\003\022\016"
    "\n\006golden\030\005 \001(\003\022\021\n\ttitletime\030\006 \001(\001\022\022\n\ncre"
    "atetime\030\007 \001(\001\022\022\n\nfactioncon\030\010 \001(\005\022\020\n\010cla"
    "nname\030\t \001(\t\022\020\n\010bossname\030\n \001(\t\022\014\n\004icon\030\013 "
    "\001(\005\022\017\n\007members\030\014 \001(\005\022\020\n\010autoflag\030\r \001(\010\"!"
    "\n\021ClientReqClanList\022\014\n\004page\030\001 \002(\005\"@\n\013Ack"
    "ClanList\022#\n\004list\030\001 \003(\0132\025.ClanPackage.Cla"
    "nList\022\014\n\004size\030\002 \001(\005\"|\n\010ClanList\022\n\n\002id\030\001 "
    "\002(\r\022\014\n\004rank\030\002 \001(\005\022\014\n\004name\030\003 \001(\t\022\r\n\005count"
    "\030\004 \001(\005\022\n\n\002lv\030\005 \001(\005\022\r\n\005fight\030\006 \001(\005\022\017\n\007cou"
    "ntry\030\007 \001(\005\022\r\n\005apply\030\010 \001(\010\"1\n\023ClientReqMe"
    "mberList\022\014\n\004type\030\001 \002(\010\022\014\n\004page\030\002 \001(\005\"c\n\r"
    "AckMemberList\022%\n\004info\030\001 \003(\0132\027.ClanPackag"
    "e.MemberInfo\022\r\n\005count\030\002 \001(\005\022\r\n\005fight\030\003 \001"
    "(\005\022\r\n\005isend\030\004 \001(\010\"\225\001\n\nMemberInfo\022\016\n\006char"
    "id\030\001 \002(\003\022\014\n\004name\030\002 \001(\t\022\022\n\nprofession\030\003 \001"
    "(\005\022\016\n\006contri\030\004 \001(\005\022\r\n\005fight\030\005 \001(\005\022\013\n\003job"
    "\030\006 \001(\005\022\n\n\002lv\030\007 \001(\005\022\013\n\003vip\030\010 \001(\005\022\020\n\010isonl"
    "ine\030\t \001(\010\">\n\020ReqSeeMemberList\022\014\n\004type\030\001 "
    "\001(\010\022\014\n\004page\030\002 \001(\005\022\016\n\006clanID\030\003 \001(\005\"a\n\020Ack"
    "SeeMemberList\022(\n\004info\030\001 \001(\0132\032.ClanPackag"
    "e.AckMemberList\022\020\n\010clanName\030\002 \001(\014\022\021\n\tcla"
    "nlevel\030\003 \001(\005\"\"\n\022ClientReqClanEvent\022\014\n\004pa"
    "ge\030\001 \002(\005\"-\n\014AckClanEvent\022\014\n\004type\030\001 \003(\005\022\017"
    "\n\007content\030\002 \003(\014\"&\n\010JoinClan\022\014\n\004time\030\001 \002("
    "\001\022\014\n\004name\030\002 \001(\t\"\'\n\tLeaveClan\022\014\n\004time\030\001 \002"
    "(\001\022\014\n\004name\030\002 \001(\t\"M\n\020ClanMemberKilled\022\014\n\004"
    "time\030\001 \002(\001\022\014\n\004name\030\002 \001(\t\022\r\n\005mapid\030\003 \001(\005\022"
    "\016\n\006killer\030\004 \001(\t\"B\n\022SynchClanEventToWS\022\016\n"
    "\006charid\030\001 \002(\003\022\014\n\004time\030\002 \002(\001\022\016\n\006killer\030\003 "
    "\001(\t\"Y\n\014MemberContri\022\014\n\004time\030\001 \002(\001\022\014\n\004nam"
    "e\030\002 \001(\t\022\016\n\006golden\030\003 \001(\005\022\r\n\005money\030\004 \001(\005\022\016"
    "\n\006contri\030\005 \001(\005\"D\n\tJobChange\022\014\n\004time\030\001 \002("
    "\001\022\r\n\005bname\030\002 \001(\t\022\r\n\005ename\030\003 \001(\t\022\013\n\003job\030\004"
    " \001(\005\"C\n\nClanUpdate\022\014\n\004time\030\001 \002(\001\022\014\n\004name"
    "\030\002 \001(\t\022\n\n\002lv\030\003 \001(\005\022\r\n\005count\030\004 \001(\005\";\n\rCla"
    "nCitryHold\022\014\n\004time\030\001 \002(\001\022\016\n\006cityid\030\002 \001(\005"
    "\022\014\n\004clan\030\003 \001(\t\"8\n\rClanPaidEvent\022\014\n\004time\030"
    "\001 \002(\001\022\n\n\002id\030\002 \001(\005\022\r\n\005money\030\003 \001(\005\"(\n\030Clie"
    "ntReqClanRequestList\022\014\n\004page\030\001 \002(\005\"O\n\022Ac"
    "kClanRequestList\022*\n\004list\030\002 \003(\0132\034.ClanPac"
    "kage.ClanRequestList\022\r\n\005isend\030\003 \001(\010\"x\n\017C"
    "lanRequestList\022\016\n\006charid\030\001 \002(\003\022\014\n\004name\030\002"
    " \001(\t\022\n\n\002lv\030\003 \001(\005\022\022\n\nprofession\030\004 \001(\005\022\r\n\005"
    "fight\030\005 \001(\005\022\013\n\003vip\030\006 \001(\005\022\013\n\003sex\030\007 \001(\005\"\'\n"
    "\027ClientReqClanContriList\022\014\n\004page\030\001 \002(\005\"M"
    "\n\021AckClanContriList\022)\n\004list\030\001 \003(\0132\033.Clan"
    "Package.ClanContriList\022\r\n\005isend\030\002 \001(\010\"\213\001"
    "\n\016ClanContriList\022\016\n\006charid\030\001 \002(\003\022\014\n\004name"
    "\030\002 \001(\t\022\n\n\002lv\030\003 \001(\005\022\r\n\005money\030\004 \001(\005\022\016\n\006gol"
    "den\030\005 \001(\005\022\016\n\006contri\030\006 \001(\005\022\021\n\tcontrimax\030\007"
    " \001(\005\022\r\n\005viplv\030\010 \001(\005\"\037\n\021ClientReqJoinClan"
    "\022\n\n\002id\030\001 \002(\r\"R\n\013AckJoinClan\022\013\n\003ret\030\001 \002(\005"
    "\022\016\n\006clanID\030\002 \001(\005\022&\n\004info\030\003 \001(\0132\030.ClanPac"
    "kage.AckClanBase\"!\n\020ClientAlterTitle\022\r\n\005"
    "title\030\001 \002(\t\"0\n\017ClientReqContri\022\r\n\005money\030"
    "\001 \002(\005\022\016\n\006golden\030\002 \002(\005\"G\n\tAckContri\022\013\n\003re"
    "t\030\001 \002(\005\022\016\n\006contri\030\002 \001(\005\022\r\n\005money\030\003 \001(\005\022\016"
    "\n\006golden\030\004 \001(\005\"&\n\013AckUpdateLv\022\013\n\003ret\030\001 \002"
    "(\005\022\n\n\002lv\030\002 \001(\005\" \n\020ClientChangeIcon\022\014\n\004ic"
    "on\030\001 \002(\005\"4\n\023AckClientChangeIcon\022\017\n\007succe"
    "ss\030\001 \002(\005\022\014\n\004icon\030\002 \001(\005\"/\n\020ClientReqGiveJ"
    "ob\022\016\n\006charid\030\001 \002(\003\022\013\n\003job\030\002 \001(\005\"6\n\nAckGi"
    "veJob\022\013\n\003ret\030\001 \002(\005\022\013\n\003job\030\002 \001(\005\022\016\n\006chari"
    "d\030\003 \001(\003\"!\n\017ClientReqOutJob\022\016\n\006charid\030\001 \002"
    "(\003\"(\n\tAckOutJob\022\013\n\003ret\030\001 \002(\005\022\016\n\006charid\030\002"
    " \001(\003\"%\n\023ClientReqKickMember\022\016\n\006charid\030\001 "
    "\002(\003\",\n\rAckKickMember\022\013\n\003ret\030\001 \002(\005\022\016\n\006cha"
    "rid\030\002 \001(\003\"$\n\024ClientChangeJoinFlag\022\014\n\004fla"
    "g\030\001 \002(\010\"4\n\024ClientReqJoinControl\022\014\n\004type\030"
    "\001 \002(\010\022\016\n\006charid\030\002 \001(\003\";\n\016AckJoinControl\022"
    "\013\n\003ret\030\001 \002(\005\022\016\n\006charid\030\002 \001(\003\022\014\n\004type\030\003 \001"
    "(\010\"\"\n\020ClientReqAskJoin\022\016\n\006charid\030\001 \002(\003\"\031"
    "\n\nAckAskJoin\022\013\n\003ret\030\001 \002(\005\";\n\rAskClientJo"
    "in\022\n\n\002id\030\001 \002(\r\022\014\n\004name\030\002 \001(\t\022\020\n\010clanname"
    "\030\003 \001(\t\"1\n\025ClientReqRefuseOrJoin\022\014\n\004type\030"
    "\001 \002(\010\022\n\n\002id\030\002 \001(\r\"F\n\017AckRefuseOrJoin\022\013\n\003"
    "ret\030\001 \002(\005\022&\n\004info\030\002 \001(\0132\030.ClanPackage.Ac"
    "kClanBase\"\235\001\n\rSynchAttrToGM\022\016\n\006charid\030\001 "
    "\002(\003\022\013\n\003blv\030\002 \001(\005\022\013\n\003elv\030\003 \001(\005\022\n\n\002id\030\004 \001("
    "\r\022\014\n\004name\030\005 \001(\t\022\013\n\003job\030\006 \001(\005\022\017\n\004type\030\007 \001"
    "(\005:\0010\022\020\n\010clanicon\030\010 \001(\005\022\030\n\020clanContribut"
    "ion\030\t \001(\005\"A\n\020WorldReqGiveCost\022\016\n\006charid\030"
    "\001 \002(\003\022\r\n\005money\030\002 \001(\r\022\016\n\006golden\030\003 \001(\r\"I\n\013"
    "AckGiveCost\022\016\n\006charid\030\001 \002(\003\022\013\n\003ret\030\002 \001(\005"
    "\022\r\n\005money\030\003 \001(\r\022\016\n\006golden\030\004 \001(\r\"+\n\016ClanN"
    "ameChange\022\014\n\004name\030\001 \002(\t\022\013\n\003key\030\002 \001(\005\"6\n\t"
    "ClanLimit\022)\n\tclanGoods\030\001 \003(\0132\026.ClanPacka"
    "ge.ClanGoods\"*\n\tClanGoods\022\016\n\006itemid\030\001 \002("
    "\005\022\r\n\005limit\030\002 \001(\005\":\n\010ClanShop\022\013\n\003ret\030\001 \002("
    "\005\022\n\n\002ID\030\002 \001(\005\022\025\n\rsurplusCounts\030\003 \001(\005\"H\n\r"
    "SaveClanLimit\022)\n\tclanGoods\030\001 \003(\0132\026.ClanP"
    "ackage.ClanGoods\022\014\n\004time\030\002 \001(\003\"<\n\rSaveCl"
    "anSkill\022+\n\nsclanSkill\030\001 \003(\0132\027.ClanPackag"
    "e.SClanSkill\";\n\nSClanSkill\022\017\n\007skillid\030\001 "
    "\002(\005\022\016\n\006curexp\030\002 \001(\005\022\014\n\004type\030\003 \001(\005\",\n\tCla"
    "nSkill\022\017\n\007skillid\030\001 \002(\005\022\016\n\006curexp\030\002 \001(\005\""
    "$\n\024ClientReqSkillUpdate\022\014\n\004type\030\001 \002(\005\"T\n"
    "\024WSToClentSkillUpdate\022\013\n\003ret\030\001 \002(\005\022\017\n\007sk"
    "illid\030\002 \001(\005\022\016\n\006curexp\030\003 \001(\005\022\016\n\006contri\030\004 "
    "\001(\005\";\n\030WSToClientSimSkillUpdate\022\017\n\007skill"
    "id\030\001 \001(\005\022\016\n\006curexp\030\002 \001(\005\"\?\n\016WSToGameADBu"
    "ff\022\016\n\006charid\030\001 \002(\003\022\014\n\004flag\030\002 \001(\010\022\017\n\007skil"
    "lid\030\003 \003(\005\"6\n\021WSToGameClanLevel\022\016\n\006charid"
    "\030\001 \002(\003\022\021\n\tclanLevel\030\002 \001(\005\"1\n\021SynchWillJo"
    "inToGM\022\016\n\006charID\030\001 \003(\003\022\014\n\004flag\030\002 \001(\010\"f\n\017"
    "ShowClanWelfare\022*\n\010welfares\030\001 \003(\0132\030.Clan"
    "Package.ClanWelfare\022\025\n\rhistoryContri\030\002 \001"
    "(\r\022\020\n\010joinTime\030\003 \001(\004\"\232\001\n\013ClanWelfare\022\021\n\t"
    "welfareID\030\001 \002(\004\022\014\n\004name\030\002 \001(\t\022\025\n\rwelfare"
    "InfoID\030\003 \001(\005\022\017\n\007limitLv\030\004 \001(\005\022\020\n\010limitDa"
    "y\030\005 \001(\005\022\023\n\013limitContri\030\006 \001(\005\022\013\n\003num\030\007 \001("
    "\005\022\016\n\006isTake\030\010 \001(\005\"^\n\017SendClanWelfare\022\025\n\r"
    "welfareInfoID\030\001 \002(\005\022\n\n\002lv\030\002 \001(\005\022\013\n\003day\030\003"
    " \001(\005\022\016\n\006contri\030\004 \001(\005\022\013\n\003num\030\005 \001(\005\"$\n\017Tak"
    "eClanWelfare\022\021\n\twelfareID\030\001 \002(\004\"L\n\022RetTa"
    "keClanWelfare\022\013\n\003err\030\001 \002(\005\022)\n\007welfare\030\002 "
    "\001(\0132\030.ClanPackage.ClanWelfare\"\026\n\024ClientR"
    "eqBackClanMap\"/\n\021AckReqBackClanMap\022\013\n\003re"
    "t\030\001 \002(\005\022\r\n\005mapid\030\002 \001(\003\"\033\n\rAckClanSkills\022"
    "\n\n\002id\030\001 \003(\005\"!\n\023ReqUpGrageClanSkill\022\n\n\002id"
    "\030\001 \002(\005\"F\n\023AckUpGradeClanSkill\022\013\n\003ret\030\001 \002"
    "(\005\022\020\n\010oldskill\030\002 \001(\005\022\020\n\010newskill\030\003 \001(\005\"I"
    "\n\021Ws2GsRobberActive\022\014\n\004flag\030\001 \002(\010\022&\n\004inf"
    "o\030\002 \003(\0132\030.ClanPackage.ClanMapInfo\"i\n\013Cla"
    "nMapInfo\022\016\n\006clanid\030\001 \002(\005\022\r\n\005mapid\030\002 \001(\003\022"
    "\013\n\003win\030\003 \001(\010\022\r\n\005param\030\004 \001(\005\022\016\n\006conwin\030\005 "
    "\001(\005\022\017\n\007confail\030\006 \001(\005\"4\n\023Ws2GsDestroyClan"
    "Map\022\016\n\006clanid\030\001 \002(\005\022\r\n\005mapid\030\002 \001(\003\"j\n\014Ro"
    "bberResult\022\016\n\006clanid\030\001 \002(\005\022\013\n\003win\030\002 \001(\010\022"
    "\r\n\005param\030\003 \001(\005\022\016\n\006conwin\030\004 \001(\005\022\017\n\007confai"
    "l\030\005 \001(\005\022\r\n\005money\030\006 \001(\005\"%\n\027ClientReqChanc"
    "eJoinClan\022\n\n\002id\030\001 \002(\r\"0\n\021AckChanceJoinCl"
    "an\022\013\n\003ret\030\001 \002(\005\022\016\n\006clanID\030\002 \001(\005", 5591);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "Clan/Clan.proto", &protobuf_RegisterTypes);
  ClientReqCreateClan::default_instance_ = new ClientReqCreateClan();
  WorldReqTakeOff::default_instance_ = new WorldReqTakeOff();
  AckCreateClan::default_instance_ = new AckCreateClan();
  AckClanBase::default_instance_ = new AckClanBase();
  ClientReqClanList::default_instance_ = new ClientReqClanList();
  AckClanList::default_instance_ = new AckClanList();
  ClanList::default_instance_ = new ClanList();
  ClientReqMemberList::default_instance_ = new ClientReqMemberList();
  AckMemberList::default_instance_ = new AckMemberList();
  MemberInfo::default_instance_ = new MemberInfo();
  ReqSeeMemberList::default_instance_ = new ReqSeeMemberList();
  AckSeeMemberList::default_instance_ = new AckSeeMemberList();
  ClientReqClanEvent::default_instance_ = new ClientReqClanEvent();
  AckClanEvent::default_instance_ = new AckClanEvent();
  JoinClan::default_instance_ = new JoinClan();
  LeaveClan::default_instance_ = new LeaveClan();
  ClanMemberKilled::default_instance_ = new ClanMemberKilled();
  SynchClanEventToWS::default_instance_ = new SynchClanEventToWS();
  MemberContri::default_instance_ = new MemberContri();
  JobChange::default_instance_ = new JobChange();
  ClanUpdate::default_instance_ = new ClanUpdate();
  ClanCitryHold::default_instance_ = new ClanCitryHold();
  ClanPaidEvent::default_instance_ = new ClanPaidEvent();
  ClientReqClanRequestList::default_instance_ = new ClientReqClanRequestList();
  AckClanRequestList::default_instance_ = new AckClanRequestList();
  ClanRequestList::default_instance_ = new ClanRequestList();
  ClientReqClanContriList::default_instance_ = new ClientReqClanContriList();
  AckClanContriList::default_instance_ = new AckClanContriList();
  ClanContriList::default_instance_ = new ClanContriList();
  ClientReqJoinClan::default_instance_ = new ClientReqJoinClan();
  AckJoinClan::default_instance_ = new AckJoinClan();
  ClientAlterTitle::default_instance_ = new ClientAlterTitle();
  ClientReqContri::default_instance_ = new ClientReqContri();
  AckContri::default_instance_ = new AckContri();
  AckUpdateLv::default_instance_ = new AckUpdateLv();
  ClientChangeIcon::default_instance_ = new ClientChangeIcon();
  AckClientChangeIcon::default_instance_ = new AckClientChangeIcon();
  ClientReqGiveJob::default_instance_ = new ClientReqGiveJob();
  AckGiveJob::default_instance_ = new AckGiveJob();
  ClientReqOutJob::default_instance_ = new ClientReqOutJob();
  AckOutJob::default_instance_ = new AckOutJob();
  ClientReqKickMember::default_instance_ = new ClientReqKickMember();
  AckKickMember::default_instance_ = new AckKickMember();
  ClientChangeJoinFlag::default_instance_ = new ClientChangeJoinFlag();
  ClientReqJoinControl::default_instance_ = new ClientReqJoinControl();
  AckJoinControl::default_instance_ = new AckJoinControl();
  ClientReqAskJoin::default_instance_ = new ClientReqAskJoin();
  AckAskJoin::default_instance_ = new AckAskJoin();
  AskClientJoin::default_instance_ = new AskClientJoin();
  ClientReqRefuseOrJoin::default_instance_ = new ClientReqRefuseOrJoin();
  AckRefuseOrJoin::default_instance_ = new AckRefuseOrJoin();
  SynchAttrToGM::default_instance_ = new SynchAttrToGM();
  WorldReqGiveCost::default_instance_ = new WorldReqGiveCost();
  AckGiveCost::default_instance_ = new AckGiveCost();
  ClanNameChange::default_instance_ = new ClanNameChange();
  ClanLimit::default_instance_ = new ClanLimit();
  ClanGoods::default_instance_ = new ClanGoods();
  ClanShop::default_instance_ = new ClanShop();
  SaveClanLimit::default_instance_ = new SaveClanLimit();
  SaveClanSkill::default_instance_ = new SaveClanSkill();
  SClanSkill::default_instance_ = new SClanSkill();
  ClanSkill::default_instance_ = new ClanSkill();
  ClientReqSkillUpdate::default_instance_ = new ClientReqSkillUpdate();
  WSToClentSkillUpdate::default_instance_ = new WSToClentSkillUpdate();
  WSToClientSimSkillUpdate::default_instance_ = new WSToClientSimSkillUpdate();
  WSToGameADBuff::default_instance_ = new WSToGameADBuff();
  WSToGameClanLevel::default_instance_ = new WSToGameClanLevel();
  SynchWillJoinToGM::default_instance_ = new SynchWillJoinToGM();
  ShowClanWelfare::default_instance_ = new ShowClanWelfare();
  ClanWelfare::default_instance_ = new ClanWelfare();
  SendClanWelfare::default_instance_ = new SendClanWelfare();
  TakeClanWelfare::default_instance_ = new TakeClanWelfare();
  RetTakeClanWelfare::default_instance_ = new RetTakeClanWelfare();
  ClientReqBackClanMap::default_instance_ = new ClientReqBackClanMap();
  AckReqBackClanMap::default_instance_ = new AckReqBackClanMap();
  AckClanSkills::default_instance_ = new AckClanSkills();
  ReqUpGrageClanSkill::default_instance_ = new ReqUpGrageClanSkill();
  AckUpGradeClanSkill::default_instance_ = new AckUpGradeClanSkill();
  Ws2GsRobberActive::default_instance_ = new Ws2GsRobberActive();
  ClanMapInfo::default_instance_ = new ClanMapInfo();
  Ws2GsDestroyClanMap::default_instance_ = new Ws2GsDestroyClanMap();
  RobberResult::default_instance_ = new RobberResult();
  ClientReqChanceJoinClan::default_instance_ = new ClientReqChanceJoinClan();
  AckChanceJoinClan::default_instance_ = new AckChanceJoinClan();
  ClientReqCreateClan::default_instance_->InitAsDefaultInstance();
  WorldReqTakeOff::default_instance_->InitAsDefaultInstance();
  AckCreateClan::default_instance_->InitAsDefaultInstance();
  AckClanBase::default_instance_->InitAsDefaultInstance();
  ClientReqClanList::default_instance_->InitAsDefaultInstance();
  AckClanList::default_instance_->InitAsDefaultInstance();
  ClanList::default_instance_->InitAsDefaultInstance();
  ClientReqMemberList::default_instance_->InitAsDefaultInstance();
  AckMemberList::default_instance_->InitAsDefaultInstance();
  MemberInfo::default_instance_->InitAsDefaultInstance();
  ReqSeeMemberList::default_instance_->InitAsDefaultInstance();
  AckSeeMemberList::default_instance_->InitAsDefaultInstance();
  ClientReqClanEvent::default_instance_->InitAsDefaultInstance();
  AckClanEvent::default_instance_->InitAsDefaultInstance();
  JoinClan::default_instance_->InitAsDefaultInstance();
  LeaveClan::default_instance_->InitAsDefaultInstance();
  ClanMemberKilled::default_instance_->InitAsDefaultInstance();
  SynchClanEventToWS::default_instance_->InitAsDefaultInstance();
  MemberContri::default_instance_->InitAsDefaultInstance();
  JobChange::default_instance_->InitAsDefaultInstance();
  ClanUpdate::default_instance_->InitAsDefaultInstance();
  ClanCitryHold::default_instance_->InitAsDefaultInstance();
  ClanPaidEvent::default_instance_->InitAsDefaultInstance();
  ClientReqClanRequestList::default_instance_->InitAsDefaultInstance();
  AckClanRequestList::default_instance_->InitAsDefaultInstance();
  ClanRequestList::default_instance_->InitAsDefaultInstance();
  ClientReqClanContriList::default_instance_->InitAsDefaultInstance();
  AckClanContriList::default_instance_->InitAsDefaultInstance();
  ClanContriList::default_instance_->InitAsDefaultInstance();
  ClientReqJoinClan::default_instance_->InitAsDefaultInstance();
  AckJoinClan::default_instance_->InitAsDefaultInstance();
  ClientAlterTitle::default_instance_->InitAsDefaultInstance();
  ClientReqContri::default_instance_->InitAsDefaultInstance();
  AckContri::default_instance_->InitAsDefaultInstance();
  AckUpdateLv::default_instance_->InitAsDefaultInstance();
  ClientChangeIcon::default_instance_->InitAsDefaultInstance();
  AckClientChangeIcon::default_instance_->InitAsDefaultInstance();
  ClientReqGiveJob::default_instance_->InitAsDefaultInstance();
  AckGiveJob::default_instance_->InitAsDefaultInstance();
  ClientReqOutJob::default_instance_->InitAsDefaultInstance();
  AckOutJob::default_instance_->InitAsDefaultInstance();
  ClientReqKickMember::default_instance_->InitAsDefaultInstance();
  AckKickMember::default_instance_->InitAsDefaultInstance();
  ClientChangeJoinFlag::default_instance_->InitAsDefaultInstance();
  ClientReqJoinControl::default_instance_->InitAsDefaultInstance();
  AckJoinControl::default_instance_->InitAsDefaultInstance();
  ClientReqAskJoin::default_instance_->InitAsDefaultInstance();
  AckAskJoin::default_instance_->InitAsDefaultInstance();
  AskClientJoin::default_instance_->InitAsDefaultInstance();
  ClientReqRefuseOrJoin::default_instance_->InitAsDefaultInstance();
  AckRefuseOrJoin::default_instance_->InitAsDefaultInstance();
  SynchAttrToGM::default_instance_->InitAsDefaultInstance();
  WorldReqGiveCost::default_instance_->InitAsDefaultInstance();
  AckGiveCost::default_instance_->InitAsDefaultInstance();
  ClanNameChange::default_instance_->InitAsDefaultInstance();
  ClanLimit::default_instance_->InitAsDefaultInstance();
  ClanGoods::default_instance_->InitAsDefaultInstance();
  ClanShop::default_instance_->InitAsDefaultInstance();
  SaveClanLimit::default_instance_->InitAsDefaultInstance();
  SaveClanSkill::default_instance_->InitAsDefaultInstance();
  SClanSkill::default_instance_->InitAsDefaultInstance();
  ClanSkill::default_instance_->InitAsDefaultInstance();
  ClientReqSkillUpdate::default_instance_->InitAsDefaultInstance();
  WSToClentSkillUpdate::default_instance_->InitAsDefaultInstance();
  WSToClientSimSkillUpdate::default_instance_->InitAsDefaultInstance();
  WSToGameADBuff::default_instance_->InitAsDefaultInstance();
  WSToGameClanLevel::default_instance_->InitAsDefaultInstance();
  SynchWillJoinToGM::default_instance_->InitAsDefaultInstance();
  ShowClanWelfare::default_instance_->InitAsDefaultInstance();
  ClanWelfare::default_instance_->InitAsDefaultInstance();
  SendClanWelfare::default_instance_->InitAsDefaultInstance();
  TakeClanWelfare::default_instance_->InitAsDefaultInstance();
  RetTakeClanWelfare::default_instance_->InitAsDefaultInstance();
  ClientReqBackClanMap::default_instance_->InitAsDefaultInstance();
  AckReqBackClanMap::default_instance_->InitAsDefaultInstance();
  AckClanSkills::default_instance_->InitAsDefaultInstance();
  ReqUpGrageClanSkill::default_instance_->InitAsDefaultInstance();
  AckUpGradeClanSkill::default_instance_->InitAsDefaultInstance();
  Ws2GsRobberActive::default_instance_->InitAsDefaultInstance();
  ClanMapInfo::default_instance_->InitAsDefaultInstance();
  Ws2GsDestroyClanMap::default_instance_->InitAsDefaultInstance();
  RobberResult::default_instance_->InitAsDefaultInstance();
  ClientReqChanceJoinClan::default_instance_->InitAsDefaultInstance();
  AckChanceJoinClan::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Clan_2fClan_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Clan_2fClan_2eproto {
  StaticDescriptorInitializer_Clan_2fClan_2eproto() {
    protobuf_AddDesc_Clan_2fClan_2eproto();
  }
} static_descriptor_initializer_Clan_2fClan_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int ClientReqCreateClan::kIdFieldNumber;
const int ClientReqCreateClan::kNameFieldNumber;
const int ClientReqCreateClan::kTypeFieldNumber;
#endif  // !_MSC_VER

ClientReqCreateClan::ClientReqCreateClan()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqCreateClan::InitAsDefaultInstance() {
}

ClientReqCreateClan::ClientReqCreateClan(const ClientReqCreateClan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqCreateClan::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqCreateClan::~ClientReqCreateClan() {
  SharedDtor();
}

void ClientReqCreateClan::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void ClientReqCreateClan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqCreateClan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqCreateClan_descriptor_;
}

const ClientReqCreateClan& ClientReqCreateClan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqCreateClan* ClientReqCreateClan::default_instance_ = NULL;

ClientReqCreateClan* ClientReqCreateClan::New() const {
  return new ClientReqCreateClan;
}

void ClientReqCreateClan::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    type_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqCreateClan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional bool type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqCreateClan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional bool type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqCreateClan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional bool type = 3;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqCreateClan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional bool type = 3;
    if (has_type()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqCreateClan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqCreateClan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqCreateClan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqCreateClan::MergeFrom(const ClientReqCreateClan& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqCreateClan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqCreateClan::CopyFrom(const ClientReqCreateClan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqCreateClan::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqCreateClan::Swap(ClientReqCreateClan* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqCreateClan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqCreateClan_descriptor_;
  metadata.reflection = ClientReqCreateClan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WorldReqTakeOff::kIdFieldNumber;
const int WorldReqTakeOff::kTypeFieldNumber;
#endif  // !_MSC_VER

WorldReqTakeOff::WorldReqTakeOff()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WorldReqTakeOff::InitAsDefaultInstance() {
}

WorldReqTakeOff::WorldReqTakeOff(const WorldReqTakeOff& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WorldReqTakeOff::SharedCtor() {
  _cached_size_ = 0;
  id_ = GOOGLE_LONGLONG(0);
  type_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WorldReqTakeOff::~WorldReqTakeOff() {
  SharedDtor();
}

void WorldReqTakeOff::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WorldReqTakeOff::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WorldReqTakeOff::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WorldReqTakeOff_descriptor_;
}

const WorldReqTakeOff& WorldReqTakeOff::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

WorldReqTakeOff* WorldReqTakeOff::default_instance_ = NULL;

WorldReqTakeOff* WorldReqTakeOff::New() const {
  return new WorldReqTakeOff;
}

void WorldReqTakeOff::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = GOOGLE_LONGLONG(0);
    type_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WorldReqTakeOff::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional bool type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WorldReqTakeOff::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->id(), output);
  }

  // optional bool type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WorldReqTakeOff::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->id(), target);
  }

  // optional bool type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WorldReqTakeOff::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->id());
    }

    // optional bool type = 2;
    if (has_type()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WorldReqTakeOff::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WorldReqTakeOff* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WorldReqTakeOff*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WorldReqTakeOff::MergeFrom(const WorldReqTakeOff& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WorldReqTakeOff::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WorldReqTakeOff::CopyFrom(const WorldReqTakeOff& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WorldReqTakeOff::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void WorldReqTakeOff::Swap(WorldReqTakeOff* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WorldReqTakeOff::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WorldReqTakeOff_descriptor_;
  metadata.reflection = WorldReqTakeOff_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckCreateClan::kRetFieldNumber;
const int AckCreateClan::kInfoFieldNumber;
#endif  // !_MSC_VER

AckCreateClan::AckCreateClan()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckCreateClan::InitAsDefaultInstance() {
  info_ = const_cast< ::ClanPackage::AckClanBase*>(&::ClanPackage::AckClanBase::default_instance());
}

AckCreateClan::AckCreateClan(const AckCreateClan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckCreateClan::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckCreateClan::~AckCreateClan() {
  SharedDtor();
}

void AckCreateClan::SharedDtor() {
  if (this != default_instance_) {
    delete info_;
  }
}

void AckCreateClan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckCreateClan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckCreateClan_descriptor_;
}

const AckCreateClan& AckCreateClan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckCreateClan* AckCreateClan::default_instance_ = NULL;

AckCreateClan* AckCreateClan::New() const {
  return new AckCreateClan;
}

void AckCreateClan::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
    if (has_info()) {
      if (info_ != NULL) info_->::ClanPackage::AckClanBase::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckCreateClan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_info;
        break;
      }

      // optional .ClanPackage.AckClanBase info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckCreateClan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  // optional .ClanPackage.AckClanBase info = 2;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckCreateClan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  // optional .ClanPackage.AckClanBase info = 2;
  if (has_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckCreateClan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional .ClanPackage.AckClanBase info = 2;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckCreateClan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckCreateClan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckCreateClan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckCreateClan::MergeFrom(const AckCreateClan& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_info()) {
      mutable_info()->::ClanPackage::AckClanBase::MergeFrom(from.info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckCreateClan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckCreateClan::CopyFrom(const AckCreateClan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckCreateClan::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  return true;
}

void AckCreateClan::Swap(AckCreateClan* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckCreateClan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckCreateClan_descriptor_;
  metadata.reflection = AckCreateClan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckClanBase::kIdFieldNumber;
const int AckClanBase::kLvFieldNumber;
const int AckClanBase::kTitleFieldNumber;
const int AckClanBase::kMoneyFieldNumber;
const int AckClanBase::kGoldenFieldNumber;
const int AckClanBase::kTitletimeFieldNumber;
const int AckClanBase::kCreatetimeFieldNumber;
const int AckClanBase::kFactionconFieldNumber;
const int AckClanBase::kClannameFieldNumber;
const int AckClanBase::kBossnameFieldNumber;
const int AckClanBase::kIconFieldNumber;
const int AckClanBase::kMembersFieldNumber;
const int AckClanBase::kAutoflagFieldNumber;
#endif  // !_MSC_VER

AckClanBase::AckClanBase()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckClanBase::InitAsDefaultInstance() {
}

AckClanBase::AckClanBase(const AckClanBase& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckClanBase::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  lv_ = 0;
  title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  money_ = GOOGLE_LONGLONG(0);
  golden_ = GOOGLE_LONGLONG(0);
  titletime_ = 0;
  createtime_ = 0;
  factioncon_ = 0;
  clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  bossname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  icon_ = 0;
  members_ = 0;
  autoflag_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckClanBase::~AckClanBase() {
  SharedDtor();
}

void AckClanBase::SharedDtor() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    delete clanname_;
  }
  if (bossname_ != &::google::protobuf::internal::kEmptyString) {
    delete bossname_;
  }
  if (this != default_instance_) {
  }
}

void AckClanBase::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckClanBase::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckClanBase_descriptor_;
}

const AckClanBase& AckClanBase::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckClanBase* AckClanBase::default_instance_ = NULL;

AckClanBase* AckClanBase::New() const {
  return new AckClanBase;
}

void AckClanBase::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
    lv_ = 0;
    if (has_title()) {
      if (title_ != &::google::protobuf::internal::kEmptyString) {
        title_->clear();
      }
    }
    money_ = GOOGLE_LONGLONG(0);
    golden_ = GOOGLE_LONGLONG(0);
    titletime_ = 0;
    createtime_ = 0;
    factioncon_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_clanname()) {
      if (clanname_ != &::google::protobuf::internal::kEmptyString) {
        clanname_->clear();
      }
    }
    if (has_bossname()) {
      if (bossname_ != &::google::protobuf::internal::kEmptyString) {
        bossname_->clear();
      }
    }
    icon_ = 0;
    members_ = 0;
    autoflag_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckClanBase::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_lv;
        break;
      }

      // optional int32 lv = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lv_)));
          set_has_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_title;
        break;
      }

      // optional string title = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_title:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_title()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->title().data(), this->title().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_money;
        break;
      }

      // optional int64 money = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_golden;
        break;
      }

      // optional int64 golden = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_golden:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &golden_)));
          set_has_golden();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(49)) goto parse_titletime;
        break;
      }

      // optional double titletime = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_titletime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &titletime_)));
          set_has_titletime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(57)) goto parse_createtime;
        break;
      }

      // optional double createtime = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_createtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &createtime_)));
          set_has_createtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_factioncon;
        break;
      }

      // optional int32 factioncon = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_factioncon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &factioncon_)));
          set_has_factioncon();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_clanname;
        break;
      }

      // optional string clanname = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_clanname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_clanname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->clanname().data(), this->clanname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_bossname;
        break;
      }

      // optional string bossname = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bossname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_bossname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->bossname().data(), this->bossname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_icon;
        break;
      }

      // optional int32 icon = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_icon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &icon_)));
          set_has_icon();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_members;
        break;
      }

      // optional int32 members = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_members:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &members_)));
          set_has_members();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_autoflag;
        break;
      }

      // optional bool autoflag = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_autoflag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &autoflag_)));
          set_has_autoflag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckClanBase::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional int32 lv = 2;
  if (has_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->lv(), output);
  }

  // optional string title = 3;
  if (has_title()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->title().data(), this->title().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->title(), output);
  }

  // optional int64 money = 4;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->money(), output);
  }

  // optional int64 golden = 5;
  if (has_golden()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->golden(), output);
  }

  // optional double titletime = 6;
  if (has_titletime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->titletime(), output);
  }

  // optional double createtime = 7;
  if (has_createtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->createtime(), output);
  }

  // optional int32 factioncon = 8;
  if (has_factioncon()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->factioncon(), output);
  }

  // optional string clanname = 9;
  if (has_clanname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->clanname().data(), this->clanname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->clanname(), output);
  }

  // optional string bossname = 10;
  if (has_bossname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->bossname().data(), this->bossname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->bossname(), output);
  }

  // optional int32 icon = 11;
  if (has_icon()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->icon(), output);
  }

  // optional int32 members = 12;
  if (has_members()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->members(), output);
  }

  // optional bool autoflag = 13;
  if (has_autoflag()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->autoflag(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckClanBase::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // optional int32 lv = 2;
  if (has_lv()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->lv(), target);
  }

  // optional string title = 3;
  if (has_title()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->title().data(), this->title().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->title(), target);
  }

  // optional int64 money = 4;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->money(), target);
  }

  // optional int64 golden = 5;
  if (has_golden()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->golden(), target);
  }

  // optional double titletime = 6;
  if (has_titletime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->titletime(), target);
  }

  // optional double createtime = 7;
  if (has_createtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->createtime(), target);
  }

  // optional int32 factioncon = 8;
  if (has_factioncon()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->factioncon(), target);
  }

  // optional string clanname = 9;
  if (has_clanname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->clanname().data(), this->clanname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->clanname(), target);
  }

  // optional string bossname = 10;
  if (has_bossname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->bossname().data(), this->bossname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->bossname(), target);
  }

  // optional int32 icon = 11;
  if (has_icon()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->icon(), target);
  }

  // optional int32 members = 12;
  if (has_members()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->members(), target);
  }

  // optional bool autoflag = 13;
  if (has_autoflag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->autoflag(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckClanBase::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional int32 lv = 2;
    if (has_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lv());
    }

    // optional string title = 3;
    if (has_title()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->title());
    }

    // optional int64 money = 4;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->money());
    }

    // optional int64 golden = 5;
    if (has_golden()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->golden());
    }

    // optional double titletime = 6;
    if (has_titletime()) {
      total_size += 1 + 8;
    }

    // optional double createtime = 7;
    if (has_createtime()) {
      total_size += 1 + 8;
    }

    // optional int32 factioncon = 8;
    if (has_factioncon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->factioncon());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string clanname = 9;
    if (has_clanname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->clanname());
    }

    // optional string bossname = 10;
    if (has_bossname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->bossname());
    }

    // optional int32 icon = 11;
    if (has_icon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->icon());
    }

    // optional int32 members = 12;
    if (has_members()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->members());
    }

    // optional bool autoflag = 13;
    if (has_autoflag()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckClanBase::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckClanBase* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckClanBase*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckClanBase::MergeFrom(const AckClanBase& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_lv()) {
      set_lv(from.lv());
    }
    if (from.has_title()) {
      set_title(from.title());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
    if (from.has_golden()) {
      set_golden(from.golden());
    }
    if (from.has_titletime()) {
      set_titletime(from.titletime());
    }
    if (from.has_createtime()) {
      set_createtime(from.createtime());
    }
    if (from.has_factioncon()) {
      set_factioncon(from.factioncon());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_clanname()) {
      set_clanname(from.clanname());
    }
    if (from.has_bossname()) {
      set_bossname(from.bossname());
    }
    if (from.has_icon()) {
      set_icon(from.icon());
    }
    if (from.has_members()) {
      set_members(from.members());
    }
    if (from.has_autoflag()) {
      set_autoflag(from.autoflag());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckClanBase::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckClanBase::CopyFrom(const AckClanBase& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckClanBase::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckClanBase::Swap(AckClanBase* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(lv_, other->lv_);
    std::swap(title_, other->title_);
    std::swap(money_, other->money_);
    std::swap(golden_, other->golden_);
    std::swap(titletime_, other->titletime_);
    std::swap(createtime_, other->createtime_);
    std::swap(factioncon_, other->factioncon_);
    std::swap(clanname_, other->clanname_);
    std::swap(bossname_, other->bossname_);
    std::swap(icon_, other->icon_);
    std::swap(members_, other->members_);
    std::swap(autoflag_, other->autoflag_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckClanBase::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckClanBase_descriptor_;
  metadata.reflection = AckClanBase_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqClanList::kPageFieldNumber;
#endif  // !_MSC_VER

ClientReqClanList::ClientReqClanList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqClanList::InitAsDefaultInstance() {
}

ClientReqClanList::ClientReqClanList(const ClientReqClanList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqClanList::SharedCtor() {
  _cached_size_ = 0;
  page_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqClanList::~ClientReqClanList() {
  SharedDtor();
}

void ClientReqClanList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqClanList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqClanList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqClanList_descriptor_;
}

const ClientReqClanList& ClientReqClanList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqClanList* ClientReqClanList::default_instance_ = NULL;

ClientReqClanList* ClientReqClanList::New() const {
  return new ClientReqClanList;
}

void ClientReqClanList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    page_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqClanList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 page = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &page_)));
          set_has_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqClanList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 page = 1;
  if (has_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->page(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqClanList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 page = 1;
  if (has_page()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->page(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqClanList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 page = 1;
    if (has_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->page());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqClanList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqClanList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqClanList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqClanList::MergeFrom(const ClientReqClanList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_page()) {
      set_page(from.page());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqClanList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqClanList::CopyFrom(const ClientReqClanList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqClanList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqClanList::Swap(ClientReqClanList* other) {
  if (other != this) {
    std::swap(page_, other->page_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqClanList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqClanList_descriptor_;
  metadata.reflection = ClientReqClanList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckClanList::kListFieldNumber;
const int AckClanList::kSizeFieldNumber;
#endif  // !_MSC_VER

AckClanList::AckClanList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckClanList::InitAsDefaultInstance() {
}

AckClanList::AckClanList(const AckClanList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckClanList::SharedCtor() {
  _cached_size_ = 0;
  size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckClanList::~AckClanList() {
  SharedDtor();
}

void AckClanList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckClanList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckClanList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckClanList_descriptor_;
}

const AckClanList& AckClanList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckClanList* AckClanList::default_instance_ = NULL;

AckClanList* AckClanList::New() const {
  return new AckClanList;
}

void AckClanList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    size_ = 0;
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckClanList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ClanPackage.ClanList list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_size;
        break;
      }

      // optional int32 size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckClanList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ClanPackage.ClanList list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }

  // optional int32 size = 2;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckClanList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ClanPackage.ClanList list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }

  // optional int32 size = 2;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckClanList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 size = 2;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->size());
    }

  }
  // repeated .ClanPackage.ClanList list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckClanList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckClanList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckClanList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckClanList::MergeFrom(const AckClanList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckClanList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckClanList::CopyFrom(const AckClanList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckClanList::IsInitialized() const {

  for (int i = 0; i < list_size(); i++) {
    if (!this->list(i).IsInitialized()) return false;
  }
  return true;
}

void AckClanList::Swap(AckClanList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckClanList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckClanList_descriptor_;
  metadata.reflection = AckClanList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClanList::kIdFieldNumber;
const int ClanList::kRankFieldNumber;
const int ClanList::kNameFieldNumber;
const int ClanList::kCountFieldNumber;
const int ClanList::kLvFieldNumber;
const int ClanList::kFightFieldNumber;
const int ClanList::kCountryFieldNumber;
const int ClanList::kApplyFieldNumber;
#endif  // !_MSC_VER

ClanList::ClanList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClanList::InitAsDefaultInstance() {
}

ClanList::ClanList(const ClanList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClanList::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  rank_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  count_ = 0;
  lv_ = 0;
  fight_ = 0;
  country_ = 0;
  apply_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClanList::~ClanList() {
  SharedDtor();
}

void ClanList::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void ClanList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClanList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClanList_descriptor_;
}

const ClanList& ClanList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClanList* ClanList::default_instance_ = NULL;

ClanList* ClanList::New() const {
  return new ClanList;
}

void ClanList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
    rank_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    count_ = 0;
    lv_ = 0;
    fight_ = 0;
    country_ = 0;
    apply_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClanList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_rank;
        break;
      }

      // optional int32 rank = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rank:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rank_)));
          set_has_rank();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_name;
        break;
      }

      // optional string name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_count;
        break;
      }

      // optional int32 count = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_lv;
        break;
      }

      // optional int32 lv = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lv_)));
          set_has_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_fight;
        break;
      }

      // optional int32 fight = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fight_)));
          set_has_fight();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_country;
        break;
      }

      // optional int32 country = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_country:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &country_)));
          set_has_country();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_apply;
        break;
      }

      // optional bool apply = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_apply:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &apply_)));
          set_has_apply();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClanList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional int32 rank = 2;
  if (has_rank()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->rank(), output);
  }

  // optional string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->name(), output);
  }

  // optional int32 count = 4;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->count(), output);
  }

  // optional int32 lv = 5;
  if (has_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->lv(), output);
  }

  // optional int32 fight = 6;
  if (has_fight()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->fight(), output);
  }

  // optional int32 country = 7;
  if (has_country()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->country(), output);
  }

  // optional bool apply = 8;
  if (has_apply()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->apply(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClanList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // optional int32 rank = 2;
  if (has_rank()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->rank(), target);
  }

  // optional string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->name(), target);
  }

  // optional int32 count = 4;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->count(), target);
  }

  // optional int32 lv = 5;
  if (has_lv()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->lv(), target);
  }

  // optional int32 fight = 6;
  if (has_fight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->fight(), target);
  }

  // optional int32 country = 7;
  if (has_country()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->country(), target);
  }

  // optional bool apply = 8;
  if (has_apply()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->apply(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClanList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional int32 rank = 2;
    if (has_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rank());
    }

    // optional string name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 count = 4;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }

    // optional int32 lv = 5;
    if (has_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lv());
    }

    // optional int32 fight = 6;
    if (has_fight()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fight());
    }

    // optional int32 country = 7;
    if (has_country()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->country());
    }

    // optional bool apply = 8;
    if (has_apply()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClanList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClanList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClanList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClanList::MergeFrom(const ClanList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_rank()) {
      set_rank(from.rank());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_lv()) {
      set_lv(from.lv());
    }
    if (from.has_fight()) {
      set_fight(from.fight());
    }
    if (from.has_country()) {
      set_country(from.country());
    }
    if (from.has_apply()) {
      set_apply(from.apply());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClanList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClanList::CopyFrom(const ClanList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClanList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClanList::Swap(ClanList* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(rank_, other->rank_);
    std::swap(name_, other->name_);
    std::swap(count_, other->count_);
    std::swap(lv_, other->lv_);
    std::swap(fight_, other->fight_);
    std::swap(country_, other->country_);
    std::swap(apply_, other->apply_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClanList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClanList_descriptor_;
  metadata.reflection = ClanList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqMemberList::kTypeFieldNumber;
const int ClientReqMemberList::kPageFieldNumber;
#endif  // !_MSC_VER

ClientReqMemberList::ClientReqMemberList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqMemberList::InitAsDefaultInstance() {
}

ClientReqMemberList::ClientReqMemberList(const ClientReqMemberList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqMemberList::SharedCtor() {
  _cached_size_ = 0;
  type_ = false;
  page_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqMemberList::~ClientReqMemberList() {
  SharedDtor();
}

void ClientReqMemberList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqMemberList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqMemberList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqMemberList_descriptor_;
}

const ClientReqMemberList& ClientReqMemberList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqMemberList* ClientReqMemberList::default_instance_ = NULL;

ClientReqMemberList* ClientReqMemberList::New() const {
  return new ClientReqMemberList;
}

void ClientReqMemberList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = false;
    page_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqMemberList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_page;
        break;
      }

      // optional int32 page = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_page:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &page_)));
          set_has_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqMemberList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->type(), output);
  }

  // optional int32 page = 2;
  if (has_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->page(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqMemberList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->type(), target);
  }

  // optional int32 page = 2;
  if (has_page()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->page(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqMemberList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool type = 1;
    if (has_type()) {
      total_size += 1 + 1;
    }

    // optional int32 page = 2;
    if (has_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->page());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqMemberList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqMemberList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqMemberList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqMemberList::MergeFrom(const ClientReqMemberList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_page()) {
      set_page(from.page());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqMemberList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqMemberList::CopyFrom(const ClientReqMemberList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqMemberList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqMemberList::Swap(ClientReqMemberList* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(page_, other->page_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqMemberList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqMemberList_descriptor_;
  metadata.reflection = ClientReqMemberList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckMemberList::kInfoFieldNumber;
const int AckMemberList::kCountFieldNumber;
const int AckMemberList::kFightFieldNumber;
const int AckMemberList::kIsendFieldNumber;
#endif  // !_MSC_VER

AckMemberList::AckMemberList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckMemberList::InitAsDefaultInstance() {
}

AckMemberList::AckMemberList(const AckMemberList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckMemberList::SharedCtor() {
  _cached_size_ = 0;
  count_ = 0;
  fight_ = 0;
  isend_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckMemberList::~AckMemberList() {
  SharedDtor();
}

void AckMemberList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckMemberList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckMemberList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckMemberList_descriptor_;
}

const AckMemberList& AckMemberList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckMemberList* AckMemberList::default_instance_ = NULL;

AckMemberList* AckMemberList::New() const {
  return new AckMemberList;
}

void AckMemberList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    count_ = 0;
    fight_ = 0;
    isend_ = false;
  }
  info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckMemberList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ClanPackage.MemberInfo info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_info;
        if (input->ExpectTag(16)) goto parse_count;
        break;
      }

      // optional int32 count = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_fight;
        break;
      }

      // optional int32 fight = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fight_)));
          set_has_fight();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_isend;
        break;
      }

      // optional bool isend = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isend:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isend_)));
          set_has_isend();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckMemberList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ClanPackage.MemberInfo info = 1;
  for (int i = 0; i < this->info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->info(i), output);
  }

  // optional int32 count = 2;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->count(), output);
  }

  // optional int32 fight = 3;
  if (has_fight()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->fight(), output);
  }

  // optional bool isend = 4;
  if (has_isend()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->isend(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckMemberList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ClanPackage.MemberInfo info = 1;
  for (int i = 0; i < this->info_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->info(i), target);
  }

  // optional int32 count = 2;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->count(), target);
  }

  // optional int32 fight = 3;
  if (has_fight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->fight(), target);
  }

  // optional bool isend = 4;
  if (has_isend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->isend(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckMemberList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }

    // optional int32 fight = 3;
    if (has_fight()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fight());
    }

    // optional bool isend = 4;
    if (has_isend()) {
      total_size += 1 + 1;
    }

  }
  // repeated .ClanPackage.MemberInfo info = 1;
  total_size += 1 * this->info_size();
  for (int i = 0; i < this->info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->info(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckMemberList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckMemberList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckMemberList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckMemberList::MergeFrom(const AckMemberList& from) {
  GOOGLE_CHECK_NE(&from, this);
  info_.MergeFrom(from.info_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_count()) {
      set_count(from.count());
    }
    if (from.has_fight()) {
      set_fight(from.fight());
    }
    if (from.has_isend()) {
      set_isend(from.isend());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckMemberList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckMemberList::CopyFrom(const AckMemberList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckMemberList::IsInitialized() const {

  for (int i = 0; i < info_size(); i++) {
    if (!this->info(i).IsInitialized()) return false;
  }
  return true;
}

void AckMemberList::Swap(AckMemberList* other) {
  if (other != this) {
    info_.Swap(&other->info_);
    std::swap(count_, other->count_);
    std::swap(fight_, other->fight_);
    std::swap(isend_, other->isend_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckMemberList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckMemberList_descriptor_;
  metadata.reflection = AckMemberList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MemberInfo::kCharidFieldNumber;
const int MemberInfo::kNameFieldNumber;
const int MemberInfo::kProfessionFieldNumber;
const int MemberInfo::kContriFieldNumber;
const int MemberInfo::kFightFieldNumber;
const int MemberInfo::kJobFieldNumber;
const int MemberInfo::kLvFieldNumber;
const int MemberInfo::kVipFieldNumber;
const int MemberInfo::kIsonlineFieldNumber;
#endif  // !_MSC_VER

MemberInfo::MemberInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MemberInfo::InitAsDefaultInstance() {
}

MemberInfo::MemberInfo(const MemberInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MemberInfo::SharedCtor() {
  _cached_size_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  profession_ = 0;
  contri_ = 0;
  fight_ = 0;
  job_ = 0;
  lv_ = 0;
  vip_ = 0;
  isonline_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MemberInfo::~MemberInfo() {
  SharedDtor();
}

void MemberInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void MemberInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MemberInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MemberInfo_descriptor_;
}

const MemberInfo& MemberInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

MemberInfo* MemberInfo::default_instance_ = NULL;

MemberInfo* MemberInfo::New() const {
  return new MemberInfo;
}

void MemberInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = GOOGLE_LONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    profession_ = 0;
    contri_ = 0;
    fight_ = 0;
    job_ = 0;
    lv_ = 0;
    vip_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    isonline_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MemberInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_profession;
        break;
      }

      // optional int32 profession = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_profession:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &profession_)));
          set_has_profession();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_contri;
        break;
      }

      // optional int32 contri = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_contri:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &contri_)));
          set_has_contri();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_fight;
        break;
      }

      // optional int32 fight = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fight_)));
          set_has_fight();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_job;
        break;
      }

      // optional int32 job = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &job_)));
          set_has_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_lv;
        break;
      }

      // optional int32 lv = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lv_)));
          set_has_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_vip;
        break;
      }

      // optional int32 vip = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_vip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &vip_)));
          set_has_vip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_isonline;
        break;
      }

      // optional bool isonline = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isonline:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isonline_)));
          set_has_isonline();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MemberInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->charid(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional int32 profession = 3;
  if (has_profession()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->profession(), output);
  }

  // optional int32 contri = 4;
  if (has_contri()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->contri(), output);
  }

  // optional int32 fight = 5;
  if (has_fight()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->fight(), output);
  }

  // optional int32 job = 6;
  if (has_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->job(), output);
  }

  // optional int32 lv = 7;
  if (has_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->lv(), output);
  }

  // optional int32 vip = 8;
  if (has_vip()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->vip(), output);
  }

  // optional bool isonline = 9;
  if (has_isonline()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->isonline(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MemberInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 charid = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->charid(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional int32 profession = 3;
  if (has_profession()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->profession(), target);
  }

  // optional int32 contri = 4;
  if (has_contri()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->contri(), target);
  }

  // optional int32 fight = 5;
  if (has_fight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->fight(), target);
  }

  // optional int32 job = 6;
  if (has_job()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->job(), target);
  }

  // optional int32 lv = 7;
  if (has_lv()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->lv(), target);
  }

  // optional int32 vip = 8;
  if (has_vip()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->vip(), target);
  }

  // optional bool isonline = 9;
  if (has_isonline()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->isonline(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MemberInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 profession = 3;
    if (has_profession()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->profession());
    }

    // optional int32 contri = 4;
    if (has_contri()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->contri());
    }

    // optional int32 fight = 5;
    if (has_fight()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fight());
    }

    // optional int32 job = 6;
    if (has_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->job());
    }

    // optional int32 lv = 7;
    if (has_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lv());
    }

    // optional int32 vip = 8;
    if (has_vip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->vip());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool isonline = 9;
    if (has_isonline()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MemberInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MemberInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MemberInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MemberInfo::MergeFrom(const MemberInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_profession()) {
      set_profession(from.profession());
    }
    if (from.has_contri()) {
      set_contri(from.contri());
    }
    if (from.has_fight()) {
      set_fight(from.fight());
    }
    if (from.has_job()) {
      set_job(from.job());
    }
    if (from.has_lv()) {
      set_lv(from.lv());
    }
    if (from.has_vip()) {
      set_vip(from.vip());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_isonline()) {
      set_isonline(from.isonline());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MemberInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MemberInfo::CopyFrom(const MemberInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemberInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void MemberInfo::Swap(MemberInfo* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(name_, other->name_);
    std::swap(profession_, other->profession_);
    std::swap(contri_, other->contri_);
    std::swap(fight_, other->fight_);
    std::swap(job_, other->job_);
    std::swap(lv_, other->lv_);
    std::swap(vip_, other->vip_);
    std::swap(isonline_, other->isonline_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MemberInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MemberInfo_descriptor_;
  metadata.reflection = MemberInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReqSeeMemberList::kTypeFieldNumber;
const int ReqSeeMemberList::kPageFieldNumber;
const int ReqSeeMemberList::kClanIDFieldNumber;
#endif  // !_MSC_VER

ReqSeeMemberList::ReqSeeMemberList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReqSeeMemberList::InitAsDefaultInstance() {
}

ReqSeeMemberList::ReqSeeMemberList(const ReqSeeMemberList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReqSeeMemberList::SharedCtor() {
  _cached_size_ = 0;
  type_ = false;
  page_ = 0;
  clanid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqSeeMemberList::~ReqSeeMemberList() {
  SharedDtor();
}

void ReqSeeMemberList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ReqSeeMemberList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReqSeeMemberList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReqSeeMemberList_descriptor_;
}

const ReqSeeMemberList& ReqSeeMemberList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ReqSeeMemberList* ReqSeeMemberList::default_instance_ = NULL;

ReqSeeMemberList* ReqSeeMemberList::New() const {
  return new ReqSeeMemberList;
}

void ReqSeeMemberList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = false;
    page_ = 0;
    clanid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReqSeeMemberList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_page;
        break;
      }

      // optional int32 page = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_page:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &page_)));
          set_has_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_clanID;
        break;
      }

      // optional int32 clanID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_clanID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &clanid_)));
          set_has_clanid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqSeeMemberList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->type(), output);
  }

  // optional int32 page = 2;
  if (has_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->page(), output);
  }

  // optional int32 clanID = 3;
  if (has_clanid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->clanid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReqSeeMemberList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->type(), target);
  }

  // optional int32 page = 2;
  if (has_page()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->page(), target);
  }

  // optional int32 clanID = 3;
  if (has_clanid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->clanid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReqSeeMemberList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool type = 1;
    if (has_type()) {
      total_size += 1 + 1;
    }

    // optional int32 page = 2;
    if (has_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->page());
    }

    // optional int32 clanID = 3;
    if (has_clanid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->clanid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqSeeMemberList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReqSeeMemberList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReqSeeMemberList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReqSeeMemberList::MergeFrom(const ReqSeeMemberList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_page()) {
      set_page(from.page());
    }
    if (from.has_clanid()) {
      set_clanid(from.clanid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReqSeeMemberList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReqSeeMemberList::CopyFrom(const ReqSeeMemberList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqSeeMemberList::IsInitialized() const {

  return true;
}

void ReqSeeMemberList::Swap(ReqSeeMemberList* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(page_, other->page_);
    std::swap(clanid_, other->clanid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReqSeeMemberList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReqSeeMemberList_descriptor_;
  metadata.reflection = ReqSeeMemberList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckSeeMemberList::kInfoFieldNumber;
const int AckSeeMemberList::kClanNameFieldNumber;
const int AckSeeMemberList::kClanlevelFieldNumber;
#endif  // !_MSC_VER

AckSeeMemberList::AckSeeMemberList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckSeeMemberList::InitAsDefaultInstance() {
  info_ = const_cast< ::ClanPackage::AckMemberList*>(&::ClanPackage::AckMemberList::default_instance());
}

AckSeeMemberList::AckSeeMemberList(const AckSeeMemberList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckSeeMemberList::SharedCtor() {
  _cached_size_ = 0;
  info_ = NULL;
  clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  clanlevel_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckSeeMemberList::~AckSeeMemberList() {
  SharedDtor();
}

void AckSeeMemberList::SharedDtor() {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    delete clanname_;
  }
  if (this != default_instance_) {
    delete info_;
  }
}

void AckSeeMemberList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckSeeMemberList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckSeeMemberList_descriptor_;
}

const AckSeeMemberList& AckSeeMemberList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckSeeMemberList* AckSeeMemberList::default_instance_ = NULL;

AckSeeMemberList* AckSeeMemberList::New() const {
  return new AckSeeMemberList;
}

void AckSeeMemberList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_info()) {
      if (info_ != NULL) info_->::ClanPackage::AckMemberList::Clear();
    }
    if (has_clanname()) {
      if (clanname_ != &::google::protobuf::internal::kEmptyString) {
        clanname_->clear();
      }
    }
    clanlevel_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckSeeMemberList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ClanPackage.AckMemberList info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_clanName;
        break;
      }

      // optional bytes clanName = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_clanName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_clanname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_clanlevel;
        break;
      }

      // optional int32 clanlevel = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_clanlevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &clanlevel_)));
          set_has_clanlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckSeeMemberList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ClanPackage.AckMemberList info = 1;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->info(), output);
  }

  // optional bytes clanName = 2;
  if (has_clanname()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->clanname(), output);
  }

  // optional int32 clanlevel = 3;
  if (has_clanlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->clanlevel(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckSeeMemberList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .ClanPackage.AckMemberList info = 1;
  if (has_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->info(), target);
  }

  // optional bytes clanName = 2;
  if (has_clanname()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->clanname(), target);
  }

  // optional int32 clanlevel = 3;
  if (has_clanlevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->clanlevel(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckSeeMemberList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ClanPackage.AckMemberList info = 1;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

    // optional bytes clanName = 2;
    if (has_clanname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->clanname());
    }

    // optional int32 clanlevel = 3;
    if (has_clanlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->clanlevel());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckSeeMemberList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckSeeMemberList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckSeeMemberList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckSeeMemberList::MergeFrom(const AckSeeMemberList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_info()) {
      mutable_info()->::ClanPackage::AckMemberList::MergeFrom(from.info());
    }
    if (from.has_clanname()) {
      set_clanname(from.clanname());
    }
    if (from.has_clanlevel()) {
      set_clanlevel(from.clanlevel());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckSeeMemberList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckSeeMemberList::CopyFrom(const AckSeeMemberList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckSeeMemberList::IsInitialized() const {

  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  return true;
}

void AckSeeMemberList::Swap(AckSeeMemberList* other) {
  if (other != this) {
    std::swap(info_, other->info_);
    std::swap(clanname_, other->clanname_);
    std::swap(clanlevel_, other->clanlevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckSeeMemberList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckSeeMemberList_descriptor_;
  metadata.reflection = AckSeeMemberList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqClanEvent::kPageFieldNumber;
#endif  // !_MSC_VER

ClientReqClanEvent::ClientReqClanEvent()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqClanEvent::InitAsDefaultInstance() {
}

ClientReqClanEvent::ClientReqClanEvent(const ClientReqClanEvent& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqClanEvent::SharedCtor() {
  _cached_size_ = 0;
  page_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqClanEvent::~ClientReqClanEvent() {
  SharedDtor();
}

void ClientReqClanEvent::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqClanEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqClanEvent::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqClanEvent_descriptor_;
}

const ClientReqClanEvent& ClientReqClanEvent::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqClanEvent* ClientReqClanEvent::default_instance_ = NULL;

ClientReqClanEvent* ClientReqClanEvent::New() const {
  return new ClientReqClanEvent;
}

void ClientReqClanEvent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    page_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqClanEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 page = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &page_)));
          set_has_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqClanEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 page = 1;
  if (has_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->page(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqClanEvent::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 page = 1;
  if (has_page()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->page(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqClanEvent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 page = 1;
    if (has_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->page());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqClanEvent::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqClanEvent* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqClanEvent*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqClanEvent::MergeFrom(const ClientReqClanEvent& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_page()) {
      set_page(from.page());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqClanEvent::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqClanEvent::CopyFrom(const ClientReqClanEvent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqClanEvent::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqClanEvent::Swap(ClientReqClanEvent* other) {
  if (other != this) {
    std::swap(page_, other->page_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqClanEvent::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqClanEvent_descriptor_;
  metadata.reflection = ClientReqClanEvent_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckClanEvent::kTypeFieldNumber;
const int AckClanEvent::kContentFieldNumber;
#endif  // !_MSC_VER

AckClanEvent::AckClanEvent()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckClanEvent::InitAsDefaultInstance() {
}

AckClanEvent::AckClanEvent(const AckClanEvent& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckClanEvent::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckClanEvent::~AckClanEvent() {
  SharedDtor();
}

void AckClanEvent::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckClanEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckClanEvent::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckClanEvent_descriptor_;
}

const AckClanEvent& AckClanEvent::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckClanEvent* AckClanEvent::default_instance_ = NULL;

AckClanEvent* AckClanEvent::New() const {
  return new AckClanEvent;
}

void AckClanEvent::Clear() {
  type_.Clear();
  content_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckClanEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_type())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_type())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_type;
        if (input->ExpectTag(18)) goto parse_content;
        break;
      }

      // repeated bytes content = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_content()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_content;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckClanEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int32 type = 1;
  for (int i = 0; i < this->type_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->type(i), output);
  }

  // repeated bytes content = 2;
  for (int i = 0; i < this->content_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->content(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckClanEvent::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated int32 type = 1;
  for (int i = 0; i < this->type_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(1, this->type(i), target);
  }

  // repeated bytes content = 2;
  for (int i = 0; i < this->content_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(2, this->content(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckClanEvent::ByteSize() const {
  int total_size = 0;

  // repeated int32 type = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->type_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->type(i));
    }
    total_size += 1 * this->type_size() + data_size;
  }

  // repeated bytes content = 2;
  total_size += 1 * this->content_size();
  for (int i = 0; i < this->content_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->content(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckClanEvent::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckClanEvent* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckClanEvent*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckClanEvent::MergeFrom(const AckClanEvent& from) {
  GOOGLE_CHECK_NE(&from, this);
  type_.MergeFrom(from.type_);
  content_.MergeFrom(from.content_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckClanEvent::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckClanEvent::CopyFrom(const AckClanEvent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckClanEvent::IsInitialized() const {

  return true;
}

void AckClanEvent::Swap(AckClanEvent* other) {
  if (other != this) {
    type_.Swap(&other->type_);
    content_.Swap(&other->content_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckClanEvent::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckClanEvent_descriptor_;
  metadata.reflection = AckClanEvent_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int JoinClan::kTimeFieldNumber;
const int JoinClan::kNameFieldNumber;
#endif  // !_MSC_VER

JoinClan::JoinClan()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void JoinClan::InitAsDefaultInstance() {
}

JoinClan::JoinClan(const JoinClan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void JoinClan::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JoinClan::~JoinClan() {
  SharedDtor();
}

void JoinClan::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void JoinClan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* JoinClan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return JoinClan_descriptor_;
}

const JoinClan& JoinClan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

JoinClan* JoinClan::default_instance_ = NULL;

JoinClan* JoinClan::New() const {
  return new JoinClan;
}

void JoinClan::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool JoinClan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void JoinClan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->time(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* JoinClan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double time = 1;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->time(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int JoinClan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double time = 1;
    if (has_time()) {
      total_size += 1 + 8;
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JoinClan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const JoinClan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const JoinClan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void JoinClan::MergeFrom(const JoinClan& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void JoinClan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JoinClan::CopyFrom(const JoinClan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinClan::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void JoinClan::Swap(JoinClan* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata JoinClan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = JoinClan_descriptor_;
  metadata.reflection = JoinClan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LeaveClan::kTimeFieldNumber;
const int LeaveClan::kNameFieldNumber;
#endif  // !_MSC_VER

LeaveClan::LeaveClan()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LeaveClan::InitAsDefaultInstance() {
}

LeaveClan::LeaveClan(const LeaveClan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LeaveClan::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LeaveClan::~LeaveClan() {
  SharedDtor();
}

void LeaveClan::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void LeaveClan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LeaveClan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LeaveClan_descriptor_;
}

const LeaveClan& LeaveClan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

LeaveClan* LeaveClan::default_instance_ = NULL;

LeaveClan* LeaveClan::New() const {
  return new LeaveClan;
}

void LeaveClan::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LeaveClan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LeaveClan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->time(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LeaveClan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double time = 1;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->time(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LeaveClan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double time = 1;
    if (has_time()) {
      total_size += 1 + 8;
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LeaveClan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LeaveClan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LeaveClan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LeaveClan::MergeFrom(const LeaveClan& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LeaveClan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LeaveClan::CopyFrom(const LeaveClan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LeaveClan::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void LeaveClan::Swap(LeaveClan* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LeaveClan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LeaveClan_descriptor_;
  metadata.reflection = LeaveClan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClanMemberKilled::kTimeFieldNumber;
const int ClanMemberKilled::kNameFieldNumber;
const int ClanMemberKilled::kMapidFieldNumber;
const int ClanMemberKilled::kKillerFieldNumber;
#endif  // !_MSC_VER

ClanMemberKilled::ClanMemberKilled()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClanMemberKilled::InitAsDefaultInstance() {
}

ClanMemberKilled::ClanMemberKilled(const ClanMemberKilled& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClanMemberKilled::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mapid_ = 0;
  killer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClanMemberKilled::~ClanMemberKilled() {
  SharedDtor();
}

void ClanMemberKilled::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (killer_ != &::google::protobuf::internal::kEmptyString) {
    delete killer_;
  }
  if (this != default_instance_) {
  }
}

void ClanMemberKilled::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClanMemberKilled::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClanMemberKilled_descriptor_;
}

const ClanMemberKilled& ClanMemberKilled::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClanMemberKilled* ClanMemberKilled::default_instance_ = NULL;

ClanMemberKilled* ClanMemberKilled::New() const {
  return new ClanMemberKilled;
}

void ClanMemberKilled::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    mapid_ = 0;
    if (has_killer()) {
      if (killer_ != &::google::protobuf::internal::kEmptyString) {
        killer_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClanMemberKilled::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_mapid;
        break;
      }

      // optional int32 mapid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mapid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mapid_)));
          set_has_mapid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_killer;
        break;
      }

      // optional string killer = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_killer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_killer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->killer().data(), this->killer().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClanMemberKilled::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->time(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional int32 mapid = 3;
  if (has_mapid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->mapid(), output);
  }

  // optional string killer = 4;
  if (has_killer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->killer().data(), this->killer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->killer(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClanMemberKilled::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double time = 1;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->time(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional int32 mapid = 3;
  if (has_mapid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->mapid(), target);
  }

  // optional string killer = 4;
  if (has_killer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->killer().data(), this->killer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->killer(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClanMemberKilled::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double time = 1;
    if (has_time()) {
      total_size += 1 + 8;
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 mapid = 3;
    if (has_mapid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mapid());
    }

    // optional string killer = 4;
    if (has_killer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->killer());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClanMemberKilled::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClanMemberKilled* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClanMemberKilled*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClanMemberKilled::MergeFrom(const ClanMemberKilled& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_mapid()) {
      set_mapid(from.mapid());
    }
    if (from.has_killer()) {
      set_killer(from.killer());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClanMemberKilled::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClanMemberKilled::CopyFrom(const ClanMemberKilled& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClanMemberKilled::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClanMemberKilled::Swap(ClanMemberKilled* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(name_, other->name_);
    std::swap(mapid_, other->mapid_);
    std::swap(killer_, other->killer_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClanMemberKilled::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClanMemberKilled_descriptor_;
  metadata.reflection = ClanMemberKilled_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SynchClanEventToWS::kCharidFieldNumber;
const int SynchClanEventToWS::kTimeFieldNumber;
const int SynchClanEventToWS::kKillerFieldNumber;
#endif  // !_MSC_VER

SynchClanEventToWS::SynchClanEventToWS()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SynchClanEventToWS::InitAsDefaultInstance() {
}

SynchClanEventToWS::SynchClanEventToWS(const SynchClanEventToWS& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SynchClanEventToWS::SharedCtor() {
  _cached_size_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  time_ = 0;
  killer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SynchClanEventToWS::~SynchClanEventToWS() {
  SharedDtor();
}

void SynchClanEventToWS::SharedDtor() {
  if (killer_ != &::google::protobuf::internal::kEmptyString) {
    delete killer_;
  }
  if (this != default_instance_) {
  }
}

void SynchClanEventToWS::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SynchClanEventToWS::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SynchClanEventToWS_descriptor_;
}

const SynchClanEventToWS& SynchClanEventToWS::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

SynchClanEventToWS* SynchClanEventToWS::default_instance_ = NULL;

SynchClanEventToWS* SynchClanEventToWS::New() const {
  return new SynchClanEventToWS;
}

void SynchClanEventToWS::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = GOOGLE_LONGLONG(0);
    time_ = 0;
    if (has_killer()) {
      if (killer_ != &::google::protobuf::internal::kEmptyString) {
        killer_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SynchClanEventToWS::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_time;
        break;
      }

      // required double time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_killer;
        break;
      }

      // optional string killer = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_killer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_killer()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->killer().data(), this->killer().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SynchClanEventToWS::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->charid(), output);
  }

  // required double time = 2;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->time(), output);
  }

  // optional string killer = 3;
  if (has_killer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->killer().data(), this->killer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->killer(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SynchClanEventToWS::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 charid = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->charid(), target);
  }

  // required double time = 2;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->time(), target);
  }

  // optional string killer = 3;
  if (has_killer()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->killer().data(), this->killer().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->killer(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SynchClanEventToWS::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

    // required double time = 2;
    if (has_time()) {
      total_size += 1 + 8;
    }

    // optional string killer = 3;
    if (has_killer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->killer());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SynchClanEventToWS::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SynchClanEventToWS* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SynchClanEventToWS*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SynchClanEventToWS::MergeFrom(const SynchClanEventToWS& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_killer()) {
      set_killer(from.killer());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SynchClanEventToWS::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SynchClanEventToWS::CopyFrom(const SynchClanEventToWS& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SynchClanEventToWS::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SynchClanEventToWS::Swap(SynchClanEventToWS* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(time_, other->time_);
    std::swap(killer_, other->killer_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SynchClanEventToWS::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SynchClanEventToWS_descriptor_;
  metadata.reflection = SynchClanEventToWS_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MemberContri::kTimeFieldNumber;
const int MemberContri::kNameFieldNumber;
const int MemberContri::kGoldenFieldNumber;
const int MemberContri::kMoneyFieldNumber;
const int MemberContri::kContriFieldNumber;
#endif  // !_MSC_VER

MemberContri::MemberContri()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MemberContri::InitAsDefaultInstance() {
}

MemberContri::MemberContri(const MemberContri& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MemberContri::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  golden_ = 0;
  money_ = 0;
  contri_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MemberContri::~MemberContri() {
  SharedDtor();
}

void MemberContri::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void MemberContri::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MemberContri::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MemberContri_descriptor_;
}

const MemberContri& MemberContri::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

MemberContri* MemberContri::default_instance_ = NULL;

MemberContri* MemberContri::New() const {
  return new MemberContri;
}

void MemberContri::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    golden_ = 0;
    money_ = 0;
    contri_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MemberContri::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_golden;
        break;
      }

      // optional int32 golden = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_golden:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &golden_)));
          set_has_golden();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_money;
        break;
      }

      // optional int32 money = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_contri;
        break;
      }

      // optional int32 contri = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_contri:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &contri_)));
          set_has_contri();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MemberContri::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->time(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional int32 golden = 3;
  if (has_golden()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->golden(), output);
  }

  // optional int32 money = 4;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->money(), output);
  }

  // optional int32 contri = 5;
  if (has_contri()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->contri(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MemberContri::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double time = 1;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->time(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional int32 golden = 3;
  if (has_golden()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->golden(), target);
  }

  // optional int32 money = 4;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->money(), target);
  }

  // optional int32 contri = 5;
  if (has_contri()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->contri(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MemberContri::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double time = 1;
    if (has_time()) {
      total_size += 1 + 8;
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 golden = 3;
    if (has_golden()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->golden());
    }

    // optional int32 money = 4;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

    // optional int32 contri = 5;
    if (has_contri()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->contri());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MemberContri::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MemberContri* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MemberContri*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MemberContri::MergeFrom(const MemberContri& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_golden()) {
      set_golden(from.golden());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
    if (from.has_contri()) {
      set_contri(from.contri());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MemberContri::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MemberContri::CopyFrom(const MemberContri& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MemberContri::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void MemberContri::Swap(MemberContri* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(name_, other->name_);
    std::swap(golden_, other->golden_);
    std::swap(money_, other->money_);
    std::swap(contri_, other->contri_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MemberContri::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MemberContri_descriptor_;
  metadata.reflection = MemberContri_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int JobChange::kTimeFieldNumber;
const int JobChange::kBnameFieldNumber;
const int JobChange::kEnameFieldNumber;
const int JobChange::kJobFieldNumber;
#endif  // !_MSC_VER

JobChange::JobChange()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void JobChange::InitAsDefaultInstance() {
}

JobChange::JobChange(const JobChange& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void JobChange::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  bname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  job_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JobChange::~JobChange() {
  SharedDtor();
}

void JobChange::SharedDtor() {
  if (bname_ != &::google::protobuf::internal::kEmptyString) {
    delete bname_;
  }
  if (ename_ != &::google::protobuf::internal::kEmptyString) {
    delete ename_;
  }
  if (this != default_instance_) {
  }
}

void JobChange::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* JobChange::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return JobChange_descriptor_;
}

const JobChange& JobChange::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

JobChange* JobChange::default_instance_ = NULL;

JobChange* JobChange::New() const {
  return new JobChange;
}

void JobChange::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    if (has_bname()) {
      if (bname_ != &::google::protobuf::internal::kEmptyString) {
        bname_->clear();
      }
    }
    if (has_ename()) {
      if (ename_ != &::google::protobuf::internal::kEmptyString) {
        ename_->clear();
      }
    }
    job_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool JobChange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_bname;
        break;
      }

      // optional string bname = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_bname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->bname().data(), this->bname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ename;
        break;
      }

      // optional string ename = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ename:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->ename().data(), this->ename().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_job;
        break;
      }

      // optional int32 job = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &job_)));
          set_has_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void JobChange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->time(), output);
  }

  // optional string bname = 2;
  if (has_bname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->bname().data(), this->bname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->bname(), output);
  }

  // optional string ename = 3;
  if (has_ename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ename().data(), this->ename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->ename(), output);
  }

  // optional int32 job = 4;
  if (has_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->job(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* JobChange::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double time = 1;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->time(), target);
  }

  // optional string bname = 2;
  if (has_bname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->bname().data(), this->bname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->bname(), target);
  }

  // optional string ename = 3;
  if (has_ename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ename().data(), this->ename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->ename(), target);
  }

  // optional int32 job = 4;
  if (has_job()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->job(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int JobChange::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double time = 1;
    if (has_time()) {
      total_size += 1 + 8;
    }

    // optional string bname = 2;
    if (has_bname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->bname());
    }

    // optional string ename = 3;
    if (has_ename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ename());
    }

    // optional int32 job = 4;
    if (has_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->job());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JobChange::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const JobChange* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const JobChange*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void JobChange::MergeFrom(const JobChange& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_bname()) {
      set_bname(from.bname());
    }
    if (from.has_ename()) {
      set_ename(from.ename());
    }
    if (from.has_job()) {
      set_job(from.job());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void JobChange::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void JobChange::CopyFrom(const JobChange& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JobChange::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void JobChange::Swap(JobChange* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(bname_, other->bname_);
    std::swap(ename_, other->ename_);
    std::swap(job_, other->job_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata JobChange::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = JobChange_descriptor_;
  metadata.reflection = JobChange_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClanUpdate::kTimeFieldNumber;
const int ClanUpdate::kNameFieldNumber;
const int ClanUpdate::kLvFieldNumber;
const int ClanUpdate::kCountFieldNumber;
#endif  // !_MSC_VER

ClanUpdate::ClanUpdate()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClanUpdate::InitAsDefaultInstance() {
}

ClanUpdate::ClanUpdate(const ClanUpdate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClanUpdate::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  lv_ = 0;
  count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClanUpdate::~ClanUpdate() {
  SharedDtor();
}

void ClanUpdate::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void ClanUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClanUpdate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClanUpdate_descriptor_;
}

const ClanUpdate& ClanUpdate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClanUpdate* ClanUpdate::default_instance_ = NULL;

ClanUpdate* ClanUpdate::New() const {
  return new ClanUpdate;
}

void ClanUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    lv_ = 0;
    count_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClanUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_lv;
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lv_)));
          set_has_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_count;
        break;
      }

      // optional int32 count = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClanUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->time(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional int32 lv = 3;
  if (has_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lv(), output);
  }

  // optional int32 count = 4;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->count(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClanUpdate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double time = 1;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->time(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional int32 lv = 3;
  if (has_lv()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lv(), target);
  }

  // optional int32 count = 4;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->count(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClanUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double time = 1;
    if (has_time()) {
      total_size += 1 + 8;
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 lv = 3;
    if (has_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lv());
    }

    // optional int32 count = 4;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClanUpdate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClanUpdate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClanUpdate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClanUpdate::MergeFrom(const ClanUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_lv()) {
      set_lv(from.lv());
    }
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClanUpdate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClanUpdate::CopyFrom(const ClanUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClanUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClanUpdate::Swap(ClanUpdate* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(name_, other->name_);
    std::swap(lv_, other->lv_);
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClanUpdate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClanUpdate_descriptor_;
  metadata.reflection = ClanUpdate_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClanCitryHold::kTimeFieldNumber;
const int ClanCitryHold::kCityidFieldNumber;
const int ClanCitryHold::kClanFieldNumber;
#endif  // !_MSC_VER

ClanCitryHold::ClanCitryHold()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClanCitryHold::InitAsDefaultInstance() {
}

ClanCitryHold::ClanCitryHold(const ClanCitryHold& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClanCitryHold::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  cityid_ = 0;
  clan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClanCitryHold::~ClanCitryHold() {
  SharedDtor();
}

void ClanCitryHold::SharedDtor() {
  if (clan_ != &::google::protobuf::internal::kEmptyString) {
    delete clan_;
  }
  if (this != default_instance_) {
  }
}

void ClanCitryHold::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClanCitryHold::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClanCitryHold_descriptor_;
}

const ClanCitryHold& ClanCitryHold::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClanCitryHold* ClanCitryHold::default_instance_ = NULL;

ClanCitryHold* ClanCitryHold::New() const {
  return new ClanCitryHold;
}

void ClanCitryHold::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    cityid_ = 0;
    if (has_clan()) {
      if (clan_ != &::google::protobuf::internal::kEmptyString) {
        clan_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClanCitryHold::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_cityid;
        break;
      }

      // optional int32 cityid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cityid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cityid_)));
          set_has_cityid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_clan;
        break;
      }

      // optional string clan = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_clan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_clan()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->clan().data(), this->clan().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClanCitryHold::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->time(), output);
  }

  // optional int32 cityid = 2;
  if (has_cityid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->cityid(), output);
  }

  // optional string clan = 3;
  if (has_clan()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->clan().data(), this->clan().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->clan(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClanCitryHold::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double time = 1;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->time(), target);
  }

  // optional int32 cityid = 2;
  if (has_cityid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->cityid(), target);
  }

  // optional string clan = 3;
  if (has_clan()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->clan().data(), this->clan().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->clan(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClanCitryHold::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double time = 1;
    if (has_time()) {
      total_size += 1 + 8;
    }

    // optional int32 cityid = 2;
    if (has_cityid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cityid());
    }

    // optional string clan = 3;
    if (has_clan()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->clan());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClanCitryHold::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClanCitryHold* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClanCitryHold*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClanCitryHold::MergeFrom(const ClanCitryHold& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_cityid()) {
      set_cityid(from.cityid());
    }
    if (from.has_clan()) {
      set_clan(from.clan());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClanCitryHold::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClanCitryHold::CopyFrom(const ClanCitryHold& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClanCitryHold::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClanCitryHold::Swap(ClanCitryHold* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(cityid_, other->cityid_);
    std::swap(clan_, other->clan_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClanCitryHold::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClanCitryHold_descriptor_;
  metadata.reflection = ClanCitryHold_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClanPaidEvent::kTimeFieldNumber;
const int ClanPaidEvent::kIdFieldNumber;
const int ClanPaidEvent::kMoneyFieldNumber;
#endif  // !_MSC_VER

ClanPaidEvent::ClanPaidEvent()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClanPaidEvent::InitAsDefaultInstance() {
}

ClanPaidEvent::ClanPaidEvent(const ClanPaidEvent& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClanPaidEvent::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0;
  id_ = 0;
  money_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClanPaidEvent::~ClanPaidEvent() {
  SharedDtor();
}

void ClanPaidEvent::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClanPaidEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClanPaidEvent::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClanPaidEvent_descriptor_;
}

const ClanPaidEvent& ClanPaidEvent::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClanPaidEvent* ClanPaidEvent::default_instance_ = NULL;

ClanPaidEvent* ClanPaidEvent::New() const {
  return new ClanPaidEvent;
}

void ClanPaidEvent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_ = 0;
    id_ = 0;
    money_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClanPaidEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double time = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }

      // optional int32 id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_money;
        break;
      }

      // optional int32 money = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClanPaidEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->time(), output);
  }

  // optional int32 id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->id(), output);
  }

  // optional int32 money = 3;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->money(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClanPaidEvent::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double time = 1;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->time(), target);
  }

  // optional int32 id = 2;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->id(), target);
  }

  // optional int32 money = 3;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->money(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClanPaidEvent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double time = 1;
    if (has_time()) {
      total_size += 1 + 8;
    }

    // optional int32 id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 money = 3;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClanPaidEvent::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClanPaidEvent* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClanPaidEvent*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClanPaidEvent::MergeFrom(const ClanPaidEvent& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClanPaidEvent::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClanPaidEvent::CopyFrom(const ClanPaidEvent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClanPaidEvent::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClanPaidEvent::Swap(ClanPaidEvent* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(id_, other->id_);
    std::swap(money_, other->money_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClanPaidEvent::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClanPaidEvent_descriptor_;
  metadata.reflection = ClanPaidEvent_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqClanRequestList::kPageFieldNumber;
#endif  // !_MSC_VER

ClientReqClanRequestList::ClientReqClanRequestList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqClanRequestList::InitAsDefaultInstance() {
}

ClientReqClanRequestList::ClientReqClanRequestList(const ClientReqClanRequestList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqClanRequestList::SharedCtor() {
  _cached_size_ = 0;
  page_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqClanRequestList::~ClientReqClanRequestList() {
  SharedDtor();
}

void ClientReqClanRequestList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqClanRequestList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqClanRequestList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqClanRequestList_descriptor_;
}

const ClientReqClanRequestList& ClientReqClanRequestList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqClanRequestList* ClientReqClanRequestList::default_instance_ = NULL;

ClientReqClanRequestList* ClientReqClanRequestList::New() const {
  return new ClientReqClanRequestList;
}

void ClientReqClanRequestList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    page_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqClanRequestList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 page = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &page_)));
          set_has_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqClanRequestList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 page = 1;
  if (has_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->page(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqClanRequestList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 page = 1;
  if (has_page()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->page(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqClanRequestList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 page = 1;
    if (has_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->page());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqClanRequestList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqClanRequestList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqClanRequestList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqClanRequestList::MergeFrom(const ClientReqClanRequestList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_page()) {
      set_page(from.page());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqClanRequestList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqClanRequestList::CopyFrom(const ClientReqClanRequestList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqClanRequestList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqClanRequestList::Swap(ClientReqClanRequestList* other) {
  if (other != this) {
    std::swap(page_, other->page_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqClanRequestList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqClanRequestList_descriptor_;
  metadata.reflection = ClientReqClanRequestList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckClanRequestList::kListFieldNumber;
const int AckClanRequestList::kIsendFieldNumber;
#endif  // !_MSC_VER

AckClanRequestList::AckClanRequestList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckClanRequestList::InitAsDefaultInstance() {
}

AckClanRequestList::AckClanRequestList(const AckClanRequestList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckClanRequestList::SharedCtor() {
  _cached_size_ = 0;
  isend_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckClanRequestList::~AckClanRequestList() {
  SharedDtor();
}

void AckClanRequestList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckClanRequestList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckClanRequestList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckClanRequestList_descriptor_;
}

const AckClanRequestList& AckClanRequestList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckClanRequestList* AckClanRequestList::default_instance_ = NULL;

AckClanRequestList* AckClanRequestList::New() const {
  return new AckClanRequestList;
}

void AckClanRequestList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    isend_ = false;
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckClanRequestList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ClanPackage.ClanRequestList list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_list;
        if (input->ExpectTag(24)) goto parse_isend;
        break;
      }

      // optional bool isend = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isend:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isend_)));
          set_has_isend();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckClanRequestList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ClanPackage.ClanRequestList list = 2;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->list(i), output);
  }

  // optional bool isend = 3;
  if (has_isend()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->isend(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckClanRequestList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ClanPackage.ClanRequestList list = 2;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->list(i), target);
  }

  // optional bool isend = 3;
  if (has_isend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->isend(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckClanRequestList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bool isend = 3;
    if (has_isend()) {
      total_size += 1 + 1;
    }

  }
  // repeated .ClanPackage.ClanRequestList list = 2;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckClanRequestList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckClanRequestList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckClanRequestList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckClanRequestList::MergeFrom(const AckClanRequestList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_isend()) {
      set_isend(from.isend());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckClanRequestList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckClanRequestList::CopyFrom(const AckClanRequestList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckClanRequestList::IsInitialized() const {

  for (int i = 0; i < list_size(); i++) {
    if (!this->list(i).IsInitialized()) return false;
  }
  return true;
}

void AckClanRequestList::Swap(AckClanRequestList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(isend_, other->isend_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckClanRequestList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckClanRequestList_descriptor_;
  metadata.reflection = AckClanRequestList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClanRequestList::kCharidFieldNumber;
const int ClanRequestList::kNameFieldNumber;
const int ClanRequestList::kLvFieldNumber;
const int ClanRequestList::kProfessionFieldNumber;
const int ClanRequestList::kFightFieldNumber;
const int ClanRequestList::kVipFieldNumber;
const int ClanRequestList::kSexFieldNumber;
#endif  // !_MSC_VER

ClanRequestList::ClanRequestList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClanRequestList::InitAsDefaultInstance() {
}

ClanRequestList::ClanRequestList(const ClanRequestList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClanRequestList::SharedCtor() {
  _cached_size_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  lv_ = 0;
  profession_ = 0;
  fight_ = 0;
  vip_ = 0;
  sex_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClanRequestList::~ClanRequestList() {
  SharedDtor();
}

void ClanRequestList::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void ClanRequestList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClanRequestList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClanRequestList_descriptor_;
}

const ClanRequestList& ClanRequestList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClanRequestList* ClanRequestList::default_instance_ = NULL;

ClanRequestList* ClanRequestList::New() const {
  return new ClanRequestList;
}

void ClanRequestList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = GOOGLE_LONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    lv_ = 0;
    profession_ = 0;
    fight_ = 0;
    vip_ = 0;
    sex_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClanRequestList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_lv;
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lv_)));
          set_has_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_profession;
        break;
      }

      // optional int32 profession = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_profession:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &profession_)));
          set_has_profession();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_fight;
        break;
      }

      // optional int32 fight = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fight_)));
          set_has_fight();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_vip;
        break;
      }

      // optional int32 vip = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_vip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &vip_)));
          set_has_vip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_sex;
        break;
      }

      // optional int32 sex = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sex_)));
          set_has_sex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClanRequestList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->charid(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional int32 lv = 3;
  if (has_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lv(), output);
  }

  // optional int32 profession = 4;
  if (has_profession()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->profession(), output);
  }

  // optional int32 fight = 5;
  if (has_fight()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->fight(), output);
  }

  // optional int32 vip = 6;
  if (has_vip()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->vip(), output);
  }

  // optional int32 sex = 7;
  if (has_sex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->sex(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClanRequestList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 charid = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->charid(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional int32 lv = 3;
  if (has_lv()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lv(), target);
  }

  // optional int32 profession = 4;
  if (has_profession()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->profession(), target);
  }

  // optional int32 fight = 5;
  if (has_fight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->fight(), target);
  }

  // optional int32 vip = 6;
  if (has_vip()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->vip(), target);
  }

  // optional int32 sex = 7;
  if (has_sex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->sex(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClanRequestList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 lv = 3;
    if (has_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lv());
    }

    // optional int32 profession = 4;
    if (has_profession()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->profession());
    }

    // optional int32 fight = 5;
    if (has_fight()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fight());
    }

    // optional int32 vip = 6;
    if (has_vip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->vip());
    }

    // optional int32 sex = 7;
    if (has_sex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sex());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClanRequestList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClanRequestList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClanRequestList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClanRequestList::MergeFrom(const ClanRequestList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_lv()) {
      set_lv(from.lv());
    }
    if (from.has_profession()) {
      set_profession(from.profession());
    }
    if (from.has_fight()) {
      set_fight(from.fight());
    }
    if (from.has_vip()) {
      set_vip(from.vip());
    }
    if (from.has_sex()) {
      set_sex(from.sex());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClanRequestList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClanRequestList::CopyFrom(const ClanRequestList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClanRequestList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClanRequestList::Swap(ClanRequestList* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(name_, other->name_);
    std::swap(lv_, other->lv_);
    std::swap(profession_, other->profession_);
    std::swap(fight_, other->fight_);
    std::swap(vip_, other->vip_);
    std::swap(sex_, other->sex_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClanRequestList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClanRequestList_descriptor_;
  metadata.reflection = ClanRequestList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqClanContriList::kPageFieldNumber;
#endif  // !_MSC_VER

ClientReqClanContriList::ClientReqClanContriList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqClanContriList::InitAsDefaultInstance() {
}

ClientReqClanContriList::ClientReqClanContriList(const ClientReqClanContriList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqClanContriList::SharedCtor() {
  _cached_size_ = 0;
  page_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqClanContriList::~ClientReqClanContriList() {
  SharedDtor();
}

void ClientReqClanContriList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqClanContriList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqClanContriList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqClanContriList_descriptor_;
}

const ClientReqClanContriList& ClientReqClanContriList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqClanContriList* ClientReqClanContriList::default_instance_ = NULL;

ClientReqClanContriList* ClientReqClanContriList::New() const {
  return new ClientReqClanContriList;
}

void ClientReqClanContriList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    page_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqClanContriList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 page = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &page_)));
          set_has_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqClanContriList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 page = 1;
  if (has_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->page(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqClanContriList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 page = 1;
  if (has_page()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->page(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqClanContriList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 page = 1;
    if (has_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->page());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqClanContriList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqClanContriList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqClanContriList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqClanContriList::MergeFrom(const ClientReqClanContriList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_page()) {
      set_page(from.page());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqClanContriList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqClanContriList::CopyFrom(const ClientReqClanContriList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqClanContriList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqClanContriList::Swap(ClientReqClanContriList* other) {
  if (other != this) {
    std::swap(page_, other->page_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqClanContriList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqClanContriList_descriptor_;
  metadata.reflection = ClientReqClanContriList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckClanContriList::kListFieldNumber;
const int AckClanContriList::kIsendFieldNumber;
#endif  // !_MSC_VER

AckClanContriList::AckClanContriList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckClanContriList::InitAsDefaultInstance() {
}

AckClanContriList::AckClanContriList(const AckClanContriList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckClanContriList::SharedCtor() {
  _cached_size_ = 0;
  isend_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckClanContriList::~AckClanContriList() {
  SharedDtor();
}

void AckClanContriList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckClanContriList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckClanContriList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckClanContriList_descriptor_;
}

const AckClanContriList& AckClanContriList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckClanContriList* AckClanContriList::default_instance_ = NULL;

AckClanContriList* AckClanContriList::New() const {
  return new AckClanContriList;
}

void AckClanContriList::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    isend_ = false;
  }
  list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckClanContriList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ClanPackage.ClanContriList list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_list;
        if (input->ExpectTag(16)) goto parse_isend;
        break;
      }

      // optional bool isend = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isend:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isend_)));
          set_has_isend();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckClanContriList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ClanPackage.ClanContriList list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->list(i), output);
  }

  // optional bool isend = 2;
  if (has_isend()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->isend(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckClanContriList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ClanPackage.ClanContriList list = 1;
  for (int i = 0; i < this->list_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->list(i), target);
  }

  // optional bool isend = 2;
  if (has_isend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->isend(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckClanContriList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bool isend = 2;
    if (has_isend()) {
      total_size += 1 + 1;
    }

  }
  // repeated .ClanPackage.ClanContriList list = 1;
  total_size += 1 * this->list_size();
  for (int i = 0; i < this->list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->list(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckClanContriList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckClanContriList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckClanContriList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckClanContriList::MergeFrom(const AckClanContriList& from) {
  GOOGLE_CHECK_NE(&from, this);
  list_.MergeFrom(from.list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_isend()) {
      set_isend(from.isend());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckClanContriList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckClanContriList::CopyFrom(const AckClanContriList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckClanContriList::IsInitialized() const {

  for (int i = 0; i < list_size(); i++) {
    if (!this->list(i).IsInitialized()) return false;
  }
  return true;
}

void AckClanContriList::Swap(AckClanContriList* other) {
  if (other != this) {
    list_.Swap(&other->list_);
    std::swap(isend_, other->isend_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckClanContriList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckClanContriList_descriptor_;
  metadata.reflection = AckClanContriList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClanContriList::kCharidFieldNumber;
const int ClanContriList::kNameFieldNumber;
const int ClanContriList::kLvFieldNumber;
const int ClanContriList::kMoneyFieldNumber;
const int ClanContriList::kGoldenFieldNumber;
const int ClanContriList::kContriFieldNumber;
const int ClanContriList::kContrimaxFieldNumber;
const int ClanContriList::kViplvFieldNumber;
#endif  // !_MSC_VER

ClanContriList::ClanContriList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClanContriList::InitAsDefaultInstance() {
}

ClanContriList::ClanContriList(const ClanContriList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClanContriList::SharedCtor() {
  _cached_size_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  lv_ = 0;
  money_ = 0;
  golden_ = 0;
  contri_ = 0;
  contrimax_ = 0;
  viplv_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClanContriList::~ClanContriList() {
  SharedDtor();
}

void ClanContriList::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void ClanContriList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClanContriList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClanContriList_descriptor_;
}

const ClanContriList& ClanContriList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClanContriList* ClanContriList::default_instance_ = NULL;

ClanContriList* ClanContriList::New() const {
  return new ClanContriList;
}

void ClanContriList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = GOOGLE_LONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    lv_ = 0;
    money_ = 0;
    golden_ = 0;
    contri_ = 0;
    contrimax_ = 0;
    viplv_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClanContriList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_lv;
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lv_)));
          set_has_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_money;
        break;
      }

      // optional int32 money = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_golden;
        break;
      }

      // optional int32 golden = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_golden:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &golden_)));
          set_has_golden();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_contri;
        break;
      }

      // optional int32 contri = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_contri:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &contri_)));
          set_has_contri();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_contrimax;
        break;
      }

      // optional int32 contrimax = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_contrimax:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &contrimax_)));
          set_has_contrimax();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_viplv;
        break;
      }

      // optional int32 viplv = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_viplv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &viplv_)));
          set_has_viplv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClanContriList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->charid(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional int32 lv = 3;
  if (has_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lv(), output);
  }

  // optional int32 money = 4;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->money(), output);
  }

  // optional int32 golden = 5;
  if (has_golden()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->golden(), output);
  }

  // optional int32 contri = 6;
  if (has_contri()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->contri(), output);
  }

  // optional int32 contrimax = 7;
  if (has_contrimax()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->contrimax(), output);
  }

  // optional int32 viplv = 8;
  if (has_viplv()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->viplv(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClanContriList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 charid = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->charid(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional int32 lv = 3;
  if (has_lv()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->lv(), target);
  }

  // optional int32 money = 4;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->money(), target);
  }

  // optional int32 golden = 5;
  if (has_golden()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->golden(), target);
  }

  // optional int32 contri = 6;
  if (has_contri()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->contri(), target);
  }

  // optional int32 contrimax = 7;
  if (has_contrimax()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->contrimax(), target);
  }

  // optional int32 viplv = 8;
  if (has_viplv()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->viplv(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClanContriList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 lv = 3;
    if (has_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lv());
    }

    // optional int32 money = 4;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

    // optional int32 golden = 5;
    if (has_golden()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->golden());
    }

    // optional int32 contri = 6;
    if (has_contri()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->contri());
    }

    // optional int32 contrimax = 7;
    if (has_contrimax()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->contrimax());
    }

    // optional int32 viplv = 8;
    if (has_viplv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->viplv());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClanContriList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClanContriList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClanContriList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClanContriList::MergeFrom(const ClanContriList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_lv()) {
      set_lv(from.lv());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
    if (from.has_golden()) {
      set_golden(from.golden());
    }
    if (from.has_contri()) {
      set_contri(from.contri());
    }
    if (from.has_contrimax()) {
      set_contrimax(from.contrimax());
    }
    if (from.has_viplv()) {
      set_viplv(from.viplv());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClanContriList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClanContriList::CopyFrom(const ClanContriList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClanContriList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClanContriList::Swap(ClanContriList* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(name_, other->name_);
    std::swap(lv_, other->lv_);
    std::swap(money_, other->money_);
    std::swap(golden_, other->golden_);
    std::swap(contri_, other->contri_);
    std::swap(contrimax_, other->contrimax_);
    std::swap(viplv_, other->viplv_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClanContriList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClanContriList_descriptor_;
  metadata.reflection = ClanContriList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqJoinClan::kIdFieldNumber;
#endif  // !_MSC_VER

ClientReqJoinClan::ClientReqJoinClan()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqJoinClan::InitAsDefaultInstance() {
}

ClientReqJoinClan::ClientReqJoinClan(const ClientReqJoinClan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqJoinClan::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqJoinClan::~ClientReqJoinClan() {
  SharedDtor();
}

void ClientReqJoinClan::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqJoinClan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqJoinClan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqJoinClan_descriptor_;
}

const ClientReqJoinClan& ClientReqJoinClan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqJoinClan* ClientReqJoinClan::default_instance_ = NULL;

ClientReqJoinClan* ClientReqJoinClan::New() const {
  return new ClientReqJoinClan;
}

void ClientReqJoinClan::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqJoinClan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqJoinClan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqJoinClan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqJoinClan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqJoinClan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqJoinClan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqJoinClan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqJoinClan::MergeFrom(const ClientReqJoinClan& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqJoinClan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqJoinClan::CopyFrom(const ClientReqJoinClan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqJoinClan::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqJoinClan::Swap(ClientReqJoinClan* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqJoinClan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqJoinClan_descriptor_;
  metadata.reflection = ClientReqJoinClan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckJoinClan::kRetFieldNumber;
const int AckJoinClan::kClanIDFieldNumber;
const int AckJoinClan::kInfoFieldNumber;
#endif  // !_MSC_VER

AckJoinClan::AckJoinClan()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckJoinClan::InitAsDefaultInstance() {
  info_ = const_cast< ::ClanPackage::AckClanBase*>(&::ClanPackage::AckClanBase::default_instance());
}

AckJoinClan::AckJoinClan(const AckJoinClan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckJoinClan::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  clanid_ = 0;
  info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckJoinClan::~AckJoinClan() {
  SharedDtor();
}

void AckJoinClan::SharedDtor() {
  if (this != default_instance_) {
    delete info_;
  }
}

void AckJoinClan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckJoinClan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckJoinClan_descriptor_;
}

const AckJoinClan& AckJoinClan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckJoinClan* AckJoinClan::default_instance_ = NULL;

AckJoinClan* AckJoinClan::New() const {
  return new AckJoinClan;
}

void AckJoinClan::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
    clanid_ = 0;
    if (has_info()) {
      if (info_ != NULL) info_->::ClanPackage::AckClanBase::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckJoinClan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_clanID;
        break;
      }

      // optional int32 clanID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_clanID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &clanid_)));
          set_has_clanid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_info;
        break;
      }

      // optional .ClanPackage.AckClanBase info = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckJoinClan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  // optional int32 clanID = 2;
  if (has_clanid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->clanid(), output);
  }

  // optional .ClanPackage.AckClanBase info = 3;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckJoinClan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  // optional int32 clanID = 2;
  if (has_clanid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->clanid(), target);
  }

  // optional .ClanPackage.AckClanBase info = 3;
  if (has_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckJoinClan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional int32 clanID = 2;
    if (has_clanid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->clanid());
    }

    // optional .ClanPackage.AckClanBase info = 3;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckJoinClan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckJoinClan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckJoinClan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckJoinClan::MergeFrom(const AckJoinClan& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_clanid()) {
      set_clanid(from.clanid());
    }
    if (from.has_info()) {
      mutable_info()->::ClanPackage::AckClanBase::MergeFrom(from.info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckJoinClan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckJoinClan::CopyFrom(const AckJoinClan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckJoinClan::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  return true;
}

void AckJoinClan::Swap(AckJoinClan* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(clanid_, other->clanid_);
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckJoinClan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckJoinClan_descriptor_;
  metadata.reflection = AckJoinClan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientAlterTitle::kTitleFieldNumber;
#endif  // !_MSC_VER

ClientAlterTitle::ClientAlterTitle()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientAlterTitle::InitAsDefaultInstance() {
}

ClientAlterTitle::ClientAlterTitle(const ClientAlterTitle& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientAlterTitle::SharedCtor() {
  _cached_size_ = 0;
  title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientAlterTitle::~ClientAlterTitle() {
  SharedDtor();
}

void ClientAlterTitle::SharedDtor() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (this != default_instance_) {
  }
}

void ClientAlterTitle::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientAlterTitle::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientAlterTitle_descriptor_;
}

const ClientAlterTitle& ClientAlterTitle::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientAlterTitle* ClientAlterTitle::default_instance_ = NULL;

ClientAlterTitle* ClientAlterTitle::New() const {
  return new ClientAlterTitle;
}

void ClientAlterTitle::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_title()) {
      if (title_ != &::google::protobuf::internal::kEmptyString) {
        title_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientAlterTitle::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string title = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_title()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->title().data(), this->title().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientAlterTitle::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string title = 1;
  if (has_title()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->title().data(), this->title().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->title(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientAlterTitle::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string title = 1;
  if (has_title()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->title().data(), this->title().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->title(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientAlterTitle::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string title = 1;
    if (has_title()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->title());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientAlterTitle::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientAlterTitle* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientAlterTitle*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientAlterTitle::MergeFrom(const ClientAlterTitle& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_title()) {
      set_title(from.title());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientAlterTitle::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientAlterTitle::CopyFrom(const ClientAlterTitle& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientAlterTitle::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientAlterTitle::Swap(ClientAlterTitle* other) {
  if (other != this) {
    std::swap(title_, other->title_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientAlterTitle::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientAlterTitle_descriptor_;
  metadata.reflection = ClientAlterTitle_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqContri::kMoneyFieldNumber;
const int ClientReqContri::kGoldenFieldNumber;
#endif  // !_MSC_VER

ClientReqContri::ClientReqContri()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqContri::InitAsDefaultInstance() {
}

ClientReqContri::ClientReqContri(const ClientReqContri& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqContri::SharedCtor() {
  _cached_size_ = 0;
  money_ = 0;
  golden_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqContri::~ClientReqContri() {
  SharedDtor();
}

void ClientReqContri::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqContri::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqContri::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqContri_descriptor_;
}

const ClientReqContri& ClientReqContri::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqContri* ClientReqContri::default_instance_ = NULL;

ClientReqContri* ClientReqContri::New() const {
  return new ClientReqContri;
}

void ClientReqContri::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    money_ = 0;
    golden_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqContri::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 money = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_golden;
        break;
      }

      // required int32 golden = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_golden:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &golden_)));
          set_has_golden();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqContri::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 money = 1;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->money(), output);
  }

  // required int32 golden = 2;
  if (has_golden()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->golden(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqContri::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 money = 1;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->money(), target);
  }

  // required int32 golden = 2;
  if (has_golden()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->golden(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqContri::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 money = 1;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

    // required int32 golden = 2;
    if (has_golden()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->golden());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqContri::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqContri* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqContri*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqContri::MergeFrom(const ClientReqContri& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_money()) {
      set_money(from.money());
    }
    if (from.has_golden()) {
      set_golden(from.golden());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqContri::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqContri::CopyFrom(const ClientReqContri& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqContri::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ClientReqContri::Swap(ClientReqContri* other) {
  if (other != this) {
    std::swap(money_, other->money_);
    std::swap(golden_, other->golden_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqContri::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqContri_descriptor_;
  metadata.reflection = ClientReqContri_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckContri::kRetFieldNumber;
const int AckContri::kContriFieldNumber;
const int AckContri::kMoneyFieldNumber;
const int AckContri::kGoldenFieldNumber;
#endif  // !_MSC_VER

AckContri::AckContri()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckContri::InitAsDefaultInstance() {
}

AckContri::AckContri(const AckContri& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckContri::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  contri_ = 0;
  money_ = 0;
  golden_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckContri::~AckContri() {
  SharedDtor();
}

void AckContri::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckContri::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckContri::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckContri_descriptor_;
}

const AckContri& AckContri::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckContri* AckContri::default_instance_ = NULL;

AckContri* AckContri::New() const {
  return new AckContri;
}

void AckContri::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
    contri_ = 0;
    money_ = 0;
    golden_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckContri::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_contri;
        break;
      }

      // optional int32 contri = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_contri:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &contri_)));
          set_has_contri();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_money;
        break;
      }

      // optional int32 money = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_golden;
        break;
      }

      // optional int32 golden = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_golden:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &golden_)));
          set_has_golden();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckContri::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  // optional int32 contri = 2;
  if (has_contri()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->contri(), output);
  }

  // optional int32 money = 3;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->money(), output);
  }

  // optional int32 golden = 4;
  if (has_golden()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->golden(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckContri::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  // optional int32 contri = 2;
  if (has_contri()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->contri(), target);
  }

  // optional int32 money = 3;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->money(), target);
  }

  // optional int32 golden = 4;
  if (has_golden()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->golden(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckContri::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional int32 contri = 2;
    if (has_contri()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->contri());
    }

    // optional int32 money = 3;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

    // optional int32 golden = 4;
    if (has_golden()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->golden());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckContri::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckContri* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckContri*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckContri::MergeFrom(const AckContri& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_contri()) {
      set_contri(from.contri());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
    if (from.has_golden()) {
      set_golden(from.golden());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckContri::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckContri::CopyFrom(const AckContri& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckContri::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckContri::Swap(AckContri* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(contri_, other->contri_);
    std::swap(money_, other->money_);
    std::swap(golden_, other->golden_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckContri::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckContri_descriptor_;
  metadata.reflection = AckContri_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckUpdateLv::kRetFieldNumber;
const int AckUpdateLv::kLvFieldNumber;
#endif  // !_MSC_VER

AckUpdateLv::AckUpdateLv()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckUpdateLv::InitAsDefaultInstance() {
}

AckUpdateLv::AckUpdateLv(const AckUpdateLv& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckUpdateLv::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  lv_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckUpdateLv::~AckUpdateLv() {
  SharedDtor();
}

void AckUpdateLv::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckUpdateLv::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckUpdateLv::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckUpdateLv_descriptor_;
}

const AckUpdateLv& AckUpdateLv::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckUpdateLv* AckUpdateLv::default_instance_ = NULL;

AckUpdateLv* AckUpdateLv::New() const {
  return new AckUpdateLv;
}

void AckUpdateLv::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
    lv_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckUpdateLv::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_lv;
        break;
      }

      // optional int32 lv = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lv_)));
          set_has_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckUpdateLv::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  // optional int32 lv = 2;
  if (has_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->lv(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckUpdateLv::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  // optional int32 lv = 2;
  if (has_lv()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->lv(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckUpdateLv::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional int32 lv = 2;
    if (has_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lv());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckUpdateLv::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckUpdateLv* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckUpdateLv*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckUpdateLv::MergeFrom(const AckUpdateLv& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_lv()) {
      set_lv(from.lv());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckUpdateLv::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckUpdateLv::CopyFrom(const AckUpdateLv& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckUpdateLv::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckUpdateLv::Swap(AckUpdateLv* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(lv_, other->lv_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckUpdateLv::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckUpdateLv_descriptor_;
  metadata.reflection = AckUpdateLv_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientChangeIcon::kIconFieldNumber;
#endif  // !_MSC_VER

ClientChangeIcon::ClientChangeIcon()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientChangeIcon::InitAsDefaultInstance() {
}

ClientChangeIcon::ClientChangeIcon(const ClientChangeIcon& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientChangeIcon::SharedCtor() {
  _cached_size_ = 0;
  icon_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientChangeIcon::~ClientChangeIcon() {
  SharedDtor();
}

void ClientChangeIcon::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientChangeIcon::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientChangeIcon::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientChangeIcon_descriptor_;
}

const ClientChangeIcon& ClientChangeIcon::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientChangeIcon* ClientChangeIcon::default_instance_ = NULL;

ClientChangeIcon* ClientChangeIcon::New() const {
  return new ClientChangeIcon;
}

void ClientChangeIcon::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    icon_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientChangeIcon::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 icon = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &icon_)));
          set_has_icon();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientChangeIcon::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 icon = 1;
  if (has_icon()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->icon(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientChangeIcon::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 icon = 1;
  if (has_icon()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->icon(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientChangeIcon::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 icon = 1;
    if (has_icon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->icon());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientChangeIcon::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientChangeIcon* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientChangeIcon*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientChangeIcon::MergeFrom(const ClientChangeIcon& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_icon()) {
      set_icon(from.icon());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientChangeIcon::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientChangeIcon::CopyFrom(const ClientChangeIcon& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientChangeIcon::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientChangeIcon::Swap(ClientChangeIcon* other) {
  if (other != this) {
    std::swap(icon_, other->icon_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientChangeIcon::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientChangeIcon_descriptor_;
  metadata.reflection = ClientChangeIcon_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckClientChangeIcon::kSuccessFieldNumber;
const int AckClientChangeIcon::kIconFieldNumber;
#endif  // !_MSC_VER

AckClientChangeIcon::AckClientChangeIcon()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckClientChangeIcon::InitAsDefaultInstance() {
}

AckClientChangeIcon::AckClientChangeIcon(const AckClientChangeIcon& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckClientChangeIcon::SharedCtor() {
  _cached_size_ = 0;
  success_ = 0;
  icon_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckClientChangeIcon::~AckClientChangeIcon() {
  SharedDtor();
}

void AckClientChangeIcon::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckClientChangeIcon::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckClientChangeIcon::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckClientChangeIcon_descriptor_;
}

const AckClientChangeIcon& AckClientChangeIcon::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckClientChangeIcon* AckClientChangeIcon::default_instance_ = NULL;

AckClientChangeIcon* AckClientChangeIcon::New() const {
  return new AckClientChangeIcon;
}

void AckClientChangeIcon::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    success_ = 0;
    icon_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckClientChangeIcon::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 success = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &success_)));
          set_has_success();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_icon;
        break;
      }

      // optional int32 icon = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_icon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &icon_)));
          set_has_icon();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckClientChangeIcon::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 success = 1;
  if (has_success()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->success(), output);
  }

  // optional int32 icon = 2;
  if (has_icon()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->icon(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckClientChangeIcon::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 success = 1;
  if (has_success()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->success(), target);
  }

  // optional int32 icon = 2;
  if (has_icon()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->icon(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckClientChangeIcon::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 success = 1;
    if (has_success()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->success());
    }

    // optional int32 icon = 2;
    if (has_icon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->icon());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckClientChangeIcon::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckClientChangeIcon* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckClientChangeIcon*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckClientChangeIcon::MergeFrom(const AckClientChangeIcon& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_success()) {
      set_success(from.success());
    }
    if (from.has_icon()) {
      set_icon(from.icon());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckClientChangeIcon::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckClientChangeIcon::CopyFrom(const AckClientChangeIcon& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckClientChangeIcon::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckClientChangeIcon::Swap(AckClientChangeIcon* other) {
  if (other != this) {
    std::swap(success_, other->success_);
    std::swap(icon_, other->icon_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckClientChangeIcon::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckClientChangeIcon_descriptor_;
  metadata.reflection = AckClientChangeIcon_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqGiveJob::kCharidFieldNumber;
const int ClientReqGiveJob::kJobFieldNumber;
#endif  // !_MSC_VER

ClientReqGiveJob::ClientReqGiveJob()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqGiveJob::InitAsDefaultInstance() {
}

ClientReqGiveJob::ClientReqGiveJob(const ClientReqGiveJob& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqGiveJob::SharedCtor() {
  _cached_size_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  job_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqGiveJob::~ClientReqGiveJob() {
  SharedDtor();
}

void ClientReqGiveJob::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqGiveJob::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqGiveJob::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqGiveJob_descriptor_;
}

const ClientReqGiveJob& ClientReqGiveJob::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqGiveJob* ClientReqGiveJob::default_instance_ = NULL;

ClientReqGiveJob* ClientReqGiveJob::New() const {
  return new ClientReqGiveJob;
}

void ClientReqGiveJob::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = GOOGLE_LONGLONG(0);
    job_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqGiveJob::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_job;
        break;
      }

      // optional int32 job = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &job_)));
          set_has_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqGiveJob::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->charid(), output);
  }

  // optional int32 job = 2;
  if (has_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->job(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqGiveJob::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 charid = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->charid(), target);
  }

  // optional int32 job = 2;
  if (has_job()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->job(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqGiveJob::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

    // optional int32 job = 2;
    if (has_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->job());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqGiveJob::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqGiveJob* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqGiveJob*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqGiveJob::MergeFrom(const ClientReqGiveJob& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_job()) {
      set_job(from.job());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqGiveJob::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqGiveJob::CopyFrom(const ClientReqGiveJob& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqGiveJob::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqGiveJob::Swap(ClientReqGiveJob* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(job_, other->job_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqGiveJob::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqGiveJob_descriptor_;
  metadata.reflection = ClientReqGiveJob_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckGiveJob::kRetFieldNumber;
const int AckGiveJob::kJobFieldNumber;
const int AckGiveJob::kCharidFieldNumber;
#endif  // !_MSC_VER

AckGiveJob::AckGiveJob()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckGiveJob::InitAsDefaultInstance() {
}

AckGiveJob::AckGiveJob(const AckGiveJob& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckGiveJob::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  job_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckGiveJob::~AckGiveJob() {
  SharedDtor();
}

void AckGiveJob::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckGiveJob::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckGiveJob::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckGiveJob_descriptor_;
}

const AckGiveJob& AckGiveJob::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckGiveJob* AckGiveJob::default_instance_ = NULL;

AckGiveJob* AckGiveJob::New() const {
  return new AckGiveJob;
}

void AckGiveJob::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
    job_ = 0;
    charid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckGiveJob::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_job;
        break;
      }

      // optional int32 job = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &job_)));
          set_has_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_charid;
        break;
      }

      // optional int64 charid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckGiveJob::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  // optional int32 job = 2;
  if (has_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->job(), output);
  }

  // optional int64 charid = 3;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->charid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckGiveJob::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  // optional int32 job = 2;
  if (has_job()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->job(), target);
  }

  // optional int64 charid = 3;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->charid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckGiveJob::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional int32 job = 2;
    if (has_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->job());
    }

    // optional int64 charid = 3;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckGiveJob::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckGiveJob* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckGiveJob*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckGiveJob::MergeFrom(const AckGiveJob& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_job()) {
      set_job(from.job());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckGiveJob::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckGiveJob::CopyFrom(const AckGiveJob& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckGiveJob::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckGiveJob::Swap(AckGiveJob* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(job_, other->job_);
    std::swap(charid_, other->charid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckGiveJob::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckGiveJob_descriptor_;
  metadata.reflection = AckGiveJob_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqOutJob::kCharidFieldNumber;
#endif  // !_MSC_VER

ClientReqOutJob::ClientReqOutJob()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqOutJob::InitAsDefaultInstance() {
}

ClientReqOutJob::ClientReqOutJob(const ClientReqOutJob& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqOutJob::SharedCtor() {
  _cached_size_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqOutJob::~ClientReqOutJob() {
  SharedDtor();
}

void ClientReqOutJob::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqOutJob::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqOutJob::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqOutJob_descriptor_;
}

const ClientReqOutJob& ClientReqOutJob::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqOutJob* ClientReqOutJob::default_instance_ = NULL;

ClientReqOutJob* ClientReqOutJob::New() const {
  return new ClientReqOutJob;
}

void ClientReqOutJob::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqOutJob::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqOutJob::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->charid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqOutJob::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 charid = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->charid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqOutJob::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqOutJob::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqOutJob* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqOutJob*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqOutJob::MergeFrom(const ClientReqOutJob& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqOutJob::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqOutJob::CopyFrom(const ClientReqOutJob& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqOutJob::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqOutJob::Swap(ClientReqOutJob* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqOutJob::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqOutJob_descriptor_;
  metadata.reflection = ClientReqOutJob_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckOutJob::kRetFieldNumber;
const int AckOutJob::kCharidFieldNumber;
#endif  // !_MSC_VER

AckOutJob::AckOutJob()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckOutJob::InitAsDefaultInstance() {
}

AckOutJob::AckOutJob(const AckOutJob& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckOutJob::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckOutJob::~AckOutJob() {
  SharedDtor();
}

void AckOutJob::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckOutJob::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckOutJob::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckOutJob_descriptor_;
}

const AckOutJob& AckOutJob::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckOutJob* AckOutJob::default_instance_ = NULL;

AckOutJob* AckOutJob::New() const {
  return new AckOutJob;
}

void AckOutJob::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
    charid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckOutJob::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_charid;
        break;
      }

      // optional int64 charid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckOutJob::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  // optional int64 charid = 2;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->charid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckOutJob::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  // optional int64 charid = 2;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->charid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckOutJob::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional int64 charid = 2;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckOutJob::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckOutJob* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckOutJob*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckOutJob::MergeFrom(const AckOutJob& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckOutJob::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckOutJob::CopyFrom(const AckOutJob& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckOutJob::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckOutJob::Swap(AckOutJob* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(charid_, other->charid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckOutJob::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckOutJob_descriptor_;
  metadata.reflection = AckOutJob_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqKickMember::kCharidFieldNumber;
#endif  // !_MSC_VER

ClientReqKickMember::ClientReqKickMember()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqKickMember::InitAsDefaultInstance() {
}

ClientReqKickMember::ClientReqKickMember(const ClientReqKickMember& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqKickMember::SharedCtor() {
  _cached_size_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqKickMember::~ClientReqKickMember() {
  SharedDtor();
}

void ClientReqKickMember::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqKickMember::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqKickMember::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqKickMember_descriptor_;
}

const ClientReqKickMember& ClientReqKickMember::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqKickMember* ClientReqKickMember::default_instance_ = NULL;

ClientReqKickMember* ClientReqKickMember::New() const {
  return new ClientReqKickMember;
}

void ClientReqKickMember::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqKickMember::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqKickMember::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->charid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqKickMember::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 charid = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->charid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqKickMember::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqKickMember::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqKickMember* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqKickMember*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqKickMember::MergeFrom(const ClientReqKickMember& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqKickMember::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqKickMember::CopyFrom(const ClientReqKickMember& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqKickMember::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqKickMember::Swap(ClientReqKickMember* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqKickMember::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqKickMember_descriptor_;
  metadata.reflection = ClientReqKickMember_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckKickMember::kRetFieldNumber;
const int AckKickMember::kCharidFieldNumber;
#endif  // !_MSC_VER

AckKickMember::AckKickMember()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckKickMember::InitAsDefaultInstance() {
}

AckKickMember::AckKickMember(const AckKickMember& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckKickMember::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckKickMember::~AckKickMember() {
  SharedDtor();
}

void AckKickMember::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckKickMember::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckKickMember::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckKickMember_descriptor_;
}

const AckKickMember& AckKickMember::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckKickMember* AckKickMember::default_instance_ = NULL;

AckKickMember* AckKickMember::New() const {
  return new AckKickMember;
}

void AckKickMember::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
    charid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckKickMember::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_charid;
        break;
      }

      // optional int64 charid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckKickMember::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  // optional int64 charid = 2;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->charid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckKickMember::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  // optional int64 charid = 2;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->charid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckKickMember::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional int64 charid = 2;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckKickMember::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckKickMember* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckKickMember*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckKickMember::MergeFrom(const AckKickMember& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckKickMember::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckKickMember::CopyFrom(const AckKickMember& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckKickMember::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckKickMember::Swap(AckKickMember* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(charid_, other->charid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckKickMember::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckKickMember_descriptor_;
  metadata.reflection = AckKickMember_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientChangeJoinFlag::kFlagFieldNumber;
#endif  // !_MSC_VER

ClientChangeJoinFlag::ClientChangeJoinFlag()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientChangeJoinFlag::InitAsDefaultInstance() {
}

ClientChangeJoinFlag::ClientChangeJoinFlag(const ClientChangeJoinFlag& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientChangeJoinFlag::SharedCtor() {
  _cached_size_ = 0;
  flag_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientChangeJoinFlag::~ClientChangeJoinFlag() {
  SharedDtor();
}

void ClientChangeJoinFlag::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientChangeJoinFlag::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientChangeJoinFlag::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientChangeJoinFlag_descriptor_;
}

const ClientChangeJoinFlag& ClientChangeJoinFlag::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientChangeJoinFlag* ClientChangeJoinFlag::default_instance_ = NULL;

ClientChangeJoinFlag* ClientChangeJoinFlag::New() const {
  return new ClientChangeJoinFlag;
}

void ClientChangeJoinFlag::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    flag_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientChangeJoinFlag::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool flag = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &flag_)));
          set_has_flag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientChangeJoinFlag::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool flag = 1;
  if (has_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->flag(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientChangeJoinFlag::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool flag = 1;
  if (has_flag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->flag(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientChangeJoinFlag::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool flag = 1;
    if (has_flag()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientChangeJoinFlag::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientChangeJoinFlag* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientChangeJoinFlag*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientChangeJoinFlag::MergeFrom(const ClientChangeJoinFlag& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_flag()) {
      set_flag(from.flag());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientChangeJoinFlag::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientChangeJoinFlag::CopyFrom(const ClientChangeJoinFlag& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientChangeJoinFlag::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientChangeJoinFlag::Swap(ClientChangeJoinFlag* other) {
  if (other != this) {
    std::swap(flag_, other->flag_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientChangeJoinFlag::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientChangeJoinFlag_descriptor_;
  metadata.reflection = ClientChangeJoinFlag_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqJoinControl::kTypeFieldNumber;
const int ClientReqJoinControl::kCharidFieldNumber;
#endif  // !_MSC_VER

ClientReqJoinControl::ClientReqJoinControl()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqJoinControl::InitAsDefaultInstance() {
}

ClientReqJoinControl::ClientReqJoinControl(const ClientReqJoinControl& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqJoinControl::SharedCtor() {
  _cached_size_ = 0;
  type_ = false;
  charid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqJoinControl::~ClientReqJoinControl() {
  SharedDtor();
}

void ClientReqJoinControl::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqJoinControl::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqJoinControl::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqJoinControl_descriptor_;
}

const ClientReqJoinControl& ClientReqJoinControl::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqJoinControl* ClientReqJoinControl::default_instance_ = NULL;

ClientReqJoinControl* ClientReqJoinControl::New() const {
  return new ClientReqJoinControl;
}

void ClientReqJoinControl::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = false;
    charid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqJoinControl::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_charid;
        break;
      }

      // optional int64 charid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqJoinControl::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->type(), output);
  }

  // optional int64 charid = 2;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->charid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqJoinControl::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->type(), target);
  }

  // optional int64 charid = 2;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->charid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqJoinControl::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool type = 1;
    if (has_type()) {
      total_size += 1 + 1;
    }

    // optional int64 charid = 2;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqJoinControl::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqJoinControl* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqJoinControl*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqJoinControl::MergeFrom(const ClientReqJoinControl& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqJoinControl::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqJoinControl::CopyFrom(const ClientReqJoinControl& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqJoinControl::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqJoinControl::Swap(ClientReqJoinControl* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(charid_, other->charid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqJoinControl::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqJoinControl_descriptor_;
  metadata.reflection = ClientReqJoinControl_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckJoinControl::kRetFieldNumber;
const int AckJoinControl::kCharidFieldNumber;
const int AckJoinControl::kTypeFieldNumber;
#endif  // !_MSC_VER

AckJoinControl::AckJoinControl()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckJoinControl::InitAsDefaultInstance() {
}

AckJoinControl::AckJoinControl(const AckJoinControl& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckJoinControl::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  type_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckJoinControl::~AckJoinControl() {
  SharedDtor();
}

void AckJoinControl::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckJoinControl::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckJoinControl::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckJoinControl_descriptor_;
}

const AckJoinControl& AckJoinControl::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckJoinControl* AckJoinControl::default_instance_ = NULL;

AckJoinControl* AckJoinControl::New() const {
  return new AckJoinControl;
}

void AckJoinControl::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
    charid_ = GOOGLE_LONGLONG(0);
    type_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckJoinControl::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_charid;
        break;
      }

      // optional int64 charid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional bool type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckJoinControl::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  // optional int64 charid = 2;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->charid(), output);
  }

  // optional bool type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckJoinControl::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  // optional int64 charid = 2;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->charid(), target);
  }

  // optional bool type = 3;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckJoinControl::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional int64 charid = 2;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

    // optional bool type = 3;
    if (has_type()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckJoinControl::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckJoinControl* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckJoinControl*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckJoinControl::MergeFrom(const AckJoinControl& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckJoinControl::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckJoinControl::CopyFrom(const AckJoinControl& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckJoinControl::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckJoinControl::Swap(AckJoinControl* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(charid_, other->charid_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckJoinControl::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckJoinControl_descriptor_;
  metadata.reflection = AckJoinControl_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqAskJoin::kCharidFieldNumber;
#endif  // !_MSC_VER

ClientReqAskJoin::ClientReqAskJoin()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqAskJoin::InitAsDefaultInstance() {
}

ClientReqAskJoin::ClientReqAskJoin(const ClientReqAskJoin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqAskJoin::SharedCtor() {
  _cached_size_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqAskJoin::~ClientReqAskJoin() {
  SharedDtor();
}

void ClientReqAskJoin::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqAskJoin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqAskJoin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqAskJoin_descriptor_;
}

const ClientReqAskJoin& ClientReqAskJoin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqAskJoin* ClientReqAskJoin::default_instance_ = NULL;

ClientReqAskJoin* ClientReqAskJoin::New() const {
  return new ClientReqAskJoin;
}

void ClientReqAskJoin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqAskJoin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqAskJoin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->charid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqAskJoin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 charid = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->charid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqAskJoin::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqAskJoin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqAskJoin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqAskJoin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqAskJoin::MergeFrom(const ClientReqAskJoin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqAskJoin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqAskJoin::CopyFrom(const ClientReqAskJoin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqAskJoin::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqAskJoin::Swap(ClientReqAskJoin* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqAskJoin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqAskJoin_descriptor_;
  metadata.reflection = ClientReqAskJoin_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckAskJoin::kRetFieldNumber;
#endif  // !_MSC_VER

AckAskJoin::AckAskJoin()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckAskJoin::InitAsDefaultInstance() {
}

AckAskJoin::AckAskJoin(const AckAskJoin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckAskJoin::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckAskJoin::~AckAskJoin() {
  SharedDtor();
}

void AckAskJoin::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckAskJoin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckAskJoin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckAskJoin_descriptor_;
}

const AckAskJoin& AckAskJoin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckAskJoin* AckAskJoin::default_instance_ = NULL;

AckAskJoin* AckAskJoin::New() const {
  return new AckAskJoin;
}

void AckAskJoin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckAskJoin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckAskJoin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckAskJoin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckAskJoin::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckAskJoin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckAskJoin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckAskJoin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckAskJoin::MergeFrom(const AckAskJoin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckAskJoin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckAskJoin::CopyFrom(const AckAskJoin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckAskJoin::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckAskJoin::Swap(AckAskJoin* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckAskJoin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckAskJoin_descriptor_;
  metadata.reflection = AckAskJoin_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AskClientJoin::kIdFieldNumber;
const int AskClientJoin::kNameFieldNumber;
const int AskClientJoin::kClannameFieldNumber;
#endif  // !_MSC_VER

AskClientJoin::AskClientJoin()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AskClientJoin::InitAsDefaultInstance() {
}

AskClientJoin::AskClientJoin(const AskClientJoin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AskClientJoin::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AskClientJoin::~AskClientJoin() {
  SharedDtor();
}

void AskClientJoin::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    delete clanname_;
  }
  if (this != default_instance_) {
  }
}

void AskClientJoin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AskClientJoin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AskClientJoin_descriptor_;
}

const AskClientJoin& AskClientJoin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AskClientJoin* AskClientJoin::default_instance_ = NULL;

AskClientJoin* AskClientJoin::New() const {
  return new AskClientJoin;
}

void AskClientJoin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_clanname()) {
      if (clanname_ != &::google::protobuf::internal::kEmptyString) {
        clanname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AskClientJoin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_clanname;
        break;
      }

      // optional string clanname = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_clanname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_clanname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->clanname().data(), this->clanname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AskClientJoin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional string clanname = 3;
  if (has_clanname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->clanname().data(), this->clanname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->clanname(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AskClientJoin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional string clanname = 3;
  if (has_clanname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->clanname().data(), this->clanname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->clanname(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AskClientJoin::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string clanname = 3;
    if (has_clanname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->clanname());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AskClientJoin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AskClientJoin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AskClientJoin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AskClientJoin::MergeFrom(const AskClientJoin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_clanname()) {
      set_clanname(from.clanname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AskClientJoin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AskClientJoin::CopyFrom(const AskClientJoin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AskClientJoin::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AskClientJoin::Swap(AskClientJoin* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(clanname_, other->clanname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AskClientJoin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AskClientJoin_descriptor_;
  metadata.reflection = AskClientJoin_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqRefuseOrJoin::kTypeFieldNumber;
const int ClientReqRefuseOrJoin::kIdFieldNumber;
#endif  // !_MSC_VER

ClientReqRefuseOrJoin::ClientReqRefuseOrJoin()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqRefuseOrJoin::InitAsDefaultInstance() {
}

ClientReqRefuseOrJoin::ClientReqRefuseOrJoin(const ClientReqRefuseOrJoin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqRefuseOrJoin::SharedCtor() {
  _cached_size_ = 0;
  type_ = false;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqRefuseOrJoin::~ClientReqRefuseOrJoin() {
  SharedDtor();
}

void ClientReqRefuseOrJoin::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqRefuseOrJoin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqRefuseOrJoin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqRefuseOrJoin_descriptor_;
}

const ClientReqRefuseOrJoin& ClientReqRefuseOrJoin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqRefuseOrJoin* ClientReqRefuseOrJoin::default_instance_ = NULL;

ClientReqRefuseOrJoin* ClientReqRefuseOrJoin::New() const {
  return new ClientReqRefuseOrJoin;
}

void ClientReqRefuseOrJoin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = false;
    id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqRefuseOrJoin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }

      // optional uint32 id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqRefuseOrJoin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->type(), output);
  }

  // optional uint32 id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqRefuseOrJoin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->type(), target);
  }

  // optional uint32 id = 2;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqRefuseOrJoin::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool type = 1;
    if (has_type()) {
      total_size += 1 + 1;
    }

    // optional uint32 id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqRefuseOrJoin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqRefuseOrJoin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqRefuseOrJoin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqRefuseOrJoin::MergeFrom(const ClientReqRefuseOrJoin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqRefuseOrJoin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqRefuseOrJoin::CopyFrom(const ClientReqRefuseOrJoin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqRefuseOrJoin::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqRefuseOrJoin::Swap(ClientReqRefuseOrJoin* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqRefuseOrJoin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqRefuseOrJoin_descriptor_;
  metadata.reflection = ClientReqRefuseOrJoin_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckRefuseOrJoin::kRetFieldNumber;
const int AckRefuseOrJoin::kInfoFieldNumber;
#endif  // !_MSC_VER

AckRefuseOrJoin::AckRefuseOrJoin()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckRefuseOrJoin::InitAsDefaultInstance() {
  info_ = const_cast< ::ClanPackage::AckClanBase*>(&::ClanPackage::AckClanBase::default_instance());
}

AckRefuseOrJoin::AckRefuseOrJoin(const AckRefuseOrJoin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckRefuseOrJoin::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckRefuseOrJoin::~AckRefuseOrJoin() {
  SharedDtor();
}

void AckRefuseOrJoin::SharedDtor() {
  if (this != default_instance_) {
    delete info_;
  }
}

void AckRefuseOrJoin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckRefuseOrJoin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckRefuseOrJoin_descriptor_;
}

const AckRefuseOrJoin& AckRefuseOrJoin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckRefuseOrJoin* AckRefuseOrJoin::default_instance_ = NULL;

AckRefuseOrJoin* AckRefuseOrJoin::New() const {
  return new AckRefuseOrJoin;
}

void AckRefuseOrJoin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
    if (has_info()) {
      if (info_ != NULL) info_->::ClanPackage::AckClanBase::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckRefuseOrJoin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_info;
        break;
      }

      // optional .ClanPackage.AckClanBase info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckRefuseOrJoin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  // optional .ClanPackage.AckClanBase info = 2;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckRefuseOrJoin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  // optional .ClanPackage.AckClanBase info = 2;
  if (has_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckRefuseOrJoin::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional .ClanPackage.AckClanBase info = 2;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckRefuseOrJoin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckRefuseOrJoin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckRefuseOrJoin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckRefuseOrJoin::MergeFrom(const AckRefuseOrJoin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_info()) {
      mutable_info()->::ClanPackage::AckClanBase::MergeFrom(from.info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckRefuseOrJoin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckRefuseOrJoin::CopyFrom(const AckRefuseOrJoin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckRefuseOrJoin::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  return true;
}

void AckRefuseOrJoin::Swap(AckRefuseOrJoin* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckRefuseOrJoin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckRefuseOrJoin_descriptor_;
  metadata.reflection = AckRefuseOrJoin_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SynchAttrToGM::kCharidFieldNumber;
const int SynchAttrToGM::kBlvFieldNumber;
const int SynchAttrToGM::kElvFieldNumber;
const int SynchAttrToGM::kIdFieldNumber;
const int SynchAttrToGM::kNameFieldNumber;
const int SynchAttrToGM::kJobFieldNumber;
const int SynchAttrToGM::kTypeFieldNumber;
const int SynchAttrToGM::kClaniconFieldNumber;
const int SynchAttrToGM::kClanContributionFieldNumber;
#endif  // !_MSC_VER

SynchAttrToGM::SynchAttrToGM()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SynchAttrToGM::InitAsDefaultInstance() {
}

SynchAttrToGM::SynchAttrToGM(const SynchAttrToGM& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SynchAttrToGM::SharedCtor() {
  _cached_size_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  blv_ = 0;
  elv_ = 0;
  id_ = 0u;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  job_ = 0;
  type_ = 0;
  clanicon_ = 0;
  clancontribution_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SynchAttrToGM::~SynchAttrToGM() {
  SharedDtor();
}

void SynchAttrToGM::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void SynchAttrToGM::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SynchAttrToGM::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SynchAttrToGM_descriptor_;
}

const SynchAttrToGM& SynchAttrToGM::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

SynchAttrToGM* SynchAttrToGM::default_instance_ = NULL;

SynchAttrToGM* SynchAttrToGM::New() const {
  return new SynchAttrToGM;
}

void SynchAttrToGM::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = GOOGLE_LONGLONG(0);
    blv_ = 0;
    elv_ = 0;
    id_ = 0u;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    job_ = 0;
    type_ = 0;
    clanicon_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    clancontribution_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SynchAttrToGM::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_blv;
        break;
      }

      // optional int32 blv = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_blv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &blv_)));
          set_has_blv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_elv;
        break;
      }

      // optional int32 elv = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_elv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &elv_)));
          set_has_elv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_id;
        break;
      }

      // optional uint32 id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_name;
        break;
      }

      // optional string name = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_job;
        break;
      }

      // optional int32 job = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_job:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &job_)));
          set_has_job();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_type;
        break;
      }

      // optional int32 type = 7 [default = 0];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_clanicon;
        break;
      }

      // optional int32 clanicon = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_clanicon:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &clanicon_)));
          set_has_clanicon();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_clanContribution;
        break;
      }

      // optional int32 clanContribution = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_clanContribution:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &clancontribution_)));
          set_has_clancontribution();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SynchAttrToGM::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->charid(), output);
  }

  // optional int32 blv = 2;
  if (has_blv()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->blv(), output);
  }

  // optional int32 elv = 3;
  if (has_elv()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->elv(), output);
  }

  // optional uint32 id = 4;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->id(), output);
  }

  // optional string name = 5;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->name(), output);
  }

  // optional int32 job = 6;
  if (has_job()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->job(), output);
  }

  // optional int32 type = 7 [default = 0];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->type(), output);
  }

  // optional int32 clanicon = 8;
  if (has_clanicon()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->clanicon(), output);
  }

  // optional int32 clanContribution = 9;
  if (has_clancontribution()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->clancontribution(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SynchAttrToGM::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 charid = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->charid(), target);
  }

  // optional int32 blv = 2;
  if (has_blv()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->blv(), target);
  }

  // optional int32 elv = 3;
  if (has_elv()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->elv(), target);
  }

  // optional uint32 id = 4;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->id(), target);
  }

  // optional string name = 5;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->name(), target);
  }

  // optional int32 job = 6;
  if (has_job()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->job(), target);
  }

  // optional int32 type = 7 [default = 0];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->type(), target);
  }

  // optional int32 clanicon = 8;
  if (has_clanicon()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->clanicon(), target);
  }

  // optional int32 clanContribution = 9;
  if (has_clancontribution()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->clancontribution(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SynchAttrToGM::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

    // optional int32 blv = 2;
    if (has_blv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->blv());
    }

    // optional int32 elv = 3;
    if (has_elv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->elv());
    }

    // optional uint32 id = 4;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional string name = 5;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 job = 6;
    if (has_job()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->job());
    }

    // optional int32 type = 7 [default = 0];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int32 clanicon = 8;
    if (has_clanicon()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->clanicon());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 clanContribution = 9;
    if (has_clancontribution()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->clancontribution());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SynchAttrToGM::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SynchAttrToGM* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SynchAttrToGM*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SynchAttrToGM::MergeFrom(const SynchAttrToGM& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_blv()) {
      set_blv(from.blv());
    }
    if (from.has_elv()) {
      set_elv(from.elv());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_job()) {
      set_job(from.job());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_clanicon()) {
      set_clanicon(from.clanicon());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_clancontribution()) {
      set_clancontribution(from.clancontribution());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SynchAttrToGM::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SynchAttrToGM::CopyFrom(const SynchAttrToGM& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SynchAttrToGM::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SynchAttrToGM::Swap(SynchAttrToGM* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(blv_, other->blv_);
    std::swap(elv_, other->elv_);
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(job_, other->job_);
    std::swap(type_, other->type_);
    std::swap(clanicon_, other->clanicon_);
    std::swap(clancontribution_, other->clancontribution_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SynchAttrToGM::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SynchAttrToGM_descriptor_;
  metadata.reflection = SynchAttrToGM_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WorldReqGiveCost::kCharidFieldNumber;
const int WorldReqGiveCost::kMoneyFieldNumber;
const int WorldReqGiveCost::kGoldenFieldNumber;
#endif  // !_MSC_VER

WorldReqGiveCost::WorldReqGiveCost()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WorldReqGiveCost::InitAsDefaultInstance() {
}

WorldReqGiveCost::WorldReqGiveCost(const WorldReqGiveCost& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WorldReqGiveCost::SharedCtor() {
  _cached_size_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  money_ = 0u;
  golden_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WorldReqGiveCost::~WorldReqGiveCost() {
  SharedDtor();
}

void WorldReqGiveCost::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WorldReqGiveCost::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WorldReqGiveCost::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WorldReqGiveCost_descriptor_;
}

const WorldReqGiveCost& WorldReqGiveCost::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

WorldReqGiveCost* WorldReqGiveCost::default_instance_ = NULL;

WorldReqGiveCost* WorldReqGiveCost::New() const {
  return new WorldReqGiveCost;
}

void WorldReqGiveCost::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = GOOGLE_LONGLONG(0);
    money_ = 0u;
    golden_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WorldReqGiveCost::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_money;
        break;
      }

      // optional uint32 money = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_golden;
        break;
      }

      // optional uint32 golden = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_golden:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &golden_)));
          set_has_golden();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WorldReqGiveCost::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->charid(), output);
  }

  // optional uint32 money = 2;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->money(), output);
  }

  // optional uint32 golden = 3;
  if (has_golden()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->golden(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WorldReqGiveCost::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 charid = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->charid(), target);
  }

  // optional uint32 money = 2;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->money(), target);
  }

  // optional uint32 golden = 3;
  if (has_golden()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->golden(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WorldReqGiveCost::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

    // optional uint32 money = 2;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->money());
    }

    // optional uint32 golden = 3;
    if (has_golden()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->golden());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WorldReqGiveCost::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WorldReqGiveCost* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WorldReqGiveCost*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WorldReqGiveCost::MergeFrom(const WorldReqGiveCost& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
    if (from.has_golden()) {
      set_golden(from.golden());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WorldReqGiveCost::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WorldReqGiveCost::CopyFrom(const WorldReqGiveCost& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WorldReqGiveCost::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void WorldReqGiveCost::Swap(WorldReqGiveCost* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(money_, other->money_);
    std::swap(golden_, other->golden_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WorldReqGiveCost::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WorldReqGiveCost_descriptor_;
  metadata.reflection = WorldReqGiveCost_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckGiveCost::kCharidFieldNumber;
const int AckGiveCost::kRetFieldNumber;
const int AckGiveCost::kMoneyFieldNumber;
const int AckGiveCost::kGoldenFieldNumber;
#endif  // !_MSC_VER

AckGiveCost::AckGiveCost()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckGiveCost::InitAsDefaultInstance() {
}

AckGiveCost::AckGiveCost(const AckGiveCost& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckGiveCost::SharedCtor() {
  _cached_size_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  ret_ = 0;
  money_ = 0u;
  golden_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckGiveCost::~AckGiveCost() {
  SharedDtor();
}

void AckGiveCost::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckGiveCost::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckGiveCost::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckGiveCost_descriptor_;
}

const AckGiveCost& AckGiveCost::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckGiveCost* AckGiveCost::default_instance_ = NULL;

AckGiveCost* AckGiveCost::New() const {
  return new AckGiveCost;
}

void AckGiveCost::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = GOOGLE_LONGLONG(0);
    ret_ = 0;
    money_ = 0u;
    golden_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckGiveCost::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ret;
        break;
      }

      // optional int32 ret = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ret:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_money;
        break;
      }

      // optional uint32 money = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_golden;
        break;
      }

      // optional uint32 golden = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_golden:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &golden_)));
          set_has_golden();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckGiveCost::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->charid(), output);
  }

  // optional int32 ret = 2;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->ret(), output);
  }

  // optional uint32 money = 3;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->money(), output);
  }

  // optional uint32 golden = 4;
  if (has_golden()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->golden(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckGiveCost::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 charid = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->charid(), target);
  }

  // optional int32 ret = 2;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->ret(), target);
  }

  // optional uint32 money = 3;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->money(), target);
  }

  // optional uint32 golden = 4;
  if (has_golden()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->golden(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckGiveCost::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

    // optional int32 ret = 2;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional uint32 money = 3;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->money());
    }

    // optional uint32 golden = 4;
    if (has_golden()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->golden());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckGiveCost::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckGiveCost* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckGiveCost*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckGiveCost::MergeFrom(const AckGiveCost& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
    if (from.has_golden()) {
      set_golden(from.golden());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckGiveCost::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckGiveCost::CopyFrom(const AckGiveCost& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckGiveCost::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckGiveCost::Swap(AckGiveCost* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(ret_, other->ret_);
    std::swap(money_, other->money_);
    std::swap(golden_, other->golden_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckGiveCost::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckGiveCost_descriptor_;
  metadata.reflection = AckGiveCost_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClanNameChange::kNameFieldNumber;
const int ClanNameChange::kKeyFieldNumber;
#endif  // !_MSC_VER

ClanNameChange::ClanNameChange()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClanNameChange::InitAsDefaultInstance() {
}

ClanNameChange::ClanNameChange(const ClanNameChange& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClanNameChange::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  key_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClanNameChange::~ClanNameChange() {
  SharedDtor();
}

void ClanNameChange::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void ClanNameChange::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClanNameChange::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClanNameChange_descriptor_;
}

const ClanNameChange& ClanNameChange::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClanNameChange* ClanNameChange::default_instance_ = NULL;

ClanNameChange* ClanNameChange::New() const {
  return new ClanNameChange;
}

void ClanNameChange::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    key_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClanNameChange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_key;
        break;
      }

      // optional int32 key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_key:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &key_)));
          set_has_key();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClanNameChange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // optional int32 key = 2;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->key(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClanNameChange::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional int32 key = 2;
  if (has_key()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->key(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClanNameChange::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 key = 2;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->key());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClanNameChange::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClanNameChange* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClanNameChange*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClanNameChange::MergeFrom(const ClanNameChange& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_key()) {
      set_key(from.key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClanNameChange::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClanNameChange::CopyFrom(const ClanNameChange& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClanNameChange::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClanNameChange::Swap(ClanNameChange* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(key_, other->key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClanNameChange::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClanNameChange_descriptor_;
  metadata.reflection = ClanNameChange_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClanLimit::kClanGoodsFieldNumber;
#endif  // !_MSC_VER

ClanLimit::ClanLimit()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClanLimit::InitAsDefaultInstance() {
}

ClanLimit::ClanLimit(const ClanLimit& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClanLimit::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClanLimit::~ClanLimit() {
  SharedDtor();
}

void ClanLimit::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClanLimit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClanLimit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClanLimit_descriptor_;
}

const ClanLimit& ClanLimit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClanLimit* ClanLimit::default_instance_ = NULL;

ClanLimit* ClanLimit::New() const {
  return new ClanLimit;
}

void ClanLimit::Clear() {
  clangoods_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClanLimit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ClanPackage.ClanGoods clanGoods = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_clanGoods:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_clangoods()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_clanGoods;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClanLimit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ClanPackage.ClanGoods clanGoods = 1;
  for (int i = 0; i < this->clangoods_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->clangoods(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClanLimit::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ClanPackage.ClanGoods clanGoods = 1;
  for (int i = 0; i < this->clangoods_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->clangoods(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClanLimit::ByteSize() const {
  int total_size = 0;

  // repeated .ClanPackage.ClanGoods clanGoods = 1;
  total_size += 1 * this->clangoods_size();
  for (int i = 0; i < this->clangoods_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->clangoods(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClanLimit::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClanLimit* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClanLimit*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClanLimit::MergeFrom(const ClanLimit& from) {
  GOOGLE_CHECK_NE(&from, this);
  clangoods_.MergeFrom(from.clangoods_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClanLimit::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClanLimit::CopyFrom(const ClanLimit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClanLimit::IsInitialized() const {

  for (int i = 0; i < clangoods_size(); i++) {
    if (!this->clangoods(i).IsInitialized()) return false;
  }
  return true;
}

void ClanLimit::Swap(ClanLimit* other) {
  if (other != this) {
    clangoods_.Swap(&other->clangoods_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClanLimit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClanLimit_descriptor_;
  metadata.reflection = ClanLimit_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClanGoods::kItemidFieldNumber;
const int ClanGoods::kLimitFieldNumber;
#endif  // !_MSC_VER

ClanGoods::ClanGoods()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClanGoods::InitAsDefaultInstance() {
}

ClanGoods::ClanGoods(const ClanGoods& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClanGoods::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0;
  limit_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClanGoods::~ClanGoods() {
  SharedDtor();
}

void ClanGoods::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClanGoods::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClanGoods::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClanGoods_descriptor_;
}

const ClanGoods& ClanGoods::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClanGoods* ClanGoods::default_instance_ = NULL;

ClanGoods* ClanGoods::New() const {
  return new ClanGoods;
}

void ClanGoods::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    itemid_ = 0;
    limit_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClanGoods::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 itemid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_limit;
        break;
      }

      // optional int32 limit = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_limit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &limit_)));
          set_has_limit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClanGoods::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 itemid = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->itemid(), output);
  }

  // optional int32 limit = 2;
  if (has_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->limit(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClanGoods::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 itemid = 1;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->itemid(), target);
  }

  // optional int32 limit = 2;
  if (has_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->limit(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClanGoods::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 itemid = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional int32 limit = 2;
    if (has_limit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->limit());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClanGoods::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClanGoods* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClanGoods*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClanGoods::MergeFrom(const ClanGoods& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_limit()) {
      set_limit(from.limit());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClanGoods::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClanGoods::CopyFrom(const ClanGoods& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClanGoods::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClanGoods::Swap(ClanGoods* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(limit_, other->limit_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClanGoods::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClanGoods_descriptor_;
  metadata.reflection = ClanGoods_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClanShop::kRetFieldNumber;
const int ClanShop::kIDFieldNumber;
const int ClanShop::kSurplusCountsFieldNumber;
#endif  // !_MSC_VER

ClanShop::ClanShop()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClanShop::InitAsDefaultInstance() {
}

ClanShop::ClanShop(const ClanShop& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClanShop::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  id_ = 0;
  surpluscounts_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClanShop::~ClanShop() {
  SharedDtor();
}

void ClanShop::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClanShop::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClanShop::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClanShop_descriptor_;
}

const ClanShop& ClanShop::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClanShop* ClanShop::default_instance_ = NULL;

ClanShop* ClanShop::New() const {
  return new ClanShop;
}

void ClanShop::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
    id_ = 0;
    surpluscounts_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClanShop::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ID;
        break;
      }

      // optional int32 ID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_surplusCounts;
        break;
      }

      // optional int32 surplusCounts = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_surplusCounts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &surpluscounts_)));
          set_has_surpluscounts();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClanShop::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  // optional int32 ID = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->id(), output);
  }

  // optional int32 surplusCounts = 3;
  if (has_surpluscounts()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->surpluscounts(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClanShop::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  // optional int32 ID = 2;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->id(), target);
  }

  // optional int32 surplusCounts = 3;
  if (has_surpluscounts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->surpluscounts(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClanShop::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional int32 ID = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 surplusCounts = 3;
    if (has_surpluscounts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->surpluscounts());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClanShop::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClanShop* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClanShop*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClanShop::MergeFrom(const ClanShop& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_surpluscounts()) {
      set_surpluscounts(from.surpluscounts());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClanShop::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClanShop::CopyFrom(const ClanShop& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClanShop::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClanShop::Swap(ClanShop* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(id_, other->id_);
    std::swap(surpluscounts_, other->surpluscounts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClanShop::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClanShop_descriptor_;
  metadata.reflection = ClanShop_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SaveClanLimit::kClanGoodsFieldNumber;
const int SaveClanLimit::kTimeFieldNumber;
#endif  // !_MSC_VER

SaveClanLimit::SaveClanLimit()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SaveClanLimit::InitAsDefaultInstance() {
}

SaveClanLimit::SaveClanLimit(const SaveClanLimit& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SaveClanLimit::SharedCtor() {
  _cached_size_ = 0;
  time_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SaveClanLimit::~SaveClanLimit() {
  SharedDtor();
}

void SaveClanLimit::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SaveClanLimit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SaveClanLimit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SaveClanLimit_descriptor_;
}

const SaveClanLimit& SaveClanLimit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

SaveClanLimit* SaveClanLimit::default_instance_ = NULL;

SaveClanLimit* SaveClanLimit::New() const {
  return new SaveClanLimit;
}

void SaveClanLimit::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    time_ = GOOGLE_LONGLONG(0);
  }
  clangoods_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SaveClanLimit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ClanPackage.ClanGoods clanGoods = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_clanGoods:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_clangoods()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_clanGoods;
        if (input->ExpectTag(16)) goto parse_time;
        break;
      }

      // optional int64 time = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SaveClanLimit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ClanPackage.ClanGoods clanGoods = 1;
  for (int i = 0; i < this->clangoods_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->clangoods(i), output);
  }

  // optional int64 time = 2;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->time(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SaveClanLimit::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ClanPackage.ClanGoods clanGoods = 1;
  for (int i = 0; i < this->clangoods_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->clangoods(i), target);
  }

  // optional int64 time = 2;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->time(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SaveClanLimit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int64 time = 2;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time());
    }

  }
  // repeated .ClanPackage.ClanGoods clanGoods = 1;
  total_size += 1 * this->clangoods_size();
  for (int i = 0; i < this->clangoods_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->clangoods(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SaveClanLimit::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SaveClanLimit* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SaveClanLimit*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SaveClanLimit::MergeFrom(const SaveClanLimit& from) {
  GOOGLE_CHECK_NE(&from, this);
  clangoods_.MergeFrom(from.clangoods_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SaveClanLimit::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SaveClanLimit::CopyFrom(const SaveClanLimit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaveClanLimit::IsInitialized() const {

  for (int i = 0; i < clangoods_size(); i++) {
    if (!this->clangoods(i).IsInitialized()) return false;
  }
  return true;
}

void SaveClanLimit::Swap(SaveClanLimit* other) {
  if (other != this) {
    clangoods_.Swap(&other->clangoods_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SaveClanLimit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SaveClanLimit_descriptor_;
  metadata.reflection = SaveClanLimit_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SaveClanSkill::kSclanSkillFieldNumber;
#endif  // !_MSC_VER

SaveClanSkill::SaveClanSkill()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SaveClanSkill::InitAsDefaultInstance() {
}

SaveClanSkill::SaveClanSkill(const SaveClanSkill& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SaveClanSkill::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SaveClanSkill::~SaveClanSkill() {
  SharedDtor();
}

void SaveClanSkill::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SaveClanSkill::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SaveClanSkill::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SaveClanSkill_descriptor_;
}

const SaveClanSkill& SaveClanSkill::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

SaveClanSkill* SaveClanSkill::default_instance_ = NULL;

SaveClanSkill* SaveClanSkill::New() const {
  return new SaveClanSkill;
}

void SaveClanSkill::Clear() {
  sclanskill_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SaveClanSkill::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ClanPackage.SClanSkill sclanSkill = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sclanSkill:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sclanskill()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_sclanSkill;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SaveClanSkill::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ClanPackage.SClanSkill sclanSkill = 1;
  for (int i = 0; i < this->sclanskill_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->sclanskill(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SaveClanSkill::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ClanPackage.SClanSkill sclanSkill = 1;
  for (int i = 0; i < this->sclanskill_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->sclanskill(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SaveClanSkill::ByteSize() const {
  int total_size = 0;

  // repeated .ClanPackage.SClanSkill sclanSkill = 1;
  total_size += 1 * this->sclanskill_size();
  for (int i = 0; i < this->sclanskill_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sclanskill(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SaveClanSkill::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SaveClanSkill* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SaveClanSkill*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SaveClanSkill::MergeFrom(const SaveClanSkill& from) {
  GOOGLE_CHECK_NE(&from, this);
  sclanskill_.MergeFrom(from.sclanskill_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SaveClanSkill::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SaveClanSkill::CopyFrom(const SaveClanSkill& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SaveClanSkill::IsInitialized() const {

  for (int i = 0; i < sclanskill_size(); i++) {
    if (!this->sclanskill(i).IsInitialized()) return false;
  }
  return true;
}

void SaveClanSkill::Swap(SaveClanSkill* other) {
  if (other != this) {
    sclanskill_.Swap(&other->sclanskill_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SaveClanSkill::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SaveClanSkill_descriptor_;
  metadata.reflection = SaveClanSkill_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SClanSkill::kSkillidFieldNumber;
const int SClanSkill::kCurexpFieldNumber;
const int SClanSkill::kTypeFieldNumber;
#endif  // !_MSC_VER

SClanSkill::SClanSkill()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SClanSkill::InitAsDefaultInstance() {
}

SClanSkill::SClanSkill(const SClanSkill& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SClanSkill::SharedCtor() {
  _cached_size_ = 0;
  skillid_ = 0;
  curexp_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SClanSkill::~SClanSkill() {
  SharedDtor();
}

void SClanSkill::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SClanSkill::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SClanSkill::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SClanSkill_descriptor_;
}

const SClanSkill& SClanSkill::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

SClanSkill* SClanSkill::default_instance_ = NULL;

SClanSkill* SClanSkill::New() const {
  return new SClanSkill;
}

void SClanSkill::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    skillid_ = 0;
    curexp_ = 0;
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SClanSkill::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 skillid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &skillid_)));
          set_has_skillid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_curexp;
        break;
      }

      // optional int32 curexp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_curexp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &curexp_)));
          set_has_curexp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional int32 type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SClanSkill::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 skillid = 1;
  if (has_skillid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->skillid(), output);
  }

  // optional int32 curexp = 2;
  if (has_curexp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->curexp(), output);
  }

  // optional int32 type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SClanSkill::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 skillid = 1;
  if (has_skillid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->skillid(), target);
  }

  // optional int32 curexp = 2;
  if (has_curexp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->curexp(), target);
  }

  // optional int32 type = 3;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SClanSkill::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 skillid = 1;
    if (has_skillid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->skillid());
    }

    // optional int32 curexp = 2;
    if (has_curexp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->curexp());
    }

    // optional int32 type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SClanSkill::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SClanSkill* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SClanSkill*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SClanSkill::MergeFrom(const SClanSkill& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_skillid()) {
      set_skillid(from.skillid());
    }
    if (from.has_curexp()) {
      set_curexp(from.curexp());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SClanSkill::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SClanSkill::CopyFrom(const SClanSkill& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SClanSkill::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SClanSkill::Swap(SClanSkill* other) {
  if (other != this) {
    std::swap(skillid_, other->skillid_);
    std::swap(curexp_, other->curexp_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SClanSkill::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SClanSkill_descriptor_;
  metadata.reflection = SClanSkill_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClanSkill::kSkillidFieldNumber;
const int ClanSkill::kCurexpFieldNumber;
#endif  // !_MSC_VER

ClanSkill::ClanSkill()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClanSkill::InitAsDefaultInstance() {
}

ClanSkill::ClanSkill(const ClanSkill& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClanSkill::SharedCtor() {
  _cached_size_ = 0;
  skillid_ = 0;
  curexp_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClanSkill::~ClanSkill() {
  SharedDtor();
}

void ClanSkill::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClanSkill::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClanSkill::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClanSkill_descriptor_;
}

const ClanSkill& ClanSkill::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClanSkill* ClanSkill::default_instance_ = NULL;

ClanSkill* ClanSkill::New() const {
  return new ClanSkill;
}

void ClanSkill::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    skillid_ = 0;
    curexp_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClanSkill::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 skillid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &skillid_)));
          set_has_skillid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_curexp;
        break;
      }

      // optional int32 curexp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_curexp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &curexp_)));
          set_has_curexp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClanSkill::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 skillid = 1;
  if (has_skillid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->skillid(), output);
  }

  // optional int32 curexp = 2;
  if (has_curexp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->curexp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClanSkill::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 skillid = 1;
  if (has_skillid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->skillid(), target);
  }

  // optional int32 curexp = 2;
  if (has_curexp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->curexp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClanSkill::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 skillid = 1;
    if (has_skillid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->skillid());
    }

    // optional int32 curexp = 2;
    if (has_curexp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->curexp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClanSkill::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClanSkill* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClanSkill*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClanSkill::MergeFrom(const ClanSkill& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_skillid()) {
      set_skillid(from.skillid());
    }
    if (from.has_curexp()) {
      set_curexp(from.curexp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClanSkill::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClanSkill::CopyFrom(const ClanSkill& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClanSkill::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClanSkill::Swap(ClanSkill* other) {
  if (other != this) {
    std::swap(skillid_, other->skillid_);
    std::swap(curexp_, other->curexp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClanSkill::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClanSkill_descriptor_;
  metadata.reflection = ClanSkill_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqSkillUpdate::kTypeFieldNumber;
#endif  // !_MSC_VER

ClientReqSkillUpdate::ClientReqSkillUpdate()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqSkillUpdate::InitAsDefaultInstance() {
}

ClientReqSkillUpdate::ClientReqSkillUpdate(const ClientReqSkillUpdate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqSkillUpdate::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqSkillUpdate::~ClientReqSkillUpdate() {
  SharedDtor();
}

void ClientReqSkillUpdate::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqSkillUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqSkillUpdate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqSkillUpdate_descriptor_;
}

const ClientReqSkillUpdate& ClientReqSkillUpdate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqSkillUpdate* ClientReqSkillUpdate::default_instance_ = NULL;

ClientReqSkillUpdate* ClientReqSkillUpdate::New() const {
  return new ClientReqSkillUpdate;
}

void ClientReqSkillUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqSkillUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqSkillUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqSkillUpdate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqSkillUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqSkillUpdate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqSkillUpdate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqSkillUpdate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqSkillUpdate::MergeFrom(const ClientReqSkillUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqSkillUpdate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqSkillUpdate::CopyFrom(const ClientReqSkillUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqSkillUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqSkillUpdate::Swap(ClientReqSkillUpdate* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqSkillUpdate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqSkillUpdate_descriptor_;
  metadata.reflection = ClientReqSkillUpdate_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WSToClentSkillUpdate::kRetFieldNumber;
const int WSToClentSkillUpdate::kSkillidFieldNumber;
const int WSToClentSkillUpdate::kCurexpFieldNumber;
const int WSToClentSkillUpdate::kContriFieldNumber;
#endif  // !_MSC_VER

WSToClentSkillUpdate::WSToClentSkillUpdate()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WSToClentSkillUpdate::InitAsDefaultInstance() {
}

WSToClentSkillUpdate::WSToClentSkillUpdate(const WSToClentSkillUpdate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WSToClentSkillUpdate::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  skillid_ = 0;
  curexp_ = 0;
  contri_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WSToClentSkillUpdate::~WSToClentSkillUpdate() {
  SharedDtor();
}

void WSToClentSkillUpdate::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WSToClentSkillUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WSToClentSkillUpdate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WSToClentSkillUpdate_descriptor_;
}

const WSToClentSkillUpdate& WSToClentSkillUpdate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

WSToClentSkillUpdate* WSToClentSkillUpdate::default_instance_ = NULL;

WSToClentSkillUpdate* WSToClentSkillUpdate::New() const {
  return new WSToClentSkillUpdate;
}

void WSToClentSkillUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
    skillid_ = 0;
    curexp_ = 0;
    contri_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WSToClentSkillUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_skillid;
        break;
      }

      // optional int32 skillid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skillid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &skillid_)));
          set_has_skillid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_curexp;
        break;
      }

      // optional int32 curexp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_curexp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &curexp_)));
          set_has_curexp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_contri;
        break;
      }

      // optional int32 contri = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_contri:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &contri_)));
          set_has_contri();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WSToClentSkillUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  // optional int32 skillid = 2;
  if (has_skillid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->skillid(), output);
  }

  // optional int32 curexp = 3;
  if (has_curexp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->curexp(), output);
  }

  // optional int32 contri = 4;
  if (has_contri()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->contri(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WSToClentSkillUpdate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  // optional int32 skillid = 2;
  if (has_skillid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->skillid(), target);
  }

  // optional int32 curexp = 3;
  if (has_curexp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->curexp(), target);
  }

  // optional int32 contri = 4;
  if (has_contri()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->contri(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WSToClentSkillUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional int32 skillid = 2;
    if (has_skillid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->skillid());
    }

    // optional int32 curexp = 3;
    if (has_curexp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->curexp());
    }

    // optional int32 contri = 4;
    if (has_contri()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->contri());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WSToClentSkillUpdate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WSToClentSkillUpdate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WSToClentSkillUpdate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WSToClentSkillUpdate::MergeFrom(const WSToClentSkillUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_skillid()) {
      set_skillid(from.skillid());
    }
    if (from.has_curexp()) {
      set_curexp(from.curexp());
    }
    if (from.has_contri()) {
      set_contri(from.contri());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WSToClentSkillUpdate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WSToClentSkillUpdate::CopyFrom(const WSToClentSkillUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WSToClentSkillUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void WSToClentSkillUpdate::Swap(WSToClentSkillUpdate* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(skillid_, other->skillid_);
    std::swap(curexp_, other->curexp_);
    std::swap(contri_, other->contri_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WSToClentSkillUpdate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WSToClentSkillUpdate_descriptor_;
  metadata.reflection = WSToClentSkillUpdate_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WSToClientSimSkillUpdate::kSkillidFieldNumber;
const int WSToClientSimSkillUpdate::kCurexpFieldNumber;
#endif  // !_MSC_VER

WSToClientSimSkillUpdate::WSToClientSimSkillUpdate()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WSToClientSimSkillUpdate::InitAsDefaultInstance() {
}

WSToClientSimSkillUpdate::WSToClientSimSkillUpdate(const WSToClientSimSkillUpdate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WSToClientSimSkillUpdate::SharedCtor() {
  _cached_size_ = 0;
  skillid_ = 0;
  curexp_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WSToClientSimSkillUpdate::~WSToClientSimSkillUpdate() {
  SharedDtor();
}

void WSToClientSimSkillUpdate::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WSToClientSimSkillUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WSToClientSimSkillUpdate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WSToClientSimSkillUpdate_descriptor_;
}

const WSToClientSimSkillUpdate& WSToClientSimSkillUpdate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

WSToClientSimSkillUpdate* WSToClientSimSkillUpdate::default_instance_ = NULL;

WSToClientSimSkillUpdate* WSToClientSimSkillUpdate::New() const {
  return new WSToClientSimSkillUpdate;
}

void WSToClientSimSkillUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    skillid_ = 0;
    curexp_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WSToClientSimSkillUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 skillid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &skillid_)));
          set_has_skillid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_curexp;
        break;
      }

      // optional int32 curexp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_curexp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &curexp_)));
          set_has_curexp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WSToClientSimSkillUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 skillid = 1;
  if (has_skillid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->skillid(), output);
  }

  // optional int32 curexp = 2;
  if (has_curexp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->curexp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WSToClientSimSkillUpdate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 skillid = 1;
  if (has_skillid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->skillid(), target);
  }

  // optional int32 curexp = 2;
  if (has_curexp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->curexp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WSToClientSimSkillUpdate::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 skillid = 1;
    if (has_skillid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->skillid());
    }

    // optional int32 curexp = 2;
    if (has_curexp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->curexp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WSToClientSimSkillUpdate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WSToClientSimSkillUpdate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WSToClientSimSkillUpdate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WSToClientSimSkillUpdate::MergeFrom(const WSToClientSimSkillUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_skillid()) {
      set_skillid(from.skillid());
    }
    if (from.has_curexp()) {
      set_curexp(from.curexp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WSToClientSimSkillUpdate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WSToClientSimSkillUpdate::CopyFrom(const WSToClientSimSkillUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WSToClientSimSkillUpdate::IsInitialized() const {

  return true;
}

void WSToClientSimSkillUpdate::Swap(WSToClientSimSkillUpdate* other) {
  if (other != this) {
    std::swap(skillid_, other->skillid_);
    std::swap(curexp_, other->curexp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WSToClientSimSkillUpdate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WSToClientSimSkillUpdate_descriptor_;
  metadata.reflection = WSToClientSimSkillUpdate_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WSToGameADBuff::kCharidFieldNumber;
const int WSToGameADBuff::kFlagFieldNumber;
const int WSToGameADBuff::kSkillidFieldNumber;
#endif  // !_MSC_VER

WSToGameADBuff::WSToGameADBuff()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WSToGameADBuff::InitAsDefaultInstance() {
}

WSToGameADBuff::WSToGameADBuff(const WSToGameADBuff& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WSToGameADBuff::SharedCtor() {
  _cached_size_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  flag_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WSToGameADBuff::~WSToGameADBuff() {
  SharedDtor();
}

void WSToGameADBuff::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WSToGameADBuff::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WSToGameADBuff::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WSToGameADBuff_descriptor_;
}

const WSToGameADBuff& WSToGameADBuff::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

WSToGameADBuff* WSToGameADBuff::default_instance_ = NULL;

WSToGameADBuff* WSToGameADBuff::New() const {
  return new WSToGameADBuff;
}

void WSToGameADBuff::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = GOOGLE_LONGLONG(0);
    flag_ = false;
  }
  skillid_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WSToGameADBuff::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_flag;
        break;
      }

      // optional bool flag = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &flag_)));
          set_has_flag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_skillid;
        break;
      }

      // repeated int32 skillid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skillid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_skillid())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_skillid())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_skillid;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WSToGameADBuff::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->charid(), output);
  }

  // optional bool flag = 2;
  if (has_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->flag(), output);
  }

  // repeated int32 skillid = 3;
  for (int i = 0; i < this->skillid_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->skillid(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WSToGameADBuff::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 charid = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->charid(), target);
  }

  // optional bool flag = 2;
  if (has_flag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->flag(), target);
  }

  // repeated int32 skillid = 3;
  for (int i = 0; i < this->skillid_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(3, this->skillid(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WSToGameADBuff::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

    // optional bool flag = 2;
    if (has_flag()) {
      total_size += 1 + 1;
    }

  }
  // repeated int32 skillid = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->skillid_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->skillid(i));
    }
    total_size += 1 * this->skillid_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WSToGameADBuff::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WSToGameADBuff* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WSToGameADBuff*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WSToGameADBuff::MergeFrom(const WSToGameADBuff& from) {
  GOOGLE_CHECK_NE(&from, this);
  skillid_.MergeFrom(from.skillid_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_flag()) {
      set_flag(from.flag());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WSToGameADBuff::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WSToGameADBuff::CopyFrom(const WSToGameADBuff& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WSToGameADBuff::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void WSToGameADBuff::Swap(WSToGameADBuff* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(flag_, other->flag_);
    skillid_.Swap(&other->skillid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WSToGameADBuff::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WSToGameADBuff_descriptor_;
  metadata.reflection = WSToGameADBuff_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WSToGameClanLevel::kCharidFieldNumber;
const int WSToGameClanLevel::kClanLevelFieldNumber;
#endif  // !_MSC_VER

WSToGameClanLevel::WSToGameClanLevel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WSToGameClanLevel::InitAsDefaultInstance() {
}

WSToGameClanLevel::WSToGameClanLevel(const WSToGameClanLevel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WSToGameClanLevel::SharedCtor() {
  _cached_size_ = 0;
  charid_ = GOOGLE_LONGLONG(0);
  clanlevel_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WSToGameClanLevel::~WSToGameClanLevel() {
  SharedDtor();
}

void WSToGameClanLevel::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WSToGameClanLevel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WSToGameClanLevel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WSToGameClanLevel_descriptor_;
}

const WSToGameClanLevel& WSToGameClanLevel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

WSToGameClanLevel* WSToGameClanLevel::default_instance_ = NULL;

WSToGameClanLevel* WSToGameClanLevel::New() const {
  return new WSToGameClanLevel;
}

void WSToGameClanLevel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = GOOGLE_LONGLONG(0);
    clanlevel_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WSToGameClanLevel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_clanLevel;
        break;
      }

      // optional int32 clanLevel = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_clanLevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &clanlevel_)));
          set_has_clanlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WSToGameClanLevel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->charid(), output);
  }

  // optional int32 clanLevel = 2;
  if (has_clanlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->clanlevel(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WSToGameClanLevel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 charid = 1;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->charid(), target);
  }

  // optional int32 clanLevel = 2;
  if (has_clanlevel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->clanlevel(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WSToGameClanLevel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->charid());
    }

    // optional int32 clanLevel = 2;
    if (has_clanlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->clanlevel());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WSToGameClanLevel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WSToGameClanLevel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WSToGameClanLevel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WSToGameClanLevel::MergeFrom(const WSToGameClanLevel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_clanlevel()) {
      set_clanlevel(from.clanlevel());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WSToGameClanLevel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WSToGameClanLevel::CopyFrom(const WSToGameClanLevel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WSToGameClanLevel::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void WSToGameClanLevel::Swap(WSToGameClanLevel* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(clanlevel_, other->clanlevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WSToGameClanLevel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WSToGameClanLevel_descriptor_;
  metadata.reflection = WSToGameClanLevel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SynchWillJoinToGM::kCharIDFieldNumber;
const int SynchWillJoinToGM::kFlagFieldNumber;
#endif  // !_MSC_VER

SynchWillJoinToGM::SynchWillJoinToGM()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SynchWillJoinToGM::InitAsDefaultInstance() {
}

SynchWillJoinToGM::SynchWillJoinToGM(const SynchWillJoinToGM& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SynchWillJoinToGM::SharedCtor() {
  _cached_size_ = 0;
  flag_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SynchWillJoinToGM::~SynchWillJoinToGM() {
  SharedDtor();
}

void SynchWillJoinToGM::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SynchWillJoinToGM::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SynchWillJoinToGM::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SynchWillJoinToGM_descriptor_;
}

const SynchWillJoinToGM& SynchWillJoinToGM::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

SynchWillJoinToGM* SynchWillJoinToGM::default_instance_ = NULL;

SynchWillJoinToGM* SynchWillJoinToGM::New() const {
  return new SynchWillJoinToGM;
}

void SynchWillJoinToGM::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    flag_ = false;
  }
  charid_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SynchWillJoinToGM::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int64 charID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 8, input, this->mutable_charid())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_charid())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_charID;
        if (input->ExpectTag(16)) goto parse_flag;
        break;
      }

      // optional bool flag = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &flag_)));
          set_has_flag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SynchWillJoinToGM::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int64 charID = 1;
  for (int i = 0; i < this->charid_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(
      1, this->charid(i), output);
  }

  // optional bool flag = 2;
  if (has_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->flag(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SynchWillJoinToGM::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated int64 charID = 1;
  for (int i = 0; i < this->charid_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt64ToArray(1, this->charid(i), target);
  }

  // optional bool flag = 2;
  if (has_flag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->flag(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SynchWillJoinToGM::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bool flag = 2;
    if (has_flag()) {
      total_size += 1 + 1;
    }

  }
  // repeated int64 charID = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->charid_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int64Size(this->charid(i));
    }
    total_size += 1 * this->charid_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SynchWillJoinToGM::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SynchWillJoinToGM* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SynchWillJoinToGM*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SynchWillJoinToGM::MergeFrom(const SynchWillJoinToGM& from) {
  GOOGLE_CHECK_NE(&from, this);
  charid_.MergeFrom(from.charid_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_flag()) {
      set_flag(from.flag());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SynchWillJoinToGM::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SynchWillJoinToGM::CopyFrom(const SynchWillJoinToGM& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SynchWillJoinToGM::IsInitialized() const {

  return true;
}

void SynchWillJoinToGM::Swap(SynchWillJoinToGM* other) {
  if (other != this) {
    charid_.Swap(&other->charid_);
    std::swap(flag_, other->flag_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SynchWillJoinToGM::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SynchWillJoinToGM_descriptor_;
  metadata.reflection = SynchWillJoinToGM_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ShowClanWelfare::kWelfaresFieldNumber;
const int ShowClanWelfare::kHistoryContriFieldNumber;
const int ShowClanWelfare::kJoinTimeFieldNumber;
#endif  // !_MSC_VER

ShowClanWelfare::ShowClanWelfare()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ShowClanWelfare::InitAsDefaultInstance() {
}

ShowClanWelfare::ShowClanWelfare(const ShowClanWelfare& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ShowClanWelfare::SharedCtor() {
  _cached_size_ = 0;
  historycontri_ = 0u;
  jointime_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShowClanWelfare::~ShowClanWelfare() {
  SharedDtor();
}

void ShowClanWelfare::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ShowClanWelfare::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ShowClanWelfare::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShowClanWelfare_descriptor_;
}

const ShowClanWelfare& ShowClanWelfare::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ShowClanWelfare* ShowClanWelfare::default_instance_ = NULL;

ShowClanWelfare* ShowClanWelfare::New() const {
  return new ShowClanWelfare;
}

void ShowClanWelfare::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    historycontri_ = 0u;
    jointime_ = GOOGLE_ULONGLONG(0);
  }
  welfares_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShowClanWelfare::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ClanPackage.ClanWelfare welfares = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_welfares:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_welfares()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_welfares;
        if (input->ExpectTag(16)) goto parse_historyContri;
        break;
      }

      // optional uint32 historyContri = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_historyContri:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &historycontri_)));
          set_has_historycontri();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_joinTime;
        break;
      }

      // optional uint64 joinTime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_joinTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &jointime_)));
          set_has_jointime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShowClanWelfare::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ClanPackage.ClanWelfare welfares = 1;
  for (int i = 0; i < this->welfares_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->welfares(i), output);
  }

  // optional uint32 historyContri = 2;
  if (has_historycontri()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->historycontri(), output);
  }

  // optional uint64 joinTime = 3;
  if (has_jointime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->jointime(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ShowClanWelfare::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ClanPackage.ClanWelfare welfares = 1;
  for (int i = 0; i < this->welfares_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->welfares(i), target);
  }

  // optional uint32 historyContri = 2;
  if (has_historycontri()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->historycontri(), target);
  }

  // optional uint64 joinTime = 3;
  if (has_jointime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->jointime(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ShowClanWelfare::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional uint32 historyContri = 2;
    if (has_historycontri()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->historycontri());
    }

    // optional uint64 joinTime = 3;
    if (has_jointime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->jointime());
    }

  }
  // repeated .ClanPackage.ClanWelfare welfares = 1;
  total_size += 1 * this->welfares_size();
  for (int i = 0; i < this->welfares_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->welfares(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShowClanWelfare::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShowClanWelfare* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShowClanWelfare*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShowClanWelfare::MergeFrom(const ShowClanWelfare& from) {
  GOOGLE_CHECK_NE(&from, this);
  welfares_.MergeFrom(from.welfares_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_historycontri()) {
      set_historycontri(from.historycontri());
    }
    if (from.has_jointime()) {
      set_jointime(from.jointime());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShowClanWelfare::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShowClanWelfare::CopyFrom(const ShowClanWelfare& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowClanWelfare::IsInitialized() const {

  for (int i = 0; i < welfares_size(); i++) {
    if (!this->welfares(i).IsInitialized()) return false;
  }
  return true;
}

void ShowClanWelfare::Swap(ShowClanWelfare* other) {
  if (other != this) {
    welfares_.Swap(&other->welfares_);
    std::swap(historycontri_, other->historycontri_);
    std::swap(jointime_, other->jointime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ShowClanWelfare::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ShowClanWelfare_descriptor_;
  metadata.reflection = ShowClanWelfare_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClanWelfare::kWelfareIDFieldNumber;
const int ClanWelfare::kNameFieldNumber;
const int ClanWelfare::kWelfareInfoIDFieldNumber;
const int ClanWelfare::kLimitLvFieldNumber;
const int ClanWelfare::kLimitDayFieldNumber;
const int ClanWelfare::kLimitContriFieldNumber;
const int ClanWelfare::kNumFieldNumber;
const int ClanWelfare::kIsTakeFieldNumber;
#endif  // !_MSC_VER

ClanWelfare::ClanWelfare()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClanWelfare::InitAsDefaultInstance() {
}

ClanWelfare::ClanWelfare(const ClanWelfare& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClanWelfare::SharedCtor() {
  _cached_size_ = 0;
  welfareid_ = GOOGLE_ULONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  welfareinfoid_ = 0;
  limitlv_ = 0;
  limitday_ = 0;
  limitcontri_ = 0;
  num_ = 0;
  istake_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClanWelfare::~ClanWelfare() {
  SharedDtor();
}

void ClanWelfare::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void ClanWelfare::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClanWelfare::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClanWelfare_descriptor_;
}

const ClanWelfare& ClanWelfare::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClanWelfare* ClanWelfare::default_instance_ = NULL;

ClanWelfare* ClanWelfare::New() const {
  return new ClanWelfare;
}

void ClanWelfare::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    welfareid_ = GOOGLE_ULONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    welfareinfoid_ = 0;
    limitlv_ = 0;
    limitday_ = 0;
    limitcontri_ = 0;
    num_ = 0;
    istake_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClanWelfare::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 welfareID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &welfareid_)));
          set_has_welfareid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_welfareInfoID;
        break;
      }

      // optional int32 welfareInfoID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_welfareInfoID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &welfareinfoid_)));
          set_has_welfareinfoid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_limitLv;
        break;
      }

      // optional int32 limitLv = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_limitLv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &limitlv_)));
          set_has_limitlv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_limitDay;
        break;
      }

      // optional int32 limitDay = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_limitDay:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &limitday_)));
          set_has_limitday();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_limitContri;
        break;
      }

      // optional int32 limitContri = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_limitContri:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &limitcontri_)));
          set_has_limitcontri();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_num;
        break;
      }

      // optional int32 num = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_isTake;
        break;
      }

      // optional int32 isTake = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isTake:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &istake_)));
          set_has_istake();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClanWelfare::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 welfareID = 1;
  if (has_welfareid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->welfareid(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional int32 welfareInfoID = 3;
  if (has_welfareinfoid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->welfareinfoid(), output);
  }

  // optional int32 limitLv = 4;
  if (has_limitlv()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->limitlv(), output);
  }

  // optional int32 limitDay = 5;
  if (has_limitday()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->limitday(), output);
  }

  // optional int32 limitContri = 6;
  if (has_limitcontri()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->limitcontri(), output);
  }

  // optional int32 num = 7;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->num(), output);
  }

  // optional int32 isTake = 8;
  if (has_istake()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->istake(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClanWelfare::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 welfareID = 1;
  if (has_welfareid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->welfareid(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional int32 welfareInfoID = 3;
  if (has_welfareinfoid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->welfareinfoid(), target);
  }

  // optional int32 limitLv = 4;
  if (has_limitlv()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->limitlv(), target);
  }

  // optional int32 limitDay = 5;
  if (has_limitday()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->limitday(), target);
  }

  // optional int32 limitContri = 6;
  if (has_limitcontri()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->limitcontri(), target);
  }

  // optional int32 num = 7;
  if (has_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->num(), target);
  }

  // optional int32 isTake = 8;
  if (has_istake()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->istake(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClanWelfare::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 welfareID = 1;
    if (has_welfareid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->welfareid());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 welfareInfoID = 3;
    if (has_welfareinfoid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->welfareinfoid());
    }

    // optional int32 limitLv = 4;
    if (has_limitlv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->limitlv());
    }

    // optional int32 limitDay = 5;
    if (has_limitday()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->limitday());
    }

    // optional int32 limitContri = 6;
    if (has_limitcontri()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->limitcontri());
    }

    // optional int32 num = 7;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

    // optional int32 isTake = 8;
    if (has_istake()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->istake());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClanWelfare::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClanWelfare* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClanWelfare*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClanWelfare::MergeFrom(const ClanWelfare& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_welfareid()) {
      set_welfareid(from.welfareid());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_welfareinfoid()) {
      set_welfareinfoid(from.welfareinfoid());
    }
    if (from.has_limitlv()) {
      set_limitlv(from.limitlv());
    }
    if (from.has_limitday()) {
      set_limitday(from.limitday());
    }
    if (from.has_limitcontri()) {
      set_limitcontri(from.limitcontri());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
    if (from.has_istake()) {
      set_istake(from.istake());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClanWelfare::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClanWelfare::CopyFrom(const ClanWelfare& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClanWelfare::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClanWelfare::Swap(ClanWelfare* other) {
  if (other != this) {
    std::swap(welfareid_, other->welfareid_);
    std::swap(name_, other->name_);
    std::swap(welfareinfoid_, other->welfareinfoid_);
    std::swap(limitlv_, other->limitlv_);
    std::swap(limitday_, other->limitday_);
    std::swap(limitcontri_, other->limitcontri_);
    std::swap(num_, other->num_);
    std::swap(istake_, other->istake_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClanWelfare::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClanWelfare_descriptor_;
  metadata.reflection = ClanWelfare_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SendClanWelfare::kWelfareInfoIDFieldNumber;
const int SendClanWelfare::kLvFieldNumber;
const int SendClanWelfare::kDayFieldNumber;
const int SendClanWelfare::kContriFieldNumber;
const int SendClanWelfare::kNumFieldNumber;
#endif  // !_MSC_VER

SendClanWelfare::SendClanWelfare()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SendClanWelfare::InitAsDefaultInstance() {
}

SendClanWelfare::SendClanWelfare(const SendClanWelfare& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SendClanWelfare::SharedCtor() {
  _cached_size_ = 0;
  welfareinfoid_ = 0;
  lv_ = 0;
  day_ = 0;
  contri_ = 0;
  num_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendClanWelfare::~SendClanWelfare() {
  SharedDtor();
}

void SendClanWelfare::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SendClanWelfare::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SendClanWelfare::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SendClanWelfare_descriptor_;
}

const SendClanWelfare& SendClanWelfare::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

SendClanWelfare* SendClanWelfare::default_instance_ = NULL;

SendClanWelfare* SendClanWelfare::New() const {
  return new SendClanWelfare;
}

void SendClanWelfare::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    welfareinfoid_ = 0;
    lv_ = 0;
    day_ = 0;
    contri_ = 0;
    num_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SendClanWelfare::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 welfareInfoID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &welfareinfoid_)));
          set_has_welfareinfoid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_lv;
        break;
      }

      // optional int32 lv = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lv_)));
          set_has_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_day;
        break;
      }

      // optional int32 day = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_day:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &day_)));
          set_has_day();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_contri;
        break;
      }

      // optional int32 contri = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_contri:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &contri_)));
          set_has_contri();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_num;
        break;
      }

      // optional int32 num = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SendClanWelfare::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 welfareInfoID = 1;
  if (has_welfareinfoid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->welfareinfoid(), output);
  }

  // optional int32 lv = 2;
  if (has_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->lv(), output);
  }

  // optional int32 day = 3;
  if (has_day()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->day(), output);
  }

  // optional int32 contri = 4;
  if (has_contri()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->contri(), output);
  }

  // optional int32 num = 5;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->num(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SendClanWelfare::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 welfareInfoID = 1;
  if (has_welfareinfoid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->welfareinfoid(), target);
  }

  // optional int32 lv = 2;
  if (has_lv()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->lv(), target);
  }

  // optional int32 day = 3;
  if (has_day()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->day(), target);
  }

  // optional int32 contri = 4;
  if (has_contri()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->contri(), target);
  }

  // optional int32 num = 5;
  if (has_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->num(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SendClanWelfare::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 welfareInfoID = 1;
    if (has_welfareinfoid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->welfareinfoid());
    }

    // optional int32 lv = 2;
    if (has_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lv());
    }

    // optional int32 day = 3;
    if (has_day()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->day());
    }

    // optional int32 contri = 4;
    if (has_contri()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->contri());
    }

    // optional int32 num = 5;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendClanWelfare::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SendClanWelfare* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SendClanWelfare*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SendClanWelfare::MergeFrom(const SendClanWelfare& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_welfareinfoid()) {
      set_welfareinfoid(from.welfareinfoid());
    }
    if (from.has_lv()) {
      set_lv(from.lv());
    }
    if (from.has_day()) {
      set_day(from.day());
    }
    if (from.has_contri()) {
      set_contri(from.contri());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SendClanWelfare::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SendClanWelfare::CopyFrom(const SendClanWelfare& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendClanWelfare::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SendClanWelfare::Swap(SendClanWelfare* other) {
  if (other != this) {
    std::swap(welfareinfoid_, other->welfareinfoid_);
    std::swap(lv_, other->lv_);
    std::swap(day_, other->day_);
    std::swap(contri_, other->contri_);
    std::swap(num_, other->num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SendClanWelfare::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SendClanWelfare_descriptor_;
  metadata.reflection = SendClanWelfare_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TakeClanWelfare::kWelfareIDFieldNumber;
#endif  // !_MSC_VER

TakeClanWelfare::TakeClanWelfare()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TakeClanWelfare::InitAsDefaultInstance() {
}

TakeClanWelfare::TakeClanWelfare(const TakeClanWelfare& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TakeClanWelfare::SharedCtor() {
  _cached_size_ = 0;
  welfareid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TakeClanWelfare::~TakeClanWelfare() {
  SharedDtor();
}

void TakeClanWelfare::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TakeClanWelfare::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TakeClanWelfare::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TakeClanWelfare_descriptor_;
}

const TakeClanWelfare& TakeClanWelfare::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

TakeClanWelfare* TakeClanWelfare::default_instance_ = NULL;

TakeClanWelfare* TakeClanWelfare::New() const {
  return new TakeClanWelfare;
}

void TakeClanWelfare::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    welfareid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TakeClanWelfare::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 welfareID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &welfareid_)));
          set_has_welfareid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TakeClanWelfare::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 welfareID = 1;
  if (has_welfareid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->welfareid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TakeClanWelfare::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 welfareID = 1;
  if (has_welfareid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->welfareid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TakeClanWelfare::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 welfareID = 1;
    if (has_welfareid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->welfareid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TakeClanWelfare::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TakeClanWelfare* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TakeClanWelfare*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TakeClanWelfare::MergeFrom(const TakeClanWelfare& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_welfareid()) {
      set_welfareid(from.welfareid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TakeClanWelfare::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TakeClanWelfare::CopyFrom(const TakeClanWelfare& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TakeClanWelfare::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TakeClanWelfare::Swap(TakeClanWelfare* other) {
  if (other != this) {
    std::swap(welfareid_, other->welfareid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TakeClanWelfare::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TakeClanWelfare_descriptor_;
  metadata.reflection = TakeClanWelfare_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RetTakeClanWelfare::kErrFieldNumber;
const int RetTakeClanWelfare::kWelfareFieldNumber;
#endif  // !_MSC_VER

RetTakeClanWelfare::RetTakeClanWelfare()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RetTakeClanWelfare::InitAsDefaultInstance() {
  welfare_ = const_cast< ::ClanPackage::ClanWelfare*>(&::ClanPackage::ClanWelfare::default_instance());
}

RetTakeClanWelfare::RetTakeClanWelfare(const RetTakeClanWelfare& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RetTakeClanWelfare::SharedCtor() {
  _cached_size_ = 0;
  err_ = 0;
  welfare_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RetTakeClanWelfare::~RetTakeClanWelfare() {
  SharedDtor();
}

void RetTakeClanWelfare::SharedDtor() {
  if (this != default_instance_) {
    delete welfare_;
  }
}

void RetTakeClanWelfare::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RetTakeClanWelfare::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RetTakeClanWelfare_descriptor_;
}

const RetTakeClanWelfare& RetTakeClanWelfare::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

RetTakeClanWelfare* RetTakeClanWelfare::default_instance_ = NULL;

RetTakeClanWelfare* RetTakeClanWelfare::New() const {
  return new RetTakeClanWelfare;
}

void RetTakeClanWelfare::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    err_ = 0;
    if (has_welfare()) {
      if (welfare_ != NULL) welfare_->::ClanPackage::ClanWelfare::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RetTakeClanWelfare::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 err = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &err_)));
          set_has_err();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_welfare;
        break;
      }

      // optional .ClanPackage.ClanWelfare welfare = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_welfare:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_welfare()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RetTakeClanWelfare::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 err = 1;
  if (has_err()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->err(), output);
  }

  // optional .ClanPackage.ClanWelfare welfare = 2;
  if (has_welfare()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->welfare(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RetTakeClanWelfare::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 err = 1;
  if (has_err()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->err(), target);
  }

  // optional .ClanPackage.ClanWelfare welfare = 2;
  if (has_welfare()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->welfare(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RetTakeClanWelfare::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 err = 1;
    if (has_err()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->err());
    }

    // optional .ClanPackage.ClanWelfare welfare = 2;
    if (has_welfare()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->welfare());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RetTakeClanWelfare::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RetTakeClanWelfare* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RetTakeClanWelfare*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RetTakeClanWelfare::MergeFrom(const RetTakeClanWelfare& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_err()) {
      set_err(from.err());
    }
    if (from.has_welfare()) {
      mutable_welfare()->::ClanPackage::ClanWelfare::MergeFrom(from.welfare());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RetTakeClanWelfare::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RetTakeClanWelfare::CopyFrom(const RetTakeClanWelfare& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RetTakeClanWelfare::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_welfare()) {
    if (!this->welfare().IsInitialized()) return false;
  }
  return true;
}

void RetTakeClanWelfare::Swap(RetTakeClanWelfare* other) {
  if (other != this) {
    std::swap(err_, other->err_);
    std::swap(welfare_, other->welfare_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RetTakeClanWelfare::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RetTakeClanWelfare_descriptor_;
  metadata.reflection = RetTakeClanWelfare_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ClientReqBackClanMap::ClientReqBackClanMap()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqBackClanMap::InitAsDefaultInstance() {
}

ClientReqBackClanMap::ClientReqBackClanMap(const ClientReqBackClanMap& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqBackClanMap::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqBackClanMap::~ClientReqBackClanMap() {
  SharedDtor();
}

void ClientReqBackClanMap::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqBackClanMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqBackClanMap::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqBackClanMap_descriptor_;
}

const ClientReqBackClanMap& ClientReqBackClanMap::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqBackClanMap* ClientReqBackClanMap::default_instance_ = NULL;

ClientReqBackClanMap* ClientReqBackClanMap::New() const {
  return new ClientReqBackClanMap;
}

void ClientReqBackClanMap::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqBackClanMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void ClientReqBackClanMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqBackClanMap::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqBackClanMap::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqBackClanMap::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqBackClanMap* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqBackClanMap*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqBackClanMap::MergeFrom(const ClientReqBackClanMap& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqBackClanMap::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqBackClanMap::CopyFrom(const ClientReqBackClanMap& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqBackClanMap::IsInitialized() const {

  return true;
}

void ClientReqBackClanMap::Swap(ClientReqBackClanMap* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqBackClanMap::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqBackClanMap_descriptor_;
  metadata.reflection = ClientReqBackClanMap_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckReqBackClanMap::kRetFieldNumber;
const int AckReqBackClanMap::kMapidFieldNumber;
#endif  // !_MSC_VER

AckReqBackClanMap::AckReqBackClanMap()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckReqBackClanMap::InitAsDefaultInstance() {
}

AckReqBackClanMap::AckReqBackClanMap(const AckReqBackClanMap& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckReqBackClanMap::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  mapid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckReqBackClanMap::~AckReqBackClanMap() {
  SharedDtor();
}

void AckReqBackClanMap::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckReqBackClanMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckReqBackClanMap::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckReqBackClanMap_descriptor_;
}

const AckReqBackClanMap& AckReqBackClanMap::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckReqBackClanMap* AckReqBackClanMap::default_instance_ = NULL;

AckReqBackClanMap* AckReqBackClanMap::New() const {
  return new AckReqBackClanMap;
}

void AckReqBackClanMap::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
    mapid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckReqBackClanMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_mapid;
        break;
      }

      // optional int64 mapid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mapid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &mapid_)));
          set_has_mapid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckReqBackClanMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  // optional int64 mapid = 2;
  if (has_mapid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->mapid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckReqBackClanMap::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  // optional int64 mapid = 2;
  if (has_mapid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->mapid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckReqBackClanMap::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional int64 mapid = 2;
    if (has_mapid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->mapid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckReqBackClanMap::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckReqBackClanMap* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckReqBackClanMap*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckReqBackClanMap::MergeFrom(const AckReqBackClanMap& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_mapid()) {
      set_mapid(from.mapid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckReqBackClanMap::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckReqBackClanMap::CopyFrom(const AckReqBackClanMap& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckReqBackClanMap::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckReqBackClanMap::Swap(AckReqBackClanMap* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(mapid_, other->mapid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckReqBackClanMap::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckReqBackClanMap_descriptor_;
  metadata.reflection = AckReqBackClanMap_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckClanSkills::kIdFieldNumber;
#endif  // !_MSC_VER

AckClanSkills::AckClanSkills()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckClanSkills::InitAsDefaultInstance() {
}

AckClanSkills::AckClanSkills(const AckClanSkills& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckClanSkills::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckClanSkills::~AckClanSkills() {
  SharedDtor();
}

void AckClanSkills::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckClanSkills::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckClanSkills::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckClanSkills_descriptor_;
}

const AckClanSkills& AckClanSkills::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckClanSkills* AckClanSkills::default_instance_ = NULL;

AckClanSkills* AckClanSkills::New() const {
  return new AckClanSkills;
}

void AckClanSkills::Clear() {
  id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckClanSkills::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_id())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_id())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_id;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckClanSkills::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int32 id = 1;
  for (int i = 0; i < this->id_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->id(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckClanSkills::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated int32 id = 1;
  for (int i = 0; i < this->id_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(1, this->id(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckClanSkills::ByteSize() const {
  int total_size = 0;

  // repeated int32 id = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->id_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->id(i));
    }
    total_size += 1 * this->id_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckClanSkills::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckClanSkills* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckClanSkills*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckClanSkills::MergeFrom(const AckClanSkills& from) {
  GOOGLE_CHECK_NE(&from, this);
  id_.MergeFrom(from.id_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckClanSkills::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckClanSkills::CopyFrom(const AckClanSkills& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckClanSkills::IsInitialized() const {

  return true;
}

void AckClanSkills::Swap(AckClanSkills* other) {
  if (other != this) {
    id_.Swap(&other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckClanSkills::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckClanSkills_descriptor_;
  metadata.reflection = AckClanSkills_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReqUpGrageClanSkill::kIdFieldNumber;
#endif  // !_MSC_VER

ReqUpGrageClanSkill::ReqUpGrageClanSkill()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReqUpGrageClanSkill::InitAsDefaultInstance() {
}

ReqUpGrageClanSkill::ReqUpGrageClanSkill(const ReqUpGrageClanSkill& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReqUpGrageClanSkill::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqUpGrageClanSkill::~ReqUpGrageClanSkill() {
  SharedDtor();
}

void ReqUpGrageClanSkill::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ReqUpGrageClanSkill::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReqUpGrageClanSkill::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReqUpGrageClanSkill_descriptor_;
}

const ReqUpGrageClanSkill& ReqUpGrageClanSkill::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ReqUpGrageClanSkill* ReqUpGrageClanSkill::default_instance_ = NULL;

ReqUpGrageClanSkill* ReqUpGrageClanSkill::New() const {
  return new ReqUpGrageClanSkill;
}

void ReqUpGrageClanSkill::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReqUpGrageClanSkill::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqUpGrageClanSkill::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReqUpGrageClanSkill::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReqUpGrageClanSkill::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqUpGrageClanSkill::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReqUpGrageClanSkill* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReqUpGrageClanSkill*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReqUpGrageClanSkill::MergeFrom(const ReqUpGrageClanSkill& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReqUpGrageClanSkill::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReqUpGrageClanSkill::CopyFrom(const ReqUpGrageClanSkill& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqUpGrageClanSkill::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqUpGrageClanSkill::Swap(ReqUpGrageClanSkill* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReqUpGrageClanSkill::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReqUpGrageClanSkill_descriptor_;
  metadata.reflection = ReqUpGrageClanSkill_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckUpGradeClanSkill::kRetFieldNumber;
const int AckUpGradeClanSkill::kOldskillFieldNumber;
const int AckUpGradeClanSkill::kNewskillFieldNumber;
#endif  // !_MSC_VER

AckUpGradeClanSkill::AckUpGradeClanSkill()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckUpGradeClanSkill::InitAsDefaultInstance() {
}

AckUpGradeClanSkill::AckUpGradeClanSkill(const AckUpGradeClanSkill& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckUpGradeClanSkill::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  oldskill_ = 0;
  newskill_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckUpGradeClanSkill::~AckUpGradeClanSkill() {
  SharedDtor();
}

void AckUpGradeClanSkill::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckUpGradeClanSkill::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckUpGradeClanSkill::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckUpGradeClanSkill_descriptor_;
}

const AckUpGradeClanSkill& AckUpGradeClanSkill::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckUpGradeClanSkill* AckUpGradeClanSkill::default_instance_ = NULL;

AckUpGradeClanSkill* AckUpGradeClanSkill::New() const {
  return new AckUpGradeClanSkill;
}

void AckUpGradeClanSkill::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
    oldskill_ = 0;
    newskill_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckUpGradeClanSkill::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_oldskill;
        break;
      }

      // optional int32 oldskill = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_oldskill:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &oldskill_)));
          set_has_oldskill();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_newskill;
        break;
      }

      // optional int32 newskill = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_newskill:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &newskill_)));
          set_has_newskill();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckUpGradeClanSkill::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  // optional int32 oldskill = 2;
  if (has_oldskill()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->oldskill(), output);
  }

  // optional int32 newskill = 3;
  if (has_newskill()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->newskill(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckUpGradeClanSkill::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  // optional int32 oldskill = 2;
  if (has_oldskill()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->oldskill(), target);
  }

  // optional int32 newskill = 3;
  if (has_newskill()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->newskill(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckUpGradeClanSkill::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional int32 oldskill = 2;
    if (has_oldskill()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->oldskill());
    }

    // optional int32 newskill = 3;
    if (has_newskill()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->newskill());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckUpGradeClanSkill::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckUpGradeClanSkill* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckUpGradeClanSkill*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckUpGradeClanSkill::MergeFrom(const AckUpGradeClanSkill& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_oldskill()) {
      set_oldskill(from.oldskill());
    }
    if (from.has_newskill()) {
      set_newskill(from.newskill());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckUpGradeClanSkill::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckUpGradeClanSkill::CopyFrom(const AckUpGradeClanSkill& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckUpGradeClanSkill::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckUpGradeClanSkill::Swap(AckUpGradeClanSkill* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(oldskill_, other->oldskill_);
    std::swap(newskill_, other->newskill_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckUpGradeClanSkill::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckUpGradeClanSkill_descriptor_;
  metadata.reflection = AckUpGradeClanSkill_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Ws2GsRobberActive::kFlagFieldNumber;
const int Ws2GsRobberActive::kInfoFieldNumber;
#endif  // !_MSC_VER

Ws2GsRobberActive::Ws2GsRobberActive()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Ws2GsRobberActive::InitAsDefaultInstance() {
}

Ws2GsRobberActive::Ws2GsRobberActive(const Ws2GsRobberActive& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Ws2GsRobberActive::SharedCtor() {
  _cached_size_ = 0;
  flag_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Ws2GsRobberActive::~Ws2GsRobberActive() {
  SharedDtor();
}

void Ws2GsRobberActive::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Ws2GsRobberActive::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Ws2GsRobberActive::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Ws2GsRobberActive_descriptor_;
}

const Ws2GsRobberActive& Ws2GsRobberActive::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

Ws2GsRobberActive* Ws2GsRobberActive::default_instance_ = NULL;

Ws2GsRobberActive* Ws2GsRobberActive::New() const {
  return new Ws2GsRobberActive;
}

void Ws2GsRobberActive::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    flag_ = false;
  }
  info_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Ws2GsRobberActive::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool flag = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &flag_)));
          set_has_flag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_info;
        break;
      }

      // repeated .ClanPackage.ClanMapInfo info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_info;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Ws2GsRobberActive::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool flag = 1;
  if (has_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->flag(), output);
  }

  // repeated .ClanPackage.ClanMapInfo info = 2;
  for (int i = 0; i < this->info_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->info(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Ws2GsRobberActive::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool flag = 1;
  if (has_flag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->flag(), target);
  }

  // repeated .ClanPackage.ClanMapInfo info = 2;
  for (int i = 0; i < this->info_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->info(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Ws2GsRobberActive::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool flag = 1;
    if (has_flag()) {
      total_size += 1 + 1;
    }

  }
  // repeated .ClanPackage.ClanMapInfo info = 2;
  total_size += 1 * this->info_size();
  for (int i = 0; i < this->info_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->info(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Ws2GsRobberActive::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Ws2GsRobberActive* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Ws2GsRobberActive*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Ws2GsRobberActive::MergeFrom(const Ws2GsRobberActive& from) {
  GOOGLE_CHECK_NE(&from, this);
  info_.MergeFrom(from.info_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_flag()) {
      set_flag(from.flag());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Ws2GsRobberActive::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Ws2GsRobberActive::CopyFrom(const Ws2GsRobberActive& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ws2GsRobberActive::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < info_size(); i++) {
    if (!this->info(i).IsInitialized()) return false;
  }
  return true;
}

void Ws2GsRobberActive::Swap(Ws2GsRobberActive* other) {
  if (other != this) {
    std::swap(flag_, other->flag_);
    info_.Swap(&other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Ws2GsRobberActive::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Ws2GsRobberActive_descriptor_;
  metadata.reflection = Ws2GsRobberActive_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClanMapInfo::kClanidFieldNumber;
const int ClanMapInfo::kMapidFieldNumber;
const int ClanMapInfo::kWinFieldNumber;
const int ClanMapInfo::kParamFieldNumber;
const int ClanMapInfo::kConwinFieldNumber;
const int ClanMapInfo::kConfailFieldNumber;
#endif  // !_MSC_VER

ClanMapInfo::ClanMapInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClanMapInfo::InitAsDefaultInstance() {
}

ClanMapInfo::ClanMapInfo(const ClanMapInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClanMapInfo::SharedCtor() {
  _cached_size_ = 0;
  clanid_ = 0;
  mapid_ = GOOGLE_LONGLONG(0);
  win_ = false;
  param_ = 0;
  conwin_ = 0;
  confail_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClanMapInfo::~ClanMapInfo() {
  SharedDtor();
}

void ClanMapInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClanMapInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClanMapInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClanMapInfo_descriptor_;
}

const ClanMapInfo& ClanMapInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClanMapInfo* ClanMapInfo::default_instance_ = NULL;

ClanMapInfo* ClanMapInfo::New() const {
  return new ClanMapInfo;
}

void ClanMapInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    clanid_ = 0;
    mapid_ = GOOGLE_LONGLONG(0);
    win_ = false;
    param_ = 0;
    conwin_ = 0;
    confail_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClanMapInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 clanid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &clanid_)));
          set_has_clanid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_mapid;
        break;
      }

      // optional int64 mapid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mapid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &mapid_)));
          set_has_mapid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_win;
        break;
      }

      // optional bool win = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_win:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &win_)));
          set_has_win();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_param;
        break;
      }

      // optional int32 param = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_param:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &param_)));
          set_has_param();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_conwin;
        break;
      }

      // optional int32 conwin = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_conwin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &conwin_)));
          set_has_conwin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_confail;
        break;
      }

      // optional int32 confail = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_confail:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &confail_)));
          set_has_confail();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClanMapInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 clanid = 1;
  if (has_clanid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->clanid(), output);
  }

  // optional int64 mapid = 2;
  if (has_mapid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->mapid(), output);
  }

  // optional bool win = 3;
  if (has_win()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->win(), output);
  }

  // optional int32 param = 4;
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->param(), output);
  }

  // optional int32 conwin = 5;
  if (has_conwin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->conwin(), output);
  }

  // optional int32 confail = 6;
  if (has_confail()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->confail(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClanMapInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 clanid = 1;
  if (has_clanid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->clanid(), target);
  }

  // optional int64 mapid = 2;
  if (has_mapid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->mapid(), target);
  }

  // optional bool win = 3;
  if (has_win()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->win(), target);
  }

  // optional int32 param = 4;
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->param(), target);
  }

  // optional int32 conwin = 5;
  if (has_conwin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->conwin(), target);
  }

  // optional int32 confail = 6;
  if (has_confail()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->confail(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClanMapInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 clanid = 1;
    if (has_clanid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->clanid());
    }

    // optional int64 mapid = 2;
    if (has_mapid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->mapid());
    }

    // optional bool win = 3;
    if (has_win()) {
      total_size += 1 + 1;
    }

    // optional int32 param = 4;
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->param());
    }

    // optional int32 conwin = 5;
    if (has_conwin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->conwin());
    }

    // optional int32 confail = 6;
    if (has_confail()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->confail());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClanMapInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClanMapInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClanMapInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClanMapInfo::MergeFrom(const ClanMapInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_clanid()) {
      set_clanid(from.clanid());
    }
    if (from.has_mapid()) {
      set_mapid(from.mapid());
    }
    if (from.has_win()) {
      set_win(from.win());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_conwin()) {
      set_conwin(from.conwin());
    }
    if (from.has_confail()) {
      set_confail(from.confail());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClanMapInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClanMapInfo::CopyFrom(const ClanMapInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClanMapInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClanMapInfo::Swap(ClanMapInfo* other) {
  if (other != this) {
    std::swap(clanid_, other->clanid_);
    std::swap(mapid_, other->mapid_);
    std::swap(win_, other->win_);
    std::swap(param_, other->param_);
    std::swap(conwin_, other->conwin_);
    std::swap(confail_, other->confail_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClanMapInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClanMapInfo_descriptor_;
  metadata.reflection = ClanMapInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Ws2GsDestroyClanMap::kClanidFieldNumber;
const int Ws2GsDestroyClanMap::kMapidFieldNumber;
#endif  // !_MSC_VER

Ws2GsDestroyClanMap::Ws2GsDestroyClanMap()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Ws2GsDestroyClanMap::InitAsDefaultInstance() {
}

Ws2GsDestroyClanMap::Ws2GsDestroyClanMap(const Ws2GsDestroyClanMap& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Ws2GsDestroyClanMap::SharedCtor() {
  _cached_size_ = 0;
  clanid_ = 0;
  mapid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Ws2GsDestroyClanMap::~Ws2GsDestroyClanMap() {
  SharedDtor();
}

void Ws2GsDestroyClanMap::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Ws2GsDestroyClanMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Ws2GsDestroyClanMap::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Ws2GsDestroyClanMap_descriptor_;
}

const Ws2GsDestroyClanMap& Ws2GsDestroyClanMap::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

Ws2GsDestroyClanMap* Ws2GsDestroyClanMap::default_instance_ = NULL;

Ws2GsDestroyClanMap* Ws2GsDestroyClanMap::New() const {
  return new Ws2GsDestroyClanMap;
}

void Ws2GsDestroyClanMap::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    clanid_ = 0;
    mapid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Ws2GsDestroyClanMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 clanid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &clanid_)));
          set_has_clanid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_mapid;
        break;
      }

      // optional int64 mapid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mapid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &mapid_)));
          set_has_mapid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Ws2GsDestroyClanMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 clanid = 1;
  if (has_clanid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->clanid(), output);
  }

  // optional int64 mapid = 2;
  if (has_mapid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->mapid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Ws2GsDestroyClanMap::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 clanid = 1;
  if (has_clanid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->clanid(), target);
  }

  // optional int64 mapid = 2;
  if (has_mapid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->mapid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Ws2GsDestroyClanMap::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 clanid = 1;
    if (has_clanid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->clanid());
    }

    // optional int64 mapid = 2;
    if (has_mapid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->mapid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Ws2GsDestroyClanMap::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Ws2GsDestroyClanMap* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Ws2GsDestroyClanMap*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Ws2GsDestroyClanMap::MergeFrom(const Ws2GsDestroyClanMap& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_clanid()) {
      set_clanid(from.clanid());
    }
    if (from.has_mapid()) {
      set_mapid(from.mapid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Ws2GsDestroyClanMap::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Ws2GsDestroyClanMap::CopyFrom(const Ws2GsDestroyClanMap& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ws2GsDestroyClanMap::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Ws2GsDestroyClanMap::Swap(Ws2GsDestroyClanMap* other) {
  if (other != this) {
    std::swap(clanid_, other->clanid_);
    std::swap(mapid_, other->mapid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Ws2GsDestroyClanMap::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Ws2GsDestroyClanMap_descriptor_;
  metadata.reflection = Ws2GsDestroyClanMap_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RobberResult::kClanidFieldNumber;
const int RobberResult::kWinFieldNumber;
const int RobberResult::kParamFieldNumber;
const int RobberResult::kConwinFieldNumber;
const int RobberResult::kConfailFieldNumber;
const int RobberResult::kMoneyFieldNumber;
#endif  // !_MSC_VER

RobberResult::RobberResult()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RobberResult::InitAsDefaultInstance() {
}

RobberResult::RobberResult(const RobberResult& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RobberResult::SharedCtor() {
  _cached_size_ = 0;
  clanid_ = 0;
  win_ = false;
  param_ = 0;
  conwin_ = 0;
  confail_ = 0;
  money_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobberResult::~RobberResult() {
  SharedDtor();
}

void RobberResult::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RobberResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobberResult::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobberResult_descriptor_;
}

const RobberResult& RobberResult::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

RobberResult* RobberResult::default_instance_ = NULL;

RobberResult* RobberResult::New() const {
  return new RobberResult;
}

void RobberResult::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    clanid_ = 0;
    win_ = false;
    param_ = 0;
    conwin_ = 0;
    confail_ = 0;
    money_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RobberResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 clanid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &clanid_)));
          set_has_clanid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_win;
        break;
      }

      // optional bool win = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_win:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &win_)));
          set_has_win();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_param;
        break;
      }

      // optional int32 param = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_param:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &param_)));
          set_has_param();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_conwin;
        break;
      }

      // optional int32 conwin = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_conwin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &conwin_)));
          set_has_conwin();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_confail;
        break;
      }

      // optional int32 confail = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_confail:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &confail_)));
          set_has_confail();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_money;
        break;
      }

      // optional int32 money = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RobberResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 clanid = 1;
  if (has_clanid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->clanid(), output);
  }

  // optional bool win = 2;
  if (has_win()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->win(), output);
  }

  // optional int32 param = 3;
  if (has_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->param(), output);
  }

  // optional int32 conwin = 4;
  if (has_conwin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->conwin(), output);
  }

  // optional int32 confail = 5;
  if (has_confail()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->confail(), output);
  }

  // optional int32 money = 6;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->money(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RobberResult::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 clanid = 1;
  if (has_clanid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->clanid(), target);
  }

  // optional bool win = 2;
  if (has_win()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->win(), target);
  }

  // optional int32 param = 3;
  if (has_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->param(), target);
  }

  // optional int32 conwin = 4;
  if (has_conwin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->conwin(), target);
  }

  // optional int32 confail = 5;
  if (has_confail()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->confail(), target);
  }

  // optional int32 money = 6;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->money(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RobberResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 clanid = 1;
    if (has_clanid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->clanid());
    }

    // optional bool win = 2;
    if (has_win()) {
      total_size += 1 + 1;
    }

    // optional int32 param = 3;
    if (has_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->param());
    }

    // optional int32 conwin = 4;
    if (has_conwin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->conwin());
    }

    // optional int32 confail = 5;
    if (has_confail()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->confail());
    }

    // optional int32 money = 6;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobberResult::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RobberResult* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RobberResult*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RobberResult::MergeFrom(const RobberResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_clanid()) {
      set_clanid(from.clanid());
    }
    if (from.has_win()) {
      set_win(from.win());
    }
    if (from.has_param()) {
      set_param(from.param());
    }
    if (from.has_conwin()) {
      set_conwin(from.conwin());
    }
    if (from.has_confail()) {
      set_confail(from.confail());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RobberResult::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobberResult::CopyFrom(const RobberResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobberResult::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RobberResult::Swap(RobberResult* other) {
  if (other != this) {
    std::swap(clanid_, other->clanid_);
    std::swap(win_, other->win_);
    std::swap(param_, other->param_);
    std::swap(conwin_, other->conwin_);
    std::swap(confail_, other->confail_);
    std::swap(money_, other->money_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RobberResult::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobberResult_descriptor_;
  metadata.reflection = RobberResult_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientReqChanceJoinClan::kIdFieldNumber;
#endif  // !_MSC_VER

ClientReqChanceJoinClan::ClientReqChanceJoinClan()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientReqChanceJoinClan::InitAsDefaultInstance() {
}

ClientReqChanceJoinClan::ClientReqChanceJoinClan(const ClientReqChanceJoinClan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientReqChanceJoinClan::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientReqChanceJoinClan::~ClientReqChanceJoinClan() {
  SharedDtor();
}

void ClientReqChanceJoinClan::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientReqChanceJoinClan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientReqChanceJoinClan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientReqChanceJoinClan_descriptor_;
}

const ClientReqChanceJoinClan& ClientReqChanceJoinClan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

ClientReqChanceJoinClan* ClientReqChanceJoinClan::default_instance_ = NULL;

ClientReqChanceJoinClan* ClientReqChanceJoinClan::New() const {
  return new ClientReqChanceJoinClan;
}

void ClientReqChanceJoinClan::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientReqChanceJoinClan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientReqChanceJoinClan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientReqChanceJoinClan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientReqChanceJoinClan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientReqChanceJoinClan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientReqChanceJoinClan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientReqChanceJoinClan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientReqChanceJoinClan::MergeFrom(const ClientReqChanceJoinClan& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientReqChanceJoinClan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientReqChanceJoinClan::CopyFrom(const ClientReqChanceJoinClan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientReqChanceJoinClan::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientReqChanceJoinClan::Swap(ClientReqChanceJoinClan* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientReqChanceJoinClan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientReqChanceJoinClan_descriptor_;
  metadata.reflection = ClientReqChanceJoinClan_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckChanceJoinClan::kRetFieldNumber;
const int AckChanceJoinClan::kClanIDFieldNumber;
#endif  // !_MSC_VER

AckChanceJoinClan::AckChanceJoinClan()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckChanceJoinClan::InitAsDefaultInstance() {
}

AckChanceJoinClan::AckChanceJoinClan(const AckChanceJoinClan& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckChanceJoinClan::SharedCtor() {
  _cached_size_ = 0;
  ret_ = 0;
  clanid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckChanceJoinClan::~AckChanceJoinClan() {
  SharedDtor();
}

void AckChanceJoinClan::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckChanceJoinClan::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckChanceJoinClan::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckChanceJoinClan_descriptor_;
}

const AckChanceJoinClan& AckChanceJoinClan::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Clan_2fClan_2eproto();
  return *default_instance_;
}

AckChanceJoinClan* AckChanceJoinClan::default_instance_ = NULL;

AckChanceJoinClan* AckChanceJoinClan::New() const {
  return new AckChanceJoinClan;
}

void AckChanceJoinClan::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = 0;
    clanid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckChanceJoinClan::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_clanID;
        break;
      }

      // optional int32 clanID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_clanID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &clanid_)));
          set_has_clanid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckChanceJoinClan::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ret(), output);
  }

  // optional int32 clanID = 2;
  if (has_clanid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->clanid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckChanceJoinClan::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ret(), target);
  }

  // optional int32 clanID = 2;
  if (has_clanid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->clanid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckChanceJoinClan::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 ret = 1;
    if (has_ret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ret());
    }

    // optional int32 clanID = 2;
    if (has_clanid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->clanid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckChanceJoinClan::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckChanceJoinClan* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckChanceJoinClan*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckChanceJoinClan::MergeFrom(const AckChanceJoinClan& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
    if (from.has_clanid()) {
      set_clanid(from.clanid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckChanceJoinClan::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckChanceJoinClan::CopyFrom(const AckChanceJoinClan& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckChanceJoinClan::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckChanceJoinClan::Swap(AckChanceJoinClan* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(clanid_, other->clanid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckChanceJoinClan::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckChanceJoinClan_descriptor_;
  metadata.reflection = AckChanceJoinClan_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ClanPackage

// @@protoc_insertion_point(global_scope)

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CharLogin/DanLu.proto

#ifndef PROTOBUF_CharLogin_2fDanLu_2eproto__INCLUDED
#define PROTOBUF_CharLogin_2fDanLu_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace DanLuInfo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CharLogin_2fDanLu_2eproto();
void protobuf_AssignDesc_CharLogin_2fDanLu_2eproto();
void protobuf_ShutdownFile_CharLogin_2fDanLu_2eproto();

class DanluStatistics;
class DanLuItemList;
class AckPlayerDanLuInfo;
class ClientDanLuAddExp;
class ClientDanLuEquip;
class RetClientDanLuEquip;
class SmeltItem;
class RetDanluEquip;

// ===================================================================

class DanluStatistics : public ::google::protobuf::Message {
 public:
  DanluStatistics();
  virtual ~DanluStatistics();

  DanluStatistics(const DanluStatistics& from);

  inline DanluStatistics& operator=(const DanluStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DanluStatistics& default_instance();

  void Swap(DanluStatistics* other);

  // implements Message ----------------------------------------------

  DanluStatistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DanluStatistics& from);
  void MergeFrom(const DanluStatistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 multiple = 1;
  inline bool has_multiple() const;
  inline void clear_multiple();
  static const int kMultipleFieldNumber = 1;
  inline ::google::protobuf::int32 multiple() const;
  inline void set_multiple(::google::protobuf::int32 value);

  // optional int32 counts = 2;
  inline bool has_counts() const;
  inline void clear_counts();
  static const int kCountsFieldNumber = 2;
  inline ::google::protobuf::int32 counts() const;
  inline void set_counts(::google::protobuf::int32 value);

  // optional int32 exp = 3;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 3;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DanLuInfo.DanluStatistics)
 private:
  inline void set_has_multiple();
  inline void clear_has_multiple();
  inline void set_has_counts();
  inline void clear_has_counts();
  inline void set_has_exp();
  inline void clear_has_exp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 multiple_;
  ::google::protobuf::int32 counts_;
  ::google::protobuf::int32 exp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fDanLu_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fDanLu_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fDanLu_2eproto();

  void InitAsDefaultInstance();
  static DanluStatistics* default_instance_;
};
// -------------------------------------------------------------------

class DanLuItemList : public ::google::protobuf::Message {
 public:
  DanLuItemList();
  virtual ~DanLuItemList();

  DanLuItemList(const DanLuItemList& from);

  inline DanLuItemList& operator=(const DanLuItemList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DanLuItemList& default_instance();

  void Swap(DanLuItemList* other);

  // implements Message ----------------------------------------------

  DanLuItemList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DanLuItemList& from);
  void MergeFrom(const DanLuItemList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 itemID = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIDFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 counts = 2;
  inline bool has_counts() const;
  inline void clear_counts();
  static const int kCountsFieldNumber = 2;
  inline ::google::protobuf::int32 counts() const;
  inline void set_counts(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DanLuInfo.DanLuItemList)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_counts();
  inline void clear_has_counts();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 counts_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fDanLu_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fDanLu_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fDanLu_2eproto();

  void InitAsDefaultInstance();
  static DanLuItemList* default_instance_;
};
// -------------------------------------------------------------------

class AckPlayerDanLuInfo : public ::google::protobuf::Message {
 public:
  AckPlayerDanLuInfo();
  virtual ~AckPlayerDanLuInfo();

  AckPlayerDanLuInfo(const AckPlayerDanLuInfo& from);

  inline AckPlayerDanLuInfo& operator=(const AckPlayerDanLuInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckPlayerDanLuInfo& default_instance();

  void Swap(AckPlayerDanLuInfo* other);

  // implements Message ----------------------------------------------

  AckPlayerDanLuInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckPlayerDanLuInfo& from);
  void MergeFrom(const AckPlayerDanLuInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 exp = 3;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 3;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int32 point = 4;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 4;
  inline ::google::protobuf::int32 point() const;
  inline void set_point(::google::protobuf::int32 value);

  // repeated .DanLuInfo.SmeltItem item = 5;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 5;
  inline const ::DanLuInfo::SmeltItem& item(int index) const;
  inline ::DanLuInfo::SmeltItem* mutable_item(int index);
  inline ::DanLuInfo::SmeltItem* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::DanLuInfo::SmeltItem >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::DanLuInfo::SmeltItem >*
      mutable_item();

  // repeated .DanLuInfo.DanluStatistics statisticsList = 6;
  inline int statisticslist_size() const;
  inline void clear_statisticslist();
  static const int kStatisticsListFieldNumber = 6;
  inline const ::DanLuInfo::DanluStatistics& statisticslist(int index) const;
  inline ::DanLuInfo::DanluStatistics* mutable_statisticslist(int index);
  inline ::DanLuInfo::DanluStatistics* add_statisticslist();
  inline const ::google::protobuf::RepeatedPtrField< ::DanLuInfo::DanluStatistics >&
      statisticslist() const;
  inline ::google::protobuf::RepeatedPtrField< ::DanLuInfo::DanluStatistics >*
      mutable_statisticslist();

  // optional int32 addAllExp = 7;
  inline bool has_addallexp() const;
  inline void clear_addallexp();
  static const int kAddAllExpFieldNumber = 7;
  inline ::google::protobuf::int32 addallexp() const;
  inline void set_addallexp(::google::protobuf::int32 value);

  // repeated .DanLuInfo.DanLuItemList itemList = 8;
  inline int itemlist_size() const;
  inline void clear_itemlist();
  static const int kItemListFieldNumber = 8;
  inline const ::DanLuInfo::DanLuItemList& itemlist(int index) const;
  inline ::DanLuInfo::DanLuItemList* mutable_itemlist(int index);
  inline ::DanLuInfo::DanLuItemList* add_itemlist();
  inline const ::google::protobuf::RepeatedPtrField< ::DanLuInfo::DanLuItemList >&
      itemlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::DanLuInfo::DanLuItemList >*
      mutable_itemlist();

  // optional int32 golden = 9;
  inline bool has_golden() const;
  inline void clear_golden();
  static const int kGoldenFieldNumber = 9;
  inline ::google::protobuf::int32 golden() const;
  inline void set_golden(::google::protobuf::int32 value);

  // optional int32 money = 10;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 10;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 stopError = 12;
  inline bool has_stoperror() const;
  inline void clear_stoperror();
  static const int kStopErrorFieldNumber = 12;
  inline ::google::protobuf::int32 stoperror() const;
  inline void set_stoperror(::google::protobuf::int32 value);

  // optional int32 type = 13;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 13;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DanLuInfo.AckPlayerDanLuInfo)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_addallexp();
  inline void clear_has_addallexp();
  inline void set_has_golden();
  inline void clear_has_golden();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_stoperror();
  inline void clear_has_stoperror();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int32 point_;
  ::google::protobuf::RepeatedPtrField< ::DanLuInfo::SmeltItem > item_;
  ::google::protobuf::RepeatedPtrField< ::DanLuInfo::DanluStatistics > statisticslist_;
  ::google::protobuf::RepeatedPtrField< ::DanLuInfo::DanLuItemList > itemlist_;
  ::google::protobuf::int32 addallexp_;
  ::google::protobuf::int32 golden_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 stoperror_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fDanLu_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fDanLu_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fDanLu_2eproto();

  void InitAsDefaultInstance();
  static AckPlayerDanLuInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClientDanLuAddExp : public ::google::protobuf::Message {
 public:
  ClientDanLuAddExp();
  virtual ~ClientDanLuAddExp();

  ClientDanLuAddExp(const ClientDanLuAddExp& from);

  inline ClientDanLuAddExp& operator=(const ClientDanLuAddExp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientDanLuAddExp& default_instance();

  void Swap(ClientDanLuAddExp* other);

  // implements Message ----------------------------------------------

  ClientDanLuAddExp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientDanLuAddExp& from);
  void MergeFrom(const ClientDanLuAddExp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional bool isAutoBuy = 2;
  inline bool has_isautobuy() const;
  inline void clear_isautobuy();
  static const int kIsAutoBuyFieldNumber = 2;
  inline bool isautobuy() const;
  inline void set_isautobuy(bool value);

  // optional int32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DanLuInfo.ClientDanLuAddExp)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_isautobuy();
  inline void clear_has_isautobuy();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;
  bool isautobuy_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fDanLu_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fDanLu_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fDanLu_2eproto();

  void InitAsDefaultInstance();
  static ClientDanLuAddExp* default_instance_;
};
// -------------------------------------------------------------------

class ClientDanLuEquip : public ::google::protobuf::Message {
 public:
  ClientDanLuEquip();
  virtual ~ClientDanLuEquip();

  ClientDanLuEquip(const ClientDanLuEquip& from);

  inline ClientDanLuEquip& operator=(const ClientDanLuEquip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientDanLuEquip& default_instance();

  void Swap(ClientDanLuEquip* other);

  // implements Message ----------------------------------------------

  ClientDanLuEquip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientDanLuEquip& from);
  void MergeFrom(const ClientDanLuEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 goodID = 1;
  inline int goodid_size() const;
  inline void clear_goodid();
  static const int kGoodIDFieldNumber = 1;
  inline ::google::protobuf::int32 goodid(int index) const;
  inline void set_goodid(int index, ::google::protobuf::int32 value);
  inline void add_goodid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      goodid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_goodid();

  // repeated int32 num = 2;
  inline int num_size() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num(int index) const;
  inline void set_num(int index, ::google::protobuf::int32 value);
  inline void add_num(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      num() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_num();

  // @@protoc_insertion_point(class_scope:DanLuInfo.ClientDanLuEquip)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > goodid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fDanLu_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fDanLu_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fDanLu_2eproto();

  void InitAsDefaultInstance();
  static ClientDanLuEquip* default_instance_;
};
// -------------------------------------------------------------------

class RetClientDanLuEquip : public ::google::protobuf::Message {
 public:
  RetClientDanLuEquip();
  virtual ~RetClientDanLuEquip();

  RetClientDanLuEquip(const RetClientDanLuEquip& from);

  inline RetClientDanLuEquip& operator=(const RetClientDanLuEquip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RetClientDanLuEquip& default_instance();

  void Swap(RetClientDanLuEquip* other);

  // implements Message ----------------------------------------------

  RetClientDanLuEquip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetClientDanLuEquip& from);
  void MergeFrom(const RetClientDanLuEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 point = 2;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 2;
  inline ::google::protobuf::int32 point() const;
  inline void set_point(::google::protobuf::int32 value);

  // repeated .DanLuInfo.SmeltItem item = 3;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 3;
  inline const ::DanLuInfo::SmeltItem& item(int index) const;
  inline ::DanLuInfo::SmeltItem* mutable_item(int index);
  inline ::DanLuInfo::SmeltItem* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::DanLuInfo::SmeltItem >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::DanLuInfo::SmeltItem >*
      mutable_item();

  // repeated .DanLuInfo.DanLuItemList itemList = 4;
  inline int itemlist_size() const;
  inline void clear_itemlist();
  static const int kItemListFieldNumber = 4;
  inline const ::DanLuInfo::DanLuItemList& itemlist(int index) const;
  inline ::DanLuInfo::DanLuItemList* mutable_itemlist(int index);
  inline ::DanLuInfo::DanLuItemList* add_itemlist();
  inline const ::google::protobuf::RepeatedPtrField< ::DanLuInfo::DanLuItemList >&
      itemlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::DanLuInfo::DanLuItemList >*
      mutable_itemlist();

  // @@protoc_insertion_point(class_scope:DanLuInfo.RetClientDanLuEquip)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_point();
  inline void clear_has_point();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 point_;
  ::google::protobuf::RepeatedPtrField< ::DanLuInfo::SmeltItem > item_;
  ::google::protobuf::RepeatedPtrField< ::DanLuInfo::DanLuItemList > itemlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fDanLu_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fDanLu_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fDanLu_2eproto();

  void InitAsDefaultInstance();
  static RetClientDanLuEquip* default_instance_;
};
// -------------------------------------------------------------------

class SmeltItem : public ::google::protobuf::Message {
 public:
  SmeltItem();
  virtual ~SmeltItem();

  SmeltItem(const SmeltItem& from);

  inline SmeltItem& operator=(const SmeltItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SmeltItem& default_instance();

  void Swap(SmeltItem* other);

  // implements Message ----------------------------------------------

  SmeltItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SmeltItem& from);
  void MergeFrom(const SmeltItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 itemID = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIDFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 itemNum = 2;
  inline bool has_itemnum() const;
  inline void clear_itemnum();
  static const int kItemNumFieldNumber = 2;
  inline ::google::protobuf::int32 itemnum() const;
  inline void set_itemnum(::google::protobuf::int32 value);

  // optional int32 itemPos = 3;
  inline bool has_itempos() const;
  inline void clear_itempos();
  static const int kItemPosFieldNumber = 3;
  inline ::google::protobuf::int32 itempos() const;
  inline void set_itempos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DanLuInfo.SmeltItem)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_itemnum();
  inline void clear_has_itemnum();
  inline void set_has_itempos();
  inline void clear_has_itempos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 itemnum_;
  ::google::protobuf::int32 itempos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fDanLu_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fDanLu_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fDanLu_2eproto();

  void InitAsDefaultInstance();
  static SmeltItem* default_instance_;
};
// -------------------------------------------------------------------

class RetDanluEquip : public ::google::protobuf::Message {
 public:
  RetDanluEquip();
  virtual ~RetDanluEquip();

  RetDanluEquip(const RetDanluEquip& from);

  inline RetDanluEquip& operator=(const RetDanluEquip& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RetDanluEquip& default_instance();

  void Swap(RetDanluEquip* other);

  // implements Message ----------------------------------------------

  RetDanluEquip* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetDanluEquip& from);
  void MergeFrom(const RetDanluEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int64 goods = 2;
  inline bool has_goods() const;
  inline void clear_goods();
  static const int kGoodsFieldNumber = 2;
  inline ::google::protobuf::int64 goods() const;
  inline void set_goods(::google::protobuf::int64 value);

  // optional int32 number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DanLuInfo.RetDanluEquip)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_goods();
  inline void clear_has_goods();
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 goods_;
  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fDanLu_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fDanLu_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fDanLu_2eproto();

  void InitAsDefaultInstance();
  static RetDanluEquip* default_instance_;
};
// ===================================================================


// ===================================================================

// DanluStatistics

// optional int32 multiple = 1;
inline bool DanluStatistics::has_multiple() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DanluStatistics::set_has_multiple() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DanluStatistics::clear_has_multiple() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DanluStatistics::clear_multiple() {
  multiple_ = 0;
  clear_has_multiple();
}
inline ::google::protobuf::int32 DanluStatistics::multiple() const {
  return multiple_;
}
inline void DanluStatistics::set_multiple(::google::protobuf::int32 value) {
  set_has_multiple();
  multiple_ = value;
}

// optional int32 counts = 2;
inline bool DanluStatistics::has_counts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DanluStatistics::set_has_counts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DanluStatistics::clear_has_counts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DanluStatistics::clear_counts() {
  counts_ = 0;
  clear_has_counts();
}
inline ::google::protobuf::int32 DanluStatistics::counts() const {
  return counts_;
}
inline void DanluStatistics::set_counts(::google::protobuf::int32 value) {
  set_has_counts();
  counts_ = value;
}

// optional int32 exp = 3;
inline bool DanluStatistics::has_exp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DanluStatistics::set_has_exp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DanluStatistics::clear_has_exp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DanluStatistics::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 DanluStatistics::exp() const {
  return exp_;
}
inline void DanluStatistics::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// -------------------------------------------------------------------

// DanLuItemList

// optional int32 itemID = 1;
inline bool DanLuItemList::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DanLuItemList::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DanLuItemList::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DanLuItemList::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 DanLuItemList::itemid() const {
  return itemid_;
}
inline void DanLuItemList::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 counts = 2;
inline bool DanLuItemList::has_counts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DanLuItemList::set_has_counts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DanLuItemList::clear_has_counts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DanLuItemList::clear_counts() {
  counts_ = 0;
  clear_has_counts();
}
inline ::google::protobuf::int32 DanLuItemList::counts() const {
  return counts_;
}
inline void DanLuItemList::set_counts(::google::protobuf::int32 value) {
  set_has_counts();
  counts_ = value;
}

// -------------------------------------------------------------------

// AckPlayerDanLuInfo

// required int32 ret = 1;
inline bool AckPlayerDanLuInfo::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckPlayerDanLuInfo::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckPlayerDanLuInfo::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckPlayerDanLuInfo::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 AckPlayerDanLuInfo::ret() const {
  return ret_;
}
inline void AckPlayerDanLuInfo::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 id = 2;
inline bool AckPlayerDanLuInfo::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckPlayerDanLuInfo::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckPlayerDanLuInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckPlayerDanLuInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 AckPlayerDanLuInfo::id() const {
  return id_;
}
inline void AckPlayerDanLuInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 exp = 3;
inline bool AckPlayerDanLuInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckPlayerDanLuInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckPlayerDanLuInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckPlayerDanLuInfo::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 AckPlayerDanLuInfo::exp() const {
  return exp_;
}
inline void AckPlayerDanLuInfo::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 point = 4;
inline bool AckPlayerDanLuInfo::has_point() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckPlayerDanLuInfo::set_has_point() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckPlayerDanLuInfo::clear_has_point() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckPlayerDanLuInfo::clear_point() {
  point_ = 0;
  clear_has_point();
}
inline ::google::protobuf::int32 AckPlayerDanLuInfo::point() const {
  return point_;
}
inline void AckPlayerDanLuInfo::set_point(::google::protobuf::int32 value) {
  set_has_point();
  point_ = value;
}

// repeated .DanLuInfo.SmeltItem item = 5;
inline int AckPlayerDanLuInfo::item_size() const {
  return item_.size();
}
inline void AckPlayerDanLuInfo::clear_item() {
  item_.Clear();
}
inline const ::DanLuInfo::SmeltItem& AckPlayerDanLuInfo::item(int index) const {
  return item_.Get(index);
}
inline ::DanLuInfo::SmeltItem* AckPlayerDanLuInfo::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::DanLuInfo::SmeltItem* AckPlayerDanLuInfo::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DanLuInfo::SmeltItem >&
AckPlayerDanLuInfo::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::DanLuInfo::SmeltItem >*
AckPlayerDanLuInfo::mutable_item() {
  return &item_;
}

// repeated .DanLuInfo.DanluStatistics statisticsList = 6;
inline int AckPlayerDanLuInfo::statisticslist_size() const {
  return statisticslist_.size();
}
inline void AckPlayerDanLuInfo::clear_statisticslist() {
  statisticslist_.Clear();
}
inline const ::DanLuInfo::DanluStatistics& AckPlayerDanLuInfo::statisticslist(int index) const {
  return statisticslist_.Get(index);
}
inline ::DanLuInfo::DanluStatistics* AckPlayerDanLuInfo::mutable_statisticslist(int index) {
  return statisticslist_.Mutable(index);
}
inline ::DanLuInfo::DanluStatistics* AckPlayerDanLuInfo::add_statisticslist() {
  return statisticslist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DanLuInfo::DanluStatistics >&
AckPlayerDanLuInfo::statisticslist() const {
  return statisticslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::DanLuInfo::DanluStatistics >*
AckPlayerDanLuInfo::mutable_statisticslist() {
  return &statisticslist_;
}

// optional int32 addAllExp = 7;
inline bool AckPlayerDanLuInfo::has_addallexp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckPlayerDanLuInfo::set_has_addallexp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckPlayerDanLuInfo::clear_has_addallexp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckPlayerDanLuInfo::clear_addallexp() {
  addallexp_ = 0;
  clear_has_addallexp();
}
inline ::google::protobuf::int32 AckPlayerDanLuInfo::addallexp() const {
  return addallexp_;
}
inline void AckPlayerDanLuInfo::set_addallexp(::google::protobuf::int32 value) {
  set_has_addallexp();
  addallexp_ = value;
}

// repeated .DanLuInfo.DanLuItemList itemList = 8;
inline int AckPlayerDanLuInfo::itemlist_size() const {
  return itemlist_.size();
}
inline void AckPlayerDanLuInfo::clear_itemlist() {
  itemlist_.Clear();
}
inline const ::DanLuInfo::DanLuItemList& AckPlayerDanLuInfo::itemlist(int index) const {
  return itemlist_.Get(index);
}
inline ::DanLuInfo::DanLuItemList* AckPlayerDanLuInfo::mutable_itemlist(int index) {
  return itemlist_.Mutable(index);
}
inline ::DanLuInfo::DanLuItemList* AckPlayerDanLuInfo::add_itemlist() {
  return itemlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DanLuInfo::DanLuItemList >&
AckPlayerDanLuInfo::itemlist() const {
  return itemlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::DanLuInfo::DanLuItemList >*
AckPlayerDanLuInfo::mutable_itemlist() {
  return &itemlist_;
}

// optional int32 golden = 9;
inline bool AckPlayerDanLuInfo::has_golden() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AckPlayerDanLuInfo::set_has_golden() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AckPlayerDanLuInfo::clear_has_golden() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AckPlayerDanLuInfo::clear_golden() {
  golden_ = 0;
  clear_has_golden();
}
inline ::google::protobuf::int32 AckPlayerDanLuInfo::golden() const {
  return golden_;
}
inline void AckPlayerDanLuInfo::set_golden(::google::protobuf::int32 value) {
  set_has_golden();
  golden_ = value;
}

// optional int32 money = 10;
inline bool AckPlayerDanLuInfo::has_money() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AckPlayerDanLuInfo::set_has_money() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AckPlayerDanLuInfo::clear_has_money() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AckPlayerDanLuInfo::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 AckPlayerDanLuInfo::money() const {
  return money_;
}
inline void AckPlayerDanLuInfo::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 stopError = 12;
inline bool AckPlayerDanLuInfo::has_stoperror() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AckPlayerDanLuInfo::set_has_stoperror() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AckPlayerDanLuInfo::clear_has_stoperror() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AckPlayerDanLuInfo::clear_stoperror() {
  stoperror_ = 0;
  clear_has_stoperror();
}
inline ::google::protobuf::int32 AckPlayerDanLuInfo::stoperror() const {
  return stoperror_;
}
inline void AckPlayerDanLuInfo::set_stoperror(::google::protobuf::int32 value) {
  set_has_stoperror();
  stoperror_ = value;
}

// optional int32 type = 13;
inline bool AckPlayerDanLuInfo::has_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AckPlayerDanLuInfo::set_has_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AckPlayerDanLuInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AckPlayerDanLuInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 AckPlayerDanLuInfo::type() const {
  return type_;
}
inline void AckPlayerDanLuInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ClientDanLuAddExp

// optional int32 type = 1;
inline bool ClientDanLuAddExp::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientDanLuAddExp::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientDanLuAddExp::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientDanLuAddExp::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ClientDanLuAddExp::type() const {
  return type_;
}
inline void ClientDanLuAddExp::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional bool isAutoBuy = 2;
inline bool ClientDanLuAddExp::has_isautobuy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientDanLuAddExp::set_has_isautobuy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientDanLuAddExp::clear_has_isautobuy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientDanLuAddExp::clear_isautobuy() {
  isautobuy_ = false;
  clear_has_isautobuy();
}
inline bool ClientDanLuAddExp::isautobuy() const {
  return isautobuy_;
}
inline void ClientDanLuAddExp::set_isautobuy(bool value) {
  set_has_isautobuy();
  isautobuy_ = value;
}

// optional int32 id = 3;
inline bool ClientDanLuAddExp::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientDanLuAddExp::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientDanLuAddExp::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientDanLuAddExp::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ClientDanLuAddExp::id() const {
  return id_;
}
inline void ClientDanLuAddExp::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// ClientDanLuEquip

// repeated int32 goodID = 1;
inline int ClientDanLuEquip::goodid_size() const {
  return goodid_.size();
}
inline void ClientDanLuEquip::clear_goodid() {
  goodid_.Clear();
}
inline ::google::protobuf::int32 ClientDanLuEquip::goodid(int index) const {
  return goodid_.Get(index);
}
inline void ClientDanLuEquip::set_goodid(int index, ::google::protobuf::int32 value) {
  goodid_.Set(index, value);
}
inline void ClientDanLuEquip::add_goodid(::google::protobuf::int32 value) {
  goodid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ClientDanLuEquip::goodid() const {
  return goodid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ClientDanLuEquip::mutable_goodid() {
  return &goodid_;
}

// repeated int32 num = 2;
inline int ClientDanLuEquip::num_size() const {
  return num_.size();
}
inline void ClientDanLuEquip::clear_num() {
  num_.Clear();
}
inline ::google::protobuf::int32 ClientDanLuEquip::num(int index) const {
  return num_.Get(index);
}
inline void ClientDanLuEquip::set_num(int index, ::google::protobuf::int32 value) {
  num_.Set(index, value);
}
inline void ClientDanLuEquip::add_num(::google::protobuf::int32 value) {
  num_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ClientDanLuEquip::num() const {
  return num_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ClientDanLuEquip::mutable_num() {
  return &num_;
}

// -------------------------------------------------------------------

// RetClientDanLuEquip

// required int32 ret = 1;
inline bool RetClientDanLuEquip::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetClientDanLuEquip::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetClientDanLuEquip::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetClientDanLuEquip::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 RetClientDanLuEquip::ret() const {
  return ret_;
}
inline void RetClientDanLuEquip::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 point = 2;
inline bool RetClientDanLuEquip::has_point() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetClientDanLuEquip::set_has_point() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetClientDanLuEquip::clear_has_point() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetClientDanLuEquip::clear_point() {
  point_ = 0;
  clear_has_point();
}
inline ::google::protobuf::int32 RetClientDanLuEquip::point() const {
  return point_;
}
inline void RetClientDanLuEquip::set_point(::google::protobuf::int32 value) {
  set_has_point();
  point_ = value;
}

// repeated .DanLuInfo.SmeltItem item = 3;
inline int RetClientDanLuEquip::item_size() const {
  return item_.size();
}
inline void RetClientDanLuEquip::clear_item() {
  item_.Clear();
}
inline const ::DanLuInfo::SmeltItem& RetClientDanLuEquip::item(int index) const {
  return item_.Get(index);
}
inline ::DanLuInfo::SmeltItem* RetClientDanLuEquip::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::DanLuInfo::SmeltItem* RetClientDanLuEquip::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DanLuInfo::SmeltItem >&
RetClientDanLuEquip::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::DanLuInfo::SmeltItem >*
RetClientDanLuEquip::mutable_item() {
  return &item_;
}

// repeated .DanLuInfo.DanLuItemList itemList = 4;
inline int RetClientDanLuEquip::itemlist_size() const {
  return itemlist_.size();
}
inline void RetClientDanLuEquip::clear_itemlist() {
  itemlist_.Clear();
}
inline const ::DanLuInfo::DanLuItemList& RetClientDanLuEquip::itemlist(int index) const {
  return itemlist_.Get(index);
}
inline ::DanLuInfo::DanLuItemList* RetClientDanLuEquip::mutable_itemlist(int index) {
  return itemlist_.Mutable(index);
}
inline ::DanLuInfo::DanLuItemList* RetClientDanLuEquip::add_itemlist() {
  return itemlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DanLuInfo::DanLuItemList >&
RetClientDanLuEquip::itemlist() const {
  return itemlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::DanLuInfo::DanLuItemList >*
RetClientDanLuEquip::mutable_itemlist() {
  return &itemlist_;
}

// -------------------------------------------------------------------

// SmeltItem

// required int32 itemID = 1;
inline bool SmeltItem::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SmeltItem::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SmeltItem::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SmeltItem::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 SmeltItem::itemid() const {
  return itemid_;
}
inline void SmeltItem::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 itemNum = 2;
inline bool SmeltItem::has_itemnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SmeltItem::set_has_itemnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SmeltItem::clear_has_itemnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SmeltItem::clear_itemnum() {
  itemnum_ = 0;
  clear_has_itemnum();
}
inline ::google::protobuf::int32 SmeltItem::itemnum() const {
  return itemnum_;
}
inline void SmeltItem::set_itemnum(::google::protobuf::int32 value) {
  set_has_itemnum();
  itemnum_ = value;
}

// optional int32 itemPos = 3;
inline bool SmeltItem::has_itempos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SmeltItem::set_has_itempos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SmeltItem::clear_has_itempos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SmeltItem::clear_itempos() {
  itempos_ = 0;
  clear_has_itempos();
}
inline ::google::protobuf::int32 SmeltItem::itempos() const {
  return itempos_;
}
inline void SmeltItem::set_itempos(::google::protobuf::int32 value) {
  set_has_itempos();
  itempos_ = value;
}

// -------------------------------------------------------------------

// RetDanluEquip

// required int32 ret = 1;
inline bool RetDanluEquip::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetDanluEquip::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetDanluEquip::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetDanluEquip::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 RetDanluEquip::ret() const {
  return ret_;
}
inline void RetDanluEquip::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int64 goods = 2;
inline bool RetDanluEquip::has_goods() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetDanluEquip::set_has_goods() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetDanluEquip::clear_has_goods() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetDanluEquip::clear_goods() {
  goods_ = GOOGLE_LONGLONG(0);
  clear_has_goods();
}
inline ::google::protobuf::int64 RetDanluEquip::goods() const {
  return goods_;
}
inline void RetDanluEquip::set_goods(::google::protobuf::int64 value) {
  set_has_goods();
  goods_ = value;
}

// optional int32 number = 3;
inline bool RetDanluEquip::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RetDanluEquip::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RetDanluEquip::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RetDanluEquip::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 RetDanluEquip::number() const {
  return number_;
}
inline void RetDanluEquip::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace DanLuInfo

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CharLogin_2fDanLu_2eproto__INCLUDED

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CharLogin/Chat.proto

#ifndef PROTOBUF_CharLogin_2fChat_2eproto__INCLUDED
#define PROTOBUF_CharLogin_2fChat_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "CharLogin/CharBaseInfo.pb.h"
// @@protoc_insertion_point(includes)

namespace ChatInfo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CharLogin_2fChat_2eproto();
void protobuf_AssignDesc_CharLogin_2fChat_2eproto();
void protobuf_ShutdownFile_CharLogin_2fChat_2eproto();

class StartChatInfo;
class Marquee;
class EndChatInfo;
class ServerMarquee;
class ServerChatInfo;
class SEndChatInfo;
class GMChatInfo;

// ===================================================================

class StartChatInfo : public ::google::protobuf::Message {
 public:
  StartChatInfo();
  virtual ~StartChatInfo();

  StartChatInfo(const StartChatInfo& from);

  inline StartChatInfo& operator=(const StartChatInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StartChatInfo& default_instance();

  void Swap(StartChatInfo* other);

  // implements Message ----------------------------------------------

  StartChatInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StartChatInfo& from);
  void MergeFrom(const StartChatInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 channel = 1;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 1;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // required string str = 2;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 2;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // repeated .CharLogin.ClientItemInfo item = 3;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 3;
  inline const ::CharLogin::ClientItemInfo& item(int index) const;
  inline ::CharLogin::ClientItemInfo* mutable_item(int index);
  inline ::CharLogin::ClientItemInfo* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::CharLogin::ClientItemInfo >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::CharLogin::ClientItemInfo >*
      mutable_item();

  // required string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 param = 5;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 5;
  inline ::google::protobuf::int32 param() const;
  inline void set_param(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ChatInfo.StartChatInfo)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_param();
  inline void clear_has_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* str_;
  ::google::protobuf::RepeatedPtrField< ::CharLogin::ClientItemInfo > item_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 param_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fChat_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fChat_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fChat_2eproto();

  void InitAsDefaultInstance();
  static StartChatInfo* default_instance_;
};
// -------------------------------------------------------------------

class Marquee : public ::google::protobuf::Message {
 public:
  Marquee();
  virtual ~Marquee();

  Marquee(const Marquee& from);

  inline Marquee& operator=(const Marquee& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Marquee& default_instance();

  void Swap(Marquee* other);

  // implements Message ----------------------------------------------

  Marquee* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Marquee& from);
  void MergeFrom(const Marquee& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string target = 3;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 3;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  inline void set_allocated_target(::std::string* target);

  // required string param = 4;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 4;
  inline const ::std::string& param() const;
  inline void set_param(const ::std::string& value);
  inline void set_param(const char* value);
  inline void set_param(const char* value, size_t size);
  inline ::std::string* mutable_param();
  inline ::std::string* release_param();
  inline void set_allocated_param(::std::string* param);

  // @@protoc_insertion_point(class_scope:ChatInfo.Marquee)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_param();
  inline void clear_has_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* target_;
  ::std::string* param_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fChat_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fChat_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fChat_2eproto();

  void InitAsDefaultInstance();
  static Marquee* default_instance_;
};
// -------------------------------------------------------------------

class EndChatInfo : public ::google::protobuf::Message {
 public:
  EndChatInfo();
  virtual ~EndChatInfo();

  EndChatInfo(const EndChatInfo& from);

  inline EndChatInfo& operator=(const EndChatInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndChatInfo& default_instance();

  void Swap(EndChatInfo* other);

  // implements Message ----------------------------------------------

  EndChatInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EndChatInfo& from);
  void MergeFrom(const EndChatInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 channel = 1;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 1;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // required string str = 2;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 2;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // repeated .CharLogin.ClientItemInfo item = 3;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 3;
  inline const ::CharLogin::ClientItemInfo& item(int index) const;
  inline ::CharLogin::ClientItemInfo* mutable_item(int index);
  inline ::CharLogin::ClientItemInfo* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::CharLogin::ClientItemInfo >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::CharLogin::ClientItemInfo >*
      mutable_item();

  // required int64 startCharid = 4;
  inline bool has_startcharid() const;
  inline void clear_startcharid();
  static const int kStartCharidFieldNumber = 4;
  inline ::google::protobuf::int64 startcharid() const;
  inline void set_startcharid(::google::protobuf::int64 value);

  // required string startName = 5;
  inline bool has_startname() const;
  inline void clear_startname();
  static const int kStartNameFieldNumber = 5;
  inline const ::std::string& startname() const;
  inline void set_startname(const ::std::string& value);
  inline void set_startname(const char* value);
  inline void set_startname(const char* value, size_t size);
  inline ::std::string* mutable_startname();
  inline ::std::string* release_startname();
  inline void set_allocated_startname(::std::string* startname);

  // optional int64 endCharid = 6;
  inline bool has_endcharid() const;
  inline void clear_endcharid();
  static const int kEndCharidFieldNumber = 6;
  inline ::google::protobuf::int64 endcharid() const;
  inline void set_endcharid(::google::protobuf::int64 value);

  // optional string endName = 7;
  inline bool has_endname() const;
  inline void clear_endname();
  static const int kEndNameFieldNumber = 7;
  inline const ::std::string& endname() const;
  inline void set_endname(const ::std::string& value);
  inline void set_endname(const char* value);
  inline void set_endname(const char* value, size_t size);
  inline ::std::string* mutable_endname();
  inline ::std::string* release_endname();
  inline void set_allocated_endname(::std::string* endname);

  // optional int32 viplv = 8;
  inline bool has_viplv() const;
  inline void clear_viplv();
  static const int kViplvFieldNumber = 8;
  inline ::google::protobuf::int32 viplv() const;
  inline void set_viplv(::google::protobuf::int32 value);

  // optional int32 param = 9;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 9;
  inline ::google::protobuf::int32 param() const;
  inline void set_param(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ChatInfo.EndChatInfo)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_startcharid();
  inline void clear_has_startcharid();
  inline void set_has_startname();
  inline void clear_has_startname();
  inline void set_has_endcharid();
  inline void clear_has_endcharid();
  inline void set_has_endname();
  inline void clear_has_endname();
  inline void set_has_viplv();
  inline void clear_has_viplv();
  inline void set_has_param();
  inline void clear_has_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* str_;
  ::google::protobuf::RepeatedPtrField< ::CharLogin::ClientItemInfo > item_;
  ::google::protobuf::int64 startcharid_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 viplv_;
  ::std::string* startname_;
  ::google::protobuf::int64 endcharid_;
  ::std::string* endname_;
  ::google::protobuf::int32 param_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fChat_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fChat_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fChat_2eproto();

  void InitAsDefaultInstance();
  static EndChatInfo* default_instance_;
};
// -------------------------------------------------------------------

class ServerMarquee : public ::google::protobuf::Message {
 public:
  ServerMarquee();
  virtual ~ServerMarquee();

  ServerMarquee(const ServerMarquee& from);

  inline ServerMarquee& operator=(const ServerMarquee& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMarquee& default_instance();

  void Swap(ServerMarquee* other);

  // implements Message ----------------------------------------------

  ServerMarquee* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerMarquee& from);
  void MergeFrom(const ServerMarquee& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // required .ChatInfo.Marquee marquee = 2;
  inline bool has_marquee() const;
  inline void clear_marquee();
  static const int kMarqueeFieldNumber = 2;
  inline const ::ChatInfo::Marquee& marquee() const;
  inline ::ChatInfo::Marquee* mutable_marquee();
  inline ::ChatInfo::Marquee* release_marquee();
  inline void set_allocated_marquee(::ChatInfo::Marquee* marquee);

  // @@protoc_insertion_point(class_scope:ChatInfo.ServerMarquee)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_marquee();
  inline void clear_has_marquee();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::ChatInfo::Marquee* marquee_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fChat_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fChat_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fChat_2eproto();

  void InitAsDefaultInstance();
  static ServerMarquee* default_instance_;
};
// -------------------------------------------------------------------

class ServerChatInfo : public ::google::protobuf::Message {
 public:
  ServerChatInfo();
  virtual ~ServerChatInfo();

  ServerChatInfo(const ServerChatInfo& from);

  inline ServerChatInfo& operator=(const ServerChatInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerChatInfo& default_instance();

  void Swap(ServerChatInfo* other);

  // implements Message ----------------------------------------------

  ServerChatInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerChatInfo& from);
  void MergeFrom(const ServerChatInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 channel = 1;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 1;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // required string str = 2;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 2;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // repeated .CharLogin.ClientItemInfo item = 3;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 3;
  inline const ::CharLogin::ClientItemInfo& item(int index) const;
  inline ::CharLogin::ClientItemInfo* mutable_item(int index);
  inline ::CharLogin::ClientItemInfo* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::CharLogin::ClientItemInfo >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::CharLogin::ClientItemInfo >*
      mutable_item();

  // required int64 startCharid = 4;
  inline bool has_startcharid() const;
  inline void clear_startcharid();
  static const int kStartCharidFieldNumber = 4;
  inline ::google::protobuf::int64 startcharid() const;
  inline void set_startcharid(::google::protobuf::int64 value);

  // required string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:ChatInfo.ServerChatInfo)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_startcharid();
  inline void clear_has_startcharid();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* str_;
  ::google::protobuf::RepeatedPtrField< ::CharLogin::ClientItemInfo > item_;
  ::google::protobuf::int64 startcharid_;
  ::std::string* name_;
  ::google::protobuf::int32 channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fChat_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fChat_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fChat_2eproto();

  void InitAsDefaultInstance();
  static ServerChatInfo* default_instance_;
};
// -------------------------------------------------------------------

class SEndChatInfo : public ::google::protobuf::Message {
 public:
  SEndChatInfo();
  virtual ~SEndChatInfo();

  SEndChatInfo(const SEndChatInfo& from);

  inline SEndChatInfo& operator=(const SEndChatInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SEndChatInfo& default_instance();

  void Swap(SEndChatInfo* other);

  // implements Message ----------------------------------------------

  SEndChatInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SEndChatInfo& from);
  void MergeFrom(const SEndChatInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // required .ChatInfo.EndChatInfo info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ChatInfo::EndChatInfo& info() const;
  inline ::ChatInfo::EndChatInfo* mutable_info();
  inline ::ChatInfo::EndChatInfo* release_info();
  inline void set_allocated_info(::ChatInfo::EndChatInfo* info);

  // @@protoc_insertion_point(class_scope:ChatInfo.SEndChatInfo)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::ChatInfo::EndChatInfo* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fChat_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fChat_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fChat_2eproto();

  void InitAsDefaultInstance();
  static SEndChatInfo* default_instance_;
};
// -------------------------------------------------------------------

class GMChatInfo : public ::google::protobuf::Message {
 public:
  GMChatInfo();
  virtual ~GMChatInfo();

  GMChatInfo(const GMChatInfo& from);

  inline GMChatInfo& operator=(const GMChatInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMChatInfo& default_instance();

  void Swap(GMChatInfo* other);

  // implements Message ----------------------------------------------

  GMChatInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GMChatInfo& from);
  void MergeFrom(const GMChatInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // required .ChatInfo.ServerChatInfo info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ChatInfo::ServerChatInfo& info() const;
  inline ::ChatInfo::ServerChatInfo* mutable_info();
  inline ::ChatInfo::ServerChatInfo* release_info();
  inline void set_allocated_info(::ChatInfo::ServerChatInfo* info);

  // @@protoc_insertion_point(class_scope:ChatInfo.GMChatInfo)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::ChatInfo::ServerChatInfo* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CharLogin_2fChat_2eproto();
  friend void protobuf_AssignDesc_CharLogin_2fChat_2eproto();
  friend void protobuf_ShutdownFile_CharLogin_2fChat_2eproto();

  void InitAsDefaultInstance();
  static GMChatInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// StartChatInfo

// required int32 channel = 1;
inline bool StartChatInfo::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartChatInfo::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartChatInfo::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartChatInfo::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 StartChatInfo::channel() const {
  return channel_;
}
inline void StartChatInfo::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// required string str = 2;
inline bool StartChatInfo::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartChatInfo::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartChatInfo::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartChatInfo::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& StartChatInfo::str() const {
  return *str_;
}
inline void StartChatInfo::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void StartChatInfo::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void StartChatInfo::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartChatInfo::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* StartChatInfo::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StartChatInfo::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .CharLogin.ClientItemInfo item = 3;
inline int StartChatInfo::item_size() const {
  return item_.size();
}
inline void StartChatInfo::clear_item() {
  item_.Clear();
}
inline const ::CharLogin::ClientItemInfo& StartChatInfo::item(int index) const {
  return item_.Get(index);
}
inline ::CharLogin::ClientItemInfo* StartChatInfo::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::CharLogin::ClientItemInfo* StartChatInfo::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CharLogin::ClientItemInfo >&
StartChatInfo::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::CharLogin::ClientItemInfo >*
StartChatInfo::mutable_item() {
  return &item_;
}

// required string name = 4;
inline bool StartChatInfo::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartChatInfo::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartChatInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartChatInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StartChatInfo::name() const {
  return *name_;
}
inline void StartChatInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StartChatInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StartChatInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartChatInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* StartChatInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StartChatInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 param = 5;
inline bool StartChatInfo::has_param() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StartChatInfo::set_has_param() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StartChatInfo::clear_has_param() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StartChatInfo::clear_param() {
  param_ = 0;
  clear_has_param();
}
inline ::google::protobuf::int32 StartChatInfo::param() const {
  return param_;
}
inline void StartChatInfo::set_param(::google::protobuf::int32 value) {
  set_has_param();
  param_ = value;
}

// -------------------------------------------------------------------

// Marquee

// required int32 type = 1;
inline bool Marquee::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Marquee::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Marquee::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Marquee::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Marquee::type() const {
  return type_;
}
inline void Marquee::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string name = 2;
inline bool Marquee::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Marquee::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Marquee::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Marquee::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Marquee::name() const {
  return *name_;
}
inline void Marquee::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Marquee::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Marquee::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Marquee::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Marquee::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Marquee::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string target = 3;
inline bool Marquee::has_target() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Marquee::set_has_target() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Marquee::clear_has_target() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Marquee::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& Marquee::target() const {
  return *target_;
}
inline void Marquee::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void Marquee::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void Marquee::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Marquee::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* Marquee::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Marquee::set_allocated_target(::std::string* target) {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (target) {
    set_has_target();
    target_ = target;
  } else {
    clear_has_target();
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string param = 4;
inline bool Marquee::has_param() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Marquee::set_has_param() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Marquee::clear_has_param() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Marquee::clear_param() {
  if (param_ != &::google::protobuf::internal::kEmptyString) {
    param_->clear();
  }
  clear_has_param();
}
inline const ::std::string& Marquee::param() const {
  return *param_;
}
inline void Marquee::set_param(const ::std::string& value) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(value);
}
inline void Marquee::set_param(const char* value) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(value);
}
inline void Marquee::set_param(const char* value, size_t size) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Marquee::mutable_param() {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  return param_;
}
inline ::std::string* Marquee::release_param() {
  clear_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = param_;
    param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Marquee::set_allocated_param(::std::string* param) {
  if (param_ != &::google::protobuf::internal::kEmptyString) {
    delete param_;
  }
  if (param) {
    set_has_param();
    param_ = param;
  } else {
    clear_has_param();
    param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EndChatInfo

// required int32 channel = 1;
inline bool EndChatInfo::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndChatInfo::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndChatInfo::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndChatInfo::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 EndChatInfo::channel() const {
  return channel_;
}
inline void EndChatInfo::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// required string str = 2;
inline bool EndChatInfo::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndChatInfo::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndChatInfo::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndChatInfo::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& EndChatInfo::str() const {
  return *str_;
}
inline void EndChatInfo::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void EndChatInfo::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void EndChatInfo::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EndChatInfo::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* EndChatInfo::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EndChatInfo::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .CharLogin.ClientItemInfo item = 3;
inline int EndChatInfo::item_size() const {
  return item_.size();
}
inline void EndChatInfo::clear_item() {
  item_.Clear();
}
inline const ::CharLogin::ClientItemInfo& EndChatInfo::item(int index) const {
  return item_.Get(index);
}
inline ::CharLogin::ClientItemInfo* EndChatInfo::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::CharLogin::ClientItemInfo* EndChatInfo::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CharLogin::ClientItemInfo >&
EndChatInfo::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::CharLogin::ClientItemInfo >*
EndChatInfo::mutable_item() {
  return &item_;
}

// required int64 startCharid = 4;
inline bool EndChatInfo::has_startcharid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EndChatInfo::set_has_startcharid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EndChatInfo::clear_has_startcharid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EndChatInfo::clear_startcharid() {
  startcharid_ = GOOGLE_LONGLONG(0);
  clear_has_startcharid();
}
inline ::google::protobuf::int64 EndChatInfo::startcharid() const {
  return startcharid_;
}
inline void EndChatInfo::set_startcharid(::google::protobuf::int64 value) {
  set_has_startcharid();
  startcharid_ = value;
}

// required string startName = 5;
inline bool EndChatInfo::has_startname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EndChatInfo::set_has_startname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EndChatInfo::clear_has_startname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EndChatInfo::clear_startname() {
  if (startname_ != &::google::protobuf::internal::kEmptyString) {
    startname_->clear();
  }
  clear_has_startname();
}
inline const ::std::string& EndChatInfo::startname() const {
  return *startname_;
}
inline void EndChatInfo::set_startname(const ::std::string& value) {
  set_has_startname();
  if (startname_ == &::google::protobuf::internal::kEmptyString) {
    startname_ = new ::std::string;
  }
  startname_->assign(value);
}
inline void EndChatInfo::set_startname(const char* value) {
  set_has_startname();
  if (startname_ == &::google::protobuf::internal::kEmptyString) {
    startname_ = new ::std::string;
  }
  startname_->assign(value);
}
inline void EndChatInfo::set_startname(const char* value, size_t size) {
  set_has_startname();
  if (startname_ == &::google::protobuf::internal::kEmptyString) {
    startname_ = new ::std::string;
  }
  startname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EndChatInfo::mutable_startname() {
  set_has_startname();
  if (startname_ == &::google::protobuf::internal::kEmptyString) {
    startname_ = new ::std::string;
  }
  return startname_;
}
inline ::std::string* EndChatInfo::release_startname() {
  clear_has_startname();
  if (startname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startname_;
    startname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EndChatInfo::set_allocated_startname(::std::string* startname) {
  if (startname_ != &::google::protobuf::internal::kEmptyString) {
    delete startname_;
  }
  if (startname) {
    set_has_startname();
    startname_ = startname;
  } else {
    clear_has_startname();
    startname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 endCharid = 6;
inline bool EndChatInfo::has_endcharid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EndChatInfo::set_has_endcharid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EndChatInfo::clear_has_endcharid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EndChatInfo::clear_endcharid() {
  endcharid_ = GOOGLE_LONGLONG(0);
  clear_has_endcharid();
}
inline ::google::protobuf::int64 EndChatInfo::endcharid() const {
  return endcharid_;
}
inline void EndChatInfo::set_endcharid(::google::protobuf::int64 value) {
  set_has_endcharid();
  endcharid_ = value;
}

// optional string endName = 7;
inline bool EndChatInfo::has_endname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EndChatInfo::set_has_endname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EndChatInfo::clear_has_endname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EndChatInfo::clear_endname() {
  if (endname_ != &::google::protobuf::internal::kEmptyString) {
    endname_->clear();
  }
  clear_has_endname();
}
inline const ::std::string& EndChatInfo::endname() const {
  return *endname_;
}
inline void EndChatInfo::set_endname(const ::std::string& value) {
  set_has_endname();
  if (endname_ == &::google::protobuf::internal::kEmptyString) {
    endname_ = new ::std::string;
  }
  endname_->assign(value);
}
inline void EndChatInfo::set_endname(const char* value) {
  set_has_endname();
  if (endname_ == &::google::protobuf::internal::kEmptyString) {
    endname_ = new ::std::string;
  }
  endname_->assign(value);
}
inline void EndChatInfo::set_endname(const char* value, size_t size) {
  set_has_endname();
  if (endname_ == &::google::protobuf::internal::kEmptyString) {
    endname_ = new ::std::string;
  }
  endname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EndChatInfo::mutable_endname() {
  set_has_endname();
  if (endname_ == &::google::protobuf::internal::kEmptyString) {
    endname_ = new ::std::string;
  }
  return endname_;
}
inline ::std::string* EndChatInfo::release_endname() {
  clear_has_endname();
  if (endname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endname_;
    endname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EndChatInfo::set_allocated_endname(::std::string* endname) {
  if (endname_ != &::google::protobuf::internal::kEmptyString) {
    delete endname_;
  }
  if (endname) {
    set_has_endname();
    endname_ = endname;
  } else {
    clear_has_endname();
    endname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 viplv = 8;
inline bool EndChatInfo::has_viplv() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EndChatInfo::set_has_viplv() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EndChatInfo::clear_has_viplv() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EndChatInfo::clear_viplv() {
  viplv_ = 0;
  clear_has_viplv();
}
inline ::google::protobuf::int32 EndChatInfo::viplv() const {
  return viplv_;
}
inline void EndChatInfo::set_viplv(::google::protobuf::int32 value) {
  set_has_viplv();
  viplv_ = value;
}

// optional int32 param = 9;
inline bool EndChatInfo::has_param() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EndChatInfo::set_has_param() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EndChatInfo::clear_has_param() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EndChatInfo::clear_param() {
  param_ = 0;
  clear_has_param();
}
inline ::google::protobuf::int32 EndChatInfo::param() const {
  return param_;
}
inline void EndChatInfo::set_param(::google::protobuf::int32 value) {
  set_has_param();
  param_ = value;
}

// -------------------------------------------------------------------

// ServerMarquee

// required int64 charid = 1;
inline bool ServerMarquee::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerMarquee::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerMarquee::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerMarquee::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 ServerMarquee::charid() const {
  return charid_;
}
inline void ServerMarquee::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// required .ChatInfo.Marquee marquee = 2;
inline bool ServerMarquee::has_marquee() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerMarquee::set_has_marquee() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerMarquee::clear_has_marquee() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerMarquee::clear_marquee() {
  if (marquee_ != NULL) marquee_->::ChatInfo::Marquee::Clear();
  clear_has_marquee();
}
inline const ::ChatInfo::Marquee& ServerMarquee::marquee() const {
  return marquee_ != NULL ? *marquee_ : *default_instance_->marquee_;
}
inline ::ChatInfo::Marquee* ServerMarquee::mutable_marquee() {
  set_has_marquee();
  if (marquee_ == NULL) marquee_ = new ::ChatInfo::Marquee;
  return marquee_;
}
inline ::ChatInfo::Marquee* ServerMarquee::release_marquee() {
  clear_has_marquee();
  ::ChatInfo::Marquee* temp = marquee_;
  marquee_ = NULL;
  return temp;
}
inline void ServerMarquee::set_allocated_marquee(::ChatInfo::Marquee* marquee) {
  delete marquee_;
  marquee_ = marquee;
  if (marquee) {
    set_has_marquee();
  } else {
    clear_has_marquee();
  }
}

// -------------------------------------------------------------------

// ServerChatInfo

// required int32 channel = 1;
inline bool ServerChatInfo::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerChatInfo::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerChatInfo::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerChatInfo::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 ServerChatInfo::channel() const {
  return channel_;
}
inline void ServerChatInfo::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// required string str = 2;
inline bool ServerChatInfo::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerChatInfo::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerChatInfo::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerChatInfo::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& ServerChatInfo::str() const {
  return *str_;
}
inline void ServerChatInfo::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void ServerChatInfo::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void ServerChatInfo::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerChatInfo::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* ServerChatInfo::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerChatInfo::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .CharLogin.ClientItemInfo item = 3;
inline int ServerChatInfo::item_size() const {
  return item_.size();
}
inline void ServerChatInfo::clear_item() {
  item_.Clear();
}
inline const ::CharLogin::ClientItemInfo& ServerChatInfo::item(int index) const {
  return item_.Get(index);
}
inline ::CharLogin::ClientItemInfo* ServerChatInfo::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::CharLogin::ClientItemInfo* ServerChatInfo::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CharLogin::ClientItemInfo >&
ServerChatInfo::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::CharLogin::ClientItemInfo >*
ServerChatInfo::mutable_item() {
  return &item_;
}

// required int64 startCharid = 4;
inline bool ServerChatInfo::has_startcharid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerChatInfo::set_has_startcharid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerChatInfo::clear_has_startcharid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerChatInfo::clear_startcharid() {
  startcharid_ = GOOGLE_LONGLONG(0);
  clear_has_startcharid();
}
inline ::google::protobuf::int64 ServerChatInfo::startcharid() const {
  return startcharid_;
}
inline void ServerChatInfo::set_startcharid(::google::protobuf::int64 value) {
  set_has_startcharid();
  startcharid_ = value;
}

// required string name = 5;
inline bool ServerChatInfo::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerChatInfo::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerChatInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerChatInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ServerChatInfo::name() const {
  return *name_;
}
inline void ServerChatInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ServerChatInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ServerChatInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerChatInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ServerChatInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerChatInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SEndChatInfo

// required int64 charid = 1;
inline bool SEndChatInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SEndChatInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SEndChatInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SEndChatInfo::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 SEndChatInfo::charid() const {
  return charid_;
}
inline void SEndChatInfo::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// required .ChatInfo.EndChatInfo info = 2;
inline bool SEndChatInfo::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SEndChatInfo::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SEndChatInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SEndChatInfo::clear_info() {
  if (info_ != NULL) info_->::ChatInfo::EndChatInfo::Clear();
  clear_has_info();
}
inline const ::ChatInfo::EndChatInfo& SEndChatInfo::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::ChatInfo::EndChatInfo* SEndChatInfo::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::ChatInfo::EndChatInfo;
  return info_;
}
inline ::ChatInfo::EndChatInfo* SEndChatInfo::release_info() {
  clear_has_info();
  ::ChatInfo::EndChatInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void SEndChatInfo::set_allocated_info(::ChatInfo::EndChatInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// GMChatInfo

// required int64 charid = 1;
inline bool GMChatInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMChatInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMChatInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMChatInfo::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 GMChatInfo::charid() const {
  return charid_;
}
inline void GMChatInfo::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// required .ChatInfo.ServerChatInfo info = 2;
inline bool GMChatInfo::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GMChatInfo::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GMChatInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GMChatInfo::clear_info() {
  if (info_ != NULL) info_->::ChatInfo::ServerChatInfo::Clear();
  clear_has_info();
}
inline const ::ChatInfo::ServerChatInfo& GMChatInfo::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::ChatInfo::ServerChatInfo* GMChatInfo::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::ChatInfo::ServerChatInfo;
  return info_;
}
inline ::ChatInfo::ServerChatInfo* GMChatInfo::release_info() {
  clear_has_info();
  ::ChatInfo::ServerChatInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void GMChatInfo::set_allocated_info(::ChatInfo::ServerChatInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ChatInfo

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CharLogin_2fChat_2eproto__INCLUDED

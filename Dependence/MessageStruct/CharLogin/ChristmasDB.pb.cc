// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CharLogin/ChristmasDB.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CharLogin/ChristmasDB.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ChristmasDB {

namespace {

const ::google::protobuf::Descriptor* BreakEggDB_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BreakEggDB_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChristmasLoginDB_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChristmasLoginDB_reflection_ = NULL;
const ::google::protobuf::Descriptor* SingleLimitDB_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SingleLimitDB_reflection_ = NULL;
const ::google::protobuf::Descriptor* LimitDataAll_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LimitDataAll_reflection_ = NULL;
const ::google::protobuf::Descriptor* NewYearPro_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NewYearPro_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChristmasAllData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChristmasAllData_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_CharLogin_2fChristmasDB_2eproto() {
  protobuf_AddDesc_CharLogin_2fChristmasDB_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "CharLogin/ChristmasDB.proto");
  GOOGLE_CHECK(file != NULL);
  BreakEggDB_descriptor_ = file->message_type(0);
  static const int BreakEggDB_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BreakEggDB, reflushtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BreakEggDB, breakinfo_),
  };
  BreakEggDB_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BreakEggDB_descriptor_,
      BreakEggDB::default_instance_,
      BreakEggDB_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BreakEggDB, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BreakEggDB, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BreakEggDB));
  ChristmasLoginDB_descriptor_ = file->message_type(1);
  static const int ChristmasLoginDB_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasLoginDB, loginday_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasLoginDB, rewardinfo_),
  };
  ChristmasLoginDB_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChristmasLoginDB_descriptor_,
      ChristmasLoginDB::default_instance_,
      ChristmasLoginDB_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasLoginDB, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasLoginDB, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChristmasLoginDB));
  SingleLimitDB_descriptor_ = file->message_type(2);
  static const int SingleLimitDB_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleLimitDB, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleLimitDB, counts_),
  };
  SingleLimitDB_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SingleLimitDB_descriptor_,
      SingleLimitDB::default_instance_,
      SingleLimitDB_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleLimitDB, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleLimitDB, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SingleLimitDB));
  LimitDataAll_descriptor_ = file->message_type(3);
  static const int LimitDataAll_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LimitDataAll, reflushtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LimitDataAll, limitlist_),
  };
  LimitDataAll_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LimitDataAll_descriptor_,
      LimitDataAll::default_instance_,
      LimitDataAll_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LimitDataAll, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LimitDataAll, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LimitDataAll));
  NewYearPro_descriptor_ = file->message_type(4);
  static const int NewYearPro_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewYearPro, loginday_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewYearPro, loginreward_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewYearPro, horsereceive_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewYearPro, contireceive_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewYearPro, inittime_),
  };
  NewYearPro_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NewYearPro_descriptor_,
      NewYearPro::default_instance_,
      NewYearPro_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewYearPro, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewYearPro, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NewYearPro));
  ChristmasAllData_descriptor_ = file->message_type(5);
  static const int ChristmasAllData_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasAllData, breakeggdata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasAllData, logindata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasAllData, limitdata_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasAllData, newyeardata_),
  };
  ChristmasAllData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChristmasAllData_descriptor_,
      ChristmasAllData::default_instance_,
      ChristmasAllData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasAllData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasAllData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChristmasAllData));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_CharLogin_2fChristmasDB_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BreakEggDB_descriptor_, &BreakEggDB::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChristmasLoginDB_descriptor_, &ChristmasLoginDB::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SingleLimitDB_descriptor_, &SingleLimitDB::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LimitDataAll_descriptor_, &LimitDataAll::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NewYearPro_descriptor_, &NewYearPro::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChristmasAllData_descriptor_, &ChristmasAllData::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_CharLogin_2fChristmasDB_2eproto() {
  delete BreakEggDB::default_instance_;
  delete BreakEggDB_reflection_;
  delete ChristmasLoginDB::default_instance_;
  delete ChristmasLoginDB_reflection_;
  delete SingleLimitDB::default_instance_;
  delete SingleLimitDB_reflection_;
  delete LimitDataAll::default_instance_;
  delete LimitDataAll_reflection_;
  delete NewYearPro::default_instance_;
  delete NewYearPro_reflection_;
  delete ChristmasAllData::default_instance_;
  delete ChristmasAllData_reflection_;
}

void protobuf_AddDesc_CharLogin_2fChristmasDB_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\033CharLogin/ChristmasDB.proto\022\013Christmas"
    "DB\"4\n\nBreakEggDB\022\023\n\013reflushTime\030\001 \001(\003\022\021\n"
    "\tbreakInfo\030\002 \001(\005\"8\n\020ChristmasLoginDB\022\020\n\010"
    "loginDay\030\001 \001(\005\022\022\n\nrewardInfo\030\002 \001(\005\"+\n\rSi"
    "ngleLimitDB\022\n\n\002id\030\001 \001(\005\022\016\n\006counts\030\002 \001(\005\""
    "R\n\014LimitDataAll\022\023\n\013reflushTime\030\001 \001(\003\022-\n\t"
    "limitList\030\002 \003(\0132\032.ChristmasDB.SingleLimi"
    "tDB\"q\n\nNewYearPro\022\020\n\010loginday\030\001 \001(\005\022\023\n\013l"
    "oginreward\030\002 \001(\005\022\024\n\014horsereceive\030\003 \001(\005\022\024"
    "\n\014contiReceive\030\004 \001(\005\022\020\n\010initTime\030\005 \001(\003\"\317"
    "\001\n\020ChristmasAllData\022-\n\014breakEggData\030\001 \001("
    "\0132\027.ChristmasDB.BreakEggDB\0220\n\tloginData\030"
    "\002 \001(\0132\035.ChristmasDB.ChristmasLoginDB\022,\n\t"
    "limitData\030\003 \001(\0132\031.ChristmasDB.LimitDataA"
    "ll\022,\n\013newyeardata\030\004 \001(\0132\027.ChristmasDB.Ne"
    "wYearPro", 608);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "CharLogin/ChristmasDB.proto", &protobuf_RegisterTypes);
  BreakEggDB::default_instance_ = new BreakEggDB();
  ChristmasLoginDB::default_instance_ = new ChristmasLoginDB();
  SingleLimitDB::default_instance_ = new SingleLimitDB();
  LimitDataAll::default_instance_ = new LimitDataAll();
  NewYearPro::default_instance_ = new NewYearPro();
  ChristmasAllData::default_instance_ = new ChristmasAllData();
  BreakEggDB::default_instance_->InitAsDefaultInstance();
  ChristmasLoginDB::default_instance_->InitAsDefaultInstance();
  SingleLimitDB::default_instance_->InitAsDefaultInstance();
  LimitDataAll::default_instance_->InitAsDefaultInstance();
  NewYearPro::default_instance_->InitAsDefaultInstance();
  ChristmasAllData::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CharLogin_2fChristmasDB_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CharLogin_2fChristmasDB_2eproto {
  StaticDescriptorInitializer_CharLogin_2fChristmasDB_2eproto() {
    protobuf_AddDesc_CharLogin_2fChristmasDB_2eproto();
  }
} static_descriptor_initializer_CharLogin_2fChristmasDB_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int BreakEggDB::kReflushTimeFieldNumber;
const int BreakEggDB::kBreakInfoFieldNumber;
#endif  // !_MSC_VER

BreakEggDB::BreakEggDB()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BreakEggDB::InitAsDefaultInstance() {
}

BreakEggDB::BreakEggDB(const BreakEggDB& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BreakEggDB::SharedCtor() {
  _cached_size_ = 0;
  reflushtime_ = GOOGLE_LONGLONG(0);
  breakinfo_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BreakEggDB::~BreakEggDB() {
  SharedDtor();
}

void BreakEggDB::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BreakEggDB::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BreakEggDB::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BreakEggDB_descriptor_;
}

const BreakEggDB& BreakEggDB::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CharLogin_2fChristmasDB_2eproto();
  return *default_instance_;
}

BreakEggDB* BreakEggDB::default_instance_ = NULL;

BreakEggDB* BreakEggDB::New() const {
  return new BreakEggDB;
}

void BreakEggDB::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    reflushtime_ = GOOGLE_LONGLONG(0);
    breakinfo_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BreakEggDB::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 reflushTime = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &reflushtime_)));
          set_has_reflushtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_breakInfo;
        break;
      }

      // optional int32 breakInfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_breakInfo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &breakinfo_)));
          set_has_breakinfo();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BreakEggDB::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 reflushTime = 1;
  if (has_reflushtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->reflushtime(), output);
  }

  // optional int32 breakInfo = 2;
  if (has_breakinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->breakinfo(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BreakEggDB::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int64 reflushTime = 1;
  if (has_reflushtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->reflushtime(), target);
  }

  // optional int32 breakInfo = 2;
  if (has_breakinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->breakinfo(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BreakEggDB::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 reflushTime = 1;
    if (has_reflushtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->reflushtime());
    }

    // optional int32 breakInfo = 2;
    if (has_breakinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->breakinfo());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BreakEggDB::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BreakEggDB* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BreakEggDB*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BreakEggDB::MergeFrom(const BreakEggDB& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reflushtime()) {
      set_reflushtime(from.reflushtime());
    }
    if (from.has_breakinfo()) {
      set_breakinfo(from.breakinfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BreakEggDB::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BreakEggDB::CopyFrom(const BreakEggDB& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BreakEggDB::IsInitialized() const {

  return true;
}

void BreakEggDB::Swap(BreakEggDB* other) {
  if (other != this) {
    std::swap(reflushtime_, other->reflushtime_);
    std::swap(breakinfo_, other->breakinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BreakEggDB::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BreakEggDB_descriptor_;
  metadata.reflection = BreakEggDB_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ChristmasLoginDB::kLoginDayFieldNumber;
const int ChristmasLoginDB::kRewardInfoFieldNumber;
#endif  // !_MSC_VER

ChristmasLoginDB::ChristmasLoginDB()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ChristmasLoginDB::InitAsDefaultInstance() {
}

ChristmasLoginDB::ChristmasLoginDB(const ChristmasLoginDB& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ChristmasLoginDB::SharedCtor() {
  _cached_size_ = 0;
  loginday_ = 0;
  rewardinfo_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChristmasLoginDB::~ChristmasLoginDB() {
  SharedDtor();
}

void ChristmasLoginDB::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ChristmasLoginDB::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChristmasLoginDB::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChristmasLoginDB_descriptor_;
}

const ChristmasLoginDB& ChristmasLoginDB::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CharLogin_2fChristmasDB_2eproto();
  return *default_instance_;
}

ChristmasLoginDB* ChristmasLoginDB::default_instance_ = NULL;

ChristmasLoginDB* ChristmasLoginDB::New() const {
  return new ChristmasLoginDB;
}

void ChristmasLoginDB::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    loginday_ = 0;
    rewardinfo_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChristmasLoginDB::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 loginDay = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &loginday_)));
          set_has_loginday();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_rewardInfo;
        break;
      }

      // optional int32 rewardInfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rewardInfo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rewardinfo_)));
          set_has_rewardinfo();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChristmasLoginDB::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 loginDay = 1;
  if (has_loginday()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->loginday(), output);
  }

  // optional int32 rewardInfo = 2;
  if (has_rewardinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->rewardinfo(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChristmasLoginDB::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 loginDay = 1;
  if (has_loginday()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->loginday(), target);
  }

  // optional int32 rewardInfo = 2;
  if (has_rewardinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->rewardinfo(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChristmasLoginDB::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 loginDay = 1;
    if (has_loginday()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->loginday());
    }

    // optional int32 rewardInfo = 2;
    if (has_rewardinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rewardinfo());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChristmasLoginDB::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChristmasLoginDB* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChristmasLoginDB*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChristmasLoginDB::MergeFrom(const ChristmasLoginDB& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_loginday()) {
      set_loginday(from.loginday());
    }
    if (from.has_rewardinfo()) {
      set_rewardinfo(from.rewardinfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChristmasLoginDB::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChristmasLoginDB::CopyFrom(const ChristmasLoginDB& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChristmasLoginDB::IsInitialized() const {

  return true;
}

void ChristmasLoginDB::Swap(ChristmasLoginDB* other) {
  if (other != this) {
    std::swap(loginday_, other->loginday_);
    std::swap(rewardinfo_, other->rewardinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChristmasLoginDB::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChristmasLoginDB_descriptor_;
  metadata.reflection = ChristmasLoginDB_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SingleLimitDB::kIdFieldNumber;
const int SingleLimitDB::kCountsFieldNumber;
#endif  // !_MSC_VER

SingleLimitDB::SingleLimitDB()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SingleLimitDB::InitAsDefaultInstance() {
}

SingleLimitDB::SingleLimitDB(const SingleLimitDB& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SingleLimitDB::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  counts_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SingleLimitDB::~SingleLimitDB() {
  SharedDtor();
}

void SingleLimitDB::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SingleLimitDB::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SingleLimitDB::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SingleLimitDB_descriptor_;
}

const SingleLimitDB& SingleLimitDB::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CharLogin_2fChristmasDB_2eproto();
  return *default_instance_;
}

SingleLimitDB* SingleLimitDB::default_instance_ = NULL;

SingleLimitDB* SingleLimitDB::New() const {
  return new SingleLimitDB;
}

void SingleLimitDB::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    counts_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SingleLimitDB::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_counts;
        break;
      }

      // optional int32 counts = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_counts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &counts_)));
          set_has_counts();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SingleLimitDB::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 counts = 2;
  if (has_counts()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->counts(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SingleLimitDB::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional int32 counts = 2;
  if (has_counts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->counts(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SingleLimitDB::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 counts = 2;
    if (has_counts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->counts());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SingleLimitDB::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SingleLimitDB* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SingleLimitDB*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SingleLimitDB::MergeFrom(const SingleLimitDB& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_counts()) {
      set_counts(from.counts());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SingleLimitDB::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SingleLimitDB::CopyFrom(const SingleLimitDB& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SingleLimitDB::IsInitialized() const {

  return true;
}

void SingleLimitDB::Swap(SingleLimitDB* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(counts_, other->counts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SingleLimitDB::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SingleLimitDB_descriptor_;
  metadata.reflection = SingleLimitDB_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LimitDataAll::kReflushTimeFieldNumber;
const int LimitDataAll::kLimitListFieldNumber;
#endif  // !_MSC_VER

LimitDataAll::LimitDataAll()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LimitDataAll::InitAsDefaultInstance() {
}

LimitDataAll::LimitDataAll(const LimitDataAll& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LimitDataAll::SharedCtor() {
  _cached_size_ = 0;
  reflushtime_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LimitDataAll::~LimitDataAll() {
  SharedDtor();
}

void LimitDataAll::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LimitDataAll::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LimitDataAll::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LimitDataAll_descriptor_;
}

const LimitDataAll& LimitDataAll::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CharLogin_2fChristmasDB_2eproto();
  return *default_instance_;
}

LimitDataAll* LimitDataAll::default_instance_ = NULL;

LimitDataAll* LimitDataAll::New() const {
  return new LimitDataAll;
}

void LimitDataAll::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    reflushtime_ = GOOGLE_LONGLONG(0);
  }
  limitlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LimitDataAll::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 reflushTime = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &reflushtime_)));
          set_has_reflushtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_limitList;
        break;
      }

      // repeated .ChristmasDB.SingleLimitDB limitList = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_limitList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_limitlist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_limitList;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LimitDataAll::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 reflushTime = 1;
  if (has_reflushtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->reflushtime(), output);
  }

  // repeated .ChristmasDB.SingleLimitDB limitList = 2;
  for (int i = 0; i < this->limitlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->limitlist(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LimitDataAll::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int64 reflushTime = 1;
  if (has_reflushtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->reflushtime(), target);
  }

  // repeated .ChristmasDB.SingleLimitDB limitList = 2;
  for (int i = 0; i < this->limitlist_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->limitlist(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LimitDataAll::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 reflushTime = 1;
    if (has_reflushtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->reflushtime());
    }

  }
  // repeated .ChristmasDB.SingleLimitDB limitList = 2;
  total_size += 1 * this->limitlist_size();
  for (int i = 0; i < this->limitlist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->limitlist(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LimitDataAll::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LimitDataAll* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LimitDataAll*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LimitDataAll::MergeFrom(const LimitDataAll& from) {
  GOOGLE_CHECK_NE(&from, this);
  limitlist_.MergeFrom(from.limitlist_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reflushtime()) {
      set_reflushtime(from.reflushtime());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LimitDataAll::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LimitDataAll::CopyFrom(const LimitDataAll& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LimitDataAll::IsInitialized() const {

  return true;
}

void LimitDataAll::Swap(LimitDataAll* other) {
  if (other != this) {
    std::swap(reflushtime_, other->reflushtime_);
    limitlist_.Swap(&other->limitlist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LimitDataAll::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LimitDataAll_descriptor_;
  metadata.reflection = LimitDataAll_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NewYearPro::kLogindayFieldNumber;
const int NewYearPro::kLoginrewardFieldNumber;
const int NewYearPro::kHorsereceiveFieldNumber;
const int NewYearPro::kContiReceiveFieldNumber;
const int NewYearPro::kInitTimeFieldNumber;
#endif  // !_MSC_VER

NewYearPro::NewYearPro()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NewYearPro::InitAsDefaultInstance() {
}

NewYearPro::NewYearPro(const NewYearPro& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NewYearPro::SharedCtor() {
  _cached_size_ = 0;
  loginday_ = 0;
  loginreward_ = 0;
  horsereceive_ = 0;
  contireceive_ = 0;
  inittime_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NewYearPro::~NewYearPro() {
  SharedDtor();
}

void NewYearPro::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NewYearPro::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NewYearPro::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NewYearPro_descriptor_;
}

const NewYearPro& NewYearPro::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CharLogin_2fChristmasDB_2eproto();
  return *default_instance_;
}

NewYearPro* NewYearPro::default_instance_ = NULL;

NewYearPro* NewYearPro::New() const {
  return new NewYearPro;
}

void NewYearPro::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    loginday_ = 0;
    loginreward_ = 0;
    horsereceive_ = 0;
    contireceive_ = 0;
    inittime_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NewYearPro::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 loginday = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &loginday_)));
          set_has_loginday();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_loginreward;
        break;
      }

      // optional int32 loginreward = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_loginreward:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &loginreward_)));
          set_has_loginreward();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_horsereceive;
        break;
      }

      // optional int32 horsereceive = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_horsereceive:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &horsereceive_)));
          set_has_horsereceive();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_contiReceive;
        break;
      }

      // optional int32 contiReceive = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_contiReceive:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &contireceive_)));
          set_has_contireceive();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_initTime;
        break;
      }

      // optional int64 initTime = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_initTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inittime_)));
          set_has_inittime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NewYearPro::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 loginday = 1;
  if (has_loginday()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->loginday(), output);
  }

  // optional int32 loginreward = 2;
  if (has_loginreward()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->loginreward(), output);
  }

  // optional int32 horsereceive = 3;
  if (has_horsereceive()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->horsereceive(), output);
  }

  // optional int32 contiReceive = 4;
  if (has_contireceive()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->contireceive(), output);
  }

  // optional int64 initTime = 5;
  if (has_inittime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->inittime(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NewYearPro::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 loginday = 1;
  if (has_loginday()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->loginday(), target);
  }

  // optional int32 loginreward = 2;
  if (has_loginreward()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->loginreward(), target);
  }

  // optional int32 horsereceive = 3;
  if (has_horsereceive()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->horsereceive(), target);
  }

  // optional int32 contiReceive = 4;
  if (has_contireceive()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->contireceive(), target);
  }

  // optional int64 initTime = 5;
  if (has_inittime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->inittime(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NewYearPro::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 loginday = 1;
    if (has_loginday()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->loginday());
    }

    // optional int32 loginreward = 2;
    if (has_loginreward()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->loginreward());
    }

    // optional int32 horsereceive = 3;
    if (has_horsereceive()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->horsereceive());
    }

    // optional int32 contiReceive = 4;
    if (has_contireceive()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->contireceive());
    }

    // optional int64 initTime = 5;
    if (has_inittime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inittime());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NewYearPro::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NewYearPro* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NewYearPro*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NewYearPro::MergeFrom(const NewYearPro& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_loginday()) {
      set_loginday(from.loginday());
    }
    if (from.has_loginreward()) {
      set_loginreward(from.loginreward());
    }
    if (from.has_horsereceive()) {
      set_horsereceive(from.horsereceive());
    }
    if (from.has_contireceive()) {
      set_contireceive(from.contireceive());
    }
    if (from.has_inittime()) {
      set_inittime(from.inittime());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NewYearPro::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NewYearPro::CopyFrom(const NewYearPro& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewYearPro::IsInitialized() const {

  return true;
}

void NewYearPro::Swap(NewYearPro* other) {
  if (other != this) {
    std::swap(loginday_, other->loginday_);
    std::swap(loginreward_, other->loginreward_);
    std::swap(horsereceive_, other->horsereceive_);
    std::swap(contireceive_, other->contireceive_);
    std::swap(inittime_, other->inittime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NewYearPro::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NewYearPro_descriptor_;
  metadata.reflection = NewYearPro_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ChristmasAllData::kBreakEggDataFieldNumber;
const int ChristmasAllData::kLoginDataFieldNumber;
const int ChristmasAllData::kLimitDataFieldNumber;
const int ChristmasAllData::kNewyeardataFieldNumber;
#endif  // !_MSC_VER

ChristmasAllData::ChristmasAllData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ChristmasAllData::InitAsDefaultInstance() {
  breakeggdata_ = const_cast< ::ChristmasDB::BreakEggDB*>(&::ChristmasDB::BreakEggDB::default_instance());
  logindata_ = const_cast< ::ChristmasDB::ChristmasLoginDB*>(&::ChristmasDB::ChristmasLoginDB::default_instance());
  limitdata_ = const_cast< ::ChristmasDB::LimitDataAll*>(&::ChristmasDB::LimitDataAll::default_instance());
  newyeardata_ = const_cast< ::ChristmasDB::NewYearPro*>(&::ChristmasDB::NewYearPro::default_instance());
}

ChristmasAllData::ChristmasAllData(const ChristmasAllData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ChristmasAllData::SharedCtor() {
  _cached_size_ = 0;
  breakeggdata_ = NULL;
  logindata_ = NULL;
  limitdata_ = NULL;
  newyeardata_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChristmasAllData::~ChristmasAllData() {
  SharedDtor();
}

void ChristmasAllData::SharedDtor() {
  if (this != default_instance_) {
    delete breakeggdata_;
    delete logindata_;
    delete limitdata_;
    delete newyeardata_;
  }
}

void ChristmasAllData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChristmasAllData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChristmasAllData_descriptor_;
}

const ChristmasAllData& ChristmasAllData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CharLogin_2fChristmasDB_2eproto();
  return *default_instance_;
}

ChristmasAllData* ChristmasAllData::default_instance_ = NULL;

ChristmasAllData* ChristmasAllData::New() const {
  return new ChristmasAllData;
}

void ChristmasAllData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_breakeggdata()) {
      if (breakeggdata_ != NULL) breakeggdata_->::ChristmasDB::BreakEggDB::Clear();
    }
    if (has_logindata()) {
      if (logindata_ != NULL) logindata_->::ChristmasDB::ChristmasLoginDB::Clear();
    }
    if (has_limitdata()) {
      if (limitdata_ != NULL) limitdata_->::ChristmasDB::LimitDataAll::Clear();
    }
    if (has_newyeardata()) {
      if (newyeardata_ != NULL) newyeardata_->::ChristmasDB::NewYearPro::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChristmasAllData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ChristmasDB.BreakEggDB breakEggData = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_breakeggdata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_loginData;
        break;
      }

      // optional .ChristmasDB.ChristmasLoginDB loginData = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_loginData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_logindata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_limitData;
        break;
      }

      // optional .ChristmasDB.LimitDataAll limitData = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_limitData:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_limitdata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_newyeardata;
        break;
      }

      // optional .ChristmasDB.NewYearPro newyeardata = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_newyeardata:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_newyeardata()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChristmasAllData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ChristmasDB.BreakEggDB breakEggData = 1;
  if (has_breakeggdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->breakeggdata(), output);
  }

  // optional .ChristmasDB.ChristmasLoginDB loginData = 2;
  if (has_logindata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->logindata(), output);
  }

  // optional .ChristmasDB.LimitDataAll limitData = 3;
  if (has_limitdata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->limitdata(), output);
  }

  // optional .ChristmasDB.NewYearPro newyeardata = 4;
  if (has_newyeardata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->newyeardata(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChristmasAllData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .ChristmasDB.BreakEggDB breakEggData = 1;
  if (has_breakeggdata()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->breakeggdata(), target);
  }

  // optional .ChristmasDB.ChristmasLoginDB loginData = 2;
  if (has_logindata()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->logindata(), target);
  }

  // optional .ChristmasDB.LimitDataAll limitData = 3;
  if (has_limitdata()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->limitdata(), target);
  }

  // optional .ChristmasDB.NewYearPro newyeardata = 4;
  if (has_newyeardata()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->newyeardata(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChristmasAllData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ChristmasDB.BreakEggDB breakEggData = 1;
    if (has_breakeggdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->breakeggdata());
    }

    // optional .ChristmasDB.ChristmasLoginDB loginData = 2;
    if (has_logindata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->logindata());
    }

    // optional .ChristmasDB.LimitDataAll limitData = 3;
    if (has_limitdata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->limitdata());
    }

    // optional .ChristmasDB.NewYearPro newyeardata = 4;
    if (has_newyeardata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->newyeardata());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChristmasAllData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChristmasAllData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChristmasAllData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChristmasAllData::MergeFrom(const ChristmasAllData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_breakeggdata()) {
      mutable_breakeggdata()->::ChristmasDB::BreakEggDB::MergeFrom(from.breakeggdata());
    }
    if (from.has_logindata()) {
      mutable_logindata()->::ChristmasDB::ChristmasLoginDB::MergeFrom(from.logindata());
    }
    if (from.has_limitdata()) {
      mutable_limitdata()->::ChristmasDB::LimitDataAll::MergeFrom(from.limitdata());
    }
    if (from.has_newyeardata()) {
      mutable_newyeardata()->::ChristmasDB::NewYearPro::MergeFrom(from.newyeardata());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChristmasAllData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChristmasAllData::CopyFrom(const ChristmasAllData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChristmasAllData::IsInitialized() const {

  return true;
}

void ChristmasAllData::Swap(ChristmasAllData* other) {
  if (other != this) {
    std::swap(breakeggdata_, other->breakeggdata_);
    std::swap(logindata_, other->logindata_);
    std::swap(limitdata_, other->limitdata_);
    std::swap(newyeardata_, other->newyeardata_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChristmasAllData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChristmasAllData_descriptor_;
  metadata.reflection = ChristmasAllData_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ChristmasDB

// @@protoc_insertion_point(global_scope)

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CharLogin/MagicWeapon.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "CharLogin/MagicWeapon.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace MagicWeapon {

namespace {

const ::google::protobuf::Descriptor* PassiveTempSkill_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PassiveTempSkill_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClientMagicWeapon_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClientMagicWeapon_reflection_ = NULL;
const ::google::protobuf::Descriptor* MagicStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MagicStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestAdvanceMagic_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestAdvanceMagic_reflection_ = NULL;
const ::google::protobuf::Descriptor* MagicItemList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MagicItemList_reflection_ = NULL;
const ::google::protobuf::Descriptor* RetAdvanceMagic_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RetAdvanceMagic_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_CharLogin_2fMagicWeapon_2eproto() {
  protobuf_AddDesc_CharLogin_2fMagicWeapon_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "CharLogin/MagicWeapon.proto");
  GOOGLE_CHECK(file != NULL);
  PassiveTempSkill_descriptor_ = file->message_type(0);
  static const int PassiveTempSkill_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PassiveTempSkill, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PassiveTempSkill, skillid_),
  };
  PassiveTempSkill_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PassiveTempSkill_descriptor_,
      PassiveTempSkill::default_instance_,
      PassiveTempSkill_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PassiveTempSkill, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PassiveTempSkill, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PassiveTempSkill));
  ClientMagicWeapon_descriptor_ = file->message_type(1);
  static const int ClientMagicWeapon_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientMagicWeapon, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientMagicWeapon, exp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientMagicWeapon, skillid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientMagicWeapon, advancetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientMagicWeapon, begintime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientMagicWeapon, tempid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientMagicWeapon, passiveskilllist_),
  };
  ClientMagicWeapon_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClientMagicWeapon_descriptor_,
      ClientMagicWeapon::default_instance_,
      ClientMagicWeapon_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientMagicWeapon, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClientMagicWeapon, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClientMagicWeapon));
  MagicStatistics_descriptor_ = file->message_type(2);
  static const int MagicStatistics_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MagicStatistics, multiple_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MagicStatistics, counts_),
  };
  MagicStatistics_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MagicStatistics_descriptor_,
      MagicStatistics::default_instance_,
      MagicStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MagicStatistics, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MagicStatistics, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MagicStatistics));
  RequestAdvanceMagic_descriptor_ = file->message_type(3);
  static const int RequestAdvanceMagic_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestAdvanceMagic, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestAdvanceMagic, isautobuy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestAdvanceMagic, id_),
  };
  RequestAdvanceMagic_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RequestAdvanceMagic_descriptor_,
      RequestAdvanceMagic::default_instance_,
      RequestAdvanceMagic_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestAdvanceMagic, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestAdvanceMagic, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RequestAdvanceMagic));
  MagicItemList_descriptor_ = file->message_type(4);
  static const int MagicItemList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MagicItemList, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MagicItemList, counts_),
  };
  MagicItemList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MagicItemList_descriptor_,
      MagicItemList::default_instance_,
      MagicItemList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MagicItemList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MagicItemList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MagicItemList));
  RetAdvanceMagic_descriptor_ = file->message_type(5);
  static const int RetAdvanceMagic_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetAdvanceMagic, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetAdvanceMagic, exp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetAdvanceMagic, skillidlist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetAdvanceMagic, multiplist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetAdvanceMagic, addallexp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetAdvanceMagic, itemlist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetAdvanceMagic, golden_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetAdvanceMagic, money_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetAdvanceMagic, error_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetAdvanceMagic, stoperror_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetAdvanceMagic, type_),
  };
  RetAdvanceMagic_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RetAdvanceMagic_descriptor_,
      RetAdvanceMagic::default_instance_,
      RetAdvanceMagic_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetAdvanceMagic, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RetAdvanceMagic, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RetAdvanceMagic));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_CharLogin_2fMagicWeapon_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PassiveTempSkill_descriptor_, &PassiveTempSkill::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClientMagicWeapon_descriptor_, &ClientMagicWeapon::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MagicStatistics_descriptor_, &MagicStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RequestAdvanceMagic_descriptor_, &RequestAdvanceMagic::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MagicItemList_descriptor_, &MagicItemList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RetAdvanceMagic_descriptor_, &RetAdvanceMagic::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_CharLogin_2fMagicWeapon_2eproto() {
  delete PassiveTempSkill::default_instance_;
  delete PassiveTempSkill_reflection_;
  delete ClientMagicWeapon::default_instance_;
  delete ClientMagicWeapon_reflection_;
  delete MagicStatistics::default_instance_;
  delete MagicStatistics_reflection_;
  delete RequestAdvanceMagic::default_instance_;
  delete RequestAdvanceMagic_reflection_;
  delete MagicItemList::default_instance_;
  delete MagicItemList_reflection_;
  delete RetAdvanceMagic::default_instance_;
  delete RetAdvanceMagic_reflection_;
}

void protobuf_AddDesc_CharLogin_2fMagicWeapon_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\033CharLogin/MagicWeapon.proto\022\013MagicWeap"
    "on\"2\n\020PassiveTempSkill\022\r\n\005index\030\001 \001(\005\022\017\n"
    "\007skillid\030\002 \001(\005\"\256\001\n\021ClientMagicWeapon\022\n\n\002"
    "id\030\001 \002(\005\022\013\n\003exp\030\002 \001(\005\022\017\n\007skillid\030\003 \003(\005\022\023"
    "\n\013advancetime\030\004 \001(\003\022\021\n\tbeginTime\030\005 \001(\005\022\016"
    "\n\006tempID\030\006 \001(\005\0227\n\020passiveSkillList\030\007 \003(\013"
    "2\035.MagicWeapon.PassiveTempSkill\"3\n\017Magic"
    "Statistics\022\020\n\010multiple\030\001 \001(\005\022\016\n\006counts\030\002"
    " \001(\005\"B\n\023RequestAdvanceMagic\022\014\n\004type\030\001 \001("
    "\005\022\021\n\tisAutoBuy\030\002 \001(\010\022\n\n\002id\030\003 \001(\005\"/\n\rMagi"
    "cItemList\022\016\n\006itemID\030\001 \001(\005\022\016\n\006counts\030\002 \001("
    "\005\"\201\002\n\017RetAdvanceMagic\022\n\n\002id\030\001 \002(\005\022\013\n\003exp"
    "\030\002 \001(\005\022\023\n\013skillidList\030\003 \003(\005\0220\n\nmultipLis"
    "t\030\004 \003(\0132\034.MagicWeapon.MagicStatistics\022\021\n"
    "\taddAllExp\030\005 \001(\005\022,\n\010itemList\030\006 \003(\0132\032.Mag"
    "icWeapon.MagicItemList\022\016\n\006golden\030\007 \001(\005\022\r"
    "\n\005money\030\010 \001(\005\022\r\n\005error\030\t \001(\005\022\021\n\tstopErro"
    "r\030\n \001(\005\022\014\n\004type\030\013 \001(\005", 701);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "CharLogin/MagicWeapon.proto", &protobuf_RegisterTypes);
  PassiveTempSkill::default_instance_ = new PassiveTempSkill();
  ClientMagicWeapon::default_instance_ = new ClientMagicWeapon();
  MagicStatistics::default_instance_ = new MagicStatistics();
  RequestAdvanceMagic::default_instance_ = new RequestAdvanceMagic();
  MagicItemList::default_instance_ = new MagicItemList();
  RetAdvanceMagic::default_instance_ = new RetAdvanceMagic();
  PassiveTempSkill::default_instance_->InitAsDefaultInstance();
  ClientMagicWeapon::default_instance_->InitAsDefaultInstance();
  MagicStatistics::default_instance_->InitAsDefaultInstance();
  RequestAdvanceMagic::default_instance_->InitAsDefaultInstance();
  MagicItemList::default_instance_->InitAsDefaultInstance();
  RetAdvanceMagic::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_CharLogin_2fMagicWeapon_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_CharLogin_2fMagicWeapon_2eproto {
  StaticDescriptorInitializer_CharLogin_2fMagicWeapon_2eproto() {
    protobuf_AddDesc_CharLogin_2fMagicWeapon_2eproto();
  }
} static_descriptor_initializer_CharLogin_2fMagicWeapon_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int PassiveTempSkill::kIndexFieldNumber;
const int PassiveTempSkill::kSkillidFieldNumber;
#endif  // !_MSC_VER

PassiveTempSkill::PassiveTempSkill()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PassiveTempSkill::InitAsDefaultInstance() {
}

PassiveTempSkill::PassiveTempSkill(const PassiveTempSkill& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PassiveTempSkill::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0;
  skillid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PassiveTempSkill::~PassiveTempSkill() {
  SharedDtor();
}

void PassiveTempSkill::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PassiveTempSkill::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PassiveTempSkill::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PassiveTempSkill_descriptor_;
}

const PassiveTempSkill& PassiveTempSkill::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CharLogin_2fMagicWeapon_2eproto();
  return *default_instance_;
}

PassiveTempSkill* PassiveTempSkill::default_instance_ = NULL;

PassiveTempSkill* PassiveTempSkill::New() const {
  return new PassiveTempSkill;
}

void PassiveTempSkill::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    index_ = 0;
    skillid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PassiveTempSkill::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_skillid;
        break;
      }

      // optional int32 skillid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skillid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &skillid_)));
          set_has_skillid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PassiveTempSkill::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // optional int32 skillid = 2;
  if (has_skillid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->skillid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PassiveTempSkill::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->index(), target);
  }

  // optional int32 skillid = 2;
  if (has_skillid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->skillid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PassiveTempSkill::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional int32 skillid = 2;
    if (has_skillid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->skillid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PassiveTempSkill::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PassiveTempSkill* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PassiveTempSkill*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PassiveTempSkill::MergeFrom(const PassiveTempSkill& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_skillid()) {
      set_skillid(from.skillid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PassiveTempSkill::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PassiveTempSkill::CopyFrom(const PassiveTempSkill& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PassiveTempSkill::IsInitialized() const {

  return true;
}

void PassiveTempSkill::Swap(PassiveTempSkill* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(skillid_, other->skillid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PassiveTempSkill::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PassiveTempSkill_descriptor_;
  metadata.reflection = PassiveTempSkill_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ClientMagicWeapon::kIdFieldNumber;
const int ClientMagicWeapon::kExpFieldNumber;
const int ClientMagicWeapon::kSkillidFieldNumber;
const int ClientMagicWeapon::kAdvancetimeFieldNumber;
const int ClientMagicWeapon::kBeginTimeFieldNumber;
const int ClientMagicWeapon::kTempIDFieldNumber;
const int ClientMagicWeapon::kPassiveSkillListFieldNumber;
#endif  // !_MSC_VER

ClientMagicWeapon::ClientMagicWeapon()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClientMagicWeapon::InitAsDefaultInstance() {
}

ClientMagicWeapon::ClientMagicWeapon(const ClientMagicWeapon& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClientMagicWeapon::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  exp_ = 0;
  advancetime_ = GOOGLE_LONGLONG(0);
  begintime_ = 0;
  tempid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClientMagicWeapon::~ClientMagicWeapon() {
  SharedDtor();
}

void ClientMagicWeapon::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClientMagicWeapon::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClientMagicWeapon::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClientMagicWeapon_descriptor_;
}

const ClientMagicWeapon& ClientMagicWeapon::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CharLogin_2fMagicWeapon_2eproto();
  return *default_instance_;
}

ClientMagicWeapon* ClientMagicWeapon::default_instance_ = NULL;

ClientMagicWeapon* ClientMagicWeapon::New() const {
  return new ClientMagicWeapon;
}

void ClientMagicWeapon::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    exp_ = 0;
    advancetime_ = GOOGLE_LONGLONG(0);
    begintime_ = 0;
    tempid_ = 0;
  }
  skillid_.Clear();
  passiveskilllist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClientMagicWeapon::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_exp;
        break;
      }

      // optional int32 exp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_skillid;
        break;
      }

      // repeated int32 skillid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skillid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_skillid())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_skillid())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_skillid;
        if (input->ExpectTag(32)) goto parse_advancetime;
        break;
      }

      // optional int64 advancetime = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_advancetime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &advancetime_)));
          set_has_advancetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_beginTime;
        break;
      }

      // optional int32 beginTime = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_beginTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &begintime_)));
          set_has_begintime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_tempID;
        break;
      }

      // optional int32 tempID = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tempID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tempid_)));
          set_has_tempid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_passiveSkillList;
        break;
      }

      // repeated .MagicWeapon.PassiveTempSkill passiveSkillList = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_passiveSkillList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_passiveskilllist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_passiveSkillList;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ClientMagicWeapon::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 exp = 2;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->exp(), output);
  }

  // repeated int32 skillid = 3;
  for (int i = 0; i < this->skillid_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->skillid(i), output);
  }

  // optional int64 advancetime = 4;
  if (has_advancetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->advancetime(), output);
  }

  // optional int32 beginTime = 5;
  if (has_begintime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->begintime(), output);
  }

  // optional int32 tempID = 6;
  if (has_tempid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->tempid(), output);
  }

  // repeated .MagicWeapon.PassiveTempSkill passiveSkillList = 7;
  for (int i = 0; i < this->passiveskilllist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->passiveskilllist(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClientMagicWeapon::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional int32 exp = 2;
  if (has_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->exp(), target);
  }

  // repeated int32 skillid = 3;
  for (int i = 0; i < this->skillid_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(3, this->skillid(i), target);
  }

  // optional int64 advancetime = 4;
  if (has_advancetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->advancetime(), target);
  }

  // optional int32 beginTime = 5;
  if (has_begintime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->begintime(), target);
  }

  // optional int32 tempID = 6;
  if (has_tempid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->tempid(), target);
  }

  // repeated .MagicWeapon.PassiveTempSkill passiveSkillList = 7;
  for (int i = 0; i < this->passiveskilllist_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->passiveskilllist(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClientMagicWeapon::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 exp = 2;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->exp());
    }

    // optional int64 advancetime = 4;
    if (has_advancetime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->advancetime());
    }

    // optional int32 beginTime = 5;
    if (has_begintime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->begintime());
    }

    // optional int32 tempID = 6;
    if (has_tempid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tempid());
    }

  }
  // repeated int32 skillid = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->skillid_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->skillid(i));
    }
    total_size += 1 * this->skillid_size() + data_size;
  }

  // repeated .MagicWeapon.PassiveTempSkill passiveSkillList = 7;
  total_size += 1 * this->passiveskilllist_size();
  for (int i = 0; i < this->passiveskilllist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->passiveskilllist(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientMagicWeapon::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClientMagicWeapon* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClientMagicWeapon*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClientMagicWeapon::MergeFrom(const ClientMagicWeapon& from) {
  GOOGLE_CHECK_NE(&from, this);
  skillid_.MergeFrom(from.skillid_);
  passiveskilllist_.MergeFrom(from.passiveskilllist_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_advancetime()) {
      set_advancetime(from.advancetime());
    }
    if (from.has_begintime()) {
      set_begintime(from.begintime());
    }
    if (from.has_tempid()) {
      set_tempid(from.tempid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClientMagicWeapon::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClientMagicWeapon::CopyFrom(const ClientMagicWeapon& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientMagicWeapon::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ClientMagicWeapon::Swap(ClientMagicWeapon* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(exp_, other->exp_);
    skillid_.Swap(&other->skillid_);
    std::swap(advancetime_, other->advancetime_);
    std::swap(begintime_, other->begintime_);
    std::swap(tempid_, other->tempid_);
    passiveskilllist_.Swap(&other->passiveskilllist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClientMagicWeapon::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClientMagicWeapon_descriptor_;
  metadata.reflection = ClientMagicWeapon_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MagicStatistics::kMultipleFieldNumber;
const int MagicStatistics::kCountsFieldNumber;
#endif  // !_MSC_VER

MagicStatistics::MagicStatistics()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MagicStatistics::InitAsDefaultInstance() {
}

MagicStatistics::MagicStatistics(const MagicStatistics& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MagicStatistics::SharedCtor() {
  _cached_size_ = 0;
  multiple_ = 0;
  counts_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MagicStatistics::~MagicStatistics() {
  SharedDtor();
}

void MagicStatistics::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MagicStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MagicStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MagicStatistics_descriptor_;
}

const MagicStatistics& MagicStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CharLogin_2fMagicWeapon_2eproto();
  return *default_instance_;
}

MagicStatistics* MagicStatistics::default_instance_ = NULL;

MagicStatistics* MagicStatistics::New() const {
  return new MagicStatistics;
}

void MagicStatistics::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    multiple_ = 0;
    counts_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MagicStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 multiple = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &multiple_)));
          set_has_multiple();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_counts;
        break;
      }

      // optional int32 counts = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_counts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &counts_)));
          set_has_counts();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MagicStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 multiple = 1;
  if (has_multiple()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->multiple(), output);
  }

  // optional int32 counts = 2;
  if (has_counts()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->counts(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MagicStatistics::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 multiple = 1;
  if (has_multiple()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->multiple(), target);
  }

  // optional int32 counts = 2;
  if (has_counts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->counts(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MagicStatistics::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 multiple = 1;
    if (has_multiple()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->multiple());
    }

    // optional int32 counts = 2;
    if (has_counts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->counts());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MagicStatistics::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MagicStatistics* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MagicStatistics*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MagicStatistics::MergeFrom(const MagicStatistics& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_multiple()) {
      set_multiple(from.multiple());
    }
    if (from.has_counts()) {
      set_counts(from.counts());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MagicStatistics::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MagicStatistics::CopyFrom(const MagicStatistics& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MagicStatistics::IsInitialized() const {

  return true;
}

void MagicStatistics::Swap(MagicStatistics* other) {
  if (other != this) {
    std::swap(multiple_, other->multiple_);
    std::swap(counts_, other->counts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MagicStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MagicStatistics_descriptor_;
  metadata.reflection = MagicStatistics_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RequestAdvanceMagic::kTypeFieldNumber;
const int RequestAdvanceMagic::kIsAutoBuyFieldNumber;
const int RequestAdvanceMagic::kIdFieldNumber;
#endif  // !_MSC_VER

RequestAdvanceMagic::RequestAdvanceMagic()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RequestAdvanceMagic::InitAsDefaultInstance() {
}

RequestAdvanceMagic::RequestAdvanceMagic(const RequestAdvanceMagic& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RequestAdvanceMagic::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  isautobuy_ = false;
  id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestAdvanceMagic::~RequestAdvanceMagic() {
  SharedDtor();
}

void RequestAdvanceMagic::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RequestAdvanceMagic::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestAdvanceMagic::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestAdvanceMagic_descriptor_;
}

const RequestAdvanceMagic& RequestAdvanceMagic::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CharLogin_2fMagicWeapon_2eproto();
  return *default_instance_;
}

RequestAdvanceMagic* RequestAdvanceMagic::default_instance_ = NULL;

RequestAdvanceMagic* RequestAdvanceMagic::New() const {
  return new RequestAdvanceMagic;
}

void RequestAdvanceMagic::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    isautobuy_ = false;
    id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RequestAdvanceMagic::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_isAutoBuy;
        break;
      }

      // optional bool isAutoBuy = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isAutoBuy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isautobuy_)));
          set_has_isautobuy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_id;
        break;
      }

      // optional int32 id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestAdvanceMagic::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // optional bool isAutoBuy = 2;
  if (has_isautobuy()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->isautobuy(), output);
  }

  // optional int32 id = 3;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RequestAdvanceMagic::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->type(), target);
  }

  // optional bool isAutoBuy = 2;
  if (has_isautobuy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->isautobuy(), target);
  }

  // optional int32 id = 3;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RequestAdvanceMagic::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional bool isAutoBuy = 2;
    if (has_isautobuy()) {
      total_size += 1 + 1;
    }

    // optional int32 id = 3;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestAdvanceMagic::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RequestAdvanceMagic* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RequestAdvanceMagic*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RequestAdvanceMagic::MergeFrom(const RequestAdvanceMagic& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_isautobuy()) {
      set_isautobuy(from.isautobuy());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RequestAdvanceMagic::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestAdvanceMagic::CopyFrom(const RequestAdvanceMagic& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestAdvanceMagic::IsInitialized() const {

  return true;
}

void RequestAdvanceMagic::Swap(RequestAdvanceMagic* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(isautobuy_, other->isautobuy_);
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RequestAdvanceMagic::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestAdvanceMagic_descriptor_;
  metadata.reflection = RequestAdvanceMagic_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MagicItemList::kItemIDFieldNumber;
const int MagicItemList::kCountsFieldNumber;
#endif  // !_MSC_VER

MagicItemList::MagicItemList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MagicItemList::InitAsDefaultInstance() {
}

MagicItemList::MagicItemList(const MagicItemList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MagicItemList::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0;
  counts_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MagicItemList::~MagicItemList() {
  SharedDtor();
}

void MagicItemList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MagicItemList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MagicItemList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MagicItemList_descriptor_;
}

const MagicItemList& MagicItemList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CharLogin_2fMagicWeapon_2eproto();
  return *default_instance_;
}

MagicItemList* MagicItemList::default_instance_ = NULL;

MagicItemList* MagicItemList::New() const {
  return new MagicItemList;
}

void MagicItemList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    itemid_ = 0;
    counts_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MagicItemList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 itemID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_counts;
        break;
      }

      // optional int32 counts = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_counts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &counts_)));
          set_has_counts();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MagicItemList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 itemID = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->itemid(), output);
  }

  // optional int32 counts = 2;
  if (has_counts()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->counts(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MagicItemList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 itemID = 1;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->itemid(), target);
  }

  // optional int32 counts = 2;
  if (has_counts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->counts(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MagicItemList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 itemID = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional int32 counts = 2;
    if (has_counts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->counts());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MagicItemList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MagicItemList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MagicItemList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MagicItemList::MergeFrom(const MagicItemList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_counts()) {
      set_counts(from.counts());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MagicItemList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MagicItemList::CopyFrom(const MagicItemList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MagicItemList::IsInitialized() const {

  return true;
}

void MagicItemList::Swap(MagicItemList* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(counts_, other->counts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MagicItemList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MagicItemList_descriptor_;
  metadata.reflection = MagicItemList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RetAdvanceMagic::kIdFieldNumber;
const int RetAdvanceMagic::kExpFieldNumber;
const int RetAdvanceMagic::kSkillidListFieldNumber;
const int RetAdvanceMagic::kMultipListFieldNumber;
const int RetAdvanceMagic::kAddAllExpFieldNumber;
const int RetAdvanceMagic::kItemListFieldNumber;
const int RetAdvanceMagic::kGoldenFieldNumber;
const int RetAdvanceMagic::kMoneyFieldNumber;
const int RetAdvanceMagic::kErrorFieldNumber;
const int RetAdvanceMagic::kStopErrorFieldNumber;
const int RetAdvanceMagic::kTypeFieldNumber;
#endif  // !_MSC_VER

RetAdvanceMagic::RetAdvanceMagic()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RetAdvanceMagic::InitAsDefaultInstance() {
}

RetAdvanceMagic::RetAdvanceMagic(const RetAdvanceMagic& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RetAdvanceMagic::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  exp_ = 0;
  addallexp_ = 0;
  golden_ = 0;
  money_ = 0;
  error_ = 0;
  stoperror_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RetAdvanceMagic::~RetAdvanceMagic() {
  SharedDtor();
}

void RetAdvanceMagic::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RetAdvanceMagic::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RetAdvanceMagic::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RetAdvanceMagic_descriptor_;
}

const RetAdvanceMagic& RetAdvanceMagic::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_CharLogin_2fMagicWeapon_2eproto();
  return *default_instance_;
}

RetAdvanceMagic* RetAdvanceMagic::default_instance_ = NULL;

RetAdvanceMagic* RetAdvanceMagic::New() const {
  return new RetAdvanceMagic;
}

void RetAdvanceMagic::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    exp_ = 0;
    addallexp_ = 0;
    golden_ = 0;
    money_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    error_ = 0;
    stoperror_ = 0;
    type_ = 0;
  }
  skillidlist_.Clear();
  multiplist_.Clear();
  itemlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RetAdvanceMagic::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_exp;
        break;
      }

      // optional int32 exp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_skillidList;
        break;
      }

      // repeated int32 skillidList = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skillidList:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_skillidlist())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_skillidlist())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_skillidList;
        if (input->ExpectTag(34)) goto parse_multipList;
        break;
      }

      // repeated .MagicWeapon.MagicStatistics multipList = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_multipList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_multiplist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_multipList;
        if (input->ExpectTag(40)) goto parse_addAllExp;
        break;
      }

      // optional int32 addAllExp = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_addAllExp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &addallexp_)));
          set_has_addallexp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_itemList;
        break;
      }

      // repeated .MagicWeapon.MagicItemList itemList = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_itemList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_itemlist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_itemList;
        if (input->ExpectTag(56)) goto parse_golden;
        break;
      }

      // optional int32 golden = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_golden:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &golden_)));
          set_has_golden();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_money;
        break;
      }

      // optional int32 money = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_error;
        break;
      }

      // optional int32 error = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_error:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &error_)));
          set_has_error();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_stopError;
        break;
      }

      // optional int32 stopError = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_stopError:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &stoperror_)));
          set_has_stoperror();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_type;
        break;
      }

      // optional int32 type = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RetAdvanceMagic::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 exp = 2;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->exp(), output);
  }

  // repeated int32 skillidList = 3;
  for (int i = 0; i < this->skillidlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->skillidlist(i), output);
  }

  // repeated .MagicWeapon.MagicStatistics multipList = 4;
  for (int i = 0; i < this->multiplist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->multiplist(i), output);
  }

  // optional int32 addAllExp = 5;
  if (has_addallexp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->addallexp(), output);
  }

  // repeated .MagicWeapon.MagicItemList itemList = 6;
  for (int i = 0; i < this->itemlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->itemlist(i), output);
  }

  // optional int32 golden = 7;
  if (has_golden()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->golden(), output);
  }

  // optional int32 money = 8;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->money(), output);
  }

  // optional int32 error = 9;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->error(), output);
  }

  // optional int32 stopError = 10;
  if (has_stoperror()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->stoperror(), output);
  }

  // optional int32 type = 11;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RetAdvanceMagic::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional int32 exp = 2;
  if (has_exp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->exp(), target);
  }

  // repeated int32 skillidList = 3;
  for (int i = 0; i < this->skillidlist_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(3, this->skillidlist(i), target);
  }

  // repeated .MagicWeapon.MagicStatistics multipList = 4;
  for (int i = 0; i < this->multiplist_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->multiplist(i), target);
  }

  // optional int32 addAllExp = 5;
  if (has_addallexp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->addallexp(), target);
  }

  // repeated .MagicWeapon.MagicItemList itemList = 6;
  for (int i = 0; i < this->itemlist_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->itemlist(i), target);
  }

  // optional int32 golden = 7;
  if (has_golden()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->golden(), target);
  }

  // optional int32 money = 8;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->money(), target);
  }

  // optional int32 error = 9;
  if (has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->error(), target);
  }

  // optional int32 stopError = 10;
  if (has_stoperror()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->stoperror(), target);
  }

  // optional int32 type = 11;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RetAdvanceMagic::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 exp = 2;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->exp());
    }

    // optional int32 addAllExp = 5;
    if (has_addallexp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->addallexp());
    }

    // optional int32 golden = 7;
    if (has_golden()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->golden());
    }

    // optional int32 money = 8;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 error = 9;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->error());
    }

    // optional int32 stopError = 10;
    if (has_stoperror()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->stoperror());
    }

    // optional int32 type = 11;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  // repeated int32 skillidList = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->skillidlist_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->skillidlist(i));
    }
    total_size += 1 * this->skillidlist_size() + data_size;
  }

  // repeated .MagicWeapon.MagicStatistics multipList = 4;
  total_size += 1 * this->multiplist_size();
  for (int i = 0; i < this->multiplist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->multiplist(i));
  }

  // repeated .MagicWeapon.MagicItemList itemList = 6;
  total_size += 1 * this->itemlist_size();
  for (int i = 0; i < this->itemlist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->itemlist(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RetAdvanceMagic::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RetAdvanceMagic* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RetAdvanceMagic*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RetAdvanceMagic::MergeFrom(const RetAdvanceMagic& from) {
  GOOGLE_CHECK_NE(&from, this);
  skillidlist_.MergeFrom(from.skillidlist_);
  multiplist_.MergeFrom(from.multiplist_);
  itemlist_.MergeFrom(from.itemlist_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_addallexp()) {
      set_addallexp(from.addallexp());
    }
    if (from.has_golden()) {
      set_golden(from.golden());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_error()) {
      set_error(from.error());
    }
    if (from.has_stoperror()) {
      set_stoperror(from.stoperror());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RetAdvanceMagic::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RetAdvanceMagic::CopyFrom(const RetAdvanceMagic& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RetAdvanceMagic::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RetAdvanceMagic::Swap(RetAdvanceMagic* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(exp_, other->exp_);
    skillidlist_.Swap(&other->skillidlist_);
    multiplist_.Swap(&other->multiplist_);
    std::swap(addallexp_, other->addallexp_);
    itemlist_.Swap(&other->itemlist_);
    std::swap(golden_, other->golden_);
    std::swap(money_, other->money_);
    std::swap(error_, other->error_);
    std::swap(stoperror_, other->stoperror_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RetAdvanceMagic::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RetAdvanceMagic_descriptor_;
  metadata.reflection = RetAdvanceMagic_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace MagicWeapon

// @@protoc_insertion_point(global_scope)

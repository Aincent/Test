// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MSProtoc/MS_ClanInfo.proto

#ifndef PROTOBUF_MSProtoc_2fMS_5fClanInfo_2eproto__INCLUDED
#define PROTOBUF_MSProtoc_2fMS_5fClanInfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace MS_ClanInfo {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
void protobuf_AssignDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
void protobuf_ShutdownFile_MSProtoc_2fMS_5fClanInfo_2eproto();

class ReqClanInfo;
class RetClanInfo;
class ReqSomeClanInfo;
class RetSomeClanInfo;
class ClanDetailInfo;
class ClanBaseInfo;
class JoinClan;
class LeaveClan;
class ClanMemberKilled;
class SynchClanEventToWS;
class MemberContri;
class JobChange;
class ClanUpdate;
class ClanCitryHold;
class ClanPaidEvent;

// ===================================================================

class ReqClanInfo : public ::google::protobuf::Message {
 public:
  ReqClanInfo();
  virtual ~ReqClanInfo();

  ReqClanInfo(const ReqClanInfo& from);

  inline ReqClanInfo& operator=(const ReqClanInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqClanInfo& default_instance();

  void Swap(ReqClanInfo* other);

  // implements Message ----------------------------------------------

  ReqClanInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqClanInfo& from);
  void MergeFrom(const ReqClanInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 begin = 1;
  inline bool has_begin() const;
  inline void clear_begin();
  static const int kBeginFieldNumber = 1;
  inline ::google::protobuf::int32 begin() const;
  inline void set_begin(::google::protobuf::int32 value);

  // required int32 end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline ::google::protobuf::int32 end() const;
  inline void set_end(::google::protobuf::int32 value);

  // required int32 queryCondition = 3;
  inline bool has_querycondition() const;
  inline void clear_querycondition();
  static const int kQueryConditionFieldNumber = 3;
  inline ::google::protobuf::int32 querycondition() const;
  inline void set_querycondition(::google::protobuf::int32 value);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:MS_ClanInfo.ReqClanInfo)
 private:
  inline void set_has_begin();
  inline void clear_has_begin();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_querycondition();
  inline void clear_has_querycondition();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 begin_;
  ::google::protobuf::int32 end_;
  ::std::string* name_;
  ::google::protobuf::int32 querycondition_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_AssignDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_ShutdownFile_MSProtoc_2fMS_5fClanInfo_2eproto();

  void InitAsDefaultInstance();
  static ReqClanInfo* default_instance_;
};
// -------------------------------------------------------------------

class RetClanInfo : public ::google::protobuf::Message {
 public:
  RetClanInfo();
  virtual ~RetClanInfo();

  RetClanInfo(const RetClanInfo& from);

  inline RetClanInfo& operator=(const RetClanInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RetClanInfo& default_instance();

  void Swap(RetClanInfo* other);

  // implements Message ----------------------------------------------

  RetClanInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetClanInfo& from);
  void MergeFrom(const RetClanInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MS_ClanInfo.ClanBaseInfo infoList = 1;
  inline int infolist_size() const;
  inline void clear_infolist();
  static const int kInfoListFieldNumber = 1;
  inline const ::MS_ClanInfo::ClanBaseInfo& infolist(int index) const;
  inline ::MS_ClanInfo::ClanBaseInfo* mutable_infolist(int index);
  inline ::MS_ClanInfo::ClanBaseInfo* add_infolist();
  inline const ::google::protobuf::RepeatedPtrField< ::MS_ClanInfo::ClanBaseInfo >&
      infolist() const;
  inline ::google::protobuf::RepeatedPtrField< ::MS_ClanInfo::ClanBaseInfo >*
      mutable_infolist();

  // required int32 isEnd = 2;
  inline bool has_isend() const;
  inline void clear_isend();
  static const int kIsEndFieldNumber = 2;
  inline ::google::protobuf::int32 isend() const;
  inline void set_isend(::google::protobuf::int32 value);

  // optional int32 totalClanNum = 3;
  inline bool has_totalclannum() const;
  inline void clear_totalclannum();
  static const int kTotalClanNumFieldNumber = 3;
  inline ::google::protobuf::int32 totalclannum() const;
  inline void set_totalclannum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MS_ClanInfo.RetClanInfo)
 private:
  inline void set_has_isend();
  inline void clear_has_isend();
  inline void set_has_totalclannum();
  inline void clear_has_totalclannum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::MS_ClanInfo::ClanBaseInfo > infolist_;
  ::google::protobuf::int32 isend_;
  ::google::protobuf::int32 totalclannum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_AssignDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_ShutdownFile_MSProtoc_2fMS_5fClanInfo_2eproto();

  void InitAsDefaultInstance();
  static RetClanInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReqSomeClanInfo : public ::google::protobuf::Message {
 public:
  ReqSomeClanInfo();
  virtual ~ReqSomeClanInfo();

  ReqSomeClanInfo(const ReqSomeClanInfo& from);

  inline ReqSomeClanInfo& operator=(const ReqSomeClanInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqSomeClanInfo& default_instance();

  void Swap(ReqSomeClanInfo* other);

  // implements Message ----------------------------------------------

  ReqSomeClanInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqSomeClanInfo& from);
  void MergeFrom(const ReqSomeClanInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 clanID = 1;
  inline bool has_clanid() const;
  inline void clear_clanid();
  static const int kClanIDFieldNumber = 1;
  inline ::google::protobuf::int32 clanid() const;
  inline void set_clanid(::google::protobuf::int32 value);

  // required string clanName = 2;
  inline bool has_clanname() const;
  inline void clear_clanname();
  static const int kClanNameFieldNumber = 2;
  inline const ::std::string& clanname() const;
  inline void set_clanname(const ::std::string& value);
  inline void set_clanname(const char* value);
  inline void set_clanname(const char* value, size_t size);
  inline ::std::string* mutable_clanname();
  inline ::std::string* release_clanname();
  inline void set_allocated_clanname(::std::string* clanname);

  // required int32 queryCondition = 3;
  inline bool has_querycondition() const;
  inline void clear_querycondition();
  static const int kQueryConditionFieldNumber = 3;
  inline ::google::protobuf::int32 querycondition() const;
  inline void set_querycondition(::google::protobuf::int32 value);

  // optional int32 memberBegin = 4;
  inline bool has_memberbegin() const;
  inline void clear_memberbegin();
  static const int kMemberBeginFieldNumber = 4;
  inline ::google::protobuf::int32 memberbegin() const;
  inline void set_memberbegin(::google::protobuf::int32 value);

  // optional int32 memberEnd = 5;
  inline bool has_memberend() const;
  inline void clear_memberend();
  static const int kMemberEndFieldNumber = 5;
  inline ::google::protobuf::int32 memberend() const;
  inline void set_memberend(::google::protobuf::int32 value);

  // optional bool isOff = 6;
  inline bool has_isoff() const;
  inline void clear_isoff();
  static const int kIsOffFieldNumber = 6;
  inline bool isoff() const;
  inline void set_isoff(bool value);

  // @@protoc_insertion_point(class_scope:MS_ClanInfo.ReqSomeClanInfo)
 private:
  inline void set_has_clanid();
  inline void clear_has_clanid();
  inline void set_has_clanname();
  inline void clear_has_clanname();
  inline void set_has_querycondition();
  inline void clear_has_querycondition();
  inline void set_has_memberbegin();
  inline void clear_has_memberbegin();
  inline void set_has_memberend();
  inline void clear_has_memberend();
  inline void set_has_isoff();
  inline void clear_has_isoff();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* clanname_;
  ::google::protobuf::int32 clanid_;
  ::google::protobuf::int32 querycondition_;
  ::google::protobuf::int32 memberbegin_;
  ::google::protobuf::int32 memberend_;
  bool isoff_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_AssignDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_ShutdownFile_MSProtoc_2fMS_5fClanInfo_2eproto();

  void InitAsDefaultInstance();
  static ReqSomeClanInfo* default_instance_;
};
// -------------------------------------------------------------------

class RetSomeClanInfo : public ::google::protobuf::Message {
 public:
  RetSomeClanInfo();
  virtual ~RetSomeClanInfo();

  RetSomeClanInfo(const RetSomeClanInfo& from);

  inline RetSomeClanInfo& operator=(const RetSomeClanInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RetSomeClanInfo& default_instance();

  void Swap(RetSomeClanInfo* other);

  // implements Message ----------------------------------------------

  RetSomeClanInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetSomeClanInfo& from);
  void MergeFrom(const RetSomeClanInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .MS_ClanInfo.ClanDetailInfo detailInfo = 1;
  inline bool has_detailinfo() const;
  inline void clear_detailinfo();
  static const int kDetailInfoFieldNumber = 1;
  inline const ::MS_ClanInfo::ClanDetailInfo& detailinfo() const;
  inline ::MS_ClanInfo::ClanDetailInfo* mutable_detailinfo();
  inline ::MS_ClanInfo::ClanDetailInfo* release_detailinfo();
  inline void set_allocated_detailinfo(::MS_ClanInfo::ClanDetailInfo* detailinfo);

  // @@protoc_insertion_point(class_scope:MS_ClanInfo.RetSomeClanInfo)
 private:
  inline void set_has_detailinfo();
  inline void clear_has_detailinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::MS_ClanInfo::ClanDetailInfo* detailinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_AssignDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_ShutdownFile_MSProtoc_2fMS_5fClanInfo_2eproto();

  void InitAsDefaultInstance();
  static RetSomeClanInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClanDetailInfo : public ::google::protobuf::Message {
 public:
  ClanDetailInfo();
  virtual ~ClanDetailInfo();

  ClanDetailInfo(const ClanDetailInfo& from);

  inline ClanDetailInfo& operator=(const ClanDetailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanDetailInfo& default_instance();

  void Swap(ClanDetailInfo* other);

  // implements Message ----------------------------------------------

  ClanDetailInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanDetailInfo& from);
  void MergeFrom(const ClanDetailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .MS_ClanInfo.ClanBaseInfo baseInfo = 1;
  inline bool has_baseinfo() const;
  inline void clear_baseinfo();
  static const int kBaseInfoFieldNumber = 1;
  inline const ::MS_ClanInfo::ClanBaseInfo& baseinfo() const;
  inline ::MS_ClanInfo::ClanBaseInfo* mutable_baseinfo();
  inline ::MS_ClanInfo::ClanBaseInfo* release_baseinfo();
  inline void set_allocated_baseinfo(::MS_ClanInfo::ClanBaseInfo* baseinfo);

  // repeated string memberName = 2;
  inline int membername_size() const;
  inline void clear_membername();
  static const int kMemberNameFieldNumber = 2;
  inline const ::std::string& membername(int index) const;
  inline ::std::string* mutable_membername(int index);
  inline void set_membername(int index, const ::std::string& value);
  inline void set_membername(int index, const char* value);
  inline void set_membername(int index, const char* value, size_t size);
  inline ::std::string* add_membername();
  inline void add_membername(const ::std::string& value);
  inline void add_membername(const char* value);
  inline void add_membername(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& membername() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_membername();

  // required int32 isEnd = 3;
  inline bool has_isend() const;
  inline void clear_isend();
  static const int kIsEndFieldNumber = 3;
  inline ::google::protobuf::int32 isend() const;
  inline void set_isend(::google::protobuf::int32 value);

  // repeated string histroyBoos = 4;
  inline int histroyboos_size() const;
  inline void clear_histroyboos();
  static const int kHistroyBoosFieldNumber = 4;
  inline const ::std::string& histroyboos(int index) const;
  inline ::std::string* mutable_histroyboos(int index);
  inline void set_histroyboos(int index, const ::std::string& value);
  inline void set_histroyboos(int index, const char* value);
  inline void set_histroyboos(int index, const char* value, size_t size);
  inline ::std::string* add_histroyboos();
  inline void add_histroyboos(const ::std::string& value);
  inline void add_histroyboos(const char* value);
  inline void add_histroyboos(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& histroyboos() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_histroyboos();

  // @@protoc_insertion_point(class_scope:MS_ClanInfo.ClanDetailInfo)
 private:
  inline void set_has_baseinfo();
  inline void clear_has_baseinfo();
  inline void set_has_isend();
  inline void clear_has_isend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::MS_ClanInfo::ClanBaseInfo* baseinfo_;
  ::google::protobuf::RepeatedPtrField< ::std::string> membername_;
  ::google::protobuf::RepeatedPtrField< ::std::string> histroyboos_;
  ::google::protobuf::int32 isend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_AssignDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_ShutdownFile_MSProtoc_2fMS_5fClanInfo_2eproto();

  void InitAsDefaultInstance();
  static ClanDetailInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClanBaseInfo : public ::google::protobuf::Message {
 public:
  ClanBaseInfo();
  virtual ~ClanBaseInfo();

  ClanBaseInfo(const ClanBaseInfo& from);

  inline ClanBaseInfo& operator=(const ClanBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanBaseInfo& default_instance();

  void Swap(ClanBaseInfo* other);

  // implements Message ----------------------------------------------

  ClanBaseInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanBaseInfo& from);
  void MergeFrom(const ClanBaseInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ID = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 Lv = 2;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 2;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // required int32 memberNum = 3;
  inline bool has_membernum() const;
  inline void clear_membernum();
  static const int kMemberNumFieldNumber = 3;
  inline ::google::protobuf::int32 membernum() const;
  inline void set_membernum(::google::protobuf::int32 value);

  // required int64 createTime = 4;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 4;
  inline ::google::protobuf::int64 createtime() const;
  inline void set_createtime(::google::protobuf::int64 value);

  // required string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string bossName = 6;
  inline bool has_bossname() const;
  inline void clear_bossname();
  static const int kBossNameFieldNumber = 6;
  inline const ::std::string& bossname() const;
  inline void set_bossname(const ::std::string& value);
  inline void set_bossname(const char* value);
  inline void set_bossname(const char* value, size_t size);
  inline ::std::string* mutable_bossname();
  inline ::std::string* release_bossname();
  inline void set_allocated_bossname(::std::string* bossname);

  // @@protoc_insertion_point(class_scope:MS_ClanInfo.ClanBaseInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_membernum();
  inline void clear_has_membernum();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_bossname();
  inline void clear_has_bossname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 lv_;
  ::google::protobuf::int64 createtime_;
  ::std::string* name_;
  ::std::string* bossname_;
  ::google::protobuf::int32 membernum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_AssignDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_ShutdownFile_MSProtoc_2fMS_5fClanInfo_2eproto();

  void InitAsDefaultInstance();
  static ClanBaseInfo* default_instance_;
};
// -------------------------------------------------------------------

class JoinClan : public ::google::protobuf::Message {
 public:
  JoinClan();
  virtual ~JoinClan();

  JoinClan(const JoinClan& from);

  inline JoinClan& operator=(const JoinClan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinClan& default_instance();

  void Swap(JoinClan* other);

  // implements Message ----------------------------------------------

  JoinClan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinClan& from);
  void MergeFrom(const JoinClan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:MS_ClanInfo.JoinClan)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_AssignDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_ShutdownFile_MSProtoc_2fMS_5fClanInfo_2eproto();

  void InitAsDefaultInstance();
  static JoinClan* default_instance_;
};
// -------------------------------------------------------------------

class LeaveClan : public ::google::protobuf::Message {
 public:
  LeaveClan();
  virtual ~LeaveClan();

  LeaveClan(const LeaveClan& from);

  inline LeaveClan& operator=(const LeaveClan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveClan& default_instance();

  void Swap(LeaveClan* other);

  // implements Message ----------------------------------------------

  LeaveClan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveClan& from);
  void MergeFrom(const LeaveClan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:MS_ClanInfo.LeaveClan)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_AssignDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_ShutdownFile_MSProtoc_2fMS_5fClanInfo_2eproto();

  void InitAsDefaultInstance();
  static LeaveClan* default_instance_;
};
// -------------------------------------------------------------------

class ClanMemberKilled : public ::google::protobuf::Message {
 public:
  ClanMemberKilled();
  virtual ~ClanMemberKilled();

  ClanMemberKilled(const ClanMemberKilled& from);

  inline ClanMemberKilled& operator=(const ClanMemberKilled& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanMemberKilled& default_instance();

  void Swap(ClanMemberKilled* other);

  // implements Message ----------------------------------------------

  ClanMemberKilled* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanMemberKilled& from);
  void MergeFrom(const ClanMemberKilled& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 mapid = 3;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapidFieldNumber = 3;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // optional string killer = 4;
  inline bool has_killer() const;
  inline void clear_killer();
  static const int kKillerFieldNumber = 4;
  inline const ::std::string& killer() const;
  inline void set_killer(const ::std::string& value);
  inline void set_killer(const char* value);
  inline void set_killer(const char* value, size_t size);
  inline ::std::string* mutable_killer();
  inline ::std::string* release_killer();
  inline void set_allocated_killer(::std::string* killer);

  // @@protoc_insertion_point(class_scope:MS_ClanInfo.ClanMemberKilled)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_killer();
  inline void clear_has_killer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::std::string* name_;
  ::std::string* killer_;
  ::google::protobuf::int32 mapid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_AssignDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_ShutdownFile_MSProtoc_2fMS_5fClanInfo_2eproto();

  void InitAsDefaultInstance();
  static ClanMemberKilled* default_instance_;
};
// -------------------------------------------------------------------

class SynchClanEventToWS : public ::google::protobuf::Message {
 public:
  SynchClanEventToWS();
  virtual ~SynchClanEventToWS();

  SynchClanEventToWS(const SynchClanEventToWS& from);

  inline SynchClanEventToWS& operator=(const SynchClanEventToWS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SynchClanEventToWS& default_instance();

  void Swap(SynchClanEventToWS* other);

  // implements Message ----------------------------------------------

  SynchClanEventToWS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SynchClanEventToWS& from);
  void MergeFrom(const SynchClanEventToWS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // required double time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline double time() const;
  inline void set_time(double value);

  // optional string killer = 3;
  inline bool has_killer() const;
  inline void clear_killer();
  static const int kKillerFieldNumber = 3;
  inline const ::std::string& killer() const;
  inline void set_killer(const ::std::string& value);
  inline void set_killer(const char* value);
  inline void set_killer(const char* value, size_t size);
  inline ::std::string* mutable_killer();
  inline ::std::string* release_killer();
  inline void set_allocated_killer(::std::string* killer);

  // @@protoc_insertion_point(class_scope:MS_ClanInfo.SynchClanEventToWS)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_killer();
  inline void clear_has_killer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  double time_;
  ::std::string* killer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_AssignDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_ShutdownFile_MSProtoc_2fMS_5fClanInfo_2eproto();

  void InitAsDefaultInstance();
  static SynchClanEventToWS* default_instance_;
};
// -------------------------------------------------------------------

class MemberContri : public ::google::protobuf::Message {
 public:
  MemberContri();
  virtual ~MemberContri();

  MemberContri(const MemberContri& from);

  inline MemberContri& operator=(const MemberContri& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemberContri& default_instance();

  void Swap(MemberContri* other);

  // implements Message ----------------------------------------------

  MemberContri* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemberContri& from);
  void MergeFrom(const MemberContri& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 golden = 3;
  inline bool has_golden() const;
  inline void clear_golden();
  static const int kGoldenFieldNumber = 3;
  inline ::google::protobuf::int32 golden() const;
  inline void set_golden(::google::protobuf::int32 value);

  // optional int32 money = 4;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 4;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 contri = 5;
  inline bool has_contri() const;
  inline void clear_contri();
  static const int kContriFieldNumber = 5;
  inline ::google::protobuf::int32 contri() const;
  inline void set_contri(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MS_ClanInfo.MemberContri)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_golden();
  inline void clear_has_golden();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_contri();
  inline void clear_has_contri();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::std::string* name_;
  ::google::protobuf::int32 golden_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 contri_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_AssignDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_ShutdownFile_MSProtoc_2fMS_5fClanInfo_2eproto();

  void InitAsDefaultInstance();
  static MemberContri* default_instance_;
};
// -------------------------------------------------------------------

class JobChange : public ::google::protobuf::Message {
 public:
  JobChange();
  virtual ~JobChange();

  JobChange(const JobChange& from);

  inline JobChange& operator=(const JobChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JobChange& default_instance();

  void Swap(JobChange* other);

  // implements Message ----------------------------------------------

  JobChange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobChange& from);
  void MergeFrom(const JobChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional string bname = 2;
  inline bool has_bname() const;
  inline void clear_bname();
  static const int kBnameFieldNumber = 2;
  inline const ::std::string& bname() const;
  inline void set_bname(const ::std::string& value);
  inline void set_bname(const char* value);
  inline void set_bname(const char* value, size_t size);
  inline ::std::string* mutable_bname();
  inline ::std::string* release_bname();
  inline void set_allocated_bname(::std::string* bname);

  // optional string ename = 3;
  inline bool has_ename() const;
  inline void clear_ename();
  static const int kEnameFieldNumber = 3;
  inline const ::std::string& ename() const;
  inline void set_ename(const ::std::string& value);
  inline void set_ename(const char* value);
  inline void set_ename(const char* value, size_t size);
  inline ::std::string* mutable_ename();
  inline ::std::string* release_ename();
  inline void set_allocated_ename(::std::string* ename);

  // optional int32 job = 4;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 4;
  inline ::google::protobuf::int32 job() const;
  inline void set_job(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MS_ClanInfo.JobChange)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_bname();
  inline void clear_has_bname();
  inline void set_has_ename();
  inline void clear_has_ename();
  inline void set_has_job();
  inline void clear_has_job();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::std::string* bname_;
  ::std::string* ename_;
  ::google::protobuf::int32 job_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_AssignDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_ShutdownFile_MSProtoc_2fMS_5fClanInfo_2eproto();

  void InitAsDefaultInstance();
  static JobChange* default_instance_;
};
// -------------------------------------------------------------------

class ClanUpdate : public ::google::protobuf::Message {
 public:
  ClanUpdate();
  virtual ~ClanUpdate();

  ClanUpdate(const ClanUpdate& from);

  inline ClanUpdate& operator=(const ClanUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanUpdate& default_instance();

  void Swap(ClanUpdate* other);

  // implements Message ----------------------------------------------

  ClanUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanUpdate& from);
  void MergeFrom(const ClanUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 lv = 3;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 3;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // optional int32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MS_ClanInfo.ClanUpdate)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::std::string* name_;
  ::google::protobuf::int32 lv_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_AssignDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_ShutdownFile_MSProtoc_2fMS_5fClanInfo_2eproto();

  void InitAsDefaultInstance();
  static ClanUpdate* default_instance_;
};
// -------------------------------------------------------------------

class ClanCitryHold : public ::google::protobuf::Message {
 public:
  ClanCitryHold();
  virtual ~ClanCitryHold();

  ClanCitryHold(const ClanCitryHold& from);

  inline ClanCitryHold& operator=(const ClanCitryHold& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanCitryHold& default_instance();

  void Swap(ClanCitryHold* other);

  // implements Message ----------------------------------------------

  ClanCitryHold* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanCitryHold& from);
  void MergeFrom(const ClanCitryHold& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional int32 cityid = 2;
  inline bool has_cityid() const;
  inline void clear_cityid();
  static const int kCityidFieldNumber = 2;
  inline ::google::protobuf::int32 cityid() const;
  inline void set_cityid(::google::protobuf::int32 value);

  // optional string clan = 3;
  inline bool has_clan() const;
  inline void clear_clan();
  static const int kClanFieldNumber = 3;
  inline const ::std::string& clan() const;
  inline void set_clan(const ::std::string& value);
  inline void set_clan(const char* value);
  inline void set_clan(const char* value, size_t size);
  inline ::std::string* mutable_clan();
  inline ::std::string* release_clan();
  inline void set_allocated_clan(::std::string* clan);

  // @@protoc_insertion_point(class_scope:MS_ClanInfo.ClanCitryHold)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_cityid();
  inline void clear_has_cityid();
  inline void set_has_clan();
  inline void clear_has_clan();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::std::string* clan_;
  ::google::protobuf::int32 cityid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_AssignDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_ShutdownFile_MSProtoc_2fMS_5fClanInfo_2eproto();

  void InitAsDefaultInstance();
  static ClanCitryHold* default_instance_;
};
// -------------------------------------------------------------------

class ClanPaidEvent : public ::google::protobuf::Message {
 public:
  ClanPaidEvent();
  virtual ~ClanPaidEvent();

  ClanPaidEvent(const ClanPaidEvent& from);

  inline ClanPaidEvent& operator=(const ClanPaidEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanPaidEvent& default_instance();

  void Swap(ClanPaidEvent* other);

  // implements Message ----------------------------------------------

  ClanPaidEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanPaidEvent& from);
  void MergeFrom(const ClanPaidEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 money = 3;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 3;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MS_ClanInfo.ClanPaidEvent)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_money();
  inline void clear_has_money();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_AssignDesc_MSProtoc_2fMS_5fClanInfo_2eproto();
  friend void protobuf_ShutdownFile_MSProtoc_2fMS_5fClanInfo_2eproto();

  void InitAsDefaultInstance();
  static ClanPaidEvent* default_instance_;
};
// ===================================================================


// ===================================================================

// ReqClanInfo

// required int32 begin = 1;
inline bool ReqClanInfo::has_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqClanInfo::set_has_begin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqClanInfo::clear_has_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqClanInfo::clear_begin() {
  begin_ = 0;
  clear_has_begin();
}
inline ::google::protobuf::int32 ReqClanInfo::begin() const {
  return begin_;
}
inline void ReqClanInfo::set_begin(::google::protobuf::int32 value) {
  set_has_begin();
  begin_ = value;
}

// required int32 end = 2;
inline bool ReqClanInfo::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqClanInfo::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqClanInfo::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqClanInfo::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 ReqClanInfo::end() const {
  return end_;
}
inline void ReqClanInfo::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
}

// required int32 queryCondition = 3;
inline bool ReqClanInfo::has_querycondition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqClanInfo::set_has_querycondition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqClanInfo::clear_has_querycondition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqClanInfo::clear_querycondition() {
  querycondition_ = 0;
  clear_has_querycondition();
}
inline ::google::protobuf::int32 ReqClanInfo::querycondition() const {
  return querycondition_;
}
inline void ReqClanInfo::set_querycondition(::google::protobuf::int32 value) {
  set_has_querycondition();
  querycondition_ = value;
}

// optional string name = 4;
inline bool ReqClanInfo::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqClanInfo::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqClanInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqClanInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ReqClanInfo::name() const {
  return *name_;
}
inline void ReqClanInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ReqClanInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ReqClanInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqClanInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ReqClanInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqClanInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RetClanInfo

// repeated .MS_ClanInfo.ClanBaseInfo infoList = 1;
inline int RetClanInfo::infolist_size() const {
  return infolist_.size();
}
inline void RetClanInfo::clear_infolist() {
  infolist_.Clear();
}
inline const ::MS_ClanInfo::ClanBaseInfo& RetClanInfo::infolist(int index) const {
  return infolist_.Get(index);
}
inline ::MS_ClanInfo::ClanBaseInfo* RetClanInfo::mutable_infolist(int index) {
  return infolist_.Mutable(index);
}
inline ::MS_ClanInfo::ClanBaseInfo* RetClanInfo::add_infolist() {
  return infolist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MS_ClanInfo::ClanBaseInfo >&
RetClanInfo::infolist() const {
  return infolist_;
}
inline ::google::protobuf::RepeatedPtrField< ::MS_ClanInfo::ClanBaseInfo >*
RetClanInfo::mutable_infolist() {
  return &infolist_;
}

// required int32 isEnd = 2;
inline bool RetClanInfo::has_isend() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetClanInfo::set_has_isend() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetClanInfo::clear_has_isend() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetClanInfo::clear_isend() {
  isend_ = 0;
  clear_has_isend();
}
inline ::google::protobuf::int32 RetClanInfo::isend() const {
  return isend_;
}
inline void RetClanInfo::set_isend(::google::protobuf::int32 value) {
  set_has_isend();
  isend_ = value;
}

// optional int32 totalClanNum = 3;
inline bool RetClanInfo::has_totalclannum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RetClanInfo::set_has_totalclannum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RetClanInfo::clear_has_totalclannum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RetClanInfo::clear_totalclannum() {
  totalclannum_ = 0;
  clear_has_totalclannum();
}
inline ::google::protobuf::int32 RetClanInfo::totalclannum() const {
  return totalclannum_;
}
inline void RetClanInfo::set_totalclannum(::google::protobuf::int32 value) {
  set_has_totalclannum();
  totalclannum_ = value;
}

// -------------------------------------------------------------------

// ReqSomeClanInfo

// required int32 clanID = 1;
inline bool ReqSomeClanInfo::has_clanid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqSomeClanInfo::set_has_clanid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqSomeClanInfo::clear_has_clanid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqSomeClanInfo::clear_clanid() {
  clanid_ = 0;
  clear_has_clanid();
}
inline ::google::protobuf::int32 ReqSomeClanInfo::clanid() const {
  return clanid_;
}
inline void ReqSomeClanInfo::set_clanid(::google::protobuf::int32 value) {
  set_has_clanid();
  clanid_ = value;
}

// required string clanName = 2;
inline bool ReqSomeClanInfo::has_clanname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqSomeClanInfo::set_has_clanname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqSomeClanInfo::clear_has_clanname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqSomeClanInfo::clear_clanname() {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    clanname_->clear();
  }
  clear_has_clanname();
}
inline const ::std::string& ReqSomeClanInfo::clanname() const {
  return *clanname_;
}
inline void ReqSomeClanInfo::set_clanname(const ::std::string& value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void ReqSomeClanInfo::set_clanname(const char* value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void ReqSomeClanInfo::set_clanname(const char* value, size_t size) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqSomeClanInfo::mutable_clanname() {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  return clanname_;
}
inline ::std::string* ReqSomeClanInfo::release_clanname() {
  clear_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clanname_;
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqSomeClanInfo::set_allocated_clanname(::std::string* clanname) {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    delete clanname_;
  }
  if (clanname) {
    set_has_clanname();
    clanname_ = clanname;
  } else {
    clear_has_clanname();
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 queryCondition = 3;
inline bool ReqSomeClanInfo::has_querycondition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqSomeClanInfo::set_has_querycondition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqSomeClanInfo::clear_has_querycondition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqSomeClanInfo::clear_querycondition() {
  querycondition_ = 0;
  clear_has_querycondition();
}
inline ::google::protobuf::int32 ReqSomeClanInfo::querycondition() const {
  return querycondition_;
}
inline void ReqSomeClanInfo::set_querycondition(::google::protobuf::int32 value) {
  set_has_querycondition();
  querycondition_ = value;
}

// optional int32 memberBegin = 4;
inline bool ReqSomeClanInfo::has_memberbegin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqSomeClanInfo::set_has_memberbegin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqSomeClanInfo::clear_has_memberbegin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqSomeClanInfo::clear_memberbegin() {
  memberbegin_ = 0;
  clear_has_memberbegin();
}
inline ::google::protobuf::int32 ReqSomeClanInfo::memberbegin() const {
  return memberbegin_;
}
inline void ReqSomeClanInfo::set_memberbegin(::google::protobuf::int32 value) {
  set_has_memberbegin();
  memberbegin_ = value;
}

// optional int32 memberEnd = 5;
inline bool ReqSomeClanInfo::has_memberend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqSomeClanInfo::set_has_memberend() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqSomeClanInfo::clear_has_memberend() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqSomeClanInfo::clear_memberend() {
  memberend_ = 0;
  clear_has_memberend();
}
inline ::google::protobuf::int32 ReqSomeClanInfo::memberend() const {
  return memberend_;
}
inline void ReqSomeClanInfo::set_memberend(::google::protobuf::int32 value) {
  set_has_memberend();
  memberend_ = value;
}

// optional bool isOff = 6;
inline bool ReqSomeClanInfo::has_isoff() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqSomeClanInfo::set_has_isoff() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqSomeClanInfo::clear_has_isoff() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqSomeClanInfo::clear_isoff() {
  isoff_ = false;
  clear_has_isoff();
}
inline bool ReqSomeClanInfo::isoff() const {
  return isoff_;
}
inline void ReqSomeClanInfo::set_isoff(bool value) {
  set_has_isoff();
  isoff_ = value;
}

// -------------------------------------------------------------------

// RetSomeClanInfo

// required .MS_ClanInfo.ClanDetailInfo detailInfo = 1;
inline bool RetSomeClanInfo::has_detailinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetSomeClanInfo::set_has_detailinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetSomeClanInfo::clear_has_detailinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetSomeClanInfo::clear_detailinfo() {
  if (detailinfo_ != NULL) detailinfo_->::MS_ClanInfo::ClanDetailInfo::Clear();
  clear_has_detailinfo();
}
inline const ::MS_ClanInfo::ClanDetailInfo& RetSomeClanInfo::detailinfo() const {
  return detailinfo_ != NULL ? *detailinfo_ : *default_instance_->detailinfo_;
}
inline ::MS_ClanInfo::ClanDetailInfo* RetSomeClanInfo::mutable_detailinfo() {
  set_has_detailinfo();
  if (detailinfo_ == NULL) detailinfo_ = new ::MS_ClanInfo::ClanDetailInfo;
  return detailinfo_;
}
inline ::MS_ClanInfo::ClanDetailInfo* RetSomeClanInfo::release_detailinfo() {
  clear_has_detailinfo();
  ::MS_ClanInfo::ClanDetailInfo* temp = detailinfo_;
  detailinfo_ = NULL;
  return temp;
}
inline void RetSomeClanInfo::set_allocated_detailinfo(::MS_ClanInfo::ClanDetailInfo* detailinfo) {
  delete detailinfo_;
  detailinfo_ = detailinfo;
  if (detailinfo) {
    set_has_detailinfo();
  } else {
    clear_has_detailinfo();
  }
}

// -------------------------------------------------------------------

// ClanDetailInfo

// required .MS_ClanInfo.ClanBaseInfo baseInfo = 1;
inline bool ClanDetailInfo::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanDetailInfo::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanDetailInfo::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanDetailInfo::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->::MS_ClanInfo::ClanBaseInfo::Clear();
  clear_has_baseinfo();
}
inline const ::MS_ClanInfo::ClanBaseInfo& ClanDetailInfo::baseinfo() const {
  return baseinfo_ != NULL ? *baseinfo_ : *default_instance_->baseinfo_;
}
inline ::MS_ClanInfo::ClanBaseInfo* ClanDetailInfo::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) baseinfo_ = new ::MS_ClanInfo::ClanBaseInfo;
  return baseinfo_;
}
inline ::MS_ClanInfo::ClanBaseInfo* ClanDetailInfo::release_baseinfo() {
  clear_has_baseinfo();
  ::MS_ClanInfo::ClanBaseInfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline void ClanDetailInfo::set_allocated_baseinfo(::MS_ClanInfo::ClanBaseInfo* baseinfo) {
  delete baseinfo_;
  baseinfo_ = baseinfo;
  if (baseinfo) {
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
}

// repeated string memberName = 2;
inline int ClanDetailInfo::membername_size() const {
  return membername_.size();
}
inline void ClanDetailInfo::clear_membername() {
  membername_.Clear();
}
inline const ::std::string& ClanDetailInfo::membername(int index) const {
  return membername_.Get(index);
}
inline ::std::string* ClanDetailInfo::mutable_membername(int index) {
  return membername_.Mutable(index);
}
inline void ClanDetailInfo::set_membername(int index, const ::std::string& value) {
  membername_.Mutable(index)->assign(value);
}
inline void ClanDetailInfo::set_membername(int index, const char* value) {
  membername_.Mutable(index)->assign(value);
}
inline void ClanDetailInfo::set_membername(int index, const char* value, size_t size) {
  membername_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanDetailInfo::add_membername() {
  return membername_.Add();
}
inline void ClanDetailInfo::add_membername(const ::std::string& value) {
  membername_.Add()->assign(value);
}
inline void ClanDetailInfo::add_membername(const char* value) {
  membername_.Add()->assign(value);
}
inline void ClanDetailInfo::add_membername(const char* value, size_t size) {
  membername_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClanDetailInfo::membername() const {
  return membername_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClanDetailInfo::mutable_membername() {
  return &membername_;
}

// required int32 isEnd = 3;
inline bool ClanDetailInfo::has_isend() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanDetailInfo::set_has_isend() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanDetailInfo::clear_has_isend() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanDetailInfo::clear_isend() {
  isend_ = 0;
  clear_has_isend();
}
inline ::google::protobuf::int32 ClanDetailInfo::isend() const {
  return isend_;
}
inline void ClanDetailInfo::set_isend(::google::protobuf::int32 value) {
  set_has_isend();
  isend_ = value;
}

// repeated string histroyBoos = 4;
inline int ClanDetailInfo::histroyboos_size() const {
  return histroyboos_.size();
}
inline void ClanDetailInfo::clear_histroyboos() {
  histroyboos_.Clear();
}
inline const ::std::string& ClanDetailInfo::histroyboos(int index) const {
  return histroyboos_.Get(index);
}
inline ::std::string* ClanDetailInfo::mutable_histroyboos(int index) {
  return histroyboos_.Mutable(index);
}
inline void ClanDetailInfo::set_histroyboos(int index, const ::std::string& value) {
  histroyboos_.Mutable(index)->assign(value);
}
inline void ClanDetailInfo::set_histroyboos(int index, const char* value) {
  histroyboos_.Mutable(index)->assign(value);
}
inline void ClanDetailInfo::set_histroyboos(int index, const char* value, size_t size) {
  histroyboos_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanDetailInfo::add_histroyboos() {
  return histroyboos_.Add();
}
inline void ClanDetailInfo::add_histroyboos(const ::std::string& value) {
  histroyboos_.Add()->assign(value);
}
inline void ClanDetailInfo::add_histroyboos(const char* value) {
  histroyboos_.Add()->assign(value);
}
inline void ClanDetailInfo::add_histroyboos(const char* value, size_t size) {
  histroyboos_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClanDetailInfo::histroyboos() const {
  return histroyboos_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClanDetailInfo::mutable_histroyboos() {
  return &histroyboos_;
}

// -------------------------------------------------------------------

// ClanBaseInfo

// required int32 ID = 1;
inline bool ClanBaseInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanBaseInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanBaseInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanBaseInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ClanBaseInfo::id() const {
  return id_;
}
inline void ClanBaseInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 Lv = 2;
inline bool ClanBaseInfo::has_lv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanBaseInfo::set_has_lv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanBaseInfo::clear_has_lv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanBaseInfo::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 ClanBaseInfo::lv() const {
  return lv_;
}
inline void ClanBaseInfo::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// required int32 memberNum = 3;
inline bool ClanBaseInfo::has_membernum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanBaseInfo::set_has_membernum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanBaseInfo::clear_has_membernum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanBaseInfo::clear_membernum() {
  membernum_ = 0;
  clear_has_membernum();
}
inline ::google::protobuf::int32 ClanBaseInfo::membernum() const {
  return membernum_;
}
inline void ClanBaseInfo::set_membernum(::google::protobuf::int32 value) {
  set_has_membernum();
  membernum_ = value;
}

// required int64 createTime = 4;
inline bool ClanBaseInfo::has_createtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanBaseInfo::set_has_createtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanBaseInfo::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanBaseInfo::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 ClanBaseInfo::createtime() const {
  return createtime_;
}
inline void ClanBaseInfo::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
}

// required string name = 5;
inline bool ClanBaseInfo::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClanBaseInfo::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClanBaseInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClanBaseInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClanBaseInfo::name() const {
  return *name_;
}
inline void ClanBaseInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanBaseInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanBaseInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanBaseInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClanBaseInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanBaseInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string bossName = 6;
inline bool ClanBaseInfo::has_bossname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClanBaseInfo::set_has_bossname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClanBaseInfo::clear_has_bossname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClanBaseInfo::clear_bossname() {
  if (bossname_ != &::google::protobuf::internal::kEmptyString) {
    bossname_->clear();
  }
  clear_has_bossname();
}
inline const ::std::string& ClanBaseInfo::bossname() const {
  return *bossname_;
}
inline void ClanBaseInfo::set_bossname(const ::std::string& value) {
  set_has_bossname();
  if (bossname_ == &::google::protobuf::internal::kEmptyString) {
    bossname_ = new ::std::string;
  }
  bossname_->assign(value);
}
inline void ClanBaseInfo::set_bossname(const char* value) {
  set_has_bossname();
  if (bossname_ == &::google::protobuf::internal::kEmptyString) {
    bossname_ = new ::std::string;
  }
  bossname_->assign(value);
}
inline void ClanBaseInfo::set_bossname(const char* value, size_t size) {
  set_has_bossname();
  if (bossname_ == &::google::protobuf::internal::kEmptyString) {
    bossname_ = new ::std::string;
  }
  bossname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanBaseInfo::mutable_bossname() {
  set_has_bossname();
  if (bossname_ == &::google::protobuf::internal::kEmptyString) {
    bossname_ = new ::std::string;
  }
  return bossname_;
}
inline ::std::string* ClanBaseInfo::release_bossname() {
  clear_has_bossname();
  if (bossname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bossname_;
    bossname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanBaseInfo::set_allocated_bossname(::std::string* bossname) {
  if (bossname_ != &::google::protobuf::internal::kEmptyString) {
    delete bossname_;
  }
  if (bossname) {
    set_has_bossname();
    bossname_ = bossname;
  } else {
    clear_has_bossname();
    bossname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// JoinClan

// required int64 time = 1;
inline bool JoinClan::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinClan::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinClan::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinClan::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 JoinClan::time() const {
  return time_;
}
inline void JoinClan::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional string name = 2;
inline bool JoinClan::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinClan::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinClan::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinClan::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& JoinClan::name() const {
  return *name_;
}
inline void JoinClan::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void JoinClan::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void JoinClan::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinClan::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* JoinClan::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinClan::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LeaveClan

// required int64 time = 1;
inline bool LeaveClan::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveClan::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveClan::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveClan::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 LeaveClan::time() const {
  return time_;
}
inline void LeaveClan::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional string name = 2;
inline bool LeaveClan::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaveClan::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaveClan::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaveClan::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LeaveClan::name() const {
  return *name_;
}
inline void LeaveClan::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LeaveClan::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LeaveClan::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaveClan::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LeaveClan::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LeaveClan::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClanMemberKilled

// required int64 time = 1;
inline bool ClanMemberKilled::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanMemberKilled::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanMemberKilled::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanMemberKilled::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 ClanMemberKilled::time() const {
  return time_;
}
inline void ClanMemberKilled::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional string name = 2;
inline bool ClanMemberKilled::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanMemberKilled::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanMemberKilled::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanMemberKilled::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClanMemberKilled::name() const {
  return *name_;
}
inline void ClanMemberKilled::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanMemberKilled::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanMemberKilled::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanMemberKilled::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClanMemberKilled::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanMemberKilled::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 mapid = 3;
inline bool ClanMemberKilled::has_mapid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanMemberKilled::set_has_mapid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanMemberKilled::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanMemberKilled::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 ClanMemberKilled::mapid() const {
  return mapid_;
}
inline void ClanMemberKilled::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
}

// optional string killer = 4;
inline bool ClanMemberKilled::has_killer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanMemberKilled::set_has_killer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanMemberKilled::clear_has_killer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanMemberKilled::clear_killer() {
  if (killer_ != &::google::protobuf::internal::kEmptyString) {
    killer_->clear();
  }
  clear_has_killer();
}
inline const ::std::string& ClanMemberKilled::killer() const {
  return *killer_;
}
inline void ClanMemberKilled::set_killer(const ::std::string& value) {
  set_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    killer_ = new ::std::string;
  }
  killer_->assign(value);
}
inline void ClanMemberKilled::set_killer(const char* value) {
  set_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    killer_ = new ::std::string;
  }
  killer_->assign(value);
}
inline void ClanMemberKilled::set_killer(const char* value, size_t size) {
  set_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    killer_ = new ::std::string;
  }
  killer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanMemberKilled::mutable_killer() {
  set_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    killer_ = new ::std::string;
  }
  return killer_;
}
inline ::std::string* ClanMemberKilled::release_killer() {
  clear_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = killer_;
    killer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanMemberKilled::set_allocated_killer(::std::string* killer) {
  if (killer_ != &::google::protobuf::internal::kEmptyString) {
    delete killer_;
  }
  if (killer) {
    set_has_killer();
    killer_ = killer;
  } else {
    clear_has_killer();
    killer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SynchClanEventToWS

// required int64 charid = 1;
inline bool SynchClanEventToWS::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SynchClanEventToWS::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SynchClanEventToWS::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SynchClanEventToWS::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 SynchClanEventToWS::charid() const {
  return charid_;
}
inline void SynchClanEventToWS::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// required double time = 2;
inline bool SynchClanEventToWS::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SynchClanEventToWS::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SynchClanEventToWS::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SynchClanEventToWS::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double SynchClanEventToWS::time() const {
  return time_;
}
inline void SynchClanEventToWS::set_time(double value) {
  set_has_time();
  time_ = value;
}

// optional string killer = 3;
inline bool SynchClanEventToWS::has_killer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SynchClanEventToWS::set_has_killer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SynchClanEventToWS::clear_has_killer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SynchClanEventToWS::clear_killer() {
  if (killer_ != &::google::protobuf::internal::kEmptyString) {
    killer_->clear();
  }
  clear_has_killer();
}
inline const ::std::string& SynchClanEventToWS::killer() const {
  return *killer_;
}
inline void SynchClanEventToWS::set_killer(const ::std::string& value) {
  set_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    killer_ = new ::std::string;
  }
  killer_->assign(value);
}
inline void SynchClanEventToWS::set_killer(const char* value) {
  set_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    killer_ = new ::std::string;
  }
  killer_->assign(value);
}
inline void SynchClanEventToWS::set_killer(const char* value, size_t size) {
  set_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    killer_ = new ::std::string;
  }
  killer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SynchClanEventToWS::mutable_killer() {
  set_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    killer_ = new ::std::string;
  }
  return killer_;
}
inline ::std::string* SynchClanEventToWS::release_killer() {
  clear_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = killer_;
    killer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SynchClanEventToWS::set_allocated_killer(::std::string* killer) {
  if (killer_ != &::google::protobuf::internal::kEmptyString) {
    delete killer_;
  }
  if (killer) {
    set_has_killer();
    killer_ = killer;
  } else {
    clear_has_killer();
    killer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MemberContri

// required int64 time = 1;
inline bool MemberContri::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemberContri::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemberContri::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemberContri::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 MemberContri::time() const {
  return time_;
}
inline void MemberContri::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional string name = 2;
inline bool MemberContri::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemberContri::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemberContri::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemberContri::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MemberContri::name() const {
  return *name_;
}
inline void MemberContri::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MemberContri::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MemberContri::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemberContri::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MemberContri::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MemberContri::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 golden = 3;
inline bool MemberContri::has_golden() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemberContri::set_has_golden() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemberContri::clear_has_golden() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemberContri::clear_golden() {
  golden_ = 0;
  clear_has_golden();
}
inline ::google::protobuf::int32 MemberContri::golden() const {
  return golden_;
}
inline void MemberContri::set_golden(::google::protobuf::int32 value) {
  set_has_golden();
  golden_ = value;
}

// optional int32 money = 4;
inline bool MemberContri::has_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemberContri::set_has_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MemberContri::clear_has_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MemberContri::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 MemberContri::money() const {
  return money_;
}
inline void MemberContri::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 contri = 5;
inline bool MemberContri::has_contri() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MemberContri::set_has_contri() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MemberContri::clear_has_contri() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MemberContri::clear_contri() {
  contri_ = 0;
  clear_has_contri();
}
inline ::google::protobuf::int32 MemberContri::contri() const {
  return contri_;
}
inline void MemberContri::set_contri(::google::protobuf::int32 value) {
  set_has_contri();
  contri_ = value;
}

// -------------------------------------------------------------------

// JobChange

// required int64 time = 1;
inline bool JobChange::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JobChange::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JobChange::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JobChange::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 JobChange::time() const {
  return time_;
}
inline void JobChange::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional string bname = 2;
inline bool JobChange::has_bname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JobChange::set_has_bname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JobChange::clear_has_bname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JobChange::clear_bname() {
  if (bname_ != &::google::protobuf::internal::kEmptyString) {
    bname_->clear();
  }
  clear_has_bname();
}
inline const ::std::string& JobChange::bname() const {
  return *bname_;
}
inline void JobChange::set_bname(const ::std::string& value) {
  set_has_bname();
  if (bname_ == &::google::protobuf::internal::kEmptyString) {
    bname_ = new ::std::string;
  }
  bname_->assign(value);
}
inline void JobChange::set_bname(const char* value) {
  set_has_bname();
  if (bname_ == &::google::protobuf::internal::kEmptyString) {
    bname_ = new ::std::string;
  }
  bname_->assign(value);
}
inline void JobChange::set_bname(const char* value, size_t size) {
  set_has_bname();
  if (bname_ == &::google::protobuf::internal::kEmptyString) {
    bname_ = new ::std::string;
  }
  bname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobChange::mutable_bname() {
  set_has_bname();
  if (bname_ == &::google::protobuf::internal::kEmptyString) {
    bname_ = new ::std::string;
  }
  return bname_;
}
inline ::std::string* JobChange::release_bname() {
  clear_has_bname();
  if (bname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bname_;
    bname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JobChange::set_allocated_bname(::std::string* bname) {
  if (bname_ != &::google::protobuf::internal::kEmptyString) {
    delete bname_;
  }
  if (bname) {
    set_has_bname();
    bname_ = bname;
  } else {
    clear_has_bname();
    bname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ename = 3;
inline bool JobChange::has_ename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JobChange::set_has_ename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JobChange::clear_has_ename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JobChange::clear_ename() {
  if (ename_ != &::google::protobuf::internal::kEmptyString) {
    ename_->clear();
  }
  clear_has_ename();
}
inline const ::std::string& JobChange::ename() const {
  return *ename_;
}
inline void JobChange::set_ename(const ::std::string& value) {
  set_has_ename();
  if (ename_ == &::google::protobuf::internal::kEmptyString) {
    ename_ = new ::std::string;
  }
  ename_->assign(value);
}
inline void JobChange::set_ename(const char* value) {
  set_has_ename();
  if (ename_ == &::google::protobuf::internal::kEmptyString) {
    ename_ = new ::std::string;
  }
  ename_->assign(value);
}
inline void JobChange::set_ename(const char* value, size_t size) {
  set_has_ename();
  if (ename_ == &::google::protobuf::internal::kEmptyString) {
    ename_ = new ::std::string;
  }
  ename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobChange::mutable_ename() {
  set_has_ename();
  if (ename_ == &::google::protobuf::internal::kEmptyString) {
    ename_ = new ::std::string;
  }
  return ename_;
}
inline ::std::string* JobChange::release_ename() {
  clear_has_ename();
  if (ename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ename_;
    ename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JobChange::set_allocated_ename(::std::string* ename) {
  if (ename_ != &::google::protobuf::internal::kEmptyString) {
    delete ename_;
  }
  if (ename) {
    set_has_ename();
    ename_ = ename;
  } else {
    clear_has_ename();
    ename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 job = 4;
inline bool JobChange::has_job() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JobChange::set_has_job() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JobChange::clear_has_job() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JobChange::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 JobChange::job() const {
  return job_;
}
inline void JobChange::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
}

// -------------------------------------------------------------------

// ClanUpdate

// required int64 time = 1;
inline bool ClanUpdate::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanUpdate::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanUpdate::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanUpdate::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 ClanUpdate::time() const {
  return time_;
}
inline void ClanUpdate::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional string name = 2;
inline bool ClanUpdate::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanUpdate::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanUpdate::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanUpdate::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClanUpdate::name() const {
  return *name_;
}
inline void ClanUpdate::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanUpdate::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanUpdate::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanUpdate::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClanUpdate::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanUpdate::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 lv = 3;
inline bool ClanUpdate::has_lv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanUpdate::set_has_lv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanUpdate::clear_has_lv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanUpdate::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 ClanUpdate::lv() const {
  return lv_;
}
inline void ClanUpdate::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// optional int32 count = 4;
inline bool ClanUpdate::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanUpdate::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanUpdate::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanUpdate::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 ClanUpdate::count() const {
  return count_;
}
inline void ClanUpdate::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// ClanCitryHold

// required int64 time = 1;
inline bool ClanCitryHold::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanCitryHold::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanCitryHold::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanCitryHold::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 ClanCitryHold::time() const {
  return time_;
}
inline void ClanCitryHold::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional int32 cityid = 2;
inline bool ClanCitryHold::has_cityid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanCitryHold::set_has_cityid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanCitryHold::clear_has_cityid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanCitryHold::clear_cityid() {
  cityid_ = 0;
  clear_has_cityid();
}
inline ::google::protobuf::int32 ClanCitryHold::cityid() const {
  return cityid_;
}
inline void ClanCitryHold::set_cityid(::google::protobuf::int32 value) {
  set_has_cityid();
  cityid_ = value;
}

// optional string clan = 3;
inline bool ClanCitryHold::has_clan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanCitryHold::set_has_clan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanCitryHold::clear_has_clan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanCitryHold::clear_clan() {
  if (clan_ != &::google::protobuf::internal::kEmptyString) {
    clan_->clear();
  }
  clear_has_clan();
}
inline const ::std::string& ClanCitryHold::clan() const {
  return *clan_;
}
inline void ClanCitryHold::set_clan(const ::std::string& value) {
  set_has_clan();
  if (clan_ == &::google::protobuf::internal::kEmptyString) {
    clan_ = new ::std::string;
  }
  clan_->assign(value);
}
inline void ClanCitryHold::set_clan(const char* value) {
  set_has_clan();
  if (clan_ == &::google::protobuf::internal::kEmptyString) {
    clan_ = new ::std::string;
  }
  clan_->assign(value);
}
inline void ClanCitryHold::set_clan(const char* value, size_t size) {
  set_has_clan();
  if (clan_ == &::google::protobuf::internal::kEmptyString) {
    clan_ = new ::std::string;
  }
  clan_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanCitryHold::mutable_clan() {
  set_has_clan();
  if (clan_ == &::google::protobuf::internal::kEmptyString) {
    clan_ = new ::std::string;
  }
  return clan_;
}
inline ::std::string* ClanCitryHold::release_clan() {
  clear_has_clan();
  if (clan_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clan_;
    clan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanCitryHold::set_allocated_clan(::std::string* clan) {
  if (clan_ != &::google::protobuf::internal::kEmptyString) {
    delete clan_;
  }
  if (clan) {
    set_has_clan();
    clan_ = clan;
  } else {
    clear_has_clan();
    clan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClanPaidEvent

// required int64 time = 1;
inline bool ClanPaidEvent::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanPaidEvent::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanPaidEvent::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanPaidEvent::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 ClanPaidEvent::time() const {
  return time_;
}
inline void ClanPaidEvent::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional int32 id = 2;
inline bool ClanPaidEvent::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanPaidEvent::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanPaidEvent::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanPaidEvent::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ClanPaidEvent::id() const {
  return id_;
}
inline void ClanPaidEvent::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 money = 3;
inline bool ClanPaidEvent::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanPaidEvent::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanPaidEvent::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanPaidEvent::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 ClanPaidEvent::money() const {
  return money_;
}
inline void ClanPaidEvent::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace MS_ClanInfo

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MSProtoc_2fMS_5fClanInfo_2eproto__INCLUDED

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Clan/Clan.proto

#ifndef PROTOBUF_Clan_2fClan_2eproto__INCLUDED
#define PROTOBUF_Clan_2fClan_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ClanPackage {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Clan_2fClan_2eproto();
void protobuf_AssignDesc_Clan_2fClan_2eproto();
void protobuf_ShutdownFile_Clan_2fClan_2eproto();

class ClientReqCreateClan;
class WorldReqTakeOff;
class AckCreateClan;
class AckClanBase;
class ClientReqClanList;
class AckClanList;
class ClanList;
class ClientReqMemberList;
class AckMemberList;
class MemberInfo;
class ReqSeeMemberList;
class AckSeeMemberList;
class ClientReqClanEvent;
class AckClanEvent;
class JoinClan;
class LeaveClan;
class ClanMemberKilled;
class SynchClanEventToWS;
class MemberContri;
class JobChange;
class ClanUpdate;
class ClanCitryHold;
class ClanPaidEvent;
class ClientReqClanRequestList;
class AckClanRequestList;
class ClanRequestList;
class ClientReqClanContriList;
class AckClanContriList;
class ClanContriList;
class ClientReqJoinClan;
class AckJoinClan;
class ClientAlterTitle;
class ClientReqContri;
class AckContri;
class AckUpdateLv;
class ClientChangeIcon;
class AckClientChangeIcon;
class ClientReqGiveJob;
class AckGiveJob;
class ClientReqOutJob;
class AckOutJob;
class ClientReqKickMember;
class AckKickMember;
class ClientChangeJoinFlag;
class ClientReqJoinControl;
class AckJoinControl;
class ClientReqAskJoin;
class AckAskJoin;
class AskClientJoin;
class ClientReqRefuseOrJoin;
class AckRefuseOrJoin;
class SynchAttrToGM;
class WorldReqGiveCost;
class AckGiveCost;
class ClanNameChange;
class ClanLimit;
class ClanGoods;
class ClanShop;
class SaveClanLimit;
class SaveClanSkill;
class SClanSkill;
class ClanSkill;
class ClientReqSkillUpdate;
class WSToClentSkillUpdate;
class WSToClientSimSkillUpdate;
class WSToGameADBuff;
class WSToGameClanLevel;
class SynchWillJoinToGM;
class ShowClanWelfare;
class ClanWelfare;
class SendClanWelfare;
class TakeClanWelfare;
class RetTakeClanWelfare;
class ClientReqBackClanMap;
class AckReqBackClanMap;
class AckClanSkills;
class ReqUpGrageClanSkill;
class AckUpGradeClanSkill;
class Ws2GsRobberActive;
class ClanMapInfo;
class Ws2GsDestroyClanMap;
class RobberResult;
class ClientReqChanceJoinClan;
class AckChanceJoinClan;

// ===================================================================

class ClientReqCreateClan : public ::google::protobuf::Message {
 public:
  ClientReqCreateClan();
  virtual ~ClientReqCreateClan();

  ClientReqCreateClan(const ClientReqCreateClan& from);

  inline ClientReqCreateClan& operator=(const ClientReqCreateClan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqCreateClan& default_instance();

  void Swap(ClientReqCreateClan* other);

  // implements Message ----------------------------------------------

  ClientReqCreateClan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqCreateClan& from);
  void MergeFrom(const ClientReqCreateClan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline bool type() const;
  inline void set_type(bool value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqCreateClan)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 id_;
  bool type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqCreateClan* default_instance_;
};
// -------------------------------------------------------------------

class WorldReqTakeOff : public ::google::protobuf::Message {
 public:
  WorldReqTakeOff();
  virtual ~WorldReqTakeOff();

  WorldReqTakeOff(const WorldReqTakeOff& from);

  inline WorldReqTakeOff& operator=(const WorldReqTakeOff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WorldReqTakeOff& default_instance();

  void Swap(WorldReqTakeOff* other);

  // implements Message ----------------------------------------------

  WorldReqTakeOff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WorldReqTakeOff& from);
  void MergeFrom(const WorldReqTakeOff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // optional bool type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline bool type() const;
  inline void set_type(bool value);

  // @@protoc_insertion_point(class_scope:ClanPackage.WorldReqTakeOff)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;
  bool type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static WorldReqTakeOff* default_instance_;
};
// -------------------------------------------------------------------

class AckCreateClan : public ::google::protobuf::Message {
 public:
  AckCreateClan();
  virtual ~AckCreateClan();

  AckCreateClan(const AckCreateClan& from);

  inline AckCreateClan& operator=(const AckCreateClan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckCreateClan& default_instance();

  void Swap(AckCreateClan* other);

  // implements Message ----------------------------------------------

  AckCreateClan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckCreateClan& from);
  void MergeFrom(const AckCreateClan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional .ClanPackage.AckClanBase info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ClanPackage::AckClanBase& info() const;
  inline ::ClanPackage::AckClanBase* mutable_info();
  inline ::ClanPackage::AckClanBase* release_info();
  inline void set_allocated_info(::ClanPackage::AckClanBase* info);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckCreateClan)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ClanPackage::AckClanBase* info_;
  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckCreateClan* default_instance_;
};
// -------------------------------------------------------------------

class AckClanBase : public ::google::protobuf::Message {
 public:
  AckClanBase();
  virtual ~AckClanBase();

  AckClanBase(const AckClanBase& from);

  inline AckClanBase& operator=(const AckClanBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckClanBase& default_instance();

  void Swap(AckClanBase* other);

  // implements Message ----------------------------------------------

  AckClanBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckClanBase& from);
  void MergeFrom(const AckClanBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional int32 lv = 2;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 2;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // optional string title = 3;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 3;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional int64 money = 4;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 4;
  inline ::google::protobuf::int64 money() const;
  inline void set_money(::google::protobuf::int64 value);

  // optional int64 golden = 5;
  inline bool has_golden() const;
  inline void clear_golden();
  static const int kGoldenFieldNumber = 5;
  inline ::google::protobuf::int64 golden() const;
  inline void set_golden(::google::protobuf::int64 value);

  // optional double titletime = 6;
  inline bool has_titletime() const;
  inline void clear_titletime();
  static const int kTitletimeFieldNumber = 6;
  inline double titletime() const;
  inline void set_titletime(double value);

  // optional double createtime = 7;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreatetimeFieldNumber = 7;
  inline double createtime() const;
  inline void set_createtime(double value);

  // optional int32 factioncon = 8;
  inline bool has_factioncon() const;
  inline void clear_factioncon();
  static const int kFactionconFieldNumber = 8;
  inline ::google::protobuf::int32 factioncon() const;
  inline void set_factioncon(::google::protobuf::int32 value);

  // optional string clanname = 9;
  inline bool has_clanname() const;
  inline void clear_clanname();
  static const int kClannameFieldNumber = 9;
  inline const ::std::string& clanname() const;
  inline void set_clanname(const ::std::string& value);
  inline void set_clanname(const char* value);
  inline void set_clanname(const char* value, size_t size);
  inline ::std::string* mutable_clanname();
  inline ::std::string* release_clanname();
  inline void set_allocated_clanname(::std::string* clanname);

  // optional string bossname = 10;
  inline bool has_bossname() const;
  inline void clear_bossname();
  static const int kBossnameFieldNumber = 10;
  inline const ::std::string& bossname() const;
  inline void set_bossname(const ::std::string& value);
  inline void set_bossname(const char* value);
  inline void set_bossname(const char* value, size_t size);
  inline ::std::string* mutable_bossname();
  inline ::std::string* release_bossname();
  inline void set_allocated_bossname(::std::string* bossname);

  // optional int32 icon = 11;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 11;
  inline ::google::protobuf::int32 icon() const;
  inline void set_icon(::google::protobuf::int32 value);

  // optional int32 members = 12;
  inline bool has_members() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 12;
  inline ::google::protobuf::int32 members() const;
  inline void set_members(::google::protobuf::int32 value);

  // optional bool autoflag = 13;
  inline bool has_autoflag() const;
  inline void clear_autoflag();
  static const int kAutoflagFieldNumber = 13;
  inline bool autoflag() const;
  inline void set_autoflag(bool value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckClanBase)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_golden();
  inline void clear_has_golden();
  inline void set_has_titletime();
  inline void clear_has_titletime();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_factioncon();
  inline void clear_has_factioncon();
  inline void set_has_clanname();
  inline void clear_has_clanname();
  inline void set_has_bossname();
  inline void clear_has_bossname();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_members();
  inline void clear_has_members();
  inline void set_has_autoflag();
  inline void clear_has_autoflag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::int32 lv_;
  ::std::string* title_;
  ::google::protobuf::int64 money_;
  ::google::protobuf::int64 golden_;
  double titletime_;
  double createtime_;
  ::std::string* clanname_;
  ::google::protobuf::int32 factioncon_;
  ::google::protobuf::int32 icon_;
  ::std::string* bossname_;
  ::google::protobuf::int32 members_;
  bool autoflag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckClanBase* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqClanList : public ::google::protobuf::Message {
 public:
  ClientReqClanList();
  virtual ~ClientReqClanList();

  ClientReqClanList(const ClientReqClanList& from);

  inline ClientReqClanList& operator=(const ClientReqClanList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqClanList& default_instance();

  void Swap(ClientReqClanList* other);

  // implements Message ----------------------------------------------

  ClientReqClanList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqClanList& from);
  void MergeFrom(const ClientReqClanList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 page = 1;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::int32 page() const;
  inline void set_page(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqClanList)
 private:
  inline void set_has_page();
  inline void clear_has_page();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 page_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqClanList* default_instance_;
};
// -------------------------------------------------------------------

class AckClanList : public ::google::protobuf::Message {
 public:
  AckClanList();
  virtual ~AckClanList();

  AckClanList(const AckClanList& from);

  inline AckClanList& operator=(const AckClanList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckClanList& default_instance();

  void Swap(AckClanList* other);

  // implements Message ----------------------------------------------

  AckClanList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckClanList& from);
  void MergeFrom(const AckClanList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ClanPackage.ClanList list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::ClanPackage::ClanList& list(int index) const;
  inline ::ClanPackage::ClanList* mutable_list(int index);
  inline ::ClanPackage::ClanList* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanList >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanList >*
      mutable_list();

  // optional int32 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckClanList)
 private:
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanList > list_;
  ::google::protobuf::int32 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckClanList* default_instance_;
};
// -------------------------------------------------------------------

class ClanList : public ::google::protobuf::Message {
 public:
  ClanList();
  virtual ~ClanList();

  ClanList(const ClanList& from);

  inline ClanList& operator=(const ClanList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanList& default_instance();

  void Swap(ClanList* other);

  // implements Message ----------------------------------------------

  ClanList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanList& from);
  void MergeFrom(const ClanList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional int32 rank = 2;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 2;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional int32 lv = 5;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 5;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // optional int32 fight = 6;
  inline bool has_fight() const;
  inline void clear_fight();
  static const int kFightFieldNumber = 6;
  inline ::google::protobuf::int32 fight() const;
  inline void set_fight(::google::protobuf::int32 value);

  // optional int32 country = 7;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 7;
  inline ::google::protobuf::int32 country() const;
  inline void set_country(::google::protobuf::int32 value);

  // optional bool apply = 8;
  inline bool has_apply() const;
  inline void clear_apply();
  static const int kApplyFieldNumber = 8;
  inline bool apply() const;
  inline void set_apply(bool value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClanList)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_fight();
  inline void clear_has_fight();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_apply();
  inline void clear_has_apply();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  ::google::protobuf::int32 rank_;
  ::std::string* name_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 lv_;
  ::google::protobuf::int32 fight_;
  ::google::protobuf::int32 country_;
  bool apply_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClanList* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqMemberList : public ::google::protobuf::Message {
 public:
  ClientReqMemberList();
  virtual ~ClientReqMemberList();

  ClientReqMemberList(const ClientReqMemberList& from);

  inline ClientReqMemberList& operator=(const ClientReqMemberList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqMemberList& default_instance();

  void Swap(ClientReqMemberList* other);

  // implements Message ----------------------------------------------

  ClientReqMemberList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqMemberList& from);
  void MergeFrom(const ClientReqMemberList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline bool type() const;
  inline void set_type(bool value);

  // optional int32 page = 2;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 2;
  inline ::google::protobuf::int32 page() const;
  inline void set_page(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqMemberList)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_page();
  inline void clear_has_page();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool type_;
  ::google::protobuf::int32 page_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqMemberList* default_instance_;
};
// -------------------------------------------------------------------

class AckMemberList : public ::google::protobuf::Message {
 public:
  AckMemberList();
  virtual ~AckMemberList();

  AckMemberList(const AckMemberList& from);

  inline AckMemberList& operator=(const AckMemberList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckMemberList& default_instance();

  void Swap(AckMemberList* other);

  // implements Message ----------------------------------------------

  AckMemberList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckMemberList& from);
  void MergeFrom(const AckMemberList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ClanPackage.MemberInfo info = 1;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ClanPackage::MemberInfo& info(int index) const;
  inline ::ClanPackage::MemberInfo* mutable_info(int index);
  inline ::ClanPackage::MemberInfo* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::MemberInfo >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::MemberInfo >*
      mutable_info();

  // optional int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional int32 fight = 3;
  inline bool has_fight() const;
  inline void clear_fight();
  static const int kFightFieldNumber = 3;
  inline ::google::protobuf::int32 fight() const;
  inline void set_fight(::google::protobuf::int32 value);

  // optional bool isend = 4;
  inline bool has_isend() const;
  inline void clear_isend();
  static const int kIsendFieldNumber = 4;
  inline bool isend() const;
  inline void set_isend(bool value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckMemberList)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_fight();
  inline void clear_has_fight();
  inline void set_has_isend();
  inline void clear_has_isend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ClanPackage::MemberInfo > info_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 fight_;
  bool isend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckMemberList* default_instance_;
};
// -------------------------------------------------------------------

class MemberInfo : public ::google::protobuf::Message {
 public:
  MemberInfo();
  virtual ~MemberInfo();

  MemberInfo(const MemberInfo& from);

  inline MemberInfo& operator=(const MemberInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemberInfo& default_instance();

  void Swap(MemberInfo* other);

  // implements Message ----------------------------------------------

  MemberInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemberInfo& from);
  void MergeFrom(const MemberInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 profession = 3;
  inline bool has_profession() const;
  inline void clear_profession();
  static const int kProfessionFieldNumber = 3;
  inline ::google::protobuf::int32 profession() const;
  inline void set_profession(::google::protobuf::int32 value);

  // optional int32 contri = 4;
  inline bool has_contri() const;
  inline void clear_contri();
  static const int kContriFieldNumber = 4;
  inline ::google::protobuf::int32 contri() const;
  inline void set_contri(::google::protobuf::int32 value);

  // optional int32 fight = 5;
  inline bool has_fight() const;
  inline void clear_fight();
  static const int kFightFieldNumber = 5;
  inline ::google::protobuf::int32 fight() const;
  inline void set_fight(::google::protobuf::int32 value);

  // optional int32 job = 6;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 6;
  inline ::google::protobuf::int32 job() const;
  inline void set_job(::google::protobuf::int32 value);

  // optional int32 lv = 7;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 7;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // optional int32 vip = 8;
  inline bool has_vip() const;
  inline void clear_vip();
  static const int kVipFieldNumber = 8;
  inline ::google::protobuf::int32 vip() const;
  inline void set_vip(::google::protobuf::int32 value);

  // optional bool isonline = 9;
  inline bool has_isonline() const;
  inline void clear_isonline();
  static const int kIsonlineFieldNumber = 9;
  inline bool isonline() const;
  inline void set_isonline(bool value);

  // @@protoc_insertion_point(class_scope:ClanPackage.MemberInfo)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_profession();
  inline void clear_has_profession();
  inline void set_has_contri();
  inline void clear_has_contri();
  inline void set_has_fight();
  inline void clear_has_fight();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_vip();
  inline void clear_has_vip();
  inline void set_has_isonline();
  inline void clear_has_isonline();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::std::string* name_;
  ::google::protobuf::int32 profession_;
  ::google::protobuf::int32 contri_;
  ::google::protobuf::int32 fight_;
  ::google::protobuf::int32 job_;
  ::google::protobuf::int32 lv_;
  ::google::protobuf::int32 vip_;
  bool isonline_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static MemberInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReqSeeMemberList : public ::google::protobuf::Message {
 public:
  ReqSeeMemberList();
  virtual ~ReqSeeMemberList();

  ReqSeeMemberList(const ReqSeeMemberList& from);

  inline ReqSeeMemberList& operator=(const ReqSeeMemberList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqSeeMemberList& default_instance();

  void Swap(ReqSeeMemberList* other);

  // implements Message ----------------------------------------------

  ReqSeeMemberList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqSeeMemberList& from);
  void MergeFrom(const ReqSeeMemberList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline bool type() const;
  inline void set_type(bool value);

  // optional int32 page = 2;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 2;
  inline ::google::protobuf::int32 page() const;
  inline void set_page(::google::protobuf::int32 value);

  // optional int32 clanID = 3;
  inline bool has_clanid() const;
  inline void clear_clanid();
  static const int kClanIDFieldNumber = 3;
  inline ::google::protobuf::int32 clanid() const;
  inline void set_clanid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ReqSeeMemberList)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_clanid();
  inline void clear_has_clanid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool type_;
  ::google::protobuf::int32 page_;
  ::google::protobuf::int32 clanid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ReqSeeMemberList* default_instance_;
};
// -------------------------------------------------------------------

class AckSeeMemberList : public ::google::protobuf::Message {
 public:
  AckSeeMemberList();
  virtual ~AckSeeMemberList();

  AckSeeMemberList(const AckSeeMemberList& from);

  inline AckSeeMemberList& operator=(const AckSeeMemberList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckSeeMemberList& default_instance();

  void Swap(AckSeeMemberList* other);

  // implements Message ----------------------------------------------

  AckSeeMemberList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckSeeMemberList& from);
  void MergeFrom(const AckSeeMemberList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ClanPackage.AckMemberList info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::ClanPackage::AckMemberList& info() const;
  inline ::ClanPackage::AckMemberList* mutable_info();
  inline ::ClanPackage::AckMemberList* release_info();
  inline void set_allocated_info(::ClanPackage::AckMemberList* info);

  // optional bytes clanName = 2;
  inline bool has_clanname() const;
  inline void clear_clanname();
  static const int kClanNameFieldNumber = 2;
  inline const ::std::string& clanname() const;
  inline void set_clanname(const ::std::string& value);
  inline void set_clanname(const char* value);
  inline void set_clanname(const void* value, size_t size);
  inline ::std::string* mutable_clanname();
  inline ::std::string* release_clanname();
  inline void set_allocated_clanname(::std::string* clanname);

  // optional int32 clanlevel = 3;
  inline bool has_clanlevel() const;
  inline void clear_clanlevel();
  static const int kClanlevelFieldNumber = 3;
  inline ::google::protobuf::int32 clanlevel() const;
  inline void set_clanlevel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckSeeMemberList)
 private:
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_clanname();
  inline void clear_has_clanname();
  inline void set_has_clanlevel();
  inline void clear_has_clanlevel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ClanPackage::AckMemberList* info_;
  ::std::string* clanname_;
  ::google::protobuf::int32 clanlevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckSeeMemberList* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqClanEvent : public ::google::protobuf::Message {
 public:
  ClientReqClanEvent();
  virtual ~ClientReqClanEvent();

  ClientReqClanEvent(const ClientReqClanEvent& from);

  inline ClientReqClanEvent& operator=(const ClientReqClanEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqClanEvent& default_instance();

  void Swap(ClientReqClanEvent* other);

  // implements Message ----------------------------------------------

  ClientReqClanEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqClanEvent& from);
  void MergeFrom(const ClientReqClanEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 page = 1;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::int32 page() const;
  inline void set_page(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqClanEvent)
 private:
  inline void set_has_page();
  inline void clear_has_page();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 page_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqClanEvent* default_instance_;
};
// -------------------------------------------------------------------

class AckClanEvent : public ::google::protobuf::Message {
 public:
  AckClanEvent();
  virtual ~AckClanEvent();

  AckClanEvent(const AckClanEvent& from);

  inline AckClanEvent& operator=(const AckClanEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckClanEvent& default_instance();

  void Swap(AckClanEvent* other);

  // implements Message ----------------------------------------------

  AckClanEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckClanEvent& from);
  void MergeFrom(const AckClanEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 type = 1;
  inline int type_size() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type(int index) const;
  inline void set_type(int index, ::google::protobuf::int32 value);
  inline void add_type(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      type() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_type();

  // repeated bytes content = 2;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content(int index) const;
  inline ::std::string* mutable_content(int index);
  inline void set_content(int index, const ::std::string& value);
  inline void set_content(int index, const char* value);
  inline void set_content(int index, const void* value, size_t size);
  inline ::std::string* add_content();
  inline void add_content(const ::std::string& value);
  inline void add_content(const char* value);
  inline void add_content(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& content() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_content();

  // @@protoc_insertion_point(class_scope:ClanPackage.AckClanEvent)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> content_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckClanEvent* default_instance_;
};
// -------------------------------------------------------------------

class JoinClan : public ::google::protobuf::Message {
 public:
  JoinClan();
  virtual ~JoinClan();

  JoinClan(const JoinClan& from);

  inline JoinClan& operator=(const JoinClan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinClan& default_instance();

  void Swap(JoinClan* other);

  // implements Message ----------------------------------------------

  JoinClan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinClan& from);
  void MergeFrom(const JoinClan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline double time() const;
  inline void set_time(double value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:ClanPackage.JoinClan)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double time_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static JoinClan* default_instance_;
};
// -------------------------------------------------------------------

class LeaveClan : public ::google::protobuf::Message {
 public:
  LeaveClan();
  virtual ~LeaveClan();

  LeaveClan(const LeaveClan& from);

  inline LeaveClan& operator=(const LeaveClan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveClan& default_instance();

  void Swap(LeaveClan* other);

  // implements Message ----------------------------------------------

  LeaveClan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveClan& from);
  void MergeFrom(const LeaveClan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline double time() const;
  inline void set_time(double value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:ClanPackage.LeaveClan)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double time_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static LeaveClan* default_instance_;
};
// -------------------------------------------------------------------

class ClanMemberKilled : public ::google::protobuf::Message {
 public:
  ClanMemberKilled();
  virtual ~ClanMemberKilled();

  ClanMemberKilled(const ClanMemberKilled& from);

  inline ClanMemberKilled& operator=(const ClanMemberKilled& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanMemberKilled& default_instance();

  void Swap(ClanMemberKilled* other);

  // implements Message ----------------------------------------------

  ClanMemberKilled* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanMemberKilled& from);
  void MergeFrom(const ClanMemberKilled& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline double time() const;
  inline void set_time(double value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 mapid = 3;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapidFieldNumber = 3;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // optional string killer = 4;
  inline bool has_killer() const;
  inline void clear_killer();
  static const int kKillerFieldNumber = 4;
  inline const ::std::string& killer() const;
  inline void set_killer(const ::std::string& value);
  inline void set_killer(const char* value);
  inline void set_killer(const char* value, size_t size);
  inline ::std::string* mutable_killer();
  inline ::std::string* release_killer();
  inline void set_allocated_killer(::std::string* killer);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClanMemberKilled)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_killer();
  inline void clear_has_killer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double time_;
  ::std::string* name_;
  ::std::string* killer_;
  ::google::protobuf::int32 mapid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClanMemberKilled* default_instance_;
};
// -------------------------------------------------------------------

class SynchClanEventToWS : public ::google::protobuf::Message {
 public:
  SynchClanEventToWS();
  virtual ~SynchClanEventToWS();

  SynchClanEventToWS(const SynchClanEventToWS& from);

  inline SynchClanEventToWS& operator=(const SynchClanEventToWS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SynchClanEventToWS& default_instance();

  void Swap(SynchClanEventToWS* other);

  // implements Message ----------------------------------------------

  SynchClanEventToWS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SynchClanEventToWS& from);
  void MergeFrom(const SynchClanEventToWS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // required double time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline double time() const;
  inline void set_time(double value);

  // optional string killer = 3;
  inline bool has_killer() const;
  inline void clear_killer();
  static const int kKillerFieldNumber = 3;
  inline const ::std::string& killer() const;
  inline void set_killer(const ::std::string& value);
  inline void set_killer(const char* value);
  inline void set_killer(const char* value, size_t size);
  inline ::std::string* mutable_killer();
  inline ::std::string* release_killer();
  inline void set_allocated_killer(::std::string* killer);

  // @@protoc_insertion_point(class_scope:ClanPackage.SynchClanEventToWS)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_killer();
  inline void clear_has_killer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  double time_;
  ::std::string* killer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static SynchClanEventToWS* default_instance_;
};
// -------------------------------------------------------------------

class MemberContri : public ::google::protobuf::Message {
 public:
  MemberContri();
  virtual ~MemberContri();

  MemberContri(const MemberContri& from);

  inline MemberContri& operator=(const MemberContri& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemberContri& default_instance();

  void Swap(MemberContri* other);

  // implements Message ----------------------------------------------

  MemberContri* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MemberContri& from);
  void MergeFrom(const MemberContri& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline double time() const;
  inline void set_time(double value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 golden = 3;
  inline bool has_golden() const;
  inline void clear_golden();
  static const int kGoldenFieldNumber = 3;
  inline ::google::protobuf::int32 golden() const;
  inline void set_golden(::google::protobuf::int32 value);

  // optional int32 money = 4;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 4;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 contri = 5;
  inline bool has_contri() const;
  inline void clear_contri();
  static const int kContriFieldNumber = 5;
  inline ::google::protobuf::int32 contri() const;
  inline void set_contri(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.MemberContri)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_golden();
  inline void clear_has_golden();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_contri();
  inline void clear_has_contri();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double time_;
  ::std::string* name_;
  ::google::protobuf::int32 golden_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 contri_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static MemberContri* default_instance_;
};
// -------------------------------------------------------------------

class JobChange : public ::google::protobuf::Message {
 public:
  JobChange();
  virtual ~JobChange();

  JobChange(const JobChange& from);

  inline JobChange& operator=(const JobChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JobChange& default_instance();

  void Swap(JobChange* other);

  // implements Message ----------------------------------------------

  JobChange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobChange& from);
  void MergeFrom(const JobChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline double time() const;
  inline void set_time(double value);

  // optional string bname = 2;
  inline bool has_bname() const;
  inline void clear_bname();
  static const int kBnameFieldNumber = 2;
  inline const ::std::string& bname() const;
  inline void set_bname(const ::std::string& value);
  inline void set_bname(const char* value);
  inline void set_bname(const char* value, size_t size);
  inline ::std::string* mutable_bname();
  inline ::std::string* release_bname();
  inline void set_allocated_bname(::std::string* bname);

  // optional string ename = 3;
  inline bool has_ename() const;
  inline void clear_ename();
  static const int kEnameFieldNumber = 3;
  inline const ::std::string& ename() const;
  inline void set_ename(const ::std::string& value);
  inline void set_ename(const char* value);
  inline void set_ename(const char* value, size_t size);
  inline ::std::string* mutable_ename();
  inline ::std::string* release_ename();
  inline void set_allocated_ename(::std::string* ename);

  // optional int32 job = 4;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 4;
  inline ::google::protobuf::int32 job() const;
  inline void set_job(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.JobChange)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_bname();
  inline void clear_has_bname();
  inline void set_has_ename();
  inline void clear_has_ename();
  inline void set_has_job();
  inline void clear_has_job();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double time_;
  ::std::string* bname_;
  ::std::string* ename_;
  ::google::protobuf::int32 job_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static JobChange* default_instance_;
};
// -------------------------------------------------------------------

class ClanUpdate : public ::google::protobuf::Message {
 public:
  ClanUpdate();
  virtual ~ClanUpdate();

  ClanUpdate(const ClanUpdate& from);

  inline ClanUpdate& operator=(const ClanUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanUpdate& default_instance();

  void Swap(ClanUpdate* other);

  // implements Message ----------------------------------------------

  ClanUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanUpdate& from);
  void MergeFrom(const ClanUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline double time() const;
  inline void set_time(double value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 lv = 3;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 3;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // optional int32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClanUpdate)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double time_;
  ::std::string* name_;
  ::google::protobuf::int32 lv_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClanUpdate* default_instance_;
};
// -------------------------------------------------------------------

class ClanCitryHold : public ::google::protobuf::Message {
 public:
  ClanCitryHold();
  virtual ~ClanCitryHold();

  ClanCitryHold(const ClanCitryHold& from);

  inline ClanCitryHold& operator=(const ClanCitryHold& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanCitryHold& default_instance();

  void Swap(ClanCitryHold* other);

  // implements Message ----------------------------------------------

  ClanCitryHold* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanCitryHold& from);
  void MergeFrom(const ClanCitryHold& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline double time() const;
  inline void set_time(double value);

  // optional int32 cityid = 2;
  inline bool has_cityid() const;
  inline void clear_cityid();
  static const int kCityidFieldNumber = 2;
  inline ::google::protobuf::int32 cityid() const;
  inline void set_cityid(::google::protobuf::int32 value);

  // optional string clan = 3;
  inline bool has_clan() const;
  inline void clear_clan();
  static const int kClanFieldNumber = 3;
  inline const ::std::string& clan() const;
  inline void set_clan(const ::std::string& value);
  inline void set_clan(const char* value);
  inline void set_clan(const char* value, size_t size);
  inline ::std::string* mutable_clan();
  inline ::std::string* release_clan();
  inline void set_allocated_clan(::std::string* clan);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClanCitryHold)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_cityid();
  inline void clear_has_cityid();
  inline void set_has_clan();
  inline void clear_has_clan();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double time_;
  ::std::string* clan_;
  ::google::protobuf::int32 cityid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClanCitryHold* default_instance_;
};
// -------------------------------------------------------------------

class ClanPaidEvent : public ::google::protobuf::Message {
 public:
  ClanPaidEvent();
  virtual ~ClanPaidEvent();

  ClanPaidEvent(const ClanPaidEvent& from);

  inline ClanPaidEvent& operator=(const ClanPaidEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanPaidEvent& default_instance();

  void Swap(ClanPaidEvent* other);

  // implements Message ----------------------------------------------

  ClanPaidEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanPaidEvent& from);
  void MergeFrom(const ClanPaidEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline double time() const;
  inline void set_time(double value);

  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 money = 3;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 3;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClanPaidEvent)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_money();
  inline void clear_has_money();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double time_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClanPaidEvent* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqClanRequestList : public ::google::protobuf::Message {
 public:
  ClientReqClanRequestList();
  virtual ~ClientReqClanRequestList();

  ClientReqClanRequestList(const ClientReqClanRequestList& from);

  inline ClientReqClanRequestList& operator=(const ClientReqClanRequestList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqClanRequestList& default_instance();

  void Swap(ClientReqClanRequestList* other);

  // implements Message ----------------------------------------------

  ClientReqClanRequestList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqClanRequestList& from);
  void MergeFrom(const ClientReqClanRequestList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 page = 1;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::int32 page() const;
  inline void set_page(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqClanRequestList)
 private:
  inline void set_has_page();
  inline void clear_has_page();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 page_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqClanRequestList* default_instance_;
};
// -------------------------------------------------------------------

class AckClanRequestList : public ::google::protobuf::Message {
 public:
  AckClanRequestList();
  virtual ~AckClanRequestList();

  AckClanRequestList(const AckClanRequestList& from);

  inline AckClanRequestList& operator=(const AckClanRequestList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckClanRequestList& default_instance();

  void Swap(AckClanRequestList* other);

  // implements Message ----------------------------------------------

  AckClanRequestList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckClanRequestList& from);
  void MergeFrom(const AckClanRequestList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ClanPackage.ClanRequestList list = 2;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 2;
  inline const ::ClanPackage::ClanRequestList& list(int index) const;
  inline ::ClanPackage::ClanRequestList* mutable_list(int index);
  inline ::ClanPackage::ClanRequestList* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanRequestList >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanRequestList >*
      mutable_list();

  // optional bool isend = 3;
  inline bool has_isend() const;
  inline void clear_isend();
  static const int kIsendFieldNumber = 3;
  inline bool isend() const;
  inline void set_isend(bool value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckClanRequestList)
 private:
  inline void set_has_isend();
  inline void clear_has_isend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanRequestList > list_;
  bool isend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckClanRequestList* default_instance_;
};
// -------------------------------------------------------------------

class ClanRequestList : public ::google::protobuf::Message {
 public:
  ClanRequestList();
  virtual ~ClanRequestList();

  ClanRequestList(const ClanRequestList& from);

  inline ClanRequestList& operator=(const ClanRequestList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanRequestList& default_instance();

  void Swap(ClanRequestList* other);

  // implements Message ----------------------------------------------

  ClanRequestList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanRequestList& from);
  void MergeFrom(const ClanRequestList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 lv = 3;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 3;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // optional int32 profession = 4;
  inline bool has_profession() const;
  inline void clear_profession();
  static const int kProfessionFieldNumber = 4;
  inline ::google::protobuf::int32 profession() const;
  inline void set_profession(::google::protobuf::int32 value);

  // optional int32 fight = 5;
  inline bool has_fight() const;
  inline void clear_fight();
  static const int kFightFieldNumber = 5;
  inline ::google::protobuf::int32 fight() const;
  inline void set_fight(::google::protobuf::int32 value);

  // optional int32 vip = 6;
  inline bool has_vip() const;
  inline void clear_vip();
  static const int kVipFieldNumber = 6;
  inline ::google::protobuf::int32 vip() const;
  inline void set_vip(::google::protobuf::int32 value);

  // optional int32 sex = 7;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 7;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClanRequestList)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_profession();
  inline void clear_has_profession();
  inline void set_has_fight();
  inline void clear_has_fight();
  inline void set_has_vip();
  inline void clear_has_vip();
  inline void set_has_sex();
  inline void clear_has_sex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::std::string* name_;
  ::google::protobuf::int32 lv_;
  ::google::protobuf::int32 profession_;
  ::google::protobuf::int32 fight_;
  ::google::protobuf::int32 vip_;
  ::google::protobuf::int32 sex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClanRequestList* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqClanContriList : public ::google::protobuf::Message {
 public:
  ClientReqClanContriList();
  virtual ~ClientReqClanContriList();

  ClientReqClanContriList(const ClientReqClanContriList& from);

  inline ClientReqClanContriList& operator=(const ClientReqClanContriList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqClanContriList& default_instance();

  void Swap(ClientReqClanContriList* other);

  // implements Message ----------------------------------------------

  ClientReqClanContriList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqClanContriList& from);
  void MergeFrom(const ClientReqClanContriList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 page = 1;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::int32 page() const;
  inline void set_page(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqClanContriList)
 private:
  inline void set_has_page();
  inline void clear_has_page();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 page_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqClanContriList* default_instance_;
};
// -------------------------------------------------------------------

class AckClanContriList : public ::google::protobuf::Message {
 public:
  AckClanContriList();
  virtual ~AckClanContriList();

  AckClanContriList(const AckClanContriList& from);

  inline AckClanContriList& operator=(const AckClanContriList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckClanContriList& default_instance();

  void Swap(AckClanContriList* other);

  // implements Message ----------------------------------------------

  AckClanContriList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckClanContriList& from);
  void MergeFrom(const AckClanContriList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ClanPackage.ClanContriList list = 1;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline const ::ClanPackage::ClanContriList& list(int index) const;
  inline ::ClanPackage::ClanContriList* mutable_list(int index);
  inline ::ClanPackage::ClanContriList* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanContriList >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanContriList >*
      mutable_list();

  // optional bool isend = 2;
  inline bool has_isend() const;
  inline void clear_isend();
  static const int kIsendFieldNumber = 2;
  inline bool isend() const;
  inline void set_isend(bool value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckClanContriList)
 private:
  inline void set_has_isend();
  inline void clear_has_isend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanContriList > list_;
  bool isend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckClanContriList* default_instance_;
};
// -------------------------------------------------------------------

class ClanContriList : public ::google::protobuf::Message {
 public:
  ClanContriList();
  virtual ~ClanContriList();

  ClanContriList(const ClanContriList& from);

  inline ClanContriList& operator=(const ClanContriList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanContriList& default_instance();

  void Swap(ClanContriList* other);

  // implements Message ----------------------------------------------

  ClanContriList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanContriList& from);
  void MergeFrom(const ClanContriList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 lv = 3;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 3;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // optional int32 money = 4;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 4;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 golden = 5;
  inline bool has_golden() const;
  inline void clear_golden();
  static const int kGoldenFieldNumber = 5;
  inline ::google::protobuf::int32 golden() const;
  inline void set_golden(::google::protobuf::int32 value);

  // optional int32 contri = 6;
  inline bool has_contri() const;
  inline void clear_contri();
  static const int kContriFieldNumber = 6;
  inline ::google::protobuf::int32 contri() const;
  inline void set_contri(::google::protobuf::int32 value);

  // optional int32 contrimax = 7;
  inline bool has_contrimax() const;
  inline void clear_contrimax();
  static const int kContrimaxFieldNumber = 7;
  inline ::google::protobuf::int32 contrimax() const;
  inline void set_contrimax(::google::protobuf::int32 value);

  // optional int32 viplv = 8;
  inline bool has_viplv() const;
  inline void clear_viplv();
  static const int kViplvFieldNumber = 8;
  inline ::google::protobuf::int32 viplv() const;
  inline void set_viplv(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClanContriList)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_golden();
  inline void clear_has_golden();
  inline void set_has_contri();
  inline void clear_has_contri();
  inline void set_has_contrimax();
  inline void clear_has_contrimax();
  inline void set_has_viplv();
  inline void clear_has_viplv();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::std::string* name_;
  ::google::protobuf::int32 lv_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 golden_;
  ::google::protobuf::int32 contri_;
  ::google::protobuf::int32 contrimax_;
  ::google::protobuf::int32 viplv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClanContriList* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqJoinClan : public ::google::protobuf::Message {
 public:
  ClientReqJoinClan();
  virtual ~ClientReqJoinClan();

  ClientReqJoinClan(const ClientReqJoinClan& from);

  inline ClientReqJoinClan& operator=(const ClientReqJoinClan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqJoinClan& default_instance();

  void Swap(ClientReqJoinClan* other);

  // implements Message ----------------------------------------------

  ClientReqJoinClan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqJoinClan& from);
  void MergeFrom(const ClientReqJoinClan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqJoinClan)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqJoinClan* default_instance_;
};
// -------------------------------------------------------------------

class AckJoinClan : public ::google::protobuf::Message {
 public:
  AckJoinClan();
  virtual ~AckJoinClan();

  AckJoinClan(const AckJoinClan& from);

  inline AckJoinClan& operator=(const AckJoinClan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckJoinClan& default_instance();

  void Swap(AckJoinClan* other);

  // implements Message ----------------------------------------------

  AckJoinClan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckJoinClan& from);
  void MergeFrom(const AckJoinClan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 clanID = 2;
  inline bool has_clanid() const;
  inline void clear_clanid();
  static const int kClanIDFieldNumber = 2;
  inline ::google::protobuf::int32 clanid() const;
  inline void set_clanid(::google::protobuf::int32 value);

  // optional .ClanPackage.AckClanBase info = 3;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 3;
  inline const ::ClanPackage::AckClanBase& info() const;
  inline ::ClanPackage::AckClanBase* mutable_info();
  inline ::ClanPackage::AckClanBase* release_info();
  inline void set_allocated_info(::ClanPackage::AckClanBase* info);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckJoinClan)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_clanid();
  inline void clear_has_clanid();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 clanid_;
  ::ClanPackage::AckClanBase* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckJoinClan* default_instance_;
};
// -------------------------------------------------------------------

class ClientAlterTitle : public ::google::protobuf::Message {
 public:
  ClientAlterTitle();
  virtual ~ClientAlterTitle();

  ClientAlterTitle(const ClientAlterTitle& from);

  inline ClientAlterTitle& operator=(const ClientAlterTitle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientAlterTitle& default_instance();

  void Swap(ClientAlterTitle* other);

  // implements Message ----------------------------------------------

  ClientAlterTitle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientAlterTitle& from);
  void MergeFrom(const ClientAlterTitle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientAlterTitle)
 private:
  inline void set_has_title();
  inline void clear_has_title();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* title_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientAlterTitle* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqContri : public ::google::protobuf::Message {
 public:
  ClientReqContri();
  virtual ~ClientReqContri();

  ClientReqContri(const ClientReqContri& from);

  inline ClientReqContri& operator=(const ClientReqContri& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqContri& default_instance();

  void Swap(ClientReqContri* other);

  // implements Message ----------------------------------------------

  ClientReqContri* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqContri& from);
  void MergeFrom(const ClientReqContri& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 money = 1;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 1;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // required int32 golden = 2;
  inline bool has_golden() const;
  inline void clear_golden();
  static const int kGoldenFieldNumber = 2;
  inline ::google::protobuf::int32 golden() const;
  inline void set_golden(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqContri)
 private:
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_golden();
  inline void clear_has_golden();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 golden_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqContri* default_instance_;
};
// -------------------------------------------------------------------

class AckContri : public ::google::protobuf::Message {
 public:
  AckContri();
  virtual ~AckContri();

  AckContri(const AckContri& from);

  inline AckContri& operator=(const AckContri& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckContri& default_instance();

  void Swap(AckContri* other);

  // implements Message ----------------------------------------------

  AckContri* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckContri& from);
  void MergeFrom(const AckContri& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 contri = 2;
  inline bool has_contri() const;
  inline void clear_contri();
  static const int kContriFieldNumber = 2;
  inline ::google::protobuf::int32 contri() const;
  inline void set_contri(::google::protobuf::int32 value);

  // optional int32 money = 3;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 3;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 golden = 4;
  inline bool has_golden() const;
  inline void clear_golden();
  static const int kGoldenFieldNumber = 4;
  inline ::google::protobuf::int32 golden() const;
  inline void set_golden(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckContri)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_contri();
  inline void clear_has_contri();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_golden();
  inline void clear_has_golden();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 contri_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 golden_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckContri* default_instance_;
};
// -------------------------------------------------------------------

class AckUpdateLv : public ::google::protobuf::Message {
 public:
  AckUpdateLv();
  virtual ~AckUpdateLv();

  AckUpdateLv(const AckUpdateLv& from);

  inline AckUpdateLv& operator=(const AckUpdateLv& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUpdateLv& default_instance();

  void Swap(AckUpdateLv* other);

  // implements Message ----------------------------------------------

  AckUpdateLv* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUpdateLv& from);
  void MergeFrom(const AckUpdateLv& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 lv = 2;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 2;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckUpdateLv)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_lv();
  inline void clear_has_lv();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 lv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckUpdateLv* default_instance_;
};
// -------------------------------------------------------------------

class ClientChangeIcon : public ::google::protobuf::Message {
 public:
  ClientChangeIcon();
  virtual ~ClientChangeIcon();

  ClientChangeIcon(const ClientChangeIcon& from);

  inline ClientChangeIcon& operator=(const ClientChangeIcon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientChangeIcon& default_instance();

  void Swap(ClientChangeIcon* other);

  // implements Message ----------------------------------------------

  ClientChangeIcon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientChangeIcon& from);
  void MergeFrom(const ClientChangeIcon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 icon = 1;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 1;
  inline ::google::protobuf::int32 icon() const;
  inline void set_icon(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientChangeIcon)
 private:
  inline void set_has_icon();
  inline void clear_has_icon();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 icon_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientChangeIcon* default_instance_;
};
// -------------------------------------------------------------------

class AckClientChangeIcon : public ::google::protobuf::Message {
 public:
  AckClientChangeIcon();
  virtual ~AckClientChangeIcon();

  AckClientChangeIcon(const AckClientChangeIcon& from);

  inline AckClientChangeIcon& operator=(const AckClientChangeIcon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckClientChangeIcon& default_instance();

  void Swap(AckClientChangeIcon* other);

  // implements Message ----------------------------------------------

  AckClientChangeIcon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckClientChangeIcon& from);
  void MergeFrom(const AckClientChangeIcon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline ::google::protobuf::int32 success() const;
  inline void set_success(::google::protobuf::int32 value);

  // optional int32 icon = 2;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 2;
  inline ::google::protobuf::int32 icon() const;
  inline void set_icon(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckClientChangeIcon)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_icon();
  inline void clear_has_icon();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 success_;
  ::google::protobuf::int32 icon_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckClientChangeIcon* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqGiveJob : public ::google::protobuf::Message {
 public:
  ClientReqGiveJob();
  virtual ~ClientReqGiveJob();

  ClientReqGiveJob(const ClientReqGiveJob& from);

  inline ClientReqGiveJob& operator=(const ClientReqGiveJob& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqGiveJob& default_instance();

  void Swap(ClientReqGiveJob* other);

  // implements Message ----------------------------------------------

  ClientReqGiveJob* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqGiveJob& from);
  void MergeFrom(const ClientReqGiveJob& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // optional int32 job = 2;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 2;
  inline ::google::protobuf::int32 job() const;
  inline void set_job(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqGiveJob)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_job();
  inline void clear_has_job();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::google::protobuf::int32 job_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqGiveJob* default_instance_;
};
// -------------------------------------------------------------------

class AckGiveJob : public ::google::protobuf::Message {
 public:
  AckGiveJob();
  virtual ~AckGiveJob();

  AckGiveJob(const AckGiveJob& from);

  inline AckGiveJob& operator=(const AckGiveJob& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckGiveJob& default_instance();

  void Swap(AckGiveJob* other);

  // implements Message ----------------------------------------------

  AckGiveJob* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckGiveJob& from);
  void MergeFrom(const AckGiveJob& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 job = 2;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 2;
  inline ::google::protobuf::int32 job() const;
  inline void set_job(::google::protobuf::int32 value);

  // optional int64 charid = 3;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 3;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckGiveJob)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_charid();
  inline void clear_has_charid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 job_;
  ::google::protobuf::int64 charid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckGiveJob* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqOutJob : public ::google::protobuf::Message {
 public:
  ClientReqOutJob();
  virtual ~ClientReqOutJob();

  ClientReqOutJob(const ClientReqOutJob& from);

  inline ClientReqOutJob& operator=(const ClientReqOutJob& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqOutJob& default_instance();

  void Swap(ClientReqOutJob* other);

  // implements Message ----------------------------------------------

  ClientReqOutJob* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqOutJob& from);
  void MergeFrom(const ClientReqOutJob& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqOutJob)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqOutJob* default_instance_;
};
// -------------------------------------------------------------------

class AckOutJob : public ::google::protobuf::Message {
 public:
  AckOutJob();
  virtual ~AckOutJob();

  AckOutJob(const AckOutJob& from);

  inline AckOutJob& operator=(const AckOutJob& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckOutJob& default_instance();

  void Swap(AckOutJob* other);

  // implements Message ----------------------------------------------

  AckOutJob* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckOutJob& from);
  void MergeFrom(const AckOutJob& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int64 charid = 2;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 2;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckOutJob)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_charid();
  inline void clear_has_charid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckOutJob* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqKickMember : public ::google::protobuf::Message {
 public:
  ClientReqKickMember();
  virtual ~ClientReqKickMember();

  ClientReqKickMember(const ClientReqKickMember& from);

  inline ClientReqKickMember& operator=(const ClientReqKickMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqKickMember& default_instance();

  void Swap(ClientReqKickMember* other);

  // implements Message ----------------------------------------------

  ClientReqKickMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqKickMember& from);
  void MergeFrom(const ClientReqKickMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqKickMember)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqKickMember* default_instance_;
};
// -------------------------------------------------------------------

class AckKickMember : public ::google::protobuf::Message {
 public:
  AckKickMember();
  virtual ~AckKickMember();

  AckKickMember(const AckKickMember& from);

  inline AckKickMember& operator=(const AckKickMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckKickMember& default_instance();

  void Swap(AckKickMember* other);

  // implements Message ----------------------------------------------

  AckKickMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckKickMember& from);
  void MergeFrom(const AckKickMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int64 charid = 2;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 2;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckKickMember)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_charid();
  inline void clear_has_charid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckKickMember* default_instance_;
};
// -------------------------------------------------------------------

class ClientChangeJoinFlag : public ::google::protobuf::Message {
 public:
  ClientChangeJoinFlag();
  virtual ~ClientChangeJoinFlag();

  ClientChangeJoinFlag(const ClientChangeJoinFlag& from);

  inline ClientChangeJoinFlag& operator=(const ClientChangeJoinFlag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientChangeJoinFlag& default_instance();

  void Swap(ClientChangeJoinFlag* other);

  // implements Message ----------------------------------------------

  ClientChangeJoinFlag* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientChangeJoinFlag& from);
  void MergeFrom(const ClientChangeJoinFlag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool flag = 1;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 1;
  inline bool flag() const;
  inline void set_flag(bool value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientChangeJoinFlag)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientChangeJoinFlag* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqJoinControl : public ::google::protobuf::Message {
 public:
  ClientReqJoinControl();
  virtual ~ClientReqJoinControl();

  ClientReqJoinControl(const ClientReqJoinControl& from);

  inline ClientReqJoinControl& operator=(const ClientReqJoinControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqJoinControl& default_instance();

  void Swap(ClientReqJoinControl* other);

  // implements Message ----------------------------------------------

  ClientReqJoinControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqJoinControl& from);
  void MergeFrom(const ClientReqJoinControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline bool type() const;
  inline void set_type(bool value);

  // optional int64 charid = 2;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 2;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqJoinControl)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_charid();
  inline void clear_has_charid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  bool type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqJoinControl* default_instance_;
};
// -------------------------------------------------------------------

class AckJoinControl : public ::google::protobuf::Message {
 public:
  AckJoinControl();
  virtual ~AckJoinControl();

  AckJoinControl(const AckJoinControl& from);

  inline AckJoinControl& operator=(const AckJoinControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckJoinControl& default_instance();

  void Swap(AckJoinControl* other);

  // implements Message ----------------------------------------------

  AckJoinControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckJoinControl& from);
  void MergeFrom(const AckJoinControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int64 charid = 2;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 2;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // optional bool type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline bool type() const;
  inline void set_type(bool value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckJoinControl)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::google::protobuf::int32 ret_;
  bool type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckJoinControl* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqAskJoin : public ::google::protobuf::Message {
 public:
  ClientReqAskJoin();
  virtual ~ClientReqAskJoin();

  ClientReqAskJoin(const ClientReqAskJoin& from);

  inline ClientReqAskJoin& operator=(const ClientReqAskJoin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqAskJoin& default_instance();

  void Swap(ClientReqAskJoin* other);

  // implements Message ----------------------------------------------

  ClientReqAskJoin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqAskJoin& from);
  void MergeFrom(const ClientReqAskJoin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqAskJoin)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqAskJoin* default_instance_;
};
// -------------------------------------------------------------------

class AckAskJoin : public ::google::protobuf::Message {
 public:
  AckAskJoin();
  virtual ~AckAskJoin();

  AckAskJoin(const AckAskJoin& from);

  inline AckAskJoin& operator=(const AckAskJoin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckAskJoin& default_instance();

  void Swap(AckAskJoin* other);

  // implements Message ----------------------------------------------

  AckAskJoin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckAskJoin& from);
  void MergeFrom(const AckAskJoin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckAskJoin)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckAskJoin* default_instance_;
};
// -------------------------------------------------------------------

class AskClientJoin : public ::google::protobuf::Message {
 public:
  AskClientJoin();
  virtual ~AskClientJoin();

  AskClientJoin(const AskClientJoin& from);

  inline AskClientJoin& operator=(const AskClientJoin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AskClientJoin& default_instance();

  void Swap(AskClientJoin* other);

  // implements Message ----------------------------------------------

  AskClientJoin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AskClientJoin& from);
  void MergeFrom(const AskClientJoin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string clanname = 3;
  inline bool has_clanname() const;
  inline void clear_clanname();
  static const int kClannameFieldNumber = 3;
  inline const ::std::string& clanname() const;
  inline void set_clanname(const ::std::string& value);
  inline void set_clanname(const char* value);
  inline void set_clanname(const char* value, size_t size);
  inline ::std::string* mutable_clanname();
  inline ::std::string* release_clanname();
  inline void set_allocated_clanname(::std::string* clanname);

  // @@protoc_insertion_point(class_scope:ClanPackage.AskClientJoin)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_clanname();
  inline void clear_has_clanname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* clanname_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AskClientJoin* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqRefuseOrJoin : public ::google::protobuf::Message {
 public:
  ClientReqRefuseOrJoin();
  virtual ~ClientReqRefuseOrJoin();

  ClientReqRefuseOrJoin(const ClientReqRefuseOrJoin& from);

  inline ClientReqRefuseOrJoin& operator=(const ClientReqRefuseOrJoin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqRefuseOrJoin& default_instance();

  void Swap(ClientReqRefuseOrJoin* other);

  // implements Message ----------------------------------------------

  ClientReqRefuseOrJoin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqRefuseOrJoin& from);
  void MergeFrom(const ClientReqRefuseOrJoin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline bool type() const;
  inline void set_type(bool value);

  // optional uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqRefuseOrJoin)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool type_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqRefuseOrJoin* default_instance_;
};
// -------------------------------------------------------------------

class AckRefuseOrJoin : public ::google::protobuf::Message {
 public:
  AckRefuseOrJoin();
  virtual ~AckRefuseOrJoin();

  AckRefuseOrJoin(const AckRefuseOrJoin& from);

  inline AckRefuseOrJoin& operator=(const AckRefuseOrJoin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckRefuseOrJoin& default_instance();

  void Swap(AckRefuseOrJoin* other);

  // implements Message ----------------------------------------------

  AckRefuseOrJoin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckRefuseOrJoin& from);
  void MergeFrom(const AckRefuseOrJoin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional .ClanPackage.AckClanBase info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ClanPackage::AckClanBase& info() const;
  inline ::ClanPackage::AckClanBase* mutable_info();
  inline ::ClanPackage::AckClanBase* release_info();
  inline void set_allocated_info(::ClanPackage::AckClanBase* info);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckRefuseOrJoin)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ClanPackage::AckClanBase* info_;
  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckRefuseOrJoin* default_instance_;
};
// -------------------------------------------------------------------

class SynchAttrToGM : public ::google::protobuf::Message {
 public:
  SynchAttrToGM();
  virtual ~SynchAttrToGM();

  SynchAttrToGM(const SynchAttrToGM& from);

  inline SynchAttrToGM& operator=(const SynchAttrToGM& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SynchAttrToGM& default_instance();

  void Swap(SynchAttrToGM* other);

  // implements Message ----------------------------------------------

  SynchAttrToGM* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SynchAttrToGM& from);
  void MergeFrom(const SynchAttrToGM& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // optional int32 blv = 2;
  inline bool has_blv() const;
  inline void clear_blv();
  static const int kBlvFieldNumber = 2;
  inline ::google::protobuf::int32 blv() const;
  inline void set_blv(::google::protobuf::int32 value);

  // optional int32 elv = 3;
  inline bool has_elv() const;
  inline void clear_elv();
  static const int kElvFieldNumber = 3;
  inline ::google::protobuf::int32 elv() const;
  inline void set_elv(::google::protobuf::int32 value);

  // optional uint32 id = 4;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 4;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 job = 6;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 6;
  inline ::google::protobuf::int32 job() const;
  inline void set_job(::google::protobuf::int32 value);

  // optional int32 type = 7 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 7;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 clanicon = 8;
  inline bool has_clanicon() const;
  inline void clear_clanicon();
  static const int kClaniconFieldNumber = 8;
  inline ::google::protobuf::int32 clanicon() const;
  inline void set_clanicon(::google::protobuf::int32 value);

  // optional int32 clanContribution = 9;
  inline bool has_clancontribution() const;
  inline void clear_clancontribution();
  static const int kClanContributionFieldNumber = 9;
  inline ::google::protobuf::int32 clancontribution() const;
  inline void set_clancontribution(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.SynchAttrToGM)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_blv();
  inline void clear_has_blv();
  inline void set_has_elv();
  inline void clear_has_elv();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_clanicon();
  inline void clear_has_clanicon();
  inline void set_has_clancontribution();
  inline void clear_has_clancontribution();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::google::protobuf::int32 blv_;
  ::google::protobuf::int32 elv_;
  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::int32 job_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 clanicon_;
  ::google::protobuf::int32 clancontribution_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static SynchAttrToGM* default_instance_;
};
// -------------------------------------------------------------------

class WorldReqGiveCost : public ::google::protobuf::Message {
 public:
  WorldReqGiveCost();
  virtual ~WorldReqGiveCost();

  WorldReqGiveCost(const WorldReqGiveCost& from);

  inline WorldReqGiveCost& operator=(const WorldReqGiveCost& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WorldReqGiveCost& default_instance();

  void Swap(WorldReqGiveCost* other);

  // implements Message ----------------------------------------------

  WorldReqGiveCost* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WorldReqGiveCost& from);
  void MergeFrom(const WorldReqGiveCost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // optional uint32 money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline ::google::protobuf::uint32 money() const;
  inline void set_money(::google::protobuf::uint32 value);

  // optional uint32 golden = 3;
  inline bool has_golden() const;
  inline void clear_golden();
  static const int kGoldenFieldNumber = 3;
  inline ::google::protobuf::uint32 golden() const;
  inline void set_golden(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.WorldReqGiveCost)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_golden();
  inline void clear_has_golden();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::google::protobuf::uint32 money_;
  ::google::protobuf::uint32 golden_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static WorldReqGiveCost* default_instance_;
};
// -------------------------------------------------------------------

class AckGiveCost : public ::google::protobuf::Message {
 public:
  AckGiveCost();
  virtual ~AckGiveCost();

  AckGiveCost(const AckGiveCost& from);

  inline AckGiveCost& operator=(const AckGiveCost& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckGiveCost& default_instance();

  void Swap(AckGiveCost* other);

  // implements Message ----------------------------------------------

  AckGiveCost* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckGiveCost& from);
  void MergeFrom(const AckGiveCost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // optional int32 ret = 2;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 2;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional uint32 money = 3;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 3;
  inline ::google::protobuf::uint32 money() const;
  inline void set_money(::google::protobuf::uint32 value);

  // optional uint32 golden = 4;
  inline bool has_golden() const;
  inline void clear_golden();
  static const int kGoldenFieldNumber = 4;
  inline ::google::protobuf::uint32 golden() const;
  inline void set_golden(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckGiveCost)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_golden();
  inline void clear_has_golden();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::google::protobuf::int32 ret_;
  ::google::protobuf::uint32 money_;
  ::google::protobuf::uint32 golden_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckGiveCost* default_instance_;
};
// -------------------------------------------------------------------

class ClanNameChange : public ::google::protobuf::Message {
 public:
  ClanNameChange();
  virtual ~ClanNameChange();

  ClanNameChange(const ClanNameChange& from);

  inline ClanNameChange& operator=(const ClanNameChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanNameChange& default_instance();

  void Swap(ClanNameChange* other);

  // implements Message ----------------------------------------------

  ClanNameChange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanNameChange& from);
  void MergeFrom(const ClanNameChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline ::google::protobuf::int32 key() const;
  inline void set_key(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClanNameChange)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClanNameChange* default_instance_;
};
// -------------------------------------------------------------------

class ClanLimit : public ::google::protobuf::Message {
 public:
  ClanLimit();
  virtual ~ClanLimit();

  ClanLimit(const ClanLimit& from);

  inline ClanLimit& operator=(const ClanLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanLimit& default_instance();

  void Swap(ClanLimit* other);

  // implements Message ----------------------------------------------

  ClanLimit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanLimit& from);
  void MergeFrom(const ClanLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ClanPackage.ClanGoods clanGoods = 1;
  inline int clangoods_size() const;
  inline void clear_clangoods();
  static const int kClanGoodsFieldNumber = 1;
  inline const ::ClanPackage::ClanGoods& clangoods(int index) const;
  inline ::ClanPackage::ClanGoods* mutable_clangoods(int index);
  inline ::ClanPackage::ClanGoods* add_clangoods();
  inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanGoods >&
      clangoods() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanGoods >*
      mutable_clangoods();

  // @@protoc_insertion_point(class_scope:ClanPackage.ClanLimit)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanGoods > clangoods_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClanLimit* default_instance_;
};
// -------------------------------------------------------------------

class ClanGoods : public ::google::protobuf::Message {
 public:
  ClanGoods();
  virtual ~ClanGoods();

  ClanGoods(const ClanGoods& from);

  inline ClanGoods& operator=(const ClanGoods& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanGoods& default_instance();

  void Swap(ClanGoods* other);

  // implements Message ----------------------------------------------

  ClanGoods* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanGoods& from);
  void MergeFrom(const ClanGoods& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 itemid = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 limit = 2;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 2;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClanGoods)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_limit();
  inline void clear_has_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 limit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClanGoods* default_instance_;
};
// -------------------------------------------------------------------

class ClanShop : public ::google::protobuf::Message {
 public:
  ClanShop();
  virtual ~ClanShop();

  ClanShop(const ClanShop& from);

  inline ClanShop& operator=(const ClanShop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanShop& default_instance();

  void Swap(ClanShop* other);

  // implements Message ----------------------------------------------

  ClanShop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanShop& from);
  void MergeFrom(const ClanShop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 ID = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 surplusCounts = 3;
  inline bool has_surpluscounts() const;
  inline void clear_surpluscounts();
  static const int kSurplusCountsFieldNumber = 3;
  inline ::google::protobuf::int32 surpluscounts() const;
  inline void set_surpluscounts(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClanShop)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_surpluscounts();
  inline void clear_has_surpluscounts();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 surpluscounts_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClanShop* default_instance_;
};
// -------------------------------------------------------------------

class SaveClanLimit : public ::google::protobuf::Message {
 public:
  SaveClanLimit();
  virtual ~SaveClanLimit();

  SaveClanLimit(const SaveClanLimit& from);

  inline SaveClanLimit& operator=(const SaveClanLimit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SaveClanLimit& default_instance();

  void Swap(SaveClanLimit* other);

  // implements Message ----------------------------------------------

  SaveClanLimit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SaveClanLimit& from);
  void MergeFrom(const SaveClanLimit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ClanPackage.ClanGoods clanGoods = 1;
  inline int clangoods_size() const;
  inline void clear_clangoods();
  static const int kClanGoodsFieldNumber = 1;
  inline const ::ClanPackage::ClanGoods& clangoods(int index) const;
  inline ::ClanPackage::ClanGoods* mutable_clangoods(int index);
  inline ::ClanPackage::ClanGoods* add_clangoods();
  inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanGoods >&
      clangoods() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanGoods >*
      mutable_clangoods();

  // optional int64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.SaveClanLimit)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanGoods > clangoods_;
  ::google::protobuf::int64 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static SaveClanLimit* default_instance_;
};
// -------------------------------------------------------------------

class SaveClanSkill : public ::google::protobuf::Message {
 public:
  SaveClanSkill();
  virtual ~SaveClanSkill();

  SaveClanSkill(const SaveClanSkill& from);

  inline SaveClanSkill& operator=(const SaveClanSkill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SaveClanSkill& default_instance();

  void Swap(SaveClanSkill* other);

  // implements Message ----------------------------------------------

  SaveClanSkill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SaveClanSkill& from);
  void MergeFrom(const SaveClanSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ClanPackage.SClanSkill sclanSkill = 1;
  inline int sclanskill_size() const;
  inline void clear_sclanskill();
  static const int kSclanSkillFieldNumber = 1;
  inline const ::ClanPackage::SClanSkill& sclanskill(int index) const;
  inline ::ClanPackage::SClanSkill* mutable_sclanskill(int index);
  inline ::ClanPackage::SClanSkill* add_sclanskill();
  inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::SClanSkill >&
      sclanskill() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::SClanSkill >*
      mutable_sclanskill();

  // @@protoc_insertion_point(class_scope:ClanPackage.SaveClanSkill)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ClanPackage::SClanSkill > sclanskill_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static SaveClanSkill* default_instance_;
};
// -------------------------------------------------------------------

class SClanSkill : public ::google::protobuf::Message {
 public:
  SClanSkill();
  virtual ~SClanSkill();

  SClanSkill(const SClanSkill& from);

  inline SClanSkill& operator=(const SClanSkill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SClanSkill& default_instance();

  void Swap(SClanSkill* other);

  // implements Message ----------------------------------------------

  SClanSkill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SClanSkill& from);
  void MergeFrom(const SClanSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 skillid = 1;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillidFieldNumber = 1;
  inline ::google::protobuf::int32 skillid() const;
  inline void set_skillid(::google::protobuf::int32 value);

  // optional int32 curexp = 2;
  inline bool has_curexp() const;
  inline void clear_curexp();
  static const int kCurexpFieldNumber = 2;
  inline ::google::protobuf::int32 curexp() const;
  inline void set_curexp(::google::protobuf::int32 value);

  // optional int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.SClanSkill)
 private:
  inline void set_has_skillid();
  inline void clear_has_skillid();
  inline void set_has_curexp();
  inline void clear_has_curexp();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 skillid_;
  ::google::protobuf::int32 curexp_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static SClanSkill* default_instance_;
};
// -------------------------------------------------------------------

class ClanSkill : public ::google::protobuf::Message {
 public:
  ClanSkill();
  virtual ~ClanSkill();

  ClanSkill(const ClanSkill& from);

  inline ClanSkill& operator=(const ClanSkill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanSkill& default_instance();

  void Swap(ClanSkill* other);

  // implements Message ----------------------------------------------

  ClanSkill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanSkill& from);
  void MergeFrom(const ClanSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 skillid = 1;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillidFieldNumber = 1;
  inline ::google::protobuf::int32 skillid() const;
  inline void set_skillid(::google::protobuf::int32 value);

  // optional int32 curexp = 2;
  inline bool has_curexp() const;
  inline void clear_curexp();
  static const int kCurexpFieldNumber = 2;
  inline ::google::protobuf::int32 curexp() const;
  inline void set_curexp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClanSkill)
 private:
  inline void set_has_skillid();
  inline void clear_has_skillid();
  inline void set_has_curexp();
  inline void clear_has_curexp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 skillid_;
  ::google::protobuf::int32 curexp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClanSkill* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqSkillUpdate : public ::google::protobuf::Message {
 public:
  ClientReqSkillUpdate();
  virtual ~ClientReqSkillUpdate();

  ClientReqSkillUpdate(const ClientReqSkillUpdate& from);

  inline ClientReqSkillUpdate& operator=(const ClientReqSkillUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqSkillUpdate& default_instance();

  void Swap(ClientReqSkillUpdate* other);

  // implements Message ----------------------------------------------

  ClientReqSkillUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqSkillUpdate& from);
  void MergeFrom(const ClientReqSkillUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqSkillUpdate)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqSkillUpdate* default_instance_;
};
// -------------------------------------------------------------------

class WSToClentSkillUpdate : public ::google::protobuf::Message {
 public:
  WSToClentSkillUpdate();
  virtual ~WSToClentSkillUpdate();

  WSToClentSkillUpdate(const WSToClentSkillUpdate& from);

  inline WSToClentSkillUpdate& operator=(const WSToClentSkillUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WSToClentSkillUpdate& default_instance();

  void Swap(WSToClentSkillUpdate* other);

  // implements Message ----------------------------------------------

  WSToClentSkillUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WSToClentSkillUpdate& from);
  void MergeFrom(const WSToClentSkillUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 skillid = 2;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillidFieldNumber = 2;
  inline ::google::protobuf::int32 skillid() const;
  inline void set_skillid(::google::protobuf::int32 value);

  // optional int32 curexp = 3;
  inline bool has_curexp() const;
  inline void clear_curexp();
  static const int kCurexpFieldNumber = 3;
  inline ::google::protobuf::int32 curexp() const;
  inline void set_curexp(::google::protobuf::int32 value);

  // optional int32 contri = 4;
  inline bool has_contri() const;
  inline void clear_contri();
  static const int kContriFieldNumber = 4;
  inline ::google::protobuf::int32 contri() const;
  inline void set_contri(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.WSToClentSkillUpdate)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_skillid();
  inline void clear_has_skillid();
  inline void set_has_curexp();
  inline void clear_has_curexp();
  inline void set_has_contri();
  inline void clear_has_contri();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 skillid_;
  ::google::protobuf::int32 curexp_;
  ::google::protobuf::int32 contri_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static WSToClentSkillUpdate* default_instance_;
};
// -------------------------------------------------------------------

class WSToClientSimSkillUpdate : public ::google::protobuf::Message {
 public:
  WSToClientSimSkillUpdate();
  virtual ~WSToClientSimSkillUpdate();

  WSToClientSimSkillUpdate(const WSToClientSimSkillUpdate& from);

  inline WSToClientSimSkillUpdate& operator=(const WSToClientSimSkillUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WSToClientSimSkillUpdate& default_instance();

  void Swap(WSToClientSimSkillUpdate* other);

  // implements Message ----------------------------------------------

  WSToClientSimSkillUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WSToClientSimSkillUpdate& from);
  void MergeFrom(const WSToClientSimSkillUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 skillid = 1;
  inline bool has_skillid() const;
  inline void clear_skillid();
  static const int kSkillidFieldNumber = 1;
  inline ::google::protobuf::int32 skillid() const;
  inline void set_skillid(::google::protobuf::int32 value);

  // optional int32 curexp = 2;
  inline bool has_curexp() const;
  inline void clear_curexp();
  static const int kCurexpFieldNumber = 2;
  inline ::google::protobuf::int32 curexp() const;
  inline void set_curexp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.WSToClientSimSkillUpdate)
 private:
  inline void set_has_skillid();
  inline void clear_has_skillid();
  inline void set_has_curexp();
  inline void clear_has_curexp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 skillid_;
  ::google::protobuf::int32 curexp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static WSToClientSimSkillUpdate* default_instance_;
};
// -------------------------------------------------------------------

class WSToGameADBuff : public ::google::protobuf::Message {
 public:
  WSToGameADBuff();
  virtual ~WSToGameADBuff();

  WSToGameADBuff(const WSToGameADBuff& from);

  inline WSToGameADBuff& operator=(const WSToGameADBuff& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WSToGameADBuff& default_instance();

  void Swap(WSToGameADBuff* other);

  // implements Message ----------------------------------------------

  WSToGameADBuff* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WSToGameADBuff& from);
  void MergeFrom(const WSToGameADBuff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // optional bool flag = 2;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 2;
  inline bool flag() const;
  inline void set_flag(bool value);

  // repeated int32 skillid = 3;
  inline int skillid_size() const;
  inline void clear_skillid();
  static const int kSkillidFieldNumber = 3;
  inline ::google::protobuf::int32 skillid(int index) const;
  inline void set_skillid(int index, ::google::protobuf::int32 value);
  inline void add_skillid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      skillid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_skillid();

  // @@protoc_insertion_point(class_scope:ClanPackage.WSToGameADBuff)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_flag();
  inline void clear_has_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > skillid_;
  bool flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static WSToGameADBuff* default_instance_;
};
// -------------------------------------------------------------------

class WSToGameClanLevel : public ::google::protobuf::Message {
 public:
  WSToGameClanLevel();
  virtual ~WSToGameClanLevel();

  WSToGameClanLevel(const WSToGameClanLevel& from);

  inline WSToGameClanLevel& operator=(const WSToGameClanLevel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WSToGameClanLevel& default_instance();

  void Swap(WSToGameClanLevel* other);

  // implements Message ----------------------------------------------

  WSToGameClanLevel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WSToGameClanLevel& from);
  void MergeFrom(const WSToGameClanLevel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int64 charid() const;
  inline void set_charid(::google::protobuf::int64 value);

  // optional int32 clanLevel = 2;
  inline bool has_clanlevel() const;
  inline void clear_clanlevel();
  static const int kClanLevelFieldNumber = 2;
  inline ::google::protobuf::int32 clanlevel() const;
  inline void set_clanlevel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.WSToGameClanLevel)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_clanlevel();
  inline void clear_has_clanlevel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 charid_;
  ::google::protobuf::int32 clanlevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static WSToGameClanLevel* default_instance_;
};
// -------------------------------------------------------------------

class SynchWillJoinToGM : public ::google::protobuf::Message {
 public:
  SynchWillJoinToGM();
  virtual ~SynchWillJoinToGM();

  SynchWillJoinToGM(const SynchWillJoinToGM& from);

  inline SynchWillJoinToGM& operator=(const SynchWillJoinToGM& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SynchWillJoinToGM& default_instance();

  void Swap(SynchWillJoinToGM* other);

  // implements Message ----------------------------------------------

  SynchWillJoinToGM* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SynchWillJoinToGM& from);
  void MergeFrom(const SynchWillJoinToGM& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 charID = 1;
  inline int charid_size() const;
  inline void clear_charid();
  static const int kCharIDFieldNumber = 1;
  inline ::google::protobuf::int64 charid(int index) const;
  inline void set_charid(int index, ::google::protobuf::int64 value);
  inline void add_charid(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      charid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_charid();

  // optional bool flag = 2;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 2;
  inline bool flag() const;
  inline void set_flag(bool value);

  // @@protoc_insertion_point(class_scope:ClanPackage.SynchWillJoinToGM)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > charid_;
  bool flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static SynchWillJoinToGM* default_instance_;
};
// -------------------------------------------------------------------

class ShowClanWelfare : public ::google::protobuf::Message {
 public:
  ShowClanWelfare();
  virtual ~ShowClanWelfare();

  ShowClanWelfare(const ShowClanWelfare& from);

  inline ShowClanWelfare& operator=(const ShowClanWelfare& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShowClanWelfare& default_instance();

  void Swap(ShowClanWelfare* other);

  // implements Message ----------------------------------------------

  ShowClanWelfare* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShowClanWelfare& from);
  void MergeFrom(const ShowClanWelfare& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ClanPackage.ClanWelfare welfares = 1;
  inline int welfares_size() const;
  inline void clear_welfares();
  static const int kWelfaresFieldNumber = 1;
  inline const ::ClanPackage::ClanWelfare& welfares(int index) const;
  inline ::ClanPackage::ClanWelfare* mutable_welfares(int index);
  inline ::ClanPackage::ClanWelfare* add_welfares();
  inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanWelfare >&
      welfares() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanWelfare >*
      mutable_welfares();

  // optional uint32 historyContri = 2;
  inline bool has_historycontri() const;
  inline void clear_historycontri();
  static const int kHistoryContriFieldNumber = 2;
  inline ::google::protobuf::uint32 historycontri() const;
  inline void set_historycontri(::google::protobuf::uint32 value);

  // optional uint64 joinTime = 3;
  inline bool has_jointime() const;
  inline void clear_jointime();
  static const int kJoinTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 jointime() const;
  inline void set_jointime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ShowClanWelfare)
 private:
  inline void set_has_historycontri();
  inline void clear_has_historycontri();
  inline void set_has_jointime();
  inline void clear_has_jointime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanWelfare > welfares_;
  ::google::protobuf::uint64 jointime_;
  ::google::protobuf::uint32 historycontri_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ShowClanWelfare* default_instance_;
};
// -------------------------------------------------------------------

class ClanWelfare : public ::google::protobuf::Message {
 public:
  ClanWelfare();
  virtual ~ClanWelfare();

  ClanWelfare(const ClanWelfare& from);

  inline ClanWelfare& operator=(const ClanWelfare& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanWelfare& default_instance();

  void Swap(ClanWelfare* other);

  // implements Message ----------------------------------------------

  ClanWelfare* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanWelfare& from);
  void MergeFrom(const ClanWelfare& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 welfareID = 1;
  inline bool has_welfareid() const;
  inline void clear_welfareid();
  static const int kWelfareIDFieldNumber = 1;
  inline ::google::protobuf::uint64 welfareid() const;
  inline void set_welfareid(::google::protobuf::uint64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 welfareInfoID = 3;
  inline bool has_welfareinfoid() const;
  inline void clear_welfareinfoid();
  static const int kWelfareInfoIDFieldNumber = 3;
  inline ::google::protobuf::int32 welfareinfoid() const;
  inline void set_welfareinfoid(::google::protobuf::int32 value);

  // optional int32 limitLv = 4;
  inline bool has_limitlv() const;
  inline void clear_limitlv();
  static const int kLimitLvFieldNumber = 4;
  inline ::google::protobuf::int32 limitlv() const;
  inline void set_limitlv(::google::protobuf::int32 value);

  // optional int32 limitDay = 5;
  inline bool has_limitday() const;
  inline void clear_limitday();
  static const int kLimitDayFieldNumber = 5;
  inline ::google::protobuf::int32 limitday() const;
  inline void set_limitday(::google::protobuf::int32 value);

  // optional int32 limitContri = 6;
  inline bool has_limitcontri() const;
  inline void clear_limitcontri();
  static const int kLimitContriFieldNumber = 6;
  inline ::google::protobuf::int32 limitcontri() const;
  inline void set_limitcontri(::google::protobuf::int32 value);

  // optional int32 num = 7;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 7;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 isTake = 8;
  inline bool has_istake() const;
  inline void clear_istake();
  static const int kIsTakeFieldNumber = 8;
  inline ::google::protobuf::int32 istake() const;
  inline void set_istake(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClanWelfare)
 private:
  inline void set_has_welfareid();
  inline void clear_has_welfareid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_welfareinfoid();
  inline void clear_has_welfareinfoid();
  inline void set_has_limitlv();
  inline void clear_has_limitlv();
  inline void set_has_limitday();
  inline void clear_has_limitday();
  inline void set_has_limitcontri();
  inline void clear_has_limitcontri();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_istake();
  inline void clear_has_istake();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 welfareid_;
  ::std::string* name_;
  ::google::protobuf::int32 welfareinfoid_;
  ::google::protobuf::int32 limitlv_;
  ::google::protobuf::int32 limitday_;
  ::google::protobuf::int32 limitcontri_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 istake_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClanWelfare* default_instance_;
};
// -------------------------------------------------------------------

class SendClanWelfare : public ::google::protobuf::Message {
 public:
  SendClanWelfare();
  virtual ~SendClanWelfare();

  SendClanWelfare(const SendClanWelfare& from);

  inline SendClanWelfare& operator=(const SendClanWelfare& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendClanWelfare& default_instance();

  void Swap(SendClanWelfare* other);

  // implements Message ----------------------------------------------

  SendClanWelfare* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendClanWelfare& from);
  void MergeFrom(const SendClanWelfare& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 welfareInfoID = 1;
  inline bool has_welfareinfoid() const;
  inline void clear_welfareinfoid();
  static const int kWelfareInfoIDFieldNumber = 1;
  inline ::google::protobuf::int32 welfareinfoid() const;
  inline void set_welfareinfoid(::google::protobuf::int32 value);

  // optional int32 lv = 2;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 2;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // optional int32 day = 3;
  inline bool has_day() const;
  inline void clear_day();
  static const int kDayFieldNumber = 3;
  inline ::google::protobuf::int32 day() const;
  inline void set_day(::google::protobuf::int32 value);

  // optional int32 contri = 4;
  inline bool has_contri() const;
  inline void clear_contri();
  static const int kContriFieldNumber = 4;
  inline ::google::protobuf::int32 contri() const;
  inline void set_contri(::google::protobuf::int32 value);

  // optional int32 num = 5;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 5;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.SendClanWelfare)
 private:
  inline void set_has_welfareinfoid();
  inline void clear_has_welfareinfoid();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_day();
  inline void clear_has_day();
  inline void set_has_contri();
  inline void clear_has_contri();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 welfareinfoid_;
  ::google::protobuf::int32 lv_;
  ::google::protobuf::int32 day_;
  ::google::protobuf::int32 contri_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static SendClanWelfare* default_instance_;
};
// -------------------------------------------------------------------

class TakeClanWelfare : public ::google::protobuf::Message {
 public:
  TakeClanWelfare();
  virtual ~TakeClanWelfare();

  TakeClanWelfare(const TakeClanWelfare& from);

  inline TakeClanWelfare& operator=(const TakeClanWelfare& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TakeClanWelfare& default_instance();

  void Swap(TakeClanWelfare* other);

  // implements Message ----------------------------------------------

  TakeClanWelfare* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TakeClanWelfare& from);
  void MergeFrom(const TakeClanWelfare& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 welfareID = 1;
  inline bool has_welfareid() const;
  inline void clear_welfareid();
  static const int kWelfareIDFieldNumber = 1;
  inline ::google::protobuf::uint64 welfareid() const;
  inline void set_welfareid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.TakeClanWelfare)
 private:
  inline void set_has_welfareid();
  inline void clear_has_welfareid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 welfareid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static TakeClanWelfare* default_instance_;
};
// -------------------------------------------------------------------

class RetTakeClanWelfare : public ::google::protobuf::Message {
 public:
  RetTakeClanWelfare();
  virtual ~RetTakeClanWelfare();

  RetTakeClanWelfare(const RetTakeClanWelfare& from);

  inline RetTakeClanWelfare& operator=(const RetTakeClanWelfare& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RetTakeClanWelfare& default_instance();

  void Swap(RetTakeClanWelfare* other);

  // implements Message ----------------------------------------------

  RetTakeClanWelfare* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetTakeClanWelfare& from);
  void MergeFrom(const RetTakeClanWelfare& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 err = 1;
  inline bool has_err() const;
  inline void clear_err();
  static const int kErrFieldNumber = 1;
  inline ::google::protobuf::int32 err() const;
  inline void set_err(::google::protobuf::int32 value);

  // optional .ClanPackage.ClanWelfare welfare = 2;
  inline bool has_welfare() const;
  inline void clear_welfare();
  static const int kWelfareFieldNumber = 2;
  inline const ::ClanPackage::ClanWelfare& welfare() const;
  inline ::ClanPackage::ClanWelfare* mutable_welfare();
  inline ::ClanPackage::ClanWelfare* release_welfare();
  inline void set_allocated_welfare(::ClanPackage::ClanWelfare* welfare);

  // @@protoc_insertion_point(class_scope:ClanPackage.RetTakeClanWelfare)
 private:
  inline void set_has_err();
  inline void clear_has_err();
  inline void set_has_welfare();
  inline void clear_has_welfare();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ClanPackage::ClanWelfare* welfare_;
  ::google::protobuf::int32 err_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static RetTakeClanWelfare* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqBackClanMap : public ::google::protobuf::Message {
 public:
  ClientReqBackClanMap();
  virtual ~ClientReqBackClanMap();

  ClientReqBackClanMap(const ClientReqBackClanMap& from);

  inline ClientReqBackClanMap& operator=(const ClientReqBackClanMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqBackClanMap& default_instance();

  void Swap(ClientReqBackClanMap* other);

  // implements Message ----------------------------------------------

  ClientReqBackClanMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqBackClanMap& from);
  void MergeFrom(const ClientReqBackClanMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqBackClanMap)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqBackClanMap* default_instance_;
};
// -------------------------------------------------------------------

class AckReqBackClanMap : public ::google::protobuf::Message {
 public:
  AckReqBackClanMap();
  virtual ~AckReqBackClanMap();

  AckReqBackClanMap(const AckReqBackClanMap& from);

  inline AckReqBackClanMap& operator=(const AckReqBackClanMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckReqBackClanMap& default_instance();

  void Swap(AckReqBackClanMap* other);

  // implements Message ----------------------------------------------

  AckReqBackClanMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckReqBackClanMap& from);
  void MergeFrom(const AckReqBackClanMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int64 mapid = 2;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapidFieldNumber = 2;
  inline ::google::protobuf::int64 mapid() const;
  inline void set_mapid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckReqBackClanMap)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_mapid();
  inline void clear_has_mapid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 mapid_;
  ::google::protobuf::int32 ret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckReqBackClanMap* default_instance_;
};
// -------------------------------------------------------------------

class AckClanSkills : public ::google::protobuf::Message {
 public:
  AckClanSkills();
  virtual ~AckClanSkills();

  AckClanSkills(const AckClanSkills& from);

  inline AckClanSkills& operator=(const AckClanSkills& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckClanSkills& default_instance();

  void Swap(AckClanSkills* other);

  // implements Message ----------------------------------------------

  AckClanSkills* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckClanSkills& from);
  void MergeFrom(const AckClanSkills& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 id = 1;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id(int index) const;
  inline void set_id(int index, ::google::protobuf::int32 value);
  inline void add_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id();

  // @@protoc_insertion_point(class_scope:ClanPackage.AckClanSkills)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckClanSkills* default_instance_;
};
// -------------------------------------------------------------------

class ReqUpGrageClanSkill : public ::google::protobuf::Message {
 public:
  ReqUpGrageClanSkill();
  virtual ~ReqUpGrageClanSkill();

  ReqUpGrageClanSkill(const ReqUpGrageClanSkill& from);

  inline ReqUpGrageClanSkill& operator=(const ReqUpGrageClanSkill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqUpGrageClanSkill& default_instance();

  void Swap(ReqUpGrageClanSkill* other);

  // implements Message ----------------------------------------------

  ReqUpGrageClanSkill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqUpGrageClanSkill& from);
  void MergeFrom(const ReqUpGrageClanSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ReqUpGrageClanSkill)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ReqUpGrageClanSkill* default_instance_;
};
// -------------------------------------------------------------------

class AckUpGradeClanSkill : public ::google::protobuf::Message {
 public:
  AckUpGradeClanSkill();
  virtual ~AckUpGradeClanSkill();

  AckUpGradeClanSkill(const AckUpGradeClanSkill& from);

  inline AckUpGradeClanSkill& operator=(const AckUpGradeClanSkill& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUpGradeClanSkill& default_instance();

  void Swap(AckUpGradeClanSkill* other);

  // implements Message ----------------------------------------------

  AckUpGradeClanSkill* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUpGradeClanSkill& from);
  void MergeFrom(const AckUpGradeClanSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 oldskill = 2;
  inline bool has_oldskill() const;
  inline void clear_oldskill();
  static const int kOldskillFieldNumber = 2;
  inline ::google::protobuf::int32 oldskill() const;
  inline void set_oldskill(::google::protobuf::int32 value);

  // optional int32 newskill = 3;
  inline bool has_newskill() const;
  inline void clear_newskill();
  static const int kNewskillFieldNumber = 3;
  inline ::google::protobuf::int32 newskill() const;
  inline void set_newskill(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckUpGradeClanSkill)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_oldskill();
  inline void clear_has_oldskill();
  inline void set_has_newskill();
  inline void clear_has_newskill();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 oldskill_;
  ::google::protobuf::int32 newskill_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckUpGradeClanSkill* default_instance_;
};
// -------------------------------------------------------------------

class Ws2GsRobberActive : public ::google::protobuf::Message {
 public:
  Ws2GsRobberActive();
  virtual ~Ws2GsRobberActive();

  Ws2GsRobberActive(const Ws2GsRobberActive& from);

  inline Ws2GsRobberActive& operator=(const Ws2GsRobberActive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ws2GsRobberActive& default_instance();

  void Swap(Ws2GsRobberActive* other);

  // implements Message ----------------------------------------------

  Ws2GsRobberActive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ws2GsRobberActive& from);
  void MergeFrom(const Ws2GsRobberActive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool flag = 1;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 1;
  inline bool flag() const;
  inline void set_flag(bool value);

  // repeated .ClanPackage.ClanMapInfo info = 2;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::ClanPackage::ClanMapInfo& info(int index) const;
  inline ::ClanPackage::ClanMapInfo* mutable_info(int index);
  inline ::ClanPackage::ClanMapInfo* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanMapInfo >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanMapInfo >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:ClanPackage.Ws2GsRobberActive)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanMapInfo > info_;
  bool flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static Ws2GsRobberActive* default_instance_;
};
// -------------------------------------------------------------------

class ClanMapInfo : public ::google::protobuf::Message {
 public:
  ClanMapInfo();
  virtual ~ClanMapInfo();

  ClanMapInfo(const ClanMapInfo& from);

  inline ClanMapInfo& operator=(const ClanMapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClanMapInfo& default_instance();

  void Swap(ClanMapInfo* other);

  // implements Message ----------------------------------------------

  ClanMapInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClanMapInfo& from);
  void MergeFrom(const ClanMapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 clanid = 1;
  inline bool has_clanid() const;
  inline void clear_clanid();
  static const int kClanidFieldNumber = 1;
  inline ::google::protobuf::int32 clanid() const;
  inline void set_clanid(::google::protobuf::int32 value);

  // optional int64 mapid = 2;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapidFieldNumber = 2;
  inline ::google::protobuf::int64 mapid() const;
  inline void set_mapid(::google::protobuf::int64 value);

  // optional bool win = 3;
  inline bool has_win() const;
  inline void clear_win();
  static const int kWinFieldNumber = 3;
  inline bool win() const;
  inline void set_win(bool value);

  // optional int32 param = 4;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 4;
  inline ::google::protobuf::int32 param() const;
  inline void set_param(::google::protobuf::int32 value);

  // optional int32 conwin = 5;
  inline bool has_conwin() const;
  inline void clear_conwin();
  static const int kConwinFieldNumber = 5;
  inline ::google::protobuf::int32 conwin() const;
  inline void set_conwin(::google::protobuf::int32 value);

  // optional int32 confail = 6;
  inline bool has_confail() const;
  inline void clear_confail();
  static const int kConfailFieldNumber = 6;
  inline ::google::protobuf::int32 confail() const;
  inline void set_confail(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClanMapInfo)
 private:
  inline void set_has_clanid();
  inline void clear_has_clanid();
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_win();
  inline void clear_has_win();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_conwin();
  inline void clear_has_conwin();
  inline void set_has_confail();
  inline void clear_has_confail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 mapid_;
  ::google::protobuf::int32 clanid_;
  bool win_;
  ::google::protobuf::int32 param_;
  ::google::protobuf::int32 conwin_;
  ::google::protobuf::int32 confail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClanMapInfo* default_instance_;
};
// -------------------------------------------------------------------

class Ws2GsDestroyClanMap : public ::google::protobuf::Message {
 public:
  Ws2GsDestroyClanMap();
  virtual ~Ws2GsDestroyClanMap();

  Ws2GsDestroyClanMap(const Ws2GsDestroyClanMap& from);

  inline Ws2GsDestroyClanMap& operator=(const Ws2GsDestroyClanMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ws2GsDestroyClanMap& default_instance();

  void Swap(Ws2GsDestroyClanMap* other);

  // implements Message ----------------------------------------------

  Ws2GsDestroyClanMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ws2GsDestroyClanMap& from);
  void MergeFrom(const Ws2GsDestroyClanMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 clanid = 1;
  inline bool has_clanid() const;
  inline void clear_clanid();
  static const int kClanidFieldNumber = 1;
  inline ::google::protobuf::int32 clanid() const;
  inline void set_clanid(::google::protobuf::int32 value);

  // optional int64 mapid = 2;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapidFieldNumber = 2;
  inline ::google::protobuf::int64 mapid() const;
  inline void set_mapid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.Ws2GsDestroyClanMap)
 private:
  inline void set_has_clanid();
  inline void clear_has_clanid();
  inline void set_has_mapid();
  inline void clear_has_mapid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 mapid_;
  ::google::protobuf::int32 clanid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static Ws2GsDestroyClanMap* default_instance_;
};
// -------------------------------------------------------------------

class RobberResult : public ::google::protobuf::Message {
 public:
  RobberResult();
  virtual ~RobberResult();

  RobberResult(const RobberResult& from);

  inline RobberResult& operator=(const RobberResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobberResult& default_instance();

  void Swap(RobberResult* other);

  // implements Message ----------------------------------------------

  RobberResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobberResult& from);
  void MergeFrom(const RobberResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 clanid = 1;
  inline bool has_clanid() const;
  inline void clear_clanid();
  static const int kClanidFieldNumber = 1;
  inline ::google::protobuf::int32 clanid() const;
  inline void set_clanid(::google::protobuf::int32 value);

  // optional bool win = 2;
  inline bool has_win() const;
  inline void clear_win();
  static const int kWinFieldNumber = 2;
  inline bool win() const;
  inline void set_win(bool value);

  // optional int32 param = 3;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 3;
  inline ::google::protobuf::int32 param() const;
  inline void set_param(::google::protobuf::int32 value);

  // optional int32 conwin = 4;
  inline bool has_conwin() const;
  inline void clear_conwin();
  static const int kConwinFieldNumber = 4;
  inline ::google::protobuf::int32 conwin() const;
  inline void set_conwin(::google::protobuf::int32 value);

  // optional int32 confail = 5;
  inline bool has_confail() const;
  inline void clear_confail();
  static const int kConfailFieldNumber = 5;
  inline ::google::protobuf::int32 confail() const;
  inline void set_confail(::google::protobuf::int32 value);

  // optional int32 money = 6;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 6;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.RobberResult)
 private:
  inline void set_has_clanid();
  inline void clear_has_clanid();
  inline void set_has_win();
  inline void clear_has_win();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_conwin();
  inline void clear_has_conwin();
  inline void set_has_confail();
  inline void clear_has_confail();
  inline void set_has_money();
  inline void clear_has_money();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 clanid_;
  bool win_;
  ::google::protobuf::int32 param_;
  ::google::protobuf::int32 conwin_;
  ::google::protobuf::int32 confail_;
  ::google::protobuf::int32 money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static RobberResult* default_instance_;
};
// -------------------------------------------------------------------

class ClientReqChanceJoinClan : public ::google::protobuf::Message {
 public:
  ClientReqChanceJoinClan();
  virtual ~ClientReqChanceJoinClan();

  ClientReqChanceJoinClan(const ClientReqChanceJoinClan& from);

  inline ClientReqChanceJoinClan& operator=(const ClientReqChanceJoinClan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientReqChanceJoinClan& default_instance();

  void Swap(ClientReqChanceJoinClan* other);

  // implements Message ----------------------------------------------

  ClientReqChanceJoinClan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientReqChanceJoinClan& from);
  void MergeFrom(const ClientReqChanceJoinClan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.ClientReqChanceJoinClan)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static ClientReqChanceJoinClan* default_instance_;
};
// -------------------------------------------------------------------

class AckChanceJoinClan : public ::google::protobuf::Message {
 public:
  AckChanceJoinClan();
  virtual ~AckChanceJoinClan();

  AckChanceJoinClan(const AckChanceJoinClan& from);

  inline AckChanceJoinClan& operator=(const AckChanceJoinClan& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckChanceJoinClan& default_instance();

  void Swap(AckChanceJoinClan* other);

  // implements Message ----------------------------------------------

  AckChanceJoinClan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckChanceJoinClan& from);
  void MergeFrom(const AckChanceJoinClan& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  inline bool has_ret() const;
  inline void clear_ret();
  static const int kRetFieldNumber = 1;
  inline ::google::protobuf::int32 ret() const;
  inline void set_ret(::google::protobuf::int32 value);

  // optional int32 clanID = 2;
  inline bool has_clanid() const;
  inline void clear_clanid();
  static const int kClanIDFieldNumber = 2;
  inline ::google::protobuf::int32 clanid() const;
  inline void set_clanid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ClanPackage.AckChanceJoinClan)
 private:
  inline void set_has_ret();
  inline void clear_has_ret();
  inline void set_has_clanid();
  inline void clear_has_clanid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 clanid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Clan_2fClan_2eproto();
  friend void protobuf_AssignDesc_Clan_2fClan_2eproto();
  friend void protobuf_ShutdownFile_Clan_2fClan_2eproto();

  void InitAsDefaultInstance();
  static AckChanceJoinClan* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientReqCreateClan

// required int32 id = 1;
inline bool ClientReqCreateClan::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqCreateClan::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqCreateClan::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqCreateClan::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ClientReqCreateClan::id() const {
  return id_;
}
inline void ClientReqCreateClan::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool ClientReqCreateClan::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientReqCreateClan::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientReqCreateClan::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientReqCreateClan::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClientReqCreateClan::name() const {
  return *name_;
}
inline void ClientReqCreateClan::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClientReqCreateClan::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClientReqCreateClan::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientReqCreateClan::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClientReqCreateClan::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientReqCreateClan::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool type = 3;
inline bool ClientReqCreateClan::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientReqCreateClan::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientReqCreateClan::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientReqCreateClan::clear_type() {
  type_ = false;
  clear_has_type();
}
inline bool ClientReqCreateClan::type() const {
  return type_;
}
inline void ClientReqCreateClan::set_type(bool value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// WorldReqTakeOff

// required int64 id = 1;
inline bool WorldReqTakeOff::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorldReqTakeOff::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorldReqTakeOff::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorldReqTakeOff::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 WorldReqTakeOff::id() const {
  return id_;
}
inline void WorldReqTakeOff::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// optional bool type = 2;
inline bool WorldReqTakeOff::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WorldReqTakeOff::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WorldReqTakeOff::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WorldReqTakeOff::clear_type() {
  type_ = false;
  clear_has_type();
}
inline bool WorldReqTakeOff::type() const {
  return type_;
}
inline void WorldReqTakeOff::set_type(bool value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// AckCreateClan

// required int32 ret = 1;
inline bool AckCreateClan::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckCreateClan::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckCreateClan::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckCreateClan::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 AckCreateClan::ret() const {
  return ret_;
}
inline void AckCreateClan::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional .ClanPackage.AckClanBase info = 2;
inline bool AckCreateClan::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckCreateClan::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckCreateClan::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckCreateClan::clear_info() {
  if (info_ != NULL) info_->::ClanPackage::AckClanBase::Clear();
  clear_has_info();
}
inline const ::ClanPackage::AckClanBase& AckCreateClan::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::ClanPackage::AckClanBase* AckCreateClan::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::ClanPackage::AckClanBase;
  return info_;
}
inline ::ClanPackage::AckClanBase* AckCreateClan::release_info() {
  clear_has_info();
  ::ClanPackage::AckClanBase* temp = info_;
  info_ = NULL;
  return temp;
}
inline void AckCreateClan::set_allocated_info(::ClanPackage::AckClanBase* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// AckClanBase

// required uint32 id = 1;
inline bool AckClanBase::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckClanBase::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckClanBase::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckClanBase::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 AckClanBase::id() const {
  return id_;
}
inline void AckClanBase::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 lv = 2;
inline bool AckClanBase::has_lv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckClanBase::set_has_lv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckClanBase::clear_has_lv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckClanBase::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 AckClanBase::lv() const {
  return lv_;
}
inline void AckClanBase::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// optional string title = 3;
inline bool AckClanBase::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckClanBase::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckClanBase::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckClanBase::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& AckClanBase::title() const {
  return *title_;
}
inline void AckClanBase::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void AckClanBase::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void AckClanBase::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckClanBase::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* AckClanBase::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckClanBase::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 money = 4;
inline bool AckClanBase::has_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckClanBase::set_has_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckClanBase::clear_has_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckClanBase::clear_money() {
  money_ = GOOGLE_LONGLONG(0);
  clear_has_money();
}
inline ::google::protobuf::int64 AckClanBase::money() const {
  return money_;
}
inline void AckClanBase::set_money(::google::protobuf::int64 value) {
  set_has_money();
  money_ = value;
}

// optional int64 golden = 5;
inline bool AckClanBase::has_golden() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckClanBase::set_has_golden() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckClanBase::clear_has_golden() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckClanBase::clear_golden() {
  golden_ = GOOGLE_LONGLONG(0);
  clear_has_golden();
}
inline ::google::protobuf::int64 AckClanBase::golden() const {
  return golden_;
}
inline void AckClanBase::set_golden(::google::protobuf::int64 value) {
  set_has_golden();
  golden_ = value;
}

// optional double titletime = 6;
inline bool AckClanBase::has_titletime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AckClanBase::set_has_titletime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AckClanBase::clear_has_titletime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AckClanBase::clear_titletime() {
  titletime_ = 0;
  clear_has_titletime();
}
inline double AckClanBase::titletime() const {
  return titletime_;
}
inline void AckClanBase::set_titletime(double value) {
  set_has_titletime();
  titletime_ = value;
}

// optional double createtime = 7;
inline bool AckClanBase::has_createtime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AckClanBase::set_has_createtime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AckClanBase::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AckClanBase::clear_createtime() {
  createtime_ = 0;
  clear_has_createtime();
}
inline double AckClanBase::createtime() const {
  return createtime_;
}
inline void AckClanBase::set_createtime(double value) {
  set_has_createtime();
  createtime_ = value;
}

// optional int32 factioncon = 8;
inline bool AckClanBase::has_factioncon() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AckClanBase::set_has_factioncon() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AckClanBase::clear_has_factioncon() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AckClanBase::clear_factioncon() {
  factioncon_ = 0;
  clear_has_factioncon();
}
inline ::google::protobuf::int32 AckClanBase::factioncon() const {
  return factioncon_;
}
inline void AckClanBase::set_factioncon(::google::protobuf::int32 value) {
  set_has_factioncon();
  factioncon_ = value;
}

// optional string clanname = 9;
inline bool AckClanBase::has_clanname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AckClanBase::set_has_clanname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AckClanBase::clear_has_clanname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AckClanBase::clear_clanname() {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    clanname_->clear();
  }
  clear_has_clanname();
}
inline const ::std::string& AckClanBase::clanname() const {
  return *clanname_;
}
inline void AckClanBase::set_clanname(const ::std::string& value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void AckClanBase::set_clanname(const char* value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void AckClanBase::set_clanname(const char* value, size_t size) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckClanBase::mutable_clanname() {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  return clanname_;
}
inline ::std::string* AckClanBase::release_clanname() {
  clear_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clanname_;
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckClanBase::set_allocated_clanname(::std::string* clanname) {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    delete clanname_;
  }
  if (clanname) {
    set_has_clanname();
    clanname_ = clanname;
  } else {
    clear_has_clanname();
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bossname = 10;
inline bool AckClanBase::has_bossname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AckClanBase::set_has_bossname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AckClanBase::clear_has_bossname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AckClanBase::clear_bossname() {
  if (bossname_ != &::google::protobuf::internal::kEmptyString) {
    bossname_->clear();
  }
  clear_has_bossname();
}
inline const ::std::string& AckClanBase::bossname() const {
  return *bossname_;
}
inline void AckClanBase::set_bossname(const ::std::string& value) {
  set_has_bossname();
  if (bossname_ == &::google::protobuf::internal::kEmptyString) {
    bossname_ = new ::std::string;
  }
  bossname_->assign(value);
}
inline void AckClanBase::set_bossname(const char* value) {
  set_has_bossname();
  if (bossname_ == &::google::protobuf::internal::kEmptyString) {
    bossname_ = new ::std::string;
  }
  bossname_->assign(value);
}
inline void AckClanBase::set_bossname(const char* value, size_t size) {
  set_has_bossname();
  if (bossname_ == &::google::protobuf::internal::kEmptyString) {
    bossname_ = new ::std::string;
  }
  bossname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckClanBase::mutable_bossname() {
  set_has_bossname();
  if (bossname_ == &::google::protobuf::internal::kEmptyString) {
    bossname_ = new ::std::string;
  }
  return bossname_;
}
inline ::std::string* AckClanBase::release_bossname() {
  clear_has_bossname();
  if (bossname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bossname_;
    bossname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckClanBase::set_allocated_bossname(::std::string* bossname) {
  if (bossname_ != &::google::protobuf::internal::kEmptyString) {
    delete bossname_;
  }
  if (bossname) {
    set_has_bossname();
    bossname_ = bossname;
  } else {
    clear_has_bossname();
    bossname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 icon = 11;
inline bool AckClanBase::has_icon() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AckClanBase::set_has_icon() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AckClanBase::clear_has_icon() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AckClanBase::clear_icon() {
  icon_ = 0;
  clear_has_icon();
}
inline ::google::protobuf::int32 AckClanBase::icon() const {
  return icon_;
}
inline void AckClanBase::set_icon(::google::protobuf::int32 value) {
  set_has_icon();
  icon_ = value;
}

// optional int32 members = 12;
inline bool AckClanBase::has_members() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AckClanBase::set_has_members() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AckClanBase::clear_has_members() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AckClanBase::clear_members() {
  members_ = 0;
  clear_has_members();
}
inline ::google::protobuf::int32 AckClanBase::members() const {
  return members_;
}
inline void AckClanBase::set_members(::google::protobuf::int32 value) {
  set_has_members();
  members_ = value;
}

// optional bool autoflag = 13;
inline bool AckClanBase::has_autoflag() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AckClanBase::set_has_autoflag() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AckClanBase::clear_has_autoflag() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AckClanBase::clear_autoflag() {
  autoflag_ = false;
  clear_has_autoflag();
}
inline bool AckClanBase::autoflag() const {
  return autoflag_;
}
inline void AckClanBase::set_autoflag(bool value) {
  set_has_autoflag();
  autoflag_ = value;
}

// -------------------------------------------------------------------

// ClientReqClanList

// required int32 page = 1;
inline bool ClientReqClanList::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqClanList::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqClanList::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqClanList::clear_page() {
  page_ = 0;
  clear_has_page();
}
inline ::google::protobuf::int32 ClientReqClanList::page() const {
  return page_;
}
inline void ClientReqClanList::set_page(::google::protobuf::int32 value) {
  set_has_page();
  page_ = value;
}

// -------------------------------------------------------------------

// AckClanList

// repeated .ClanPackage.ClanList list = 1;
inline int AckClanList::list_size() const {
  return list_.size();
}
inline void AckClanList::clear_list() {
  list_.Clear();
}
inline const ::ClanPackage::ClanList& AckClanList::list(int index) const {
  return list_.Get(index);
}
inline ::ClanPackage::ClanList* AckClanList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::ClanPackage::ClanList* AckClanList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanList >&
AckClanList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanList >*
AckClanList::mutable_list() {
  return &list_;
}

// optional int32 size = 2;
inline bool AckClanList::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckClanList::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckClanList::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckClanList::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 AckClanList::size() const {
  return size_;
}
inline void AckClanList::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// ClanList

// required uint32 id = 1;
inline bool ClanList::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanList::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanList::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanList::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ClanList::id() const {
  return id_;
}
inline void ClanList::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 rank = 2;
inline bool ClanList::has_rank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanList::set_has_rank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanList::clear_has_rank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanList::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 ClanList::rank() const {
  return rank_;
}
inline void ClanList::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// optional string name = 3;
inline bool ClanList::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanList::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanList::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanList::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClanList::name() const {
  return *name_;
}
inline void ClanList::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanList::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanList::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanList::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClanList::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanList::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 count = 4;
inline bool ClanList::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanList::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanList::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanList::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 ClanList::count() const {
  return count_;
}
inline void ClanList::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// optional int32 lv = 5;
inline bool ClanList::has_lv() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClanList::set_has_lv() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClanList::clear_has_lv() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClanList::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 ClanList::lv() const {
  return lv_;
}
inline void ClanList::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// optional int32 fight = 6;
inline bool ClanList::has_fight() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClanList::set_has_fight() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClanList::clear_has_fight() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClanList::clear_fight() {
  fight_ = 0;
  clear_has_fight();
}
inline ::google::protobuf::int32 ClanList::fight() const {
  return fight_;
}
inline void ClanList::set_fight(::google::protobuf::int32 value) {
  set_has_fight();
  fight_ = value;
}

// optional int32 country = 7;
inline bool ClanList::has_country() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClanList::set_has_country() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClanList::clear_has_country() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClanList::clear_country() {
  country_ = 0;
  clear_has_country();
}
inline ::google::protobuf::int32 ClanList::country() const {
  return country_;
}
inline void ClanList::set_country(::google::protobuf::int32 value) {
  set_has_country();
  country_ = value;
}

// optional bool apply = 8;
inline bool ClanList::has_apply() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClanList::set_has_apply() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClanList::clear_has_apply() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClanList::clear_apply() {
  apply_ = false;
  clear_has_apply();
}
inline bool ClanList::apply() const {
  return apply_;
}
inline void ClanList::set_apply(bool value) {
  set_has_apply();
  apply_ = value;
}

// -------------------------------------------------------------------

// ClientReqMemberList

// required bool type = 1;
inline bool ClientReqMemberList::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqMemberList::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqMemberList::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqMemberList::clear_type() {
  type_ = false;
  clear_has_type();
}
inline bool ClientReqMemberList::type() const {
  return type_;
}
inline void ClientReqMemberList::set_type(bool value) {
  set_has_type();
  type_ = value;
}

// optional int32 page = 2;
inline bool ClientReqMemberList::has_page() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientReqMemberList::set_has_page() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientReqMemberList::clear_has_page() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientReqMemberList::clear_page() {
  page_ = 0;
  clear_has_page();
}
inline ::google::protobuf::int32 ClientReqMemberList::page() const {
  return page_;
}
inline void ClientReqMemberList::set_page(::google::protobuf::int32 value) {
  set_has_page();
  page_ = value;
}

// -------------------------------------------------------------------

// AckMemberList

// repeated .ClanPackage.MemberInfo info = 1;
inline int AckMemberList::info_size() const {
  return info_.size();
}
inline void AckMemberList::clear_info() {
  info_.Clear();
}
inline const ::ClanPackage::MemberInfo& AckMemberList::info(int index) const {
  return info_.Get(index);
}
inline ::ClanPackage::MemberInfo* AckMemberList::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::ClanPackage::MemberInfo* AckMemberList::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::MemberInfo >&
AckMemberList::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::MemberInfo >*
AckMemberList::mutable_info() {
  return &info_;
}

// optional int32 count = 2;
inline bool AckMemberList::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckMemberList::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckMemberList::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckMemberList::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 AckMemberList::count() const {
  return count_;
}
inline void AckMemberList::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// optional int32 fight = 3;
inline bool AckMemberList::has_fight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckMemberList::set_has_fight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckMemberList::clear_has_fight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckMemberList::clear_fight() {
  fight_ = 0;
  clear_has_fight();
}
inline ::google::protobuf::int32 AckMemberList::fight() const {
  return fight_;
}
inline void AckMemberList::set_fight(::google::protobuf::int32 value) {
  set_has_fight();
  fight_ = value;
}

// optional bool isend = 4;
inline bool AckMemberList::has_isend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckMemberList::set_has_isend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckMemberList::clear_has_isend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckMemberList::clear_isend() {
  isend_ = false;
  clear_has_isend();
}
inline bool AckMemberList::isend() const {
  return isend_;
}
inline void AckMemberList::set_isend(bool value) {
  set_has_isend();
  isend_ = value;
}

// -------------------------------------------------------------------

// MemberInfo

// required int64 charid = 1;
inline bool MemberInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemberInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemberInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemberInfo::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 MemberInfo::charid() const {
  return charid_;
}
inline void MemberInfo::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// optional string name = 2;
inline bool MemberInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemberInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemberInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemberInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MemberInfo::name() const {
  return *name_;
}
inline void MemberInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MemberInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MemberInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemberInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MemberInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MemberInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 profession = 3;
inline bool MemberInfo::has_profession() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemberInfo::set_has_profession() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemberInfo::clear_has_profession() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemberInfo::clear_profession() {
  profession_ = 0;
  clear_has_profession();
}
inline ::google::protobuf::int32 MemberInfo::profession() const {
  return profession_;
}
inline void MemberInfo::set_profession(::google::protobuf::int32 value) {
  set_has_profession();
  profession_ = value;
}

// optional int32 contri = 4;
inline bool MemberInfo::has_contri() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemberInfo::set_has_contri() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MemberInfo::clear_has_contri() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MemberInfo::clear_contri() {
  contri_ = 0;
  clear_has_contri();
}
inline ::google::protobuf::int32 MemberInfo::contri() const {
  return contri_;
}
inline void MemberInfo::set_contri(::google::protobuf::int32 value) {
  set_has_contri();
  contri_ = value;
}

// optional int32 fight = 5;
inline bool MemberInfo::has_fight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MemberInfo::set_has_fight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MemberInfo::clear_has_fight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MemberInfo::clear_fight() {
  fight_ = 0;
  clear_has_fight();
}
inline ::google::protobuf::int32 MemberInfo::fight() const {
  return fight_;
}
inline void MemberInfo::set_fight(::google::protobuf::int32 value) {
  set_has_fight();
  fight_ = value;
}

// optional int32 job = 6;
inline bool MemberInfo::has_job() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MemberInfo::set_has_job() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MemberInfo::clear_has_job() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MemberInfo::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 MemberInfo::job() const {
  return job_;
}
inline void MemberInfo::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
}

// optional int32 lv = 7;
inline bool MemberInfo::has_lv() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MemberInfo::set_has_lv() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MemberInfo::clear_has_lv() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MemberInfo::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 MemberInfo::lv() const {
  return lv_;
}
inline void MemberInfo::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// optional int32 vip = 8;
inline bool MemberInfo::has_vip() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MemberInfo::set_has_vip() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MemberInfo::clear_has_vip() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MemberInfo::clear_vip() {
  vip_ = 0;
  clear_has_vip();
}
inline ::google::protobuf::int32 MemberInfo::vip() const {
  return vip_;
}
inline void MemberInfo::set_vip(::google::protobuf::int32 value) {
  set_has_vip();
  vip_ = value;
}

// optional bool isonline = 9;
inline bool MemberInfo::has_isonline() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MemberInfo::set_has_isonline() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MemberInfo::clear_has_isonline() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MemberInfo::clear_isonline() {
  isonline_ = false;
  clear_has_isonline();
}
inline bool MemberInfo::isonline() const {
  return isonline_;
}
inline void MemberInfo::set_isonline(bool value) {
  set_has_isonline();
  isonline_ = value;
}

// -------------------------------------------------------------------

// ReqSeeMemberList

// optional bool type = 1;
inline bool ReqSeeMemberList::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqSeeMemberList::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqSeeMemberList::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqSeeMemberList::clear_type() {
  type_ = false;
  clear_has_type();
}
inline bool ReqSeeMemberList::type() const {
  return type_;
}
inline void ReqSeeMemberList::set_type(bool value) {
  set_has_type();
  type_ = value;
}

// optional int32 page = 2;
inline bool ReqSeeMemberList::has_page() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqSeeMemberList::set_has_page() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqSeeMemberList::clear_has_page() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqSeeMemberList::clear_page() {
  page_ = 0;
  clear_has_page();
}
inline ::google::protobuf::int32 ReqSeeMemberList::page() const {
  return page_;
}
inline void ReqSeeMemberList::set_page(::google::protobuf::int32 value) {
  set_has_page();
  page_ = value;
}

// optional int32 clanID = 3;
inline bool ReqSeeMemberList::has_clanid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqSeeMemberList::set_has_clanid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqSeeMemberList::clear_has_clanid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqSeeMemberList::clear_clanid() {
  clanid_ = 0;
  clear_has_clanid();
}
inline ::google::protobuf::int32 ReqSeeMemberList::clanid() const {
  return clanid_;
}
inline void ReqSeeMemberList::set_clanid(::google::protobuf::int32 value) {
  set_has_clanid();
  clanid_ = value;
}

// -------------------------------------------------------------------

// AckSeeMemberList

// optional .ClanPackage.AckMemberList info = 1;
inline bool AckSeeMemberList::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckSeeMemberList::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckSeeMemberList::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckSeeMemberList::clear_info() {
  if (info_ != NULL) info_->::ClanPackage::AckMemberList::Clear();
  clear_has_info();
}
inline const ::ClanPackage::AckMemberList& AckSeeMemberList::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::ClanPackage::AckMemberList* AckSeeMemberList::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::ClanPackage::AckMemberList;
  return info_;
}
inline ::ClanPackage::AckMemberList* AckSeeMemberList::release_info() {
  clear_has_info();
  ::ClanPackage::AckMemberList* temp = info_;
  info_ = NULL;
  return temp;
}
inline void AckSeeMemberList::set_allocated_info(::ClanPackage::AckMemberList* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// optional bytes clanName = 2;
inline bool AckSeeMemberList::has_clanname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckSeeMemberList::set_has_clanname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckSeeMemberList::clear_has_clanname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckSeeMemberList::clear_clanname() {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    clanname_->clear();
  }
  clear_has_clanname();
}
inline const ::std::string& AckSeeMemberList::clanname() const {
  return *clanname_;
}
inline void AckSeeMemberList::set_clanname(const ::std::string& value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void AckSeeMemberList::set_clanname(const char* value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void AckSeeMemberList::set_clanname(const void* value, size_t size) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckSeeMemberList::mutable_clanname() {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  return clanname_;
}
inline ::std::string* AckSeeMemberList::release_clanname() {
  clear_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clanname_;
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckSeeMemberList::set_allocated_clanname(::std::string* clanname) {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    delete clanname_;
  }
  if (clanname) {
    set_has_clanname();
    clanname_ = clanname;
  } else {
    clear_has_clanname();
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 clanlevel = 3;
inline bool AckSeeMemberList::has_clanlevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckSeeMemberList::set_has_clanlevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckSeeMemberList::clear_has_clanlevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckSeeMemberList::clear_clanlevel() {
  clanlevel_ = 0;
  clear_has_clanlevel();
}
inline ::google::protobuf::int32 AckSeeMemberList::clanlevel() const {
  return clanlevel_;
}
inline void AckSeeMemberList::set_clanlevel(::google::protobuf::int32 value) {
  set_has_clanlevel();
  clanlevel_ = value;
}

// -------------------------------------------------------------------

// ClientReqClanEvent

// required int32 page = 1;
inline bool ClientReqClanEvent::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqClanEvent::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqClanEvent::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqClanEvent::clear_page() {
  page_ = 0;
  clear_has_page();
}
inline ::google::protobuf::int32 ClientReqClanEvent::page() const {
  return page_;
}
inline void ClientReqClanEvent::set_page(::google::protobuf::int32 value) {
  set_has_page();
  page_ = value;
}

// -------------------------------------------------------------------

// AckClanEvent

// repeated int32 type = 1;
inline int AckClanEvent::type_size() const {
  return type_.size();
}
inline void AckClanEvent::clear_type() {
  type_.Clear();
}
inline ::google::protobuf::int32 AckClanEvent::type(int index) const {
  return type_.Get(index);
}
inline void AckClanEvent::set_type(int index, ::google::protobuf::int32 value) {
  type_.Set(index, value);
}
inline void AckClanEvent::add_type(::google::protobuf::int32 value) {
  type_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AckClanEvent::type() const {
  return type_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AckClanEvent::mutable_type() {
  return &type_;
}

// repeated bytes content = 2;
inline int AckClanEvent::content_size() const {
  return content_.size();
}
inline void AckClanEvent::clear_content() {
  content_.Clear();
}
inline const ::std::string& AckClanEvent::content(int index) const {
  return content_.Get(index);
}
inline ::std::string* AckClanEvent::mutable_content(int index) {
  return content_.Mutable(index);
}
inline void AckClanEvent::set_content(int index, const ::std::string& value) {
  content_.Mutable(index)->assign(value);
}
inline void AckClanEvent::set_content(int index, const char* value) {
  content_.Mutable(index)->assign(value);
}
inline void AckClanEvent::set_content(int index, const void* value, size_t size) {
  content_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckClanEvent::add_content() {
  return content_.Add();
}
inline void AckClanEvent::add_content(const ::std::string& value) {
  content_.Add()->assign(value);
}
inline void AckClanEvent::add_content(const char* value) {
  content_.Add()->assign(value);
}
inline void AckClanEvent::add_content(const void* value, size_t size) {
  content_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AckClanEvent::content() const {
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AckClanEvent::mutable_content() {
  return &content_;
}

// -------------------------------------------------------------------

// JoinClan

// required double time = 1;
inline bool JoinClan::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinClan::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinClan::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinClan::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double JoinClan::time() const {
  return time_;
}
inline void JoinClan::set_time(double value) {
  set_has_time();
  time_ = value;
}

// optional string name = 2;
inline bool JoinClan::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinClan::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinClan::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinClan::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& JoinClan::name() const {
  return *name_;
}
inline void JoinClan::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void JoinClan::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void JoinClan::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JoinClan::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* JoinClan::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JoinClan::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LeaveClan

// required double time = 1;
inline bool LeaveClan::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveClan::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveClan::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveClan::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double LeaveClan::time() const {
  return time_;
}
inline void LeaveClan::set_time(double value) {
  set_has_time();
  time_ = value;
}

// optional string name = 2;
inline bool LeaveClan::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaveClan::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaveClan::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaveClan::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LeaveClan::name() const {
  return *name_;
}
inline void LeaveClan::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LeaveClan::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LeaveClan::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaveClan::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LeaveClan::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LeaveClan::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClanMemberKilled

// required double time = 1;
inline bool ClanMemberKilled::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanMemberKilled::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanMemberKilled::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanMemberKilled::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double ClanMemberKilled::time() const {
  return time_;
}
inline void ClanMemberKilled::set_time(double value) {
  set_has_time();
  time_ = value;
}

// optional string name = 2;
inline bool ClanMemberKilled::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanMemberKilled::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanMemberKilled::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanMemberKilled::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClanMemberKilled::name() const {
  return *name_;
}
inline void ClanMemberKilled::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanMemberKilled::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanMemberKilled::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanMemberKilled::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClanMemberKilled::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanMemberKilled::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 mapid = 3;
inline bool ClanMemberKilled::has_mapid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanMemberKilled::set_has_mapid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanMemberKilled::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanMemberKilled::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 ClanMemberKilled::mapid() const {
  return mapid_;
}
inline void ClanMemberKilled::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
}

// optional string killer = 4;
inline bool ClanMemberKilled::has_killer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanMemberKilled::set_has_killer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanMemberKilled::clear_has_killer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanMemberKilled::clear_killer() {
  if (killer_ != &::google::protobuf::internal::kEmptyString) {
    killer_->clear();
  }
  clear_has_killer();
}
inline const ::std::string& ClanMemberKilled::killer() const {
  return *killer_;
}
inline void ClanMemberKilled::set_killer(const ::std::string& value) {
  set_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    killer_ = new ::std::string;
  }
  killer_->assign(value);
}
inline void ClanMemberKilled::set_killer(const char* value) {
  set_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    killer_ = new ::std::string;
  }
  killer_->assign(value);
}
inline void ClanMemberKilled::set_killer(const char* value, size_t size) {
  set_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    killer_ = new ::std::string;
  }
  killer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanMemberKilled::mutable_killer() {
  set_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    killer_ = new ::std::string;
  }
  return killer_;
}
inline ::std::string* ClanMemberKilled::release_killer() {
  clear_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = killer_;
    killer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanMemberKilled::set_allocated_killer(::std::string* killer) {
  if (killer_ != &::google::protobuf::internal::kEmptyString) {
    delete killer_;
  }
  if (killer) {
    set_has_killer();
    killer_ = killer;
  } else {
    clear_has_killer();
    killer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SynchClanEventToWS

// required int64 charid = 1;
inline bool SynchClanEventToWS::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SynchClanEventToWS::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SynchClanEventToWS::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SynchClanEventToWS::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 SynchClanEventToWS::charid() const {
  return charid_;
}
inline void SynchClanEventToWS::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// required double time = 2;
inline bool SynchClanEventToWS::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SynchClanEventToWS::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SynchClanEventToWS::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SynchClanEventToWS::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double SynchClanEventToWS::time() const {
  return time_;
}
inline void SynchClanEventToWS::set_time(double value) {
  set_has_time();
  time_ = value;
}

// optional string killer = 3;
inline bool SynchClanEventToWS::has_killer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SynchClanEventToWS::set_has_killer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SynchClanEventToWS::clear_has_killer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SynchClanEventToWS::clear_killer() {
  if (killer_ != &::google::protobuf::internal::kEmptyString) {
    killer_->clear();
  }
  clear_has_killer();
}
inline const ::std::string& SynchClanEventToWS::killer() const {
  return *killer_;
}
inline void SynchClanEventToWS::set_killer(const ::std::string& value) {
  set_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    killer_ = new ::std::string;
  }
  killer_->assign(value);
}
inline void SynchClanEventToWS::set_killer(const char* value) {
  set_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    killer_ = new ::std::string;
  }
  killer_->assign(value);
}
inline void SynchClanEventToWS::set_killer(const char* value, size_t size) {
  set_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    killer_ = new ::std::string;
  }
  killer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SynchClanEventToWS::mutable_killer() {
  set_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    killer_ = new ::std::string;
  }
  return killer_;
}
inline ::std::string* SynchClanEventToWS::release_killer() {
  clear_has_killer();
  if (killer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = killer_;
    killer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SynchClanEventToWS::set_allocated_killer(::std::string* killer) {
  if (killer_ != &::google::protobuf::internal::kEmptyString) {
    delete killer_;
  }
  if (killer) {
    set_has_killer();
    killer_ = killer;
  } else {
    clear_has_killer();
    killer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MemberContri

// required double time = 1;
inline bool MemberContri::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemberContri::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemberContri::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemberContri::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double MemberContri::time() const {
  return time_;
}
inline void MemberContri::set_time(double value) {
  set_has_time();
  time_ = value;
}

// optional string name = 2;
inline bool MemberContri::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemberContri::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemberContri::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemberContri::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MemberContri::name() const {
  return *name_;
}
inline void MemberContri::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MemberContri::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MemberContri::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MemberContri::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MemberContri::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MemberContri::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 golden = 3;
inline bool MemberContri::has_golden() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemberContri::set_has_golden() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemberContri::clear_has_golden() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemberContri::clear_golden() {
  golden_ = 0;
  clear_has_golden();
}
inline ::google::protobuf::int32 MemberContri::golden() const {
  return golden_;
}
inline void MemberContri::set_golden(::google::protobuf::int32 value) {
  set_has_golden();
  golden_ = value;
}

// optional int32 money = 4;
inline bool MemberContri::has_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MemberContri::set_has_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MemberContri::clear_has_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MemberContri::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 MemberContri::money() const {
  return money_;
}
inline void MemberContri::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 contri = 5;
inline bool MemberContri::has_contri() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MemberContri::set_has_contri() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MemberContri::clear_has_contri() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MemberContri::clear_contri() {
  contri_ = 0;
  clear_has_contri();
}
inline ::google::protobuf::int32 MemberContri::contri() const {
  return contri_;
}
inline void MemberContri::set_contri(::google::protobuf::int32 value) {
  set_has_contri();
  contri_ = value;
}

// -------------------------------------------------------------------

// JobChange

// required double time = 1;
inline bool JobChange::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JobChange::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JobChange::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JobChange::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double JobChange::time() const {
  return time_;
}
inline void JobChange::set_time(double value) {
  set_has_time();
  time_ = value;
}

// optional string bname = 2;
inline bool JobChange::has_bname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JobChange::set_has_bname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JobChange::clear_has_bname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JobChange::clear_bname() {
  if (bname_ != &::google::protobuf::internal::kEmptyString) {
    bname_->clear();
  }
  clear_has_bname();
}
inline const ::std::string& JobChange::bname() const {
  return *bname_;
}
inline void JobChange::set_bname(const ::std::string& value) {
  set_has_bname();
  if (bname_ == &::google::protobuf::internal::kEmptyString) {
    bname_ = new ::std::string;
  }
  bname_->assign(value);
}
inline void JobChange::set_bname(const char* value) {
  set_has_bname();
  if (bname_ == &::google::protobuf::internal::kEmptyString) {
    bname_ = new ::std::string;
  }
  bname_->assign(value);
}
inline void JobChange::set_bname(const char* value, size_t size) {
  set_has_bname();
  if (bname_ == &::google::protobuf::internal::kEmptyString) {
    bname_ = new ::std::string;
  }
  bname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobChange::mutable_bname() {
  set_has_bname();
  if (bname_ == &::google::protobuf::internal::kEmptyString) {
    bname_ = new ::std::string;
  }
  return bname_;
}
inline ::std::string* JobChange::release_bname() {
  clear_has_bname();
  if (bname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bname_;
    bname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JobChange::set_allocated_bname(::std::string* bname) {
  if (bname_ != &::google::protobuf::internal::kEmptyString) {
    delete bname_;
  }
  if (bname) {
    set_has_bname();
    bname_ = bname;
  } else {
    clear_has_bname();
    bname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ename = 3;
inline bool JobChange::has_ename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JobChange::set_has_ename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JobChange::clear_has_ename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JobChange::clear_ename() {
  if (ename_ != &::google::protobuf::internal::kEmptyString) {
    ename_->clear();
  }
  clear_has_ename();
}
inline const ::std::string& JobChange::ename() const {
  return *ename_;
}
inline void JobChange::set_ename(const ::std::string& value) {
  set_has_ename();
  if (ename_ == &::google::protobuf::internal::kEmptyString) {
    ename_ = new ::std::string;
  }
  ename_->assign(value);
}
inline void JobChange::set_ename(const char* value) {
  set_has_ename();
  if (ename_ == &::google::protobuf::internal::kEmptyString) {
    ename_ = new ::std::string;
  }
  ename_->assign(value);
}
inline void JobChange::set_ename(const char* value, size_t size) {
  set_has_ename();
  if (ename_ == &::google::protobuf::internal::kEmptyString) {
    ename_ = new ::std::string;
  }
  ename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* JobChange::mutable_ename() {
  set_has_ename();
  if (ename_ == &::google::protobuf::internal::kEmptyString) {
    ename_ = new ::std::string;
  }
  return ename_;
}
inline ::std::string* JobChange::release_ename() {
  clear_has_ename();
  if (ename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ename_;
    ename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void JobChange::set_allocated_ename(::std::string* ename) {
  if (ename_ != &::google::protobuf::internal::kEmptyString) {
    delete ename_;
  }
  if (ename) {
    set_has_ename();
    ename_ = ename;
  } else {
    clear_has_ename();
    ename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 job = 4;
inline bool JobChange::has_job() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JobChange::set_has_job() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JobChange::clear_has_job() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JobChange::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 JobChange::job() const {
  return job_;
}
inline void JobChange::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
}

// -------------------------------------------------------------------

// ClanUpdate

// required double time = 1;
inline bool ClanUpdate::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanUpdate::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanUpdate::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanUpdate::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double ClanUpdate::time() const {
  return time_;
}
inline void ClanUpdate::set_time(double value) {
  set_has_time();
  time_ = value;
}

// optional string name = 2;
inline bool ClanUpdate::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanUpdate::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanUpdate::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanUpdate::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClanUpdate::name() const {
  return *name_;
}
inline void ClanUpdate::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanUpdate::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanUpdate::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanUpdate::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClanUpdate::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanUpdate::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 lv = 3;
inline bool ClanUpdate::has_lv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanUpdate::set_has_lv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanUpdate::clear_has_lv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanUpdate::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 ClanUpdate::lv() const {
  return lv_;
}
inline void ClanUpdate::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// optional int32 count = 4;
inline bool ClanUpdate::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanUpdate::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanUpdate::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanUpdate::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 ClanUpdate::count() const {
  return count_;
}
inline void ClanUpdate::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// ClanCitryHold

// required double time = 1;
inline bool ClanCitryHold::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanCitryHold::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanCitryHold::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanCitryHold::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double ClanCitryHold::time() const {
  return time_;
}
inline void ClanCitryHold::set_time(double value) {
  set_has_time();
  time_ = value;
}

// optional int32 cityid = 2;
inline bool ClanCitryHold::has_cityid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanCitryHold::set_has_cityid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanCitryHold::clear_has_cityid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanCitryHold::clear_cityid() {
  cityid_ = 0;
  clear_has_cityid();
}
inline ::google::protobuf::int32 ClanCitryHold::cityid() const {
  return cityid_;
}
inline void ClanCitryHold::set_cityid(::google::protobuf::int32 value) {
  set_has_cityid();
  cityid_ = value;
}

// optional string clan = 3;
inline bool ClanCitryHold::has_clan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanCitryHold::set_has_clan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanCitryHold::clear_has_clan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanCitryHold::clear_clan() {
  if (clan_ != &::google::protobuf::internal::kEmptyString) {
    clan_->clear();
  }
  clear_has_clan();
}
inline const ::std::string& ClanCitryHold::clan() const {
  return *clan_;
}
inline void ClanCitryHold::set_clan(const ::std::string& value) {
  set_has_clan();
  if (clan_ == &::google::protobuf::internal::kEmptyString) {
    clan_ = new ::std::string;
  }
  clan_->assign(value);
}
inline void ClanCitryHold::set_clan(const char* value) {
  set_has_clan();
  if (clan_ == &::google::protobuf::internal::kEmptyString) {
    clan_ = new ::std::string;
  }
  clan_->assign(value);
}
inline void ClanCitryHold::set_clan(const char* value, size_t size) {
  set_has_clan();
  if (clan_ == &::google::protobuf::internal::kEmptyString) {
    clan_ = new ::std::string;
  }
  clan_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanCitryHold::mutable_clan() {
  set_has_clan();
  if (clan_ == &::google::protobuf::internal::kEmptyString) {
    clan_ = new ::std::string;
  }
  return clan_;
}
inline ::std::string* ClanCitryHold::release_clan() {
  clear_has_clan();
  if (clan_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clan_;
    clan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanCitryHold::set_allocated_clan(::std::string* clan) {
  if (clan_ != &::google::protobuf::internal::kEmptyString) {
    delete clan_;
  }
  if (clan) {
    set_has_clan();
    clan_ = clan;
  } else {
    clear_has_clan();
    clan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClanPaidEvent

// required double time = 1;
inline bool ClanPaidEvent::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanPaidEvent::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanPaidEvent::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanPaidEvent::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double ClanPaidEvent::time() const {
  return time_;
}
inline void ClanPaidEvent::set_time(double value) {
  set_has_time();
  time_ = value;
}

// optional int32 id = 2;
inline bool ClanPaidEvent::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanPaidEvent::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanPaidEvent::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanPaidEvent::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ClanPaidEvent::id() const {
  return id_;
}
inline void ClanPaidEvent::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 money = 3;
inline bool ClanPaidEvent::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanPaidEvent::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanPaidEvent::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanPaidEvent::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 ClanPaidEvent::money() const {
  return money_;
}
inline void ClanPaidEvent::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// -------------------------------------------------------------------

// ClientReqClanRequestList

// required int32 page = 1;
inline bool ClientReqClanRequestList::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqClanRequestList::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqClanRequestList::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqClanRequestList::clear_page() {
  page_ = 0;
  clear_has_page();
}
inline ::google::protobuf::int32 ClientReqClanRequestList::page() const {
  return page_;
}
inline void ClientReqClanRequestList::set_page(::google::protobuf::int32 value) {
  set_has_page();
  page_ = value;
}

// -------------------------------------------------------------------

// AckClanRequestList

// repeated .ClanPackage.ClanRequestList list = 2;
inline int AckClanRequestList::list_size() const {
  return list_.size();
}
inline void AckClanRequestList::clear_list() {
  list_.Clear();
}
inline const ::ClanPackage::ClanRequestList& AckClanRequestList::list(int index) const {
  return list_.Get(index);
}
inline ::ClanPackage::ClanRequestList* AckClanRequestList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::ClanPackage::ClanRequestList* AckClanRequestList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanRequestList >&
AckClanRequestList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanRequestList >*
AckClanRequestList::mutable_list() {
  return &list_;
}

// optional bool isend = 3;
inline bool AckClanRequestList::has_isend() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckClanRequestList::set_has_isend() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckClanRequestList::clear_has_isend() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckClanRequestList::clear_isend() {
  isend_ = false;
  clear_has_isend();
}
inline bool AckClanRequestList::isend() const {
  return isend_;
}
inline void AckClanRequestList::set_isend(bool value) {
  set_has_isend();
  isend_ = value;
}

// -------------------------------------------------------------------

// ClanRequestList

// required int64 charid = 1;
inline bool ClanRequestList::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanRequestList::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanRequestList::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanRequestList::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 ClanRequestList::charid() const {
  return charid_;
}
inline void ClanRequestList::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// optional string name = 2;
inline bool ClanRequestList::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanRequestList::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanRequestList::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanRequestList::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClanRequestList::name() const {
  return *name_;
}
inline void ClanRequestList::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanRequestList::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanRequestList::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanRequestList::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClanRequestList::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanRequestList::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 lv = 3;
inline bool ClanRequestList::has_lv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanRequestList::set_has_lv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanRequestList::clear_has_lv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanRequestList::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 ClanRequestList::lv() const {
  return lv_;
}
inline void ClanRequestList::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// optional int32 profession = 4;
inline bool ClanRequestList::has_profession() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanRequestList::set_has_profession() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanRequestList::clear_has_profession() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanRequestList::clear_profession() {
  profession_ = 0;
  clear_has_profession();
}
inline ::google::protobuf::int32 ClanRequestList::profession() const {
  return profession_;
}
inline void ClanRequestList::set_profession(::google::protobuf::int32 value) {
  set_has_profession();
  profession_ = value;
}

// optional int32 fight = 5;
inline bool ClanRequestList::has_fight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClanRequestList::set_has_fight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClanRequestList::clear_has_fight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClanRequestList::clear_fight() {
  fight_ = 0;
  clear_has_fight();
}
inline ::google::protobuf::int32 ClanRequestList::fight() const {
  return fight_;
}
inline void ClanRequestList::set_fight(::google::protobuf::int32 value) {
  set_has_fight();
  fight_ = value;
}

// optional int32 vip = 6;
inline bool ClanRequestList::has_vip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClanRequestList::set_has_vip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClanRequestList::clear_has_vip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClanRequestList::clear_vip() {
  vip_ = 0;
  clear_has_vip();
}
inline ::google::protobuf::int32 ClanRequestList::vip() const {
  return vip_;
}
inline void ClanRequestList::set_vip(::google::protobuf::int32 value) {
  set_has_vip();
  vip_ = value;
}

// optional int32 sex = 7;
inline bool ClanRequestList::has_sex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClanRequestList::set_has_sex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClanRequestList::clear_has_sex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClanRequestList::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 ClanRequestList::sex() const {
  return sex_;
}
inline void ClanRequestList::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// -------------------------------------------------------------------

// ClientReqClanContriList

// required int32 page = 1;
inline bool ClientReqClanContriList::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqClanContriList::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqClanContriList::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqClanContriList::clear_page() {
  page_ = 0;
  clear_has_page();
}
inline ::google::protobuf::int32 ClientReqClanContriList::page() const {
  return page_;
}
inline void ClientReqClanContriList::set_page(::google::protobuf::int32 value) {
  set_has_page();
  page_ = value;
}

// -------------------------------------------------------------------

// AckClanContriList

// repeated .ClanPackage.ClanContriList list = 1;
inline int AckClanContriList::list_size() const {
  return list_.size();
}
inline void AckClanContriList::clear_list() {
  list_.Clear();
}
inline const ::ClanPackage::ClanContriList& AckClanContriList::list(int index) const {
  return list_.Get(index);
}
inline ::ClanPackage::ClanContriList* AckClanContriList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::ClanPackage::ClanContriList* AckClanContriList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanContriList >&
AckClanContriList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanContriList >*
AckClanContriList::mutable_list() {
  return &list_;
}

// optional bool isend = 2;
inline bool AckClanContriList::has_isend() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckClanContriList::set_has_isend() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckClanContriList::clear_has_isend() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckClanContriList::clear_isend() {
  isend_ = false;
  clear_has_isend();
}
inline bool AckClanContriList::isend() const {
  return isend_;
}
inline void AckClanContriList::set_isend(bool value) {
  set_has_isend();
  isend_ = value;
}

// -------------------------------------------------------------------

// ClanContriList

// required int64 charid = 1;
inline bool ClanContriList::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanContriList::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanContriList::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanContriList::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 ClanContriList::charid() const {
  return charid_;
}
inline void ClanContriList::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// optional string name = 2;
inline bool ClanContriList::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanContriList::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanContriList::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanContriList::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClanContriList::name() const {
  return *name_;
}
inline void ClanContriList::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanContriList::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanContriList::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanContriList::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClanContriList::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanContriList::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 lv = 3;
inline bool ClanContriList::has_lv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanContriList::set_has_lv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanContriList::clear_has_lv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanContriList::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 ClanContriList::lv() const {
  return lv_;
}
inline void ClanContriList::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// optional int32 money = 4;
inline bool ClanContriList::has_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanContriList::set_has_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanContriList::clear_has_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanContriList::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 ClanContriList::money() const {
  return money_;
}
inline void ClanContriList::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 golden = 5;
inline bool ClanContriList::has_golden() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClanContriList::set_has_golden() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClanContriList::clear_has_golden() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClanContriList::clear_golden() {
  golden_ = 0;
  clear_has_golden();
}
inline ::google::protobuf::int32 ClanContriList::golden() const {
  return golden_;
}
inline void ClanContriList::set_golden(::google::protobuf::int32 value) {
  set_has_golden();
  golden_ = value;
}

// optional int32 contri = 6;
inline bool ClanContriList::has_contri() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClanContriList::set_has_contri() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClanContriList::clear_has_contri() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClanContriList::clear_contri() {
  contri_ = 0;
  clear_has_contri();
}
inline ::google::protobuf::int32 ClanContriList::contri() const {
  return contri_;
}
inline void ClanContriList::set_contri(::google::protobuf::int32 value) {
  set_has_contri();
  contri_ = value;
}

// optional int32 contrimax = 7;
inline bool ClanContriList::has_contrimax() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClanContriList::set_has_contrimax() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClanContriList::clear_has_contrimax() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClanContriList::clear_contrimax() {
  contrimax_ = 0;
  clear_has_contrimax();
}
inline ::google::protobuf::int32 ClanContriList::contrimax() const {
  return contrimax_;
}
inline void ClanContriList::set_contrimax(::google::protobuf::int32 value) {
  set_has_contrimax();
  contrimax_ = value;
}

// optional int32 viplv = 8;
inline bool ClanContriList::has_viplv() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClanContriList::set_has_viplv() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClanContriList::clear_has_viplv() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClanContriList::clear_viplv() {
  viplv_ = 0;
  clear_has_viplv();
}
inline ::google::protobuf::int32 ClanContriList::viplv() const {
  return viplv_;
}
inline void ClanContriList::set_viplv(::google::protobuf::int32 value) {
  set_has_viplv();
  viplv_ = value;
}

// -------------------------------------------------------------------

// ClientReqJoinClan

// required uint32 id = 1;
inline bool ClientReqJoinClan::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqJoinClan::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqJoinClan::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqJoinClan::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ClientReqJoinClan::id() const {
  return id_;
}
inline void ClientReqJoinClan::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// AckJoinClan

// required int32 ret = 1;
inline bool AckJoinClan::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckJoinClan::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckJoinClan::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckJoinClan::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 AckJoinClan::ret() const {
  return ret_;
}
inline void AckJoinClan::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 clanID = 2;
inline bool AckJoinClan::has_clanid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckJoinClan::set_has_clanid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckJoinClan::clear_has_clanid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckJoinClan::clear_clanid() {
  clanid_ = 0;
  clear_has_clanid();
}
inline ::google::protobuf::int32 AckJoinClan::clanid() const {
  return clanid_;
}
inline void AckJoinClan::set_clanid(::google::protobuf::int32 value) {
  set_has_clanid();
  clanid_ = value;
}

// optional .ClanPackage.AckClanBase info = 3;
inline bool AckJoinClan::has_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckJoinClan::set_has_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckJoinClan::clear_has_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckJoinClan::clear_info() {
  if (info_ != NULL) info_->::ClanPackage::AckClanBase::Clear();
  clear_has_info();
}
inline const ::ClanPackage::AckClanBase& AckJoinClan::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::ClanPackage::AckClanBase* AckJoinClan::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::ClanPackage::AckClanBase;
  return info_;
}
inline ::ClanPackage::AckClanBase* AckJoinClan::release_info() {
  clear_has_info();
  ::ClanPackage::AckClanBase* temp = info_;
  info_ = NULL;
  return temp;
}
inline void AckJoinClan::set_allocated_info(::ClanPackage::AckClanBase* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// ClientAlterTitle

// required string title = 1;
inline bool ClientAlterTitle::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientAlterTitle::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientAlterTitle::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientAlterTitle::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& ClientAlterTitle::title() const {
  return *title_;
}
inline void ClientAlterTitle::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void ClientAlterTitle::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void ClientAlterTitle::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientAlterTitle::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* ClientAlterTitle::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientAlterTitle::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientReqContri

// required int32 money = 1;
inline bool ClientReqContri::has_money() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqContri::set_has_money() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqContri::clear_has_money() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqContri::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 ClientReqContri::money() const {
  return money_;
}
inline void ClientReqContri::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// required int32 golden = 2;
inline bool ClientReqContri::has_golden() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientReqContri::set_has_golden() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientReqContri::clear_has_golden() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientReqContri::clear_golden() {
  golden_ = 0;
  clear_has_golden();
}
inline ::google::protobuf::int32 ClientReqContri::golden() const {
  return golden_;
}
inline void ClientReqContri::set_golden(::google::protobuf::int32 value) {
  set_has_golden();
  golden_ = value;
}

// -------------------------------------------------------------------

// AckContri

// required int32 ret = 1;
inline bool AckContri::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckContri::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckContri::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckContri::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 AckContri::ret() const {
  return ret_;
}
inline void AckContri::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 contri = 2;
inline bool AckContri::has_contri() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckContri::set_has_contri() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckContri::clear_has_contri() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckContri::clear_contri() {
  contri_ = 0;
  clear_has_contri();
}
inline ::google::protobuf::int32 AckContri::contri() const {
  return contri_;
}
inline void AckContri::set_contri(::google::protobuf::int32 value) {
  set_has_contri();
  contri_ = value;
}

// optional int32 money = 3;
inline bool AckContri::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckContri::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckContri::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckContri::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 AckContri::money() const {
  return money_;
}
inline void AckContri::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 golden = 4;
inline bool AckContri::has_golden() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckContri::set_has_golden() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckContri::clear_has_golden() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckContri::clear_golden() {
  golden_ = 0;
  clear_has_golden();
}
inline ::google::protobuf::int32 AckContri::golden() const {
  return golden_;
}
inline void AckContri::set_golden(::google::protobuf::int32 value) {
  set_has_golden();
  golden_ = value;
}

// -------------------------------------------------------------------

// AckUpdateLv

// required int32 ret = 1;
inline bool AckUpdateLv::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckUpdateLv::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckUpdateLv::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckUpdateLv::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 AckUpdateLv::ret() const {
  return ret_;
}
inline void AckUpdateLv::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 lv = 2;
inline bool AckUpdateLv::has_lv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckUpdateLv::set_has_lv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckUpdateLv::clear_has_lv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckUpdateLv::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 AckUpdateLv::lv() const {
  return lv_;
}
inline void AckUpdateLv::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// -------------------------------------------------------------------

// ClientChangeIcon

// required int32 icon = 1;
inline bool ClientChangeIcon::has_icon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientChangeIcon::set_has_icon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientChangeIcon::clear_has_icon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientChangeIcon::clear_icon() {
  icon_ = 0;
  clear_has_icon();
}
inline ::google::protobuf::int32 ClientChangeIcon::icon() const {
  return icon_;
}
inline void ClientChangeIcon::set_icon(::google::protobuf::int32 value) {
  set_has_icon();
  icon_ = value;
}

// -------------------------------------------------------------------

// AckClientChangeIcon

// required int32 success = 1;
inline bool AckClientChangeIcon::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckClientChangeIcon::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckClientChangeIcon::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckClientChangeIcon::clear_success() {
  success_ = 0;
  clear_has_success();
}
inline ::google::protobuf::int32 AckClientChangeIcon::success() const {
  return success_;
}
inline void AckClientChangeIcon::set_success(::google::protobuf::int32 value) {
  set_has_success();
  success_ = value;
}

// optional int32 icon = 2;
inline bool AckClientChangeIcon::has_icon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckClientChangeIcon::set_has_icon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckClientChangeIcon::clear_has_icon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckClientChangeIcon::clear_icon() {
  icon_ = 0;
  clear_has_icon();
}
inline ::google::protobuf::int32 AckClientChangeIcon::icon() const {
  return icon_;
}
inline void AckClientChangeIcon::set_icon(::google::protobuf::int32 value) {
  set_has_icon();
  icon_ = value;
}

// -------------------------------------------------------------------

// ClientReqGiveJob

// required int64 charid = 1;
inline bool ClientReqGiveJob::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqGiveJob::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqGiveJob::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqGiveJob::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 ClientReqGiveJob::charid() const {
  return charid_;
}
inline void ClientReqGiveJob::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// optional int32 job = 2;
inline bool ClientReqGiveJob::has_job() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientReqGiveJob::set_has_job() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientReqGiveJob::clear_has_job() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientReqGiveJob::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 ClientReqGiveJob::job() const {
  return job_;
}
inline void ClientReqGiveJob::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
}

// -------------------------------------------------------------------

// AckGiveJob

// required int32 ret = 1;
inline bool AckGiveJob::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckGiveJob::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckGiveJob::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckGiveJob::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 AckGiveJob::ret() const {
  return ret_;
}
inline void AckGiveJob::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 job = 2;
inline bool AckGiveJob::has_job() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckGiveJob::set_has_job() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckGiveJob::clear_has_job() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckGiveJob::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 AckGiveJob::job() const {
  return job_;
}
inline void AckGiveJob::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
}

// optional int64 charid = 3;
inline bool AckGiveJob::has_charid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckGiveJob::set_has_charid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckGiveJob::clear_has_charid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckGiveJob::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 AckGiveJob::charid() const {
  return charid_;
}
inline void AckGiveJob::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// -------------------------------------------------------------------

// ClientReqOutJob

// required int64 charid = 1;
inline bool ClientReqOutJob::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqOutJob::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqOutJob::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqOutJob::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 ClientReqOutJob::charid() const {
  return charid_;
}
inline void ClientReqOutJob::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// -------------------------------------------------------------------

// AckOutJob

// required int32 ret = 1;
inline bool AckOutJob::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckOutJob::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckOutJob::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckOutJob::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 AckOutJob::ret() const {
  return ret_;
}
inline void AckOutJob::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int64 charid = 2;
inline bool AckOutJob::has_charid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckOutJob::set_has_charid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckOutJob::clear_has_charid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckOutJob::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 AckOutJob::charid() const {
  return charid_;
}
inline void AckOutJob::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// -------------------------------------------------------------------

// ClientReqKickMember

// required int64 charid = 1;
inline bool ClientReqKickMember::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqKickMember::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqKickMember::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqKickMember::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 ClientReqKickMember::charid() const {
  return charid_;
}
inline void ClientReqKickMember::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// -------------------------------------------------------------------

// AckKickMember

// required int32 ret = 1;
inline bool AckKickMember::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckKickMember::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckKickMember::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckKickMember::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 AckKickMember::ret() const {
  return ret_;
}
inline void AckKickMember::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int64 charid = 2;
inline bool AckKickMember::has_charid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckKickMember::set_has_charid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckKickMember::clear_has_charid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckKickMember::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 AckKickMember::charid() const {
  return charid_;
}
inline void AckKickMember::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// -------------------------------------------------------------------

// ClientChangeJoinFlag

// required bool flag = 1;
inline bool ClientChangeJoinFlag::has_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientChangeJoinFlag::set_has_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientChangeJoinFlag::clear_has_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientChangeJoinFlag::clear_flag() {
  flag_ = false;
  clear_has_flag();
}
inline bool ClientChangeJoinFlag::flag() const {
  return flag_;
}
inline void ClientChangeJoinFlag::set_flag(bool value) {
  set_has_flag();
  flag_ = value;
}

// -------------------------------------------------------------------

// ClientReqJoinControl

// required bool type = 1;
inline bool ClientReqJoinControl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqJoinControl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqJoinControl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqJoinControl::clear_type() {
  type_ = false;
  clear_has_type();
}
inline bool ClientReqJoinControl::type() const {
  return type_;
}
inline void ClientReqJoinControl::set_type(bool value) {
  set_has_type();
  type_ = value;
}

// optional int64 charid = 2;
inline bool ClientReqJoinControl::has_charid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientReqJoinControl::set_has_charid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientReqJoinControl::clear_has_charid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientReqJoinControl::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 ClientReqJoinControl::charid() const {
  return charid_;
}
inline void ClientReqJoinControl::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// -------------------------------------------------------------------

// AckJoinControl

// required int32 ret = 1;
inline bool AckJoinControl::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckJoinControl::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckJoinControl::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckJoinControl::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 AckJoinControl::ret() const {
  return ret_;
}
inline void AckJoinControl::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int64 charid = 2;
inline bool AckJoinControl::has_charid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckJoinControl::set_has_charid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckJoinControl::clear_has_charid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckJoinControl::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 AckJoinControl::charid() const {
  return charid_;
}
inline void AckJoinControl::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// optional bool type = 3;
inline bool AckJoinControl::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckJoinControl::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckJoinControl::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckJoinControl::clear_type() {
  type_ = false;
  clear_has_type();
}
inline bool AckJoinControl::type() const {
  return type_;
}
inline void AckJoinControl::set_type(bool value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ClientReqAskJoin

// required int64 charid = 1;
inline bool ClientReqAskJoin::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqAskJoin::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqAskJoin::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqAskJoin::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 ClientReqAskJoin::charid() const {
  return charid_;
}
inline void ClientReqAskJoin::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// -------------------------------------------------------------------

// AckAskJoin

// required int32 ret = 1;
inline bool AckAskJoin::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckAskJoin::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckAskJoin::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckAskJoin::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 AckAskJoin::ret() const {
  return ret_;
}
inline void AckAskJoin::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// -------------------------------------------------------------------

// AskClientJoin

// required uint32 id = 1;
inline bool AskClientJoin::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AskClientJoin::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AskClientJoin::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AskClientJoin::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 AskClientJoin::id() const {
  return id_;
}
inline void AskClientJoin::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool AskClientJoin::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AskClientJoin::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AskClientJoin::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AskClientJoin::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AskClientJoin::name() const {
  return *name_;
}
inline void AskClientJoin::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AskClientJoin::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AskClientJoin::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AskClientJoin::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AskClientJoin::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AskClientJoin::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string clanname = 3;
inline bool AskClientJoin::has_clanname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AskClientJoin::set_has_clanname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AskClientJoin::clear_has_clanname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AskClientJoin::clear_clanname() {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    clanname_->clear();
  }
  clear_has_clanname();
}
inline const ::std::string& AskClientJoin::clanname() const {
  return *clanname_;
}
inline void AskClientJoin::set_clanname(const ::std::string& value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void AskClientJoin::set_clanname(const char* value) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(value);
}
inline void AskClientJoin::set_clanname(const char* value, size_t size) {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  clanname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AskClientJoin::mutable_clanname() {
  set_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    clanname_ = new ::std::string;
  }
  return clanname_;
}
inline ::std::string* AskClientJoin::release_clanname() {
  clear_has_clanname();
  if (clanname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clanname_;
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AskClientJoin::set_allocated_clanname(::std::string* clanname) {
  if (clanname_ != &::google::protobuf::internal::kEmptyString) {
    delete clanname_;
  }
  if (clanname) {
    set_has_clanname();
    clanname_ = clanname;
  } else {
    clear_has_clanname();
    clanname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClientReqRefuseOrJoin

// required bool type = 1;
inline bool ClientReqRefuseOrJoin::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqRefuseOrJoin::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqRefuseOrJoin::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqRefuseOrJoin::clear_type() {
  type_ = false;
  clear_has_type();
}
inline bool ClientReqRefuseOrJoin::type() const {
  return type_;
}
inline void ClientReqRefuseOrJoin::set_type(bool value) {
  set_has_type();
  type_ = value;
}

// optional uint32 id = 2;
inline bool ClientReqRefuseOrJoin::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientReqRefuseOrJoin::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientReqRefuseOrJoin::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientReqRefuseOrJoin::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ClientReqRefuseOrJoin::id() const {
  return id_;
}
inline void ClientReqRefuseOrJoin::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// AckRefuseOrJoin

// required int32 ret = 1;
inline bool AckRefuseOrJoin::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckRefuseOrJoin::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckRefuseOrJoin::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckRefuseOrJoin::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 AckRefuseOrJoin::ret() const {
  return ret_;
}
inline void AckRefuseOrJoin::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional .ClanPackage.AckClanBase info = 2;
inline bool AckRefuseOrJoin::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckRefuseOrJoin::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckRefuseOrJoin::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckRefuseOrJoin::clear_info() {
  if (info_ != NULL) info_->::ClanPackage::AckClanBase::Clear();
  clear_has_info();
}
inline const ::ClanPackage::AckClanBase& AckRefuseOrJoin::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::ClanPackage::AckClanBase* AckRefuseOrJoin::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::ClanPackage::AckClanBase;
  return info_;
}
inline ::ClanPackage::AckClanBase* AckRefuseOrJoin::release_info() {
  clear_has_info();
  ::ClanPackage::AckClanBase* temp = info_;
  info_ = NULL;
  return temp;
}
inline void AckRefuseOrJoin::set_allocated_info(::ClanPackage::AckClanBase* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// SynchAttrToGM

// required int64 charid = 1;
inline bool SynchAttrToGM::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SynchAttrToGM::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SynchAttrToGM::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SynchAttrToGM::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 SynchAttrToGM::charid() const {
  return charid_;
}
inline void SynchAttrToGM::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// optional int32 blv = 2;
inline bool SynchAttrToGM::has_blv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SynchAttrToGM::set_has_blv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SynchAttrToGM::clear_has_blv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SynchAttrToGM::clear_blv() {
  blv_ = 0;
  clear_has_blv();
}
inline ::google::protobuf::int32 SynchAttrToGM::blv() const {
  return blv_;
}
inline void SynchAttrToGM::set_blv(::google::protobuf::int32 value) {
  set_has_blv();
  blv_ = value;
}

// optional int32 elv = 3;
inline bool SynchAttrToGM::has_elv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SynchAttrToGM::set_has_elv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SynchAttrToGM::clear_has_elv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SynchAttrToGM::clear_elv() {
  elv_ = 0;
  clear_has_elv();
}
inline ::google::protobuf::int32 SynchAttrToGM::elv() const {
  return elv_;
}
inline void SynchAttrToGM::set_elv(::google::protobuf::int32 value) {
  set_has_elv();
  elv_ = value;
}

// optional uint32 id = 4;
inline bool SynchAttrToGM::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SynchAttrToGM::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SynchAttrToGM::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SynchAttrToGM::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 SynchAttrToGM::id() const {
  return id_;
}
inline void SynchAttrToGM::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 5;
inline bool SynchAttrToGM::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SynchAttrToGM::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SynchAttrToGM::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SynchAttrToGM::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SynchAttrToGM::name() const {
  return *name_;
}
inline void SynchAttrToGM::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SynchAttrToGM::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SynchAttrToGM::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SynchAttrToGM::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SynchAttrToGM::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SynchAttrToGM::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 job = 6;
inline bool SynchAttrToGM::has_job() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SynchAttrToGM::set_has_job() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SynchAttrToGM::clear_has_job() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SynchAttrToGM::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 SynchAttrToGM::job() const {
  return job_;
}
inline void SynchAttrToGM::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
}

// optional int32 type = 7 [default = 0];
inline bool SynchAttrToGM::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SynchAttrToGM::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SynchAttrToGM::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SynchAttrToGM::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SynchAttrToGM::type() const {
  return type_;
}
inline void SynchAttrToGM::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 clanicon = 8;
inline bool SynchAttrToGM::has_clanicon() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SynchAttrToGM::set_has_clanicon() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SynchAttrToGM::clear_has_clanicon() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SynchAttrToGM::clear_clanicon() {
  clanicon_ = 0;
  clear_has_clanicon();
}
inline ::google::protobuf::int32 SynchAttrToGM::clanicon() const {
  return clanicon_;
}
inline void SynchAttrToGM::set_clanicon(::google::protobuf::int32 value) {
  set_has_clanicon();
  clanicon_ = value;
}

// optional int32 clanContribution = 9;
inline bool SynchAttrToGM::has_clancontribution() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SynchAttrToGM::set_has_clancontribution() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SynchAttrToGM::clear_has_clancontribution() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SynchAttrToGM::clear_clancontribution() {
  clancontribution_ = 0;
  clear_has_clancontribution();
}
inline ::google::protobuf::int32 SynchAttrToGM::clancontribution() const {
  return clancontribution_;
}
inline void SynchAttrToGM::set_clancontribution(::google::protobuf::int32 value) {
  set_has_clancontribution();
  clancontribution_ = value;
}

// -------------------------------------------------------------------

// WorldReqGiveCost

// required int64 charid = 1;
inline bool WorldReqGiveCost::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WorldReqGiveCost::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WorldReqGiveCost::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WorldReqGiveCost::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 WorldReqGiveCost::charid() const {
  return charid_;
}
inline void WorldReqGiveCost::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// optional uint32 money = 2;
inline bool WorldReqGiveCost::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WorldReqGiveCost::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WorldReqGiveCost::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WorldReqGiveCost::clear_money() {
  money_ = 0u;
  clear_has_money();
}
inline ::google::protobuf::uint32 WorldReqGiveCost::money() const {
  return money_;
}
inline void WorldReqGiveCost::set_money(::google::protobuf::uint32 value) {
  set_has_money();
  money_ = value;
}

// optional uint32 golden = 3;
inline bool WorldReqGiveCost::has_golden() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WorldReqGiveCost::set_has_golden() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WorldReqGiveCost::clear_has_golden() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WorldReqGiveCost::clear_golden() {
  golden_ = 0u;
  clear_has_golden();
}
inline ::google::protobuf::uint32 WorldReqGiveCost::golden() const {
  return golden_;
}
inline void WorldReqGiveCost::set_golden(::google::protobuf::uint32 value) {
  set_has_golden();
  golden_ = value;
}

// -------------------------------------------------------------------

// AckGiveCost

// required int64 charid = 1;
inline bool AckGiveCost::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckGiveCost::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckGiveCost::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckGiveCost::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 AckGiveCost::charid() const {
  return charid_;
}
inline void AckGiveCost::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// optional int32 ret = 2;
inline bool AckGiveCost::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckGiveCost::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckGiveCost::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckGiveCost::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 AckGiveCost::ret() const {
  return ret_;
}
inline void AckGiveCost::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional uint32 money = 3;
inline bool AckGiveCost::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckGiveCost::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckGiveCost::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckGiveCost::clear_money() {
  money_ = 0u;
  clear_has_money();
}
inline ::google::protobuf::uint32 AckGiveCost::money() const {
  return money_;
}
inline void AckGiveCost::set_money(::google::protobuf::uint32 value) {
  set_has_money();
  money_ = value;
}

// optional uint32 golden = 4;
inline bool AckGiveCost::has_golden() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AckGiveCost::set_has_golden() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AckGiveCost::clear_has_golden() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AckGiveCost::clear_golden() {
  golden_ = 0u;
  clear_has_golden();
}
inline ::google::protobuf::uint32 AckGiveCost::golden() const {
  return golden_;
}
inline void AckGiveCost::set_golden(::google::protobuf::uint32 value) {
  set_has_golden();
  golden_ = value;
}

// -------------------------------------------------------------------

// ClanNameChange

// required string name = 1;
inline bool ClanNameChange::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanNameChange::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanNameChange::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanNameChange::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClanNameChange::name() const {
  return *name_;
}
inline void ClanNameChange::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanNameChange::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanNameChange::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanNameChange::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClanNameChange::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanNameChange::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 key = 2;
inline bool ClanNameChange::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanNameChange::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanNameChange::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanNameChange::clear_key() {
  key_ = 0;
  clear_has_key();
}
inline ::google::protobuf::int32 ClanNameChange::key() const {
  return key_;
}
inline void ClanNameChange::set_key(::google::protobuf::int32 value) {
  set_has_key();
  key_ = value;
}

// -------------------------------------------------------------------

// ClanLimit

// repeated .ClanPackage.ClanGoods clanGoods = 1;
inline int ClanLimit::clangoods_size() const {
  return clangoods_.size();
}
inline void ClanLimit::clear_clangoods() {
  clangoods_.Clear();
}
inline const ::ClanPackage::ClanGoods& ClanLimit::clangoods(int index) const {
  return clangoods_.Get(index);
}
inline ::ClanPackage::ClanGoods* ClanLimit::mutable_clangoods(int index) {
  return clangoods_.Mutable(index);
}
inline ::ClanPackage::ClanGoods* ClanLimit::add_clangoods() {
  return clangoods_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanGoods >&
ClanLimit::clangoods() const {
  return clangoods_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanGoods >*
ClanLimit::mutable_clangoods() {
  return &clangoods_;
}

// -------------------------------------------------------------------

// ClanGoods

// required int32 itemid = 1;
inline bool ClanGoods::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanGoods::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanGoods::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanGoods::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 ClanGoods::itemid() const {
  return itemid_;
}
inline void ClanGoods::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 limit = 2;
inline bool ClanGoods::has_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanGoods::set_has_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanGoods::clear_has_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanGoods::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 ClanGoods::limit() const {
  return limit_;
}
inline void ClanGoods::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// -------------------------------------------------------------------

// ClanShop

// required int32 ret = 1;
inline bool ClanShop::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanShop::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanShop::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanShop::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 ClanShop::ret() const {
  return ret_;
}
inline void ClanShop::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 ID = 2;
inline bool ClanShop::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanShop::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanShop::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanShop::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ClanShop::id() const {
  return id_;
}
inline void ClanShop::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 surplusCounts = 3;
inline bool ClanShop::has_surpluscounts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanShop::set_has_surpluscounts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanShop::clear_has_surpluscounts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanShop::clear_surpluscounts() {
  surpluscounts_ = 0;
  clear_has_surpluscounts();
}
inline ::google::protobuf::int32 ClanShop::surpluscounts() const {
  return surpluscounts_;
}
inline void ClanShop::set_surpluscounts(::google::protobuf::int32 value) {
  set_has_surpluscounts();
  surpluscounts_ = value;
}

// -------------------------------------------------------------------

// SaveClanLimit

// repeated .ClanPackage.ClanGoods clanGoods = 1;
inline int SaveClanLimit::clangoods_size() const {
  return clangoods_.size();
}
inline void SaveClanLimit::clear_clangoods() {
  clangoods_.Clear();
}
inline const ::ClanPackage::ClanGoods& SaveClanLimit::clangoods(int index) const {
  return clangoods_.Get(index);
}
inline ::ClanPackage::ClanGoods* SaveClanLimit::mutable_clangoods(int index) {
  return clangoods_.Mutable(index);
}
inline ::ClanPackage::ClanGoods* SaveClanLimit::add_clangoods() {
  return clangoods_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanGoods >&
SaveClanLimit::clangoods() const {
  return clangoods_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanGoods >*
SaveClanLimit::mutable_clangoods() {
  return &clangoods_;
}

// optional int64 time = 2;
inline bool SaveClanLimit::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SaveClanLimit::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SaveClanLimit::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SaveClanLimit::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 SaveClanLimit::time() const {
  return time_;
}
inline void SaveClanLimit::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// SaveClanSkill

// repeated .ClanPackage.SClanSkill sclanSkill = 1;
inline int SaveClanSkill::sclanskill_size() const {
  return sclanskill_.size();
}
inline void SaveClanSkill::clear_sclanskill() {
  sclanskill_.Clear();
}
inline const ::ClanPackage::SClanSkill& SaveClanSkill::sclanskill(int index) const {
  return sclanskill_.Get(index);
}
inline ::ClanPackage::SClanSkill* SaveClanSkill::mutable_sclanskill(int index) {
  return sclanskill_.Mutable(index);
}
inline ::ClanPackage::SClanSkill* SaveClanSkill::add_sclanskill() {
  return sclanskill_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::SClanSkill >&
SaveClanSkill::sclanskill() const {
  return sclanskill_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::SClanSkill >*
SaveClanSkill::mutable_sclanskill() {
  return &sclanskill_;
}

// -------------------------------------------------------------------

// SClanSkill

// required int32 skillid = 1;
inline bool SClanSkill::has_skillid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SClanSkill::set_has_skillid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SClanSkill::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SClanSkill::clear_skillid() {
  skillid_ = 0;
  clear_has_skillid();
}
inline ::google::protobuf::int32 SClanSkill::skillid() const {
  return skillid_;
}
inline void SClanSkill::set_skillid(::google::protobuf::int32 value) {
  set_has_skillid();
  skillid_ = value;
}

// optional int32 curexp = 2;
inline bool SClanSkill::has_curexp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SClanSkill::set_has_curexp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SClanSkill::clear_has_curexp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SClanSkill::clear_curexp() {
  curexp_ = 0;
  clear_has_curexp();
}
inline ::google::protobuf::int32 SClanSkill::curexp() const {
  return curexp_;
}
inline void SClanSkill::set_curexp(::google::protobuf::int32 value) {
  set_has_curexp();
  curexp_ = value;
}

// optional int32 type = 3;
inline bool SClanSkill::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SClanSkill::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SClanSkill::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SClanSkill::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 SClanSkill::type() const {
  return type_;
}
inline void SClanSkill::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ClanSkill

// required int32 skillid = 1;
inline bool ClanSkill::has_skillid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanSkill::set_has_skillid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanSkill::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanSkill::clear_skillid() {
  skillid_ = 0;
  clear_has_skillid();
}
inline ::google::protobuf::int32 ClanSkill::skillid() const {
  return skillid_;
}
inline void ClanSkill::set_skillid(::google::protobuf::int32 value) {
  set_has_skillid();
  skillid_ = value;
}

// optional int32 curexp = 2;
inline bool ClanSkill::has_curexp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanSkill::set_has_curexp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanSkill::clear_has_curexp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanSkill::clear_curexp() {
  curexp_ = 0;
  clear_has_curexp();
}
inline ::google::protobuf::int32 ClanSkill::curexp() const {
  return curexp_;
}
inline void ClanSkill::set_curexp(::google::protobuf::int32 value) {
  set_has_curexp();
  curexp_ = value;
}

// -------------------------------------------------------------------

// ClientReqSkillUpdate

// required int32 type = 1;
inline bool ClientReqSkillUpdate::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqSkillUpdate::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqSkillUpdate::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqSkillUpdate::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ClientReqSkillUpdate::type() const {
  return type_;
}
inline void ClientReqSkillUpdate::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// WSToClentSkillUpdate

// required int32 ret = 1;
inline bool WSToClentSkillUpdate::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WSToClentSkillUpdate::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WSToClentSkillUpdate::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WSToClentSkillUpdate::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 WSToClentSkillUpdate::ret() const {
  return ret_;
}
inline void WSToClentSkillUpdate::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 skillid = 2;
inline bool WSToClentSkillUpdate::has_skillid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WSToClentSkillUpdate::set_has_skillid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WSToClentSkillUpdate::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WSToClentSkillUpdate::clear_skillid() {
  skillid_ = 0;
  clear_has_skillid();
}
inline ::google::protobuf::int32 WSToClentSkillUpdate::skillid() const {
  return skillid_;
}
inline void WSToClentSkillUpdate::set_skillid(::google::protobuf::int32 value) {
  set_has_skillid();
  skillid_ = value;
}

// optional int32 curexp = 3;
inline bool WSToClentSkillUpdate::has_curexp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WSToClentSkillUpdate::set_has_curexp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WSToClentSkillUpdate::clear_has_curexp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WSToClentSkillUpdate::clear_curexp() {
  curexp_ = 0;
  clear_has_curexp();
}
inline ::google::protobuf::int32 WSToClentSkillUpdate::curexp() const {
  return curexp_;
}
inline void WSToClentSkillUpdate::set_curexp(::google::protobuf::int32 value) {
  set_has_curexp();
  curexp_ = value;
}

// optional int32 contri = 4;
inline bool WSToClentSkillUpdate::has_contri() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WSToClentSkillUpdate::set_has_contri() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WSToClentSkillUpdate::clear_has_contri() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WSToClentSkillUpdate::clear_contri() {
  contri_ = 0;
  clear_has_contri();
}
inline ::google::protobuf::int32 WSToClentSkillUpdate::contri() const {
  return contri_;
}
inline void WSToClentSkillUpdate::set_contri(::google::protobuf::int32 value) {
  set_has_contri();
  contri_ = value;
}

// -------------------------------------------------------------------

// WSToClientSimSkillUpdate

// optional int32 skillid = 1;
inline bool WSToClientSimSkillUpdate::has_skillid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WSToClientSimSkillUpdate::set_has_skillid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WSToClientSimSkillUpdate::clear_has_skillid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WSToClientSimSkillUpdate::clear_skillid() {
  skillid_ = 0;
  clear_has_skillid();
}
inline ::google::protobuf::int32 WSToClientSimSkillUpdate::skillid() const {
  return skillid_;
}
inline void WSToClientSimSkillUpdate::set_skillid(::google::protobuf::int32 value) {
  set_has_skillid();
  skillid_ = value;
}

// optional int32 curexp = 2;
inline bool WSToClientSimSkillUpdate::has_curexp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WSToClientSimSkillUpdate::set_has_curexp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WSToClientSimSkillUpdate::clear_has_curexp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WSToClientSimSkillUpdate::clear_curexp() {
  curexp_ = 0;
  clear_has_curexp();
}
inline ::google::protobuf::int32 WSToClientSimSkillUpdate::curexp() const {
  return curexp_;
}
inline void WSToClientSimSkillUpdate::set_curexp(::google::protobuf::int32 value) {
  set_has_curexp();
  curexp_ = value;
}

// -------------------------------------------------------------------

// WSToGameADBuff

// required int64 charid = 1;
inline bool WSToGameADBuff::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WSToGameADBuff::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WSToGameADBuff::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WSToGameADBuff::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 WSToGameADBuff::charid() const {
  return charid_;
}
inline void WSToGameADBuff::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// optional bool flag = 2;
inline bool WSToGameADBuff::has_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WSToGameADBuff::set_has_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WSToGameADBuff::clear_has_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WSToGameADBuff::clear_flag() {
  flag_ = false;
  clear_has_flag();
}
inline bool WSToGameADBuff::flag() const {
  return flag_;
}
inline void WSToGameADBuff::set_flag(bool value) {
  set_has_flag();
  flag_ = value;
}

// repeated int32 skillid = 3;
inline int WSToGameADBuff::skillid_size() const {
  return skillid_.size();
}
inline void WSToGameADBuff::clear_skillid() {
  skillid_.Clear();
}
inline ::google::protobuf::int32 WSToGameADBuff::skillid(int index) const {
  return skillid_.Get(index);
}
inline void WSToGameADBuff::set_skillid(int index, ::google::protobuf::int32 value) {
  skillid_.Set(index, value);
}
inline void WSToGameADBuff::add_skillid(::google::protobuf::int32 value) {
  skillid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
WSToGameADBuff::skillid() const {
  return skillid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
WSToGameADBuff::mutable_skillid() {
  return &skillid_;
}

// -------------------------------------------------------------------

// WSToGameClanLevel

// required int64 charid = 1;
inline bool WSToGameClanLevel::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WSToGameClanLevel::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WSToGameClanLevel::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WSToGameClanLevel::clear_charid() {
  charid_ = GOOGLE_LONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::int64 WSToGameClanLevel::charid() const {
  return charid_;
}
inline void WSToGameClanLevel::set_charid(::google::protobuf::int64 value) {
  set_has_charid();
  charid_ = value;
}

// optional int32 clanLevel = 2;
inline bool WSToGameClanLevel::has_clanlevel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WSToGameClanLevel::set_has_clanlevel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WSToGameClanLevel::clear_has_clanlevel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WSToGameClanLevel::clear_clanlevel() {
  clanlevel_ = 0;
  clear_has_clanlevel();
}
inline ::google::protobuf::int32 WSToGameClanLevel::clanlevel() const {
  return clanlevel_;
}
inline void WSToGameClanLevel::set_clanlevel(::google::protobuf::int32 value) {
  set_has_clanlevel();
  clanlevel_ = value;
}

// -------------------------------------------------------------------

// SynchWillJoinToGM

// repeated int64 charID = 1;
inline int SynchWillJoinToGM::charid_size() const {
  return charid_.size();
}
inline void SynchWillJoinToGM::clear_charid() {
  charid_.Clear();
}
inline ::google::protobuf::int64 SynchWillJoinToGM::charid(int index) const {
  return charid_.Get(index);
}
inline void SynchWillJoinToGM::set_charid(int index, ::google::protobuf::int64 value) {
  charid_.Set(index, value);
}
inline void SynchWillJoinToGM::add_charid(::google::protobuf::int64 value) {
  charid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
SynchWillJoinToGM::charid() const {
  return charid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
SynchWillJoinToGM::mutable_charid() {
  return &charid_;
}

// optional bool flag = 2;
inline bool SynchWillJoinToGM::has_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SynchWillJoinToGM::set_has_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SynchWillJoinToGM::clear_has_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SynchWillJoinToGM::clear_flag() {
  flag_ = false;
  clear_has_flag();
}
inline bool SynchWillJoinToGM::flag() const {
  return flag_;
}
inline void SynchWillJoinToGM::set_flag(bool value) {
  set_has_flag();
  flag_ = value;
}

// -------------------------------------------------------------------

// ShowClanWelfare

// repeated .ClanPackage.ClanWelfare welfares = 1;
inline int ShowClanWelfare::welfares_size() const {
  return welfares_.size();
}
inline void ShowClanWelfare::clear_welfares() {
  welfares_.Clear();
}
inline const ::ClanPackage::ClanWelfare& ShowClanWelfare::welfares(int index) const {
  return welfares_.Get(index);
}
inline ::ClanPackage::ClanWelfare* ShowClanWelfare::mutable_welfares(int index) {
  return welfares_.Mutable(index);
}
inline ::ClanPackage::ClanWelfare* ShowClanWelfare::add_welfares() {
  return welfares_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanWelfare >&
ShowClanWelfare::welfares() const {
  return welfares_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanWelfare >*
ShowClanWelfare::mutable_welfares() {
  return &welfares_;
}

// optional uint32 historyContri = 2;
inline bool ShowClanWelfare::has_historycontri() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShowClanWelfare::set_has_historycontri() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShowClanWelfare::clear_has_historycontri() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShowClanWelfare::clear_historycontri() {
  historycontri_ = 0u;
  clear_has_historycontri();
}
inline ::google::protobuf::uint32 ShowClanWelfare::historycontri() const {
  return historycontri_;
}
inline void ShowClanWelfare::set_historycontri(::google::protobuf::uint32 value) {
  set_has_historycontri();
  historycontri_ = value;
}

// optional uint64 joinTime = 3;
inline bool ShowClanWelfare::has_jointime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShowClanWelfare::set_has_jointime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShowClanWelfare::clear_has_jointime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShowClanWelfare::clear_jointime() {
  jointime_ = GOOGLE_ULONGLONG(0);
  clear_has_jointime();
}
inline ::google::protobuf::uint64 ShowClanWelfare::jointime() const {
  return jointime_;
}
inline void ShowClanWelfare::set_jointime(::google::protobuf::uint64 value) {
  set_has_jointime();
  jointime_ = value;
}

// -------------------------------------------------------------------

// ClanWelfare

// required uint64 welfareID = 1;
inline bool ClanWelfare::has_welfareid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanWelfare::set_has_welfareid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanWelfare::clear_has_welfareid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanWelfare::clear_welfareid() {
  welfareid_ = GOOGLE_ULONGLONG(0);
  clear_has_welfareid();
}
inline ::google::protobuf::uint64 ClanWelfare::welfareid() const {
  return welfareid_;
}
inline void ClanWelfare::set_welfareid(::google::protobuf::uint64 value) {
  set_has_welfareid();
  welfareid_ = value;
}

// optional string name = 2;
inline bool ClanWelfare::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanWelfare::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanWelfare::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanWelfare::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ClanWelfare::name() const {
  return *name_;
}
inline void ClanWelfare::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanWelfare::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ClanWelfare::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClanWelfare::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ClanWelfare::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClanWelfare::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 welfareInfoID = 3;
inline bool ClanWelfare::has_welfareinfoid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanWelfare::set_has_welfareinfoid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanWelfare::clear_has_welfareinfoid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanWelfare::clear_welfareinfoid() {
  welfareinfoid_ = 0;
  clear_has_welfareinfoid();
}
inline ::google::protobuf::int32 ClanWelfare::welfareinfoid() const {
  return welfareinfoid_;
}
inline void ClanWelfare::set_welfareinfoid(::google::protobuf::int32 value) {
  set_has_welfareinfoid();
  welfareinfoid_ = value;
}

// optional int32 limitLv = 4;
inline bool ClanWelfare::has_limitlv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanWelfare::set_has_limitlv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanWelfare::clear_has_limitlv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanWelfare::clear_limitlv() {
  limitlv_ = 0;
  clear_has_limitlv();
}
inline ::google::protobuf::int32 ClanWelfare::limitlv() const {
  return limitlv_;
}
inline void ClanWelfare::set_limitlv(::google::protobuf::int32 value) {
  set_has_limitlv();
  limitlv_ = value;
}

// optional int32 limitDay = 5;
inline bool ClanWelfare::has_limitday() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClanWelfare::set_has_limitday() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClanWelfare::clear_has_limitday() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClanWelfare::clear_limitday() {
  limitday_ = 0;
  clear_has_limitday();
}
inline ::google::protobuf::int32 ClanWelfare::limitday() const {
  return limitday_;
}
inline void ClanWelfare::set_limitday(::google::protobuf::int32 value) {
  set_has_limitday();
  limitday_ = value;
}

// optional int32 limitContri = 6;
inline bool ClanWelfare::has_limitcontri() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClanWelfare::set_has_limitcontri() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClanWelfare::clear_has_limitcontri() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClanWelfare::clear_limitcontri() {
  limitcontri_ = 0;
  clear_has_limitcontri();
}
inline ::google::protobuf::int32 ClanWelfare::limitcontri() const {
  return limitcontri_;
}
inline void ClanWelfare::set_limitcontri(::google::protobuf::int32 value) {
  set_has_limitcontri();
  limitcontri_ = value;
}

// optional int32 num = 7;
inline bool ClanWelfare::has_num() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClanWelfare::set_has_num() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClanWelfare::clear_has_num() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClanWelfare::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 ClanWelfare::num() const {
  return num_;
}
inline void ClanWelfare::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 isTake = 8;
inline bool ClanWelfare::has_istake() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClanWelfare::set_has_istake() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClanWelfare::clear_has_istake() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClanWelfare::clear_istake() {
  istake_ = 0;
  clear_has_istake();
}
inline ::google::protobuf::int32 ClanWelfare::istake() const {
  return istake_;
}
inline void ClanWelfare::set_istake(::google::protobuf::int32 value) {
  set_has_istake();
  istake_ = value;
}

// -------------------------------------------------------------------

// SendClanWelfare

// required int32 welfareInfoID = 1;
inline bool SendClanWelfare::has_welfareinfoid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendClanWelfare::set_has_welfareinfoid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendClanWelfare::clear_has_welfareinfoid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendClanWelfare::clear_welfareinfoid() {
  welfareinfoid_ = 0;
  clear_has_welfareinfoid();
}
inline ::google::protobuf::int32 SendClanWelfare::welfareinfoid() const {
  return welfareinfoid_;
}
inline void SendClanWelfare::set_welfareinfoid(::google::protobuf::int32 value) {
  set_has_welfareinfoid();
  welfareinfoid_ = value;
}

// optional int32 lv = 2;
inline bool SendClanWelfare::has_lv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendClanWelfare::set_has_lv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendClanWelfare::clear_has_lv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendClanWelfare::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 SendClanWelfare::lv() const {
  return lv_;
}
inline void SendClanWelfare::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// optional int32 day = 3;
inline bool SendClanWelfare::has_day() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendClanWelfare::set_has_day() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendClanWelfare::clear_has_day() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendClanWelfare::clear_day() {
  day_ = 0;
  clear_has_day();
}
inline ::google::protobuf::int32 SendClanWelfare::day() const {
  return day_;
}
inline void SendClanWelfare::set_day(::google::protobuf::int32 value) {
  set_has_day();
  day_ = value;
}

// optional int32 contri = 4;
inline bool SendClanWelfare::has_contri() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendClanWelfare::set_has_contri() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendClanWelfare::clear_has_contri() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendClanWelfare::clear_contri() {
  contri_ = 0;
  clear_has_contri();
}
inline ::google::protobuf::int32 SendClanWelfare::contri() const {
  return contri_;
}
inline void SendClanWelfare::set_contri(::google::protobuf::int32 value) {
  set_has_contri();
  contri_ = value;
}

// optional int32 num = 5;
inline bool SendClanWelfare::has_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SendClanWelfare::set_has_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SendClanWelfare::clear_has_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SendClanWelfare::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 SendClanWelfare::num() const {
  return num_;
}
inline void SendClanWelfare::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// TakeClanWelfare

// required uint64 welfareID = 1;
inline bool TakeClanWelfare::has_welfareid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TakeClanWelfare::set_has_welfareid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TakeClanWelfare::clear_has_welfareid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TakeClanWelfare::clear_welfareid() {
  welfareid_ = GOOGLE_ULONGLONG(0);
  clear_has_welfareid();
}
inline ::google::protobuf::uint64 TakeClanWelfare::welfareid() const {
  return welfareid_;
}
inline void TakeClanWelfare::set_welfareid(::google::protobuf::uint64 value) {
  set_has_welfareid();
  welfareid_ = value;
}

// -------------------------------------------------------------------

// RetTakeClanWelfare

// required int32 err = 1;
inline bool RetTakeClanWelfare::has_err() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetTakeClanWelfare::set_has_err() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetTakeClanWelfare::clear_has_err() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetTakeClanWelfare::clear_err() {
  err_ = 0;
  clear_has_err();
}
inline ::google::protobuf::int32 RetTakeClanWelfare::err() const {
  return err_;
}
inline void RetTakeClanWelfare::set_err(::google::protobuf::int32 value) {
  set_has_err();
  err_ = value;
}

// optional .ClanPackage.ClanWelfare welfare = 2;
inline bool RetTakeClanWelfare::has_welfare() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetTakeClanWelfare::set_has_welfare() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetTakeClanWelfare::clear_has_welfare() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetTakeClanWelfare::clear_welfare() {
  if (welfare_ != NULL) welfare_->::ClanPackage::ClanWelfare::Clear();
  clear_has_welfare();
}
inline const ::ClanPackage::ClanWelfare& RetTakeClanWelfare::welfare() const {
  return welfare_ != NULL ? *welfare_ : *default_instance_->welfare_;
}
inline ::ClanPackage::ClanWelfare* RetTakeClanWelfare::mutable_welfare() {
  set_has_welfare();
  if (welfare_ == NULL) welfare_ = new ::ClanPackage::ClanWelfare;
  return welfare_;
}
inline ::ClanPackage::ClanWelfare* RetTakeClanWelfare::release_welfare() {
  clear_has_welfare();
  ::ClanPackage::ClanWelfare* temp = welfare_;
  welfare_ = NULL;
  return temp;
}
inline void RetTakeClanWelfare::set_allocated_welfare(::ClanPackage::ClanWelfare* welfare) {
  delete welfare_;
  welfare_ = welfare;
  if (welfare) {
    set_has_welfare();
  } else {
    clear_has_welfare();
  }
}

// -------------------------------------------------------------------

// ClientReqBackClanMap

// -------------------------------------------------------------------

// AckReqBackClanMap

// required int32 ret = 1;
inline bool AckReqBackClanMap::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckReqBackClanMap::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckReqBackClanMap::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckReqBackClanMap::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 AckReqBackClanMap::ret() const {
  return ret_;
}
inline void AckReqBackClanMap::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int64 mapid = 2;
inline bool AckReqBackClanMap::has_mapid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckReqBackClanMap::set_has_mapid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckReqBackClanMap::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckReqBackClanMap::clear_mapid() {
  mapid_ = GOOGLE_LONGLONG(0);
  clear_has_mapid();
}
inline ::google::protobuf::int64 AckReqBackClanMap::mapid() const {
  return mapid_;
}
inline void AckReqBackClanMap::set_mapid(::google::protobuf::int64 value) {
  set_has_mapid();
  mapid_ = value;
}

// -------------------------------------------------------------------

// AckClanSkills

// repeated int32 id = 1;
inline int AckClanSkills::id_size() const {
  return id_.size();
}
inline void AckClanSkills::clear_id() {
  id_.Clear();
}
inline ::google::protobuf::int32 AckClanSkills::id(int index) const {
  return id_.Get(index);
}
inline void AckClanSkills::set_id(int index, ::google::protobuf::int32 value) {
  id_.Set(index, value);
}
inline void AckClanSkills::add_id(::google::protobuf::int32 value) {
  id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AckClanSkills::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AckClanSkills::mutable_id() {
  return &id_;
}

// -------------------------------------------------------------------

// ReqUpGrageClanSkill

// required int32 id = 1;
inline bool ReqUpGrageClanSkill::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqUpGrageClanSkill::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqUpGrageClanSkill::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqUpGrageClanSkill::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ReqUpGrageClanSkill::id() const {
  return id_;
}
inline void ReqUpGrageClanSkill::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// AckUpGradeClanSkill

// required int32 ret = 1;
inline bool AckUpGradeClanSkill::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckUpGradeClanSkill::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckUpGradeClanSkill::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckUpGradeClanSkill::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 AckUpGradeClanSkill::ret() const {
  return ret_;
}
inline void AckUpGradeClanSkill::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 oldskill = 2;
inline bool AckUpGradeClanSkill::has_oldskill() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckUpGradeClanSkill::set_has_oldskill() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckUpGradeClanSkill::clear_has_oldskill() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckUpGradeClanSkill::clear_oldskill() {
  oldskill_ = 0;
  clear_has_oldskill();
}
inline ::google::protobuf::int32 AckUpGradeClanSkill::oldskill() const {
  return oldskill_;
}
inline void AckUpGradeClanSkill::set_oldskill(::google::protobuf::int32 value) {
  set_has_oldskill();
  oldskill_ = value;
}

// optional int32 newskill = 3;
inline bool AckUpGradeClanSkill::has_newskill() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckUpGradeClanSkill::set_has_newskill() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckUpGradeClanSkill::clear_has_newskill() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckUpGradeClanSkill::clear_newskill() {
  newskill_ = 0;
  clear_has_newskill();
}
inline ::google::protobuf::int32 AckUpGradeClanSkill::newskill() const {
  return newskill_;
}
inline void AckUpGradeClanSkill::set_newskill(::google::protobuf::int32 value) {
  set_has_newskill();
  newskill_ = value;
}

// -------------------------------------------------------------------

// Ws2GsRobberActive

// required bool flag = 1;
inline bool Ws2GsRobberActive::has_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ws2GsRobberActive::set_has_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ws2GsRobberActive::clear_has_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ws2GsRobberActive::clear_flag() {
  flag_ = false;
  clear_has_flag();
}
inline bool Ws2GsRobberActive::flag() const {
  return flag_;
}
inline void Ws2GsRobberActive::set_flag(bool value) {
  set_has_flag();
  flag_ = value;
}

// repeated .ClanPackage.ClanMapInfo info = 2;
inline int Ws2GsRobberActive::info_size() const {
  return info_.size();
}
inline void Ws2GsRobberActive::clear_info() {
  info_.Clear();
}
inline const ::ClanPackage::ClanMapInfo& Ws2GsRobberActive::info(int index) const {
  return info_.Get(index);
}
inline ::ClanPackage::ClanMapInfo* Ws2GsRobberActive::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::ClanPackage::ClanMapInfo* Ws2GsRobberActive::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanMapInfo >&
Ws2GsRobberActive::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::ClanPackage::ClanMapInfo >*
Ws2GsRobberActive::mutable_info() {
  return &info_;
}

// -------------------------------------------------------------------

// ClanMapInfo

// required int32 clanid = 1;
inline bool ClanMapInfo::has_clanid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClanMapInfo::set_has_clanid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClanMapInfo::clear_has_clanid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClanMapInfo::clear_clanid() {
  clanid_ = 0;
  clear_has_clanid();
}
inline ::google::protobuf::int32 ClanMapInfo::clanid() const {
  return clanid_;
}
inline void ClanMapInfo::set_clanid(::google::protobuf::int32 value) {
  set_has_clanid();
  clanid_ = value;
}

// optional int64 mapid = 2;
inline bool ClanMapInfo::has_mapid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClanMapInfo::set_has_mapid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClanMapInfo::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClanMapInfo::clear_mapid() {
  mapid_ = GOOGLE_LONGLONG(0);
  clear_has_mapid();
}
inline ::google::protobuf::int64 ClanMapInfo::mapid() const {
  return mapid_;
}
inline void ClanMapInfo::set_mapid(::google::protobuf::int64 value) {
  set_has_mapid();
  mapid_ = value;
}

// optional bool win = 3;
inline bool ClanMapInfo::has_win() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClanMapInfo::set_has_win() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClanMapInfo::clear_has_win() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClanMapInfo::clear_win() {
  win_ = false;
  clear_has_win();
}
inline bool ClanMapInfo::win() const {
  return win_;
}
inline void ClanMapInfo::set_win(bool value) {
  set_has_win();
  win_ = value;
}

// optional int32 param = 4;
inline bool ClanMapInfo::has_param() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClanMapInfo::set_has_param() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClanMapInfo::clear_has_param() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClanMapInfo::clear_param() {
  param_ = 0;
  clear_has_param();
}
inline ::google::protobuf::int32 ClanMapInfo::param() const {
  return param_;
}
inline void ClanMapInfo::set_param(::google::protobuf::int32 value) {
  set_has_param();
  param_ = value;
}

// optional int32 conwin = 5;
inline bool ClanMapInfo::has_conwin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClanMapInfo::set_has_conwin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClanMapInfo::clear_has_conwin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClanMapInfo::clear_conwin() {
  conwin_ = 0;
  clear_has_conwin();
}
inline ::google::protobuf::int32 ClanMapInfo::conwin() const {
  return conwin_;
}
inline void ClanMapInfo::set_conwin(::google::protobuf::int32 value) {
  set_has_conwin();
  conwin_ = value;
}

// optional int32 confail = 6;
inline bool ClanMapInfo::has_confail() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClanMapInfo::set_has_confail() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClanMapInfo::clear_has_confail() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClanMapInfo::clear_confail() {
  confail_ = 0;
  clear_has_confail();
}
inline ::google::protobuf::int32 ClanMapInfo::confail() const {
  return confail_;
}
inline void ClanMapInfo::set_confail(::google::protobuf::int32 value) {
  set_has_confail();
  confail_ = value;
}

// -------------------------------------------------------------------

// Ws2GsDestroyClanMap

// required int32 clanid = 1;
inline bool Ws2GsDestroyClanMap::has_clanid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ws2GsDestroyClanMap::set_has_clanid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ws2GsDestroyClanMap::clear_has_clanid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ws2GsDestroyClanMap::clear_clanid() {
  clanid_ = 0;
  clear_has_clanid();
}
inline ::google::protobuf::int32 Ws2GsDestroyClanMap::clanid() const {
  return clanid_;
}
inline void Ws2GsDestroyClanMap::set_clanid(::google::protobuf::int32 value) {
  set_has_clanid();
  clanid_ = value;
}

// optional int64 mapid = 2;
inline bool Ws2GsDestroyClanMap::has_mapid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ws2GsDestroyClanMap::set_has_mapid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ws2GsDestroyClanMap::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ws2GsDestroyClanMap::clear_mapid() {
  mapid_ = GOOGLE_LONGLONG(0);
  clear_has_mapid();
}
inline ::google::protobuf::int64 Ws2GsDestroyClanMap::mapid() const {
  return mapid_;
}
inline void Ws2GsDestroyClanMap::set_mapid(::google::protobuf::int64 value) {
  set_has_mapid();
  mapid_ = value;
}

// -------------------------------------------------------------------

// RobberResult

// required int32 clanid = 1;
inline bool RobberResult::has_clanid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobberResult::set_has_clanid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobberResult::clear_has_clanid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobberResult::clear_clanid() {
  clanid_ = 0;
  clear_has_clanid();
}
inline ::google::protobuf::int32 RobberResult::clanid() const {
  return clanid_;
}
inline void RobberResult::set_clanid(::google::protobuf::int32 value) {
  set_has_clanid();
  clanid_ = value;
}

// optional bool win = 2;
inline bool RobberResult::has_win() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobberResult::set_has_win() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobberResult::clear_has_win() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobberResult::clear_win() {
  win_ = false;
  clear_has_win();
}
inline bool RobberResult::win() const {
  return win_;
}
inline void RobberResult::set_win(bool value) {
  set_has_win();
  win_ = value;
}

// optional int32 param = 3;
inline bool RobberResult::has_param() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobberResult::set_has_param() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobberResult::clear_has_param() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobberResult::clear_param() {
  param_ = 0;
  clear_has_param();
}
inline ::google::protobuf::int32 RobberResult::param() const {
  return param_;
}
inline void RobberResult::set_param(::google::protobuf::int32 value) {
  set_has_param();
  param_ = value;
}

// optional int32 conwin = 4;
inline bool RobberResult::has_conwin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobberResult::set_has_conwin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobberResult::clear_has_conwin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobberResult::clear_conwin() {
  conwin_ = 0;
  clear_has_conwin();
}
inline ::google::protobuf::int32 RobberResult::conwin() const {
  return conwin_;
}
inline void RobberResult::set_conwin(::google::protobuf::int32 value) {
  set_has_conwin();
  conwin_ = value;
}

// optional int32 confail = 5;
inline bool RobberResult::has_confail() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RobberResult::set_has_confail() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RobberResult::clear_has_confail() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RobberResult::clear_confail() {
  confail_ = 0;
  clear_has_confail();
}
inline ::google::protobuf::int32 RobberResult::confail() const {
  return confail_;
}
inline void RobberResult::set_confail(::google::protobuf::int32 value) {
  set_has_confail();
  confail_ = value;
}

// optional int32 money = 6;
inline bool RobberResult::has_money() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RobberResult::set_has_money() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RobberResult::clear_has_money() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RobberResult::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 RobberResult::money() const {
  return money_;
}
inline void RobberResult::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// -------------------------------------------------------------------

// ClientReqChanceJoinClan

// required uint32 id = 1;
inline bool ClientReqChanceJoinClan::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientReqChanceJoinClan::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientReqChanceJoinClan::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientReqChanceJoinClan::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ClientReqChanceJoinClan::id() const {
  return id_;
}
inline void ClientReqChanceJoinClan::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// AckChanceJoinClan

// required int32 ret = 1;
inline bool AckChanceJoinClan::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckChanceJoinClan::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckChanceJoinClan::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckChanceJoinClan::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 AckChanceJoinClan::ret() const {
  return ret_;
}
inline void AckChanceJoinClan::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
}

// optional int32 clanID = 2;
inline bool AckChanceJoinClan::has_clanid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckChanceJoinClan::set_has_clanid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckChanceJoinClan::clear_has_clanid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckChanceJoinClan::clear_clanid() {
  clanid_ = 0;
  clear_has_clanid();
}
inline ::google::protobuf::int32 AckChanceJoinClan::clanid() const {
  return clanid_;
}
inline void AckChanceJoinClan::set_clanid(::google::protobuf::int32 value) {
  set_has_clanid();
  clanid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ClanPackage

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Clan_2fClan_2eproto__INCLUDED

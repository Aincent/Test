// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ChristmasActivity/ChristmasActivity.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ChristmasActivity/ChristmasActivity.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ChristmasActivity {

namespace {

const ::google::protobuf::Descriptor* BreakEggMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BreakEggMsg_reflection_ = NULL;
const ::google::protobuf::Descriptor* OneItemData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OneItemData_reflection_ = NULL;
const ::google::protobuf::Descriptor* BreakEggReturn_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BreakEggReturn_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChristmasLoginMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChristmasLoginMsg_reflection_ = NULL;
const ::google::protobuf::Descriptor* SingleLimitData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SingleLimitData_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChristmasLimitBuyInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChristmasLimitBuyInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* LimitBuyReturn_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LimitBuyReturn_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_ChristmasActivity_2fChristmasActivity_2eproto() {
  protobuf_AddDesc_ChristmasActivity_2fChristmasActivity_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "ChristmasActivity/ChristmasActivity.proto");
  GOOGLE_CHECK(file != NULL);
  BreakEggMsg_descriptor_ = file->message_type(0);
  static const int BreakEggMsg_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BreakEggMsg, reflushtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BreakEggMsg, breakinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BreakEggMsg, endtime_),
  };
  BreakEggMsg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BreakEggMsg_descriptor_,
      BreakEggMsg::default_instance_,
      BreakEggMsg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BreakEggMsg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BreakEggMsg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BreakEggMsg));
  OneItemData_descriptor_ = file->message_type(1);
  static const int OneItemData_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OneItemData, itemid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OneItemData, bindtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OneItemData, num_),
  };
  OneItemData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OneItemData_descriptor_,
      OneItemData::default_instance_,
      OneItemData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OneItemData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OneItemData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OneItemData));
  BreakEggReturn_descriptor_ = file->message_type(2);
  static const int BreakEggReturn_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BreakEggReturn, error_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BreakEggReturn, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BreakEggReturn, itemlist_),
  };
  BreakEggReturn_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BreakEggReturn_descriptor_,
      BreakEggReturn::default_instance_,
      BreakEggReturn_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BreakEggReturn, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BreakEggReturn, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BreakEggReturn));
  ChristmasLoginMsg_descriptor_ = file->message_type(3);
  static const int ChristmasLoginMsg_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasLoginMsg, loginday_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasLoginMsg, rewardinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasLoginMsg, endtime_),
  };
  ChristmasLoginMsg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChristmasLoginMsg_descriptor_,
      ChristmasLoginMsg::default_instance_,
      ChristmasLoginMsg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasLoginMsg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasLoginMsg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChristmasLoginMsg));
  SingleLimitData_descriptor_ = file->message_type(4);
  static const int SingleLimitData_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleLimitData, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleLimitData, counts_),
  };
  SingleLimitData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SingleLimitData_descriptor_,
      SingleLimitData::default_instance_,
      SingleLimitData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleLimitData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SingleLimitData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SingleLimitData));
  ChristmasLimitBuyInfo_descriptor_ = file->message_type(5);
  static const int ChristmasLimitBuyInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasLimitBuyInfo, reflushtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasLimitBuyInfo, datalist_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasLimitBuyInfo, endtime_),
  };
  ChristmasLimitBuyInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChristmasLimitBuyInfo_descriptor_,
      ChristmasLimitBuyInfo::default_instance_,
      ChristmasLimitBuyInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasLimitBuyInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChristmasLimitBuyInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChristmasLimitBuyInfo));
  LimitBuyReturn_descriptor_ = file->message_type(6);
  static const int LimitBuyReturn_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LimitBuyReturn, error_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LimitBuyReturn, datalist_),
  };
  LimitBuyReturn_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LimitBuyReturn_descriptor_,
      LimitBuyReturn::default_instance_,
      LimitBuyReturn_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LimitBuyReturn, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LimitBuyReturn, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LimitBuyReturn));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_ChristmasActivity_2fChristmasActivity_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BreakEggMsg_descriptor_, &BreakEggMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OneItemData_descriptor_, &OneItemData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BreakEggReturn_descriptor_, &BreakEggReturn::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChristmasLoginMsg_descriptor_, &ChristmasLoginMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SingleLimitData_descriptor_, &SingleLimitData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChristmasLimitBuyInfo_descriptor_, &ChristmasLimitBuyInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LimitBuyReturn_descriptor_, &LimitBuyReturn::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_ChristmasActivity_2fChristmasActivity_2eproto() {
  delete BreakEggMsg::default_instance_;
  delete BreakEggMsg_reflection_;
  delete OneItemData::default_instance_;
  delete OneItemData_reflection_;
  delete BreakEggReturn::default_instance_;
  delete BreakEggReturn_reflection_;
  delete ChristmasLoginMsg::default_instance_;
  delete ChristmasLoginMsg_reflection_;
  delete SingleLimitData::default_instance_;
  delete SingleLimitData_reflection_;
  delete ChristmasLimitBuyInfo::default_instance_;
  delete ChristmasLimitBuyInfo_reflection_;
  delete LimitBuyReturn::default_instance_;
  delete LimitBuyReturn_reflection_;
}

void protobuf_AddDesc_ChristmasActivity_2fChristmasActivity_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n)ChristmasActivity/ChristmasActivity.pr"
    "oto\022\021ChristmasActivity\"F\n\013BreakEggMsg\022\023\n"
    "\013reflushTime\030\001 \001(\003\022\021\n\tbreakInfo\030\002 \001(\005\022\017\n"
    "\007endTime\030\003 \001(\003\"<\n\013OneItemData\022\016\n\006itemID\030"
    "\001 \001(\005\022\020\n\010bindType\030\002 \001(\005\022\013\n\003num\030\003 \001(\005\"`\n\016"
    "BreakEggReturn\022\r\n\005error\030\001 \001(\005\022\r\n\005index\030\002"
    " \001(\005\0220\n\010itemList\030\003 \003(\0132\036.ChristmasActivi"
    "ty.OneItemData\"J\n\021ChristmasLoginMsg\022\020\n\010l"
    "oginDay\030\001 \001(\005\022\022\n\nrewardInfo\030\002 \001(\005\022\017\n\007end"
    "Time\030\003 \001(\003\"-\n\017SingleLimitData\022\n\n\002id\030\001 \001("
    "\005\022\016\n\006counts\030\002 \001(\005\"s\n\025ChristmasLimitBuyIn"
    "fo\022\023\n\013reflushTime\030\001 \001(\003\0224\n\010dataList\030\002 \003("
    "\0132\".ChristmasActivity.SingleLimitData\022\017\n"
    "\007endTime\030\003 \001(\003\"U\n\016LimitBuyReturn\022\r\n\005erro"
    "r\030\001 \001(\005\0224\n\010dataList\030\002 \003(\0132\".ChristmasAct"
    "ivity.SingleLimitData", 621);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "ChristmasActivity/ChristmasActivity.proto", &protobuf_RegisterTypes);
  BreakEggMsg::default_instance_ = new BreakEggMsg();
  OneItemData::default_instance_ = new OneItemData();
  BreakEggReturn::default_instance_ = new BreakEggReturn();
  ChristmasLoginMsg::default_instance_ = new ChristmasLoginMsg();
  SingleLimitData::default_instance_ = new SingleLimitData();
  ChristmasLimitBuyInfo::default_instance_ = new ChristmasLimitBuyInfo();
  LimitBuyReturn::default_instance_ = new LimitBuyReturn();
  BreakEggMsg::default_instance_->InitAsDefaultInstance();
  OneItemData::default_instance_->InitAsDefaultInstance();
  BreakEggReturn::default_instance_->InitAsDefaultInstance();
  ChristmasLoginMsg::default_instance_->InitAsDefaultInstance();
  SingleLimitData::default_instance_->InitAsDefaultInstance();
  ChristmasLimitBuyInfo::default_instance_->InitAsDefaultInstance();
  LimitBuyReturn::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ChristmasActivity_2fChristmasActivity_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ChristmasActivity_2fChristmasActivity_2eproto {
  StaticDescriptorInitializer_ChristmasActivity_2fChristmasActivity_2eproto() {
    protobuf_AddDesc_ChristmasActivity_2fChristmasActivity_2eproto();
  }
} static_descriptor_initializer_ChristmasActivity_2fChristmasActivity_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int BreakEggMsg::kReflushTimeFieldNumber;
const int BreakEggMsg::kBreakInfoFieldNumber;
const int BreakEggMsg::kEndTimeFieldNumber;
#endif  // !_MSC_VER

BreakEggMsg::BreakEggMsg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BreakEggMsg::InitAsDefaultInstance() {
}

BreakEggMsg::BreakEggMsg(const BreakEggMsg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BreakEggMsg::SharedCtor() {
  _cached_size_ = 0;
  reflushtime_ = GOOGLE_LONGLONG(0);
  breakinfo_ = 0;
  endtime_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BreakEggMsg::~BreakEggMsg() {
  SharedDtor();
}

void BreakEggMsg::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BreakEggMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BreakEggMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BreakEggMsg_descriptor_;
}

const BreakEggMsg& BreakEggMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ChristmasActivity_2fChristmasActivity_2eproto();
  return *default_instance_;
}

BreakEggMsg* BreakEggMsg::default_instance_ = NULL;

BreakEggMsg* BreakEggMsg::New() const {
  return new BreakEggMsg;
}

void BreakEggMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    reflushtime_ = GOOGLE_LONGLONG(0);
    breakinfo_ = 0;
    endtime_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BreakEggMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 reflushTime = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &reflushtime_)));
          set_has_reflushtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_breakInfo;
        break;
      }

      // optional int32 breakInfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_breakInfo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &breakinfo_)));
          set_has_breakinfo();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_endTime;
        break;
      }

      // optional int64 endTime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_endTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BreakEggMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 reflushTime = 1;
  if (has_reflushtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->reflushtime(), output);
  }

  // optional int32 breakInfo = 2;
  if (has_breakinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->breakinfo(), output);
  }

  // optional int64 endTime = 3;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->endtime(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BreakEggMsg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int64 reflushTime = 1;
  if (has_reflushtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->reflushtime(), target);
  }

  // optional int32 breakInfo = 2;
  if (has_breakinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->breakinfo(), target);
  }

  // optional int64 endTime = 3;
  if (has_endtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->endtime(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BreakEggMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 reflushTime = 1;
    if (has_reflushtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->reflushtime());
    }

    // optional int32 breakInfo = 2;
    if (has_breakinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->breakinfo());
    }

    // optional int64 endTime = 3;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->endtime());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BreakEggMsg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BreakEggMsg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BreakEggMsg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BreakEggMsg::MergeFrom(const BreakEggMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reflushtime()) {
      set_reflushtime(from.reflushtime());
    }
    if (from.has_breakinfo()) {
      set_breakinfo(from.breakinfo());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BreakEggMsg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BreakEggMsg::CopyFrom(const BreakEggMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BreakEggMsg::IsInitialized() const {

  return true;
}

void BreakEggMsg::Swap(BreakEggMsg* other) {
  if (other != this) {
    std::swap(reflushtime_, other->reflushtime_);
    std::swap(breakinfo_, other->breakinfo_);
    std::swap(endtime_, other->endtime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BreakEggMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BreakEggMsg_descriptor_;
  metadata.reflection = BreakEggMsg_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int OneItemData::kItemIDFieldNumber;
const int OneItemData::kBindTypeFieldNumber;
const int OneItemData::kNumFieldNumber;
#endif  // !_MSC_VER

OneItemData::OneItemData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void OneItemData::InitAsDefaultInstance() {
}

OneItemData::OneItemData(const OneItemData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void OneItemData::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0;
  bindtype_ = 0;
  num_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OneItemData::~OneItemData() {
  SharedDtor();
}

void OneItemData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OneItemData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OneItemData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OneItemData_descriptor_;
}

const OneItemData& OneItemData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ChristmasActivity_2fChristmasActivity_2eproto();
  return *default_instance_;
}

OneItemData* OneItemData::default_instance_ = NULL;

OneItemData* OneItemData::New() const {
  return new OneItemData;
}

void OneItemData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    itemid_ = 0;
    bindtype_ = 0;
    num_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OneItemData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 itemID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_bindType;
        break;
      }

      // optional int32 bindType = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bindType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bindtype_)));
          set_has_bindtype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_num;
        break;
      }

      // optional int32 num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OneItemData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 itemID = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->itemid(), output);
  }

  // optional int32 bindType = 2;
  if (has_bindtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->bindtype(), output);
  }

  // optional int32 num = 3;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->num(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* OneItemData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 itemID = 1;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->itemid(), target);
  }

  // optional int32 bindType = 2;
  if (has_bindtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->bindtype(), target);
  }

  // optional int32 num = 3;
  if (has_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->num(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int OneItemData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 itemID = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional int32 bindType = 2;
    if (has_bindtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bindtype());
    }

    // optional int32 num = 3;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OneItemData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OneItemData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OneItemData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OneItemData::MergeFrom(const OneItemData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_bindtype()) {
      set_bindtype(from.bindtype());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OneItemData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OneItemData::CopyFrom(const OneItemData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OneItemData::IsInitialized() const {

  return true;
}

void OneItemData::Swap(OneItemData* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(bindtype_, other->bindtype_);
    std::swap(num_, other->num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OneItemData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OneItemData_descriptor_;
  metadata.reflection = OneItemData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BreakEggReturn::kErrorFieldNumber;
const int BreakEggReturn::kIndexFieldNumber;
const int BreakEggReturn::kItemListFieldNumber;
#endif  // !_MSC_VER

BreakEggReturn::BreakEggReturn()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BreakEggReturn::InitAsDefaultInstance() {
}

BreakEggReturn::BreakEggReturn(const BreakEggReturn& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BreakEggReturn::SharedCtor() {
  _cached_size_ = 0;
  error_ = 0;
  index_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BreakEggReturn::~BreakEggReturn() {
  SharedDtor();
}

void BreakEggReturn::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BreakEggReturn::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BreakEggReturn::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BreakEggReturn_descriptor_;
}

const BreakEggReturn& BreakEggReturn::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ChristmasActivity_2fChristmasActivity_2eproto();
  return *default_instance_;
}

BreakEggReturn* BreakEggReturn::default_instance_ = NULL;

BreakEggReturn* BreakEggReturn::New() const {
  return new BreakEggReturn;
}

void BreakEggReturn::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_ = 0;
    index_ = 0;
  }
  itemlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BreakEggReturn::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 error = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &error_)));
          set_has_error();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_index;
        break;
      }

      // optional int32 index = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_itemList;
        break;
      }

      // repeated .ChristmasActivity.OneItemData itemList = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_itemList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_itemlist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_itemList;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BreakEggReturn::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->error(), output);
  }

  // optional int32 index = 2;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->index(), output);
  }

  // repeated .ChristmasActivity.OneItemData itemList = 3;
  for (int i = 0; i < this->itemlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->itemlist(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BreakEggReturn::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 error = 1;
  if (has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->error(), target);
  }

  // optional int32 index = 2;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->index(), target);
  }

  // repeated .ChristmasActivity.OneItemData itemList = 3;
  for (int i = 0; i < this->itemlist_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->itemlist(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BreakEggReturn::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->error());
    }

    // optional int32 index = 2;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

  }
  // repeated .ChristmasActivity.OneItemData itemList = 3;
  total_size += 1 * this->itemlist_size();
  for (int i = 0; i < this->itemlist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->itemlist(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BreakEggReturn::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BreakEggReturn* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BreakEggReturn*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BreakEggReturn::MergeFrom(const BreakEggReturn& from) {
  GOOGLE_CHECK_NE(&from, this);
  itemlist_.MergeFrom(from.itemlist_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      set_error(from.error());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BreakEggReturn::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BreakEggReturn::CopyFrom(const BreakEggReturn& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BreakEggReturn::IsInitialized() const {

  return true;
}

void BreakEggReturn::Swap(BreakEggReturn* other) {
  if (other != this) {
    std::swap(error_, other->error_);
    std::swap(index_, other->index_);
    itemlist_.Swap(&other->itemlist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BreakEggReturn::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BreakEggReturn_descriptor_;
  metadata.reflection = BreakEggReturn_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ChristmasLoginMsg::kLoginDayFieldNumber;
const int ChristmasLoginMsg::kRewardInfoFieldNumber;
const int ChristmasLoginMsg::kEndTimeFieldNumber;
#endif  // !_MSC_VER

ChristmasLoginMsg::ChristmasLoginMsg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ChristmasLoginMsg::InitAsDefaultInstance() {
}

ChristmasLoginMsg::ChristmasLoginMsg(const ChristmasLoginMsg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ChristmasLoginMsg::SharedCtor() {
  _cached_size_ = 0;
  loginday_ = 0;
  rewardinfo_ = 0;
  endtime_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChristmasLoginMsg::~ChristmasLoginMsg() {
  SharedDtor();
}

void ChristmasLoginMsg::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ChristmasLoginMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChristmasLoginMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChristmasLoginMsg_descriptor_;
}

const ChristmasLoginMsg& ChristmasLoginMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ChristmasActivity_2fChristmasActivity_2eproto();
  return *default_instance_;
}

ChristmasLoginMsg* ChristmasLoginMsg::default_instance_ = NULL;

ChristmasLoginMsg* ChristmasLoginMsg::New() const {
  return new ChristmasLoginMsg;
}

void ChristmasLoginMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    loginday_ = 0;
    rewardinfo_ = 0;
    endtime_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChristmasLoginMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 loginDay = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &loginday_)));
          set_has_loginday();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_rewardInfo;
        break;
      }

      // optional int32 rewardInfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_rewardInfo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &rewardinfo_)));
          set_has_rewardinfo();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_endTime;
        break;
      }

      // optional int64 endTime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_endTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChristmasLoginMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 loginDay = 1;
  if (has_loginday()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->loginday(), output);
  }

  // optional int32 rewardInfo = 2;
  if (has_rewardinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->rewardinfo(), output);
  }

  // optional int64 endTime = 3;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->endtime(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChristmasLoginMsg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 loginDay = 1;
  if (has_loginday()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->loginday(), target);
  }

  // optional int32 rewardInfo = 2;
  if (has_rewardinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->rewardinfo(), target);
  }

  // optional int64 endTime = 3;
  if (has_endtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->endtime(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChristmasLoginMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 loginDay = 1;
    if (has_loginday()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->loginday());
    }

    // optional int32 rewardInfo = 2;
    if (has_rewardinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->rewardinfo());
    }

    // optional int64 endTime = 3;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->endtime());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChristmasLoginMsg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChristmasLoginMsg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChristmasLoginMsg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChristmasLoginMsg::MergeFrom(const ChristmasLoginMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_loginday()) {
      set_loginday(from.loginday());
    }
    if (from.has_rewardinfo()) {
      set_rewardinfo(from.rewardinfo());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChristmasLoginMsg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChristmasLoginMsg::CopyFrom(const ChristmasLoginMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChristmasLoginMsg::IsInitialized() const {

  return true;
}

void ChristmasLoginMsg::Swap(ChristmasLoginMsg* other) {
  if (other != this) {
    std::swap(loginday_, other->loginday_);
    std::swap(rewardinfo_, other->rewardinfo_);
    std::swap(endtime_, other->endtime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChristmasLoginMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChristmasLoginMsg_descriptor_;
  metadata.reflection = ChristmasLoginMsg_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SingleLimitData::kIdFieldNumber;
const int SingleLimitData::kCountsFieldNumber;
#endif  // !_MSC_VER

SingleLimitData::SingleLimitData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SingleLimitData::InitAsDefaultInstance() {
}

SingleLimitData::SingleLimitData(const SingleLimitData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SingleLimitData::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  counts_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SingleLimitData::~SingleLimitData() {
  SharedDtor();
}

void SingleLimitData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SingleLimitData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SingleLimitData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SingleLimitData_descriptor_;
}

const SingleLimitData& SingleLimitData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ChristmasActivity_2fChristmasActivity_2eproto();
  return *default_instance_;
}

SingleLimitData* SingleLimitData::default_instance_ = NULL;

SingleLimitData* SingleLimitData::New() const {
  return new SingleLimitData;
}

void SingleLimitData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    counts_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SingleLimitData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_counts;
        break;
      }

      // optional int32 counts = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_counts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &counts_)));
          set_has_counts();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SingleLimitData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 counts = 2;
  if (has_counts()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->counts(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SingleLimitData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional int32 counts = 2;
  if (has_counts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->counts(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SingleLimitData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 counts = 2;
    if (has_counts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->counts());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SingleLimitData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SingleLimitData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SingleLimitData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SingleLimitData::MergeFrom(const SingleLimitData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_counts()) {
      set_counts(from.counts());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SingleLimitData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SingleLimitData::CopyFrom(const SingleLimitData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SingleLimitData::IsInitialized() const {

  return true;
}

void SingleLimitData::Swap(SingleLimitData* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(counts_, other->counts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SingleLimitData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SingleLimitData_descriptor_;
  metadata.reflection = SingleLimitData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ChristmasLimitBuyInfo::kReflushTimeFieldNumber;
const int ChristmasLimitBuyInfo::kDataListFieldNumber;
const int ChristmasLimitBuyInfo::kEndTimeFieldNumber;
#endif  // !_MSC_VER

ChristmasLimitBuyInfo::ChristmasLimitBuyInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ChristmasLimitBuyInfo::InitAsDefaultInstance() {
}

ChristmasLimitBuyInfo::ChristmasLimitBuyInfo(const ChristmasLimitBuyInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ChristmasLimitBuyInfo::SharedCtor() {
  _cached_size_ = 0;
  reflushtime_ = GOOGLE_LONGLONG(0);
  endtime_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChristmasLimitBuyInfo::~ChristmasLimitBuyInfo() {
  SharedDtor();
}

void ChristmasLimitBuyInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ChristmasLimitBuyInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChristmasLimitBuyInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChristmasLimitBuyInfo_descriptor_;
}

const ChristmasLimitBuyInfo& ChristmasLimitBuyInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ChristmasActivity_2fChristmasActivity_2eproto();
  return *default_instance_;
}

ChristmasLimitBuyInfo* ChristmasLimitBuyInfo::default_instance_ = NULL;

ChristmasLimitBuyInfo* ChristmasLimitBuyInfo::New() const {
  return new ChristmasLimitBuyInfo;
}

void ChristmasLimitBuyInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    reflushtime_ = GOOGLE_LONGLONG(0);
    endtime_ = GOOGLE_LONGLONG(0);
  }
  datalist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChristmasLimitBuyInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 reflushTime = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &reflushtime_)));
          set_has_reflushtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_dataList;
        break;
      }

      // repeated .ChristmasActivity.SingleLimitData dataList = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dataList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_datalist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_dataList;
        if (input->ExpectTag(24)) goto parse_endTime;
        break;
      }

      // optional int64 endTime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_endTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &endtime_)));
          set_has_endtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChristmasLimitBuyInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int64 reflushTime = 1;
  if (has_reflushtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->reflushtime(), output);
  }

  // repeated .ChristmasActivity.SingleLimitData dataList = 2;
  for (int i = 0; i < this->datalist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->datalist(i), output);
  }

  // optional int64 endTime = 3;
  if (has_endtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->endtime(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChristmasLimitBuyInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int64 reflushTime = 1;
  if (has_reflushtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->reflushtime(), target);
  }

  // repeated .ChristmasActivity.SingleLimitData dataList = 2;
  for (int i = 0; i < this->datalist_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->datalist(i), target);
  }

  // optional int64 endTime = 3;
  if (has_endtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->endtime(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChristmasLimitBuyInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int64 reflushTime = 1;
    if (has_reflushtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->reflushtime());
    }

    // optional int64 endTime = 3;
    if (has_endtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->endtime());
    }

  }
  // repeated .ChristmasActivity.SingleLimitData dataList = 2;
  total_size += 1 * this->datalist_size();
  for (int i = 0; i < this->datalist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->datalist(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChristmasLimitBuyInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChristmasLimitBuyInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChristmasLimitBuyInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChristmasLimitBuyInfo::MergeFrom(const ChristmasLimitBuyInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  datalist_.MergeFrom(from.datalist_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reflushtime()) {
      set_reflushtime(from.reflushtime());
    }
    if (from.has_endtime()) {
      set_endtime(from.endtime());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChristmasLimitBuyInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChristmasLimitBuyInfo::CopyFrom(const ChristmasLimitBuyInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChristmasLimitBuyInfo::IsInitialized() const {

  return true;
}

void ChristmasLimitBuyInfo::Swap(ChristmasLimitBuyInfo* other) {
  if (other != this) {
    std::swap(reflushtime_, other->reflushtime_);
    datalist_.Swap(&other->datalist_);
    std::swap(endtime_, other->endtime_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChristmasLimitBuyInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChristmasLimitBuyInfo_descriptor_;
  metadata.reflection = ChristmasLimitBuyInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LimitBuyReturn::kErrorFieldNumber;
const int LimitBuyReturn::kDataListFieldNumber;
#endif  // !_MSC_VER

LimitBuyReturn::LimitBuyReturn()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LimitBuyReturn::InitAsDefaultInstance() {
}

LimitBuyReturn::LimitBuyReturn(const LimitBuyReturn& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LimitBuyReturn::SharedCtor() {
  _cached_size_ = 0;
  error_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LimitBuyReturn::~LimitBuyReturn() {
  SharedDtor();
}

void LimitBuyReturn::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LimitBuyReturn::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LimitBuyReturn::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LimitBuyReturn_descriptor_;
}

const LimitBuyReturn& LimitBuyReturn::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ChristmasActivity_2fChristmasActivity_2eproto();
  return *default_instance_;
}

LimitBuyReturn* LimitBuyReturn::default_instance_ = NULL;

LimitBuyReturn* LimitBuyReturn::New() const {
  return new LimitBuyReturn;
}

void LimitBuyReturn::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    error_ = 0;
  }
  datalist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LimitBuyReturn::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 error = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &error_)));
          set_has_error();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_dataList;
        break;
      }

      // repeated .ChristmasActivity.SingleLimitData dataList = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dataList:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_datalist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_dataList;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LimitBuyReturn::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->error(), output);
  }

  // repeated .ChristmasActivity.SingleLimitData dataList = 2;
  for (int i = 0; i < this->datalist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->datalist(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LimitBuyReturn::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 error = 1;
  if (has_error()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->error(), target);
  }

  // repeated .ChristmasActivity.SingleLimitData dataList = 2;
  for (int i = 0; i < this->datalist_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->datalist(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LimitBuyReturn::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 error = 1;
    if (has_error()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->error());
    }

  }
  // repeated .ChristmasActivity.SingleLimitData dataList = 2;
  total_size += 1 * this->datalist_size();
  for (int i = 0; i < this->datalist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->datalist(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LimitBuyReturn::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LimitBuyReturn* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LimitBuyReturn*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LimitBuyReturn::MergeFrom(const LimitBuyReturn& from) {
  GOOGLE_CHECK_NE(&from, this);
  datalist_.MergeFrom(from.datalist_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      set_error(from.error());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LimitBuyReturn::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LimitBuyReturn::CopyFrom(const LimitBuyReturn& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LimitBuyReturn::IsInitialized() const {

  return true;
}

void LimitBuyReturn::Swap(LimitBuyReturn* other) {
  if (other != this) {
    std::swap(error_, other->error_);
    datalist_.Swap(&other->datalist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LimitBuyReturn::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LimitBuyReturn_descriptor_;
  metadata.reflection = LimitBuyReturn_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ChristmasActivity

// @@protoc_insertion_point(global_scope)
